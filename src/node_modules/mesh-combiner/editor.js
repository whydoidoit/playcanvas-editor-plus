import isObject from 'lodash/isObject'
import groupBy from 'lodash/groupBy'
import filter from 'lodash/filter'
import forEachRight from 'lodash/forEachRight'
import 'of-type'


const MAX_VERTEX_COUNT = 62000

function round(value) {
    return Math.round(value * 10000) / 10000
}

let app = pc.Application.getApplication()

const validTypes = {
    "POSITION": true,
    "NORMAL": true,
    "TANGENT": true,
    "TEXCOORD0": true,
    "TEXCOORD1": true
};


function Vertices(args) {
    args = args || {}
    Object.assign(this, {
        position: {
            type: 'float32',
            components: 3,
            data: []
        },
        normal: {
            type: 'float32',
            components: 3,
            data: []
        },
        texCoord0: {
            type: 'float32',
            components: 2,
            data: []
        },
        texCoord1: {
            type: 'float32',
            components: 2,
            data: []
        }
    }, args)
    Object.assign(this, args)
}

Vertices.prototype.addPosition = function (x, y, z) {
    if (Array.isArray(x)) {
        this.position.data.push.apply(this.position.data, x)
    } else if (isObject(x)) {
        this.position.data.push(x.x, x.y, x.z)
    } else {
        this.position.data.push(x, y, z)
    }
}

Vertices.prototype.addNormal = function (x, y, z) {
    if (Array.isArray(x)) {
        this.normal.data.push.apply(this.position.data, x)
    } else if (isObject(x)) {
        this.normal.data.push(x.x, x.y, x.z)
    } else {
        this.normal.data.push(x, y, z)
    }
}

Vertices.prototype.addTex0 = function (x, y) {
    if (Array.isArray(x)) {
        this.texCoord0.data.push.apply(this.position.data, x)
    } else if (isObject(x)) {
        this.texCoord0.data.push(x.x, x.y)
    } else {
        this.texCoord0.data.push(x, y)
    }
}

Vertices.prototype.addTex1 = function (x, y) {
    if (Array.isArray(x)) {
        this.texCoord1.data.push.apply(this.position.data, x)
    } else if (isObject(x)) {
        this.texCoord1.data.push(x.x, x.y)
    } else {
        this.texCoord1.data.push(x, y)
    }
}

Vertices.prototype.add = function (position, normal, uv0, uv1) {
    if (position) {
        this.addPosition(position)
    }
    if (normal) {
        this.addNormal(normal)
    }
    if (uv0) {
        this.addTex0(uv0)
    }
    if (uv1) {
        this.addTex1(uv1)
    }
}

function returnTrue() {
    return true
}

function combine(target, castShadows, receiveShadows, lightmapped, lightmapSizeMultipler, predicate) {

    predicate = predicate || returnTrue
    lightmapped = lightmapped !== false
    lightmapSizeMultipler = lightmapSizeMultipler || 8
    receiveShadows = receiveShadows !== false
    castShadows = castShadows !== false

    let loadedMaterials = app.assets.filter(function (asset) {
        return asset.type === 'material' && asset.resource
    })

    function findId(material) {
        return loadedMaterials.filter(function (m) {
            return m.resource === material
        })[0]._id
    }

    function createNode(name, parent) {
        let node = {
            name: name,
            position: [0, 0, 0],
            rotation: [0, 0, 0],
            scale: [1, 1, 1]
        }
        parent = parent !== undefined ? parent : -1
        if (isObject(parent)) {
            parent = parent.$id !== undefined ? parent.$id : nodes.indexOf(parent)
        }
        nodes.push(node)
        node.$id = nodes.length - 1
        parents.push(parent)
        return node
    }


    function createVertices() {
        let vertexList = new Vertices()
        vertices.push(vertexList)
        vertexList.$id = vertices.length - 1
        return vertexList
    }


    function createMesh() {
        let mesh = {
            aabb: {
                min: [0, 0, 0],
                max: [0, 0, 0]
            },
            vertices: 0,
            indices: [],
            type: 'triangles',
            base: 0,
            count: 0
        }
        createdMeshes.push(mesh)
        mesh.$id = createdMeshes.length - 1
        return mesh
    }

    function createMeshInstance(node, mesh) {
        if (isObject(node)) {
            node = node.$id !== undefined ? node.$id : nodes.indexOf(node)
        }
        if (isObject(mesh)) {
            mesh = mesh.$id !== undefined ? mesh.$id : createdMeshes.indexOf(mesh)
        }
        let instance = {
            node: node,
            mesh: mesh
        }
        meshInstances.push(instance)
        instance.$id = meshInstances.length - 1
        return instance
    }

    let nodes = []
    let parents = []
    let vertices = []
    let createdMeshes = []
    let meshInstances = []

    let output = {
        model: {
            version: 2,
            nodes: nodes,
            parents: parents,
            skins: [],
            vertices: vertices,
            meshes: createdMeshes,
            meshInstances: meshInstances
        }
    }


    //Combine
    let root = createNode('root')
    let materials = []
    let meshes = [];
    target = Array.isArray(target) ? target : [target]
    target.forEach(target => target.entity.ofType('model')
        .filter(m => m.model && m.enabled && m.model._entity._enabled && m.model.meshInstances.every(m => predicate(m)))
        .forEach(function (model) {
            model.model.meshInstances.forEach(function (mesh) {
                meshes.push({
                    mesh: mesh,
                    material: mesh.material,
                    model: model
                })
            })
        })
    )

    let byMaterial = filter(groupBy(meshes, function (mesh) {
        return mesh.material.id
    }), function (g) {
        return g.length > 0
    })

    let transform = new pc.Mat4();
    let worldToLocal = new pc.Mat4();
    worldToLocal.invert();
    forEachRight(byMaterial, function (list) {

        function fixup() {
            //Fix up the UV1s
            let side = Math.ceil(Math.sqrt(fixups.length))
            let hside = Math.ceil(fixups.length / side)
            let w = 1.0 / side
            let h = 1.0 / hside
            let x = 0
            let y = 0
            for (let i = 0; i < fixups.length; i++) {
                fixups[i](x, y, w * 0.97, h * 0.97)
                x += w
                if (x >= 0.99) {
                    x = 0
                    y += h
                }
            }
            fixups = []
        }

        let id = 1
        let material = list[0].material;
        let newMesh = createMesh()
        let vertices = createVertices()
        let node = createNode(material.name + "_" + id++, root)
        let instance = createMeshInstance(node, newMesh)
        let pos = vertices.position.data
        let uv = vertices.texCoord0.data
        let uv1 = vertices.texCoord1.data
        let normal = vertices.normal.data
        let indices = newMesh.indices
        let fixups = []
        let hasUV1

        newMesh.vertices = vertices.$id

        let p = 0;
        //Now loop through and transform everything
        list.forEach(function (m) {
            //First get the world transform of the item
            transform.copy(m.mesh.node.getWorldTransform());
            transform.mul(worldToLocal);

            let vb = m.mesh.mesh.vertexBuffer;
            let ib = m.mesh.mesh.indexBuffer[pc.RENDERSTYLE_SOLID];
            let iblocked = ib.lock();
            let indexes = new Uint16Array(iblocked);
            let locked = vb.lock();
            let format = vb.getFormat();
            let base = m.mesh.mesh.primitive[0].base;
            let stride = format.size / 4;
            let data = {};
            for (let j = 0; j < format.elements.length; j++) {
                let element = format.elements[j];
                if (validTypes[element.name]) {
                    data[element.name] = new Float32Array(locked, element.offset);
                }
            }
            hasUV1 = hasUV1 || !!data["TEXCOORD1"]
            let positions = data["POSITION"];
            let vec = new pc.Vec3();
            let t = p;

            if (p + (positions.length / stride) > MAX_VERTEX_COUNT) {
                fixup()
                materials.push(material)
                //Finish off the previous object
                newMesh.count = indices.length
                let min = newMesh.aabb.min = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
                let max = newMesh.aabb.max = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY]
                for (let s = 0; s < pos.length; s += 3) {
                    for (let q = 0; q < 3; q++) {
                        let v = pos[s + q]
                        if (v > max[q]) max[q] = v
                        if (v < min[q]) min[q] = v
                    }
                }
                if (!hasUV1) {
                    delete vertices.texCoord1
                }
                newMesh = createMesh()
                vertices = createVertices()
                node = createNode(material.name + "_" + id++, root)
                instance = createMeshInstance(node, newMesh)
                pos = vertices.position.data
                uv = vertices.texCoord0.data
                uv1 = vertices.texCoord1.data
                normal = vertices.normal.data
                indices = newMesh.indices
                newMesh.vertices = vertices.$id

                p = 0
            }

            //Make room for the new ones
            for (let i = 0; i < Math.floor(positions.length / stride); i++) {
                pos.push(0);
                pos.push(0);
                pos.push(0);
                uv.push(0);
                uv.push(0);
                if (hasUV1) {
                    uv1.push(0);
                    uv1.push(0);
                }
                normal.push(0);
                normal.push(0);
                normal.push(0);
            }
            let tv;
            for (let i = 0; i < positions.length; i += stride) {
                vec.set(positions[i], positions[i + 1], positions[i + 2]);
                tv = transform.transformPoint(vec);
                pos[t] = round(tv.x);
                pos[t + 1] = round(tv.y);
                pos[t + 2] = round(tv.z);
                t += 3;
            }
            let normals = data["NORMAL"];
            t = p;
            if (normals) {
                for (let i = 0; i < normals.length; i += stride) {
                    vec.set(normals[i], normals[i + 1], normals[i + 2]);
                    vec = transform.transformVector(vec);
                    normal[t] = round(vec.x);
                    normal[t + 1] = round(vec.y);
                    normal[t + 2] = round(vec.z);
                    t += 3;
                }

            }
            let uvs = data["TEXCOORD0"];
            t = p / 3 * 2;
            if (uvs) {
                for (let i = 0; i < uvs.length; i += stride, t += 2) {
                    uv[t] = round(uvs[i]);
                    uv[t + 1] = round(uvs[i + 1]);
                }
            }

            let uvs1 = data["TEXCOORD1"];
            t = p / 3 * 2;
            if (uvs1) {
                for (let i = 0; i < uvs1.length; i += stride, t += 2) {
                    uv1[t] = round(uvs1[i]);
                    uv1[t + 1] = round(uvs1[i + 1]);
                }
            }
            (function (p) {
                fixups.push(function (x, y, w, h) {
                    let t = p / 3 * 2
                    //Fixup the uv1s
                    for (let i = 0; i < uvs1.length; i += stride, t += 2) {
                        uv1[t] = x + uv1[t] * w
                        uv1[t + 1] = y + uv1[t + 1] * h
                    }
                })
            })(p)

            let numIndices = m.mesh.mesh.primitive[0].count;

            let offset = p / 3
            for (let i = 0; i < numIndices; i++) {
                indices.push(indexes[i + base] + offset);
            }
            p += (positions.length / stride) * 3;
            //Turn off the existing object
            vb.unlock();
            ib.unlock();

        });

        newMesh.count = indices.length
        let min = newMesh.aabb.min = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
        let max = newMesh.aabb.max = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY]
        for (let s = 0; s < pos.length; s += 3) {
            for (let q = 0; q < 3; q++) {
                let v = pos[s + q]
                if (v > max[q]) max[q] = v
                if (v < min[q]) min[q] = v
            }
        }
        if (!hasUV1) {
            delete vertices.texCoord1
        }

        materials.push(material)
        fixup();

    });


    let modelData = JSON.stringify(output, function (key, value) {
        return key.slice(0, 1) === '$' ? undefined : value
    })
    let mergedName = target.map(t => t.get('name')).join('-');
    editor.call('assets:create', {
        name: 'Baked ' + mergedName + '.json',
        type: 'model',
        source: false,
        preload: false,
        data: {
            area: 0,
            mapping: materials.map(function (m) {
                return {material: findId(m)}
            })
        },
        parent: editor.call('assets:panel:currentFolder'),
        filename: 'Baked ' + mergedName + '.json',
        file: new Blob([modelData], {type: 'application/json'})
    }, function (err, assetId) {
        let myRoot = editor.call('entities:new', {
            parent: editor.call('entities:root')
        })
        myRoot.set("name", "Baked " + mergedName)
        myRoot.set('components.model', {
            asset: +assetId,
            castShadows: castShadows,
            castShadowsLightmap: lightmapped && castShadows,
            enabled: true,
            isStatic: true,
            lightmapSizeMultiplier: lightmapSizeMultipler,
            lightmapped: lightmapped,
            materialAsset: null,
            receiveShadows: receiveShadows,
            type: "asset"
        })
        target.forEach(t=>t.set('enabled', false))
    })
}

export default combine

