/* array.js */
Object.defineProperty(Array.prototype, 'equals', {
    enumerable: false,
    value: function(array) {
        if (! array)
            return false;

        if (this.length !== array.length)
            return false;

        for (var i = 0, l = this.length; i < l; i++) {
            if (this[i] instanceof Array && array[i] instanceof Array) {
                if (! this[i].equals(array[i]))
                    return false;
            } else if (this[i] !== array[i]) {
                return false;
            }
        }
        return true;
    }
});

Object.defineProperty(Array.prototype, 'match', {
    enumerable: false,
    value: function(pattern) {
        if (this.length !== pattern.length)
            return;

        for(var i = 0, l = this.length; i < l; i++) {
            if (pattern[i] !== '*' && pattern[i] !== this[i])
                return false;
        }

        return true;
    }
});


Array.prototype.binaryIndexOf = function(b) {
    var min = 0;
    var max = this.length - 1;
    var cur;
    var a;

    while (min <= max) {
        cur = Math.floor((min + max) / 2);
        a = this[cur];

        if (a < b) {
            min = cur + 1;
        } else if (a > b) {
            max = cur - 1;
        } else {
            return cur;
        }
    }

    return -1;
};


/* utils.js */
var utils = { };


// utils.deepCopy
utils.deepCopy = function deepCopy(data) {
    if (data == null || typeof(data) !== 'object')
        return data;

    if (data instanceof Array) {
        var arr = [ ];
        for(var i = 0; i < data.length; i++) {
            arr[i] = deepCopy(data[i]);
        }
        return arr;
    } else {
        var obj = { };
        for(var key in data) {
            if (data.hasOwnProperty(key))
                obj[key] = deepCopy(data[key]);
        }
        return obj;
    }
};

utils.isMobile = function() {
    return /Android/i.test(navigator.userAgent) ||
        /iPhone|iPad|iPod/i.test(navigator.userAgent);
};

// String.startsWith
if (! String.prototype.startsWith) {
    Object.defineProperty(String.prototype, 'startsWith', {
        enumerable: false,
        configurable: false,
        writable: false,
        value: function(str) {
            var that = this;
            var ceil = str.length;
            for(var i = 0; i < ceil; i++)
                if(that[i] !== str[i]) return false;
            return true;
        }
    });
}

// String.endsWith polyfill
if (! String.prototype.endsWith) {
    Object.defineProperty(String.prototype, 'endsWith', {
        enumerable: false,
        configurable: false,
        writable: false,
        value: function(str) {
            var that = this;
            for(var i = 0, ceil = str.length; i < ceil; i++)
                if (that[i + that.length - ceil] !== str[i])
                    return false;
            return true;
        }
    });
}

// element.classList.add polyfill
(function () {
    /*global DOMTokenList */
    var dummy  = document.createElement('div'),
        dtp    = DOMTokenList.prototype,
        toggle = dtp.toggle,
        add    = dtp.add,
        rem    = dtp.remove;

    dummy.classList.add('class1', 'class2');

    // Older versions of the HTMLElement.classList spec didn't allow multiple
    // arguments, easy to test for
    if (!dummy.classList.contains('class2')) {
        dtp.add    = function () {
            Array.prototype.forEach.call(arguments, add.bind(this));
        };
        dtp.remove = function () {
            Array.prototype.forEach.call(arguments, rem.bind(this));
        };
    }
})();

var bytesToHuman = function(bytes) {
    if (isNaN(bytes) || bytes === 0) return '0 B';
    var k = 1000;
    var sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    var i = Math.floor(Math.log(bytes) / Math.log(k));
    return (bytes / Math.pow(k, i)).toPrecision(3) + ' ' + sizes[i];
};


/* color.js */
var rgb2hsv = function(rgb) {
    var rr, gg, bb,
        r = rgb[0] / 255,
        g = rgb[1] / 255,
        b = rgb[2] / 255,
        h, s,
        v = Math.max(r, g, b),
        diff = v - Math.min(r, g, b),
        diffc = function(c) {
            return (v - c) / 6 / diff + 1 / 2;
        };

    if (diff == 0) {
        h = s = 0;
    } else {
        s = diff / v;
        rr = diffc(r);
        gg = diffc(g);
        bb = diffc(b);

        if (r === v) {
            h = bb - gg;
        } else if (g === v) {
            h = (1 / 3) + rr - bb;
        } else if (b === v) {
            h = (2 / 3) + gg - rr;
        }
        if (h < 0) {
            h += 1;
        } else if (h > 1) {
            h -= 1;
        }
    }
    return [ h, s, v ];
};


var hsv2rgb = function(hsv) {
    var h = hsv[0];
    var s = hsv[1];
    var v = hsv[2];
    var r, g, b, i, f, p, q, t;
    if (h && s === undefined && v === undefined) {
        s = h.s, v = h.v, h = h.h;
    }
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }
    return [ Math.round(r * 255), Math.round(g * 255), Math.round(b * 255) ];
};


/* ajax.js */
function Ajax(args) {
    if (typeof(args) === 'string')
        args = { url: args };

    return new AjaxRequest(args);
};

Ajax.get = function(url) {
    return new AjaxRequest({
        url: url
    });
};

Ajax.post = function(url, data) {
    return new AjaxRequest({
        method: 'POST',
        url: url,
        data: data
    });
};

Ajax.put = function(url, data) {
    return new AjaxRequest({
        method: 'PUT',
        url: url,
        data: data
    });
};

Ajax.delete = function(url) {
    return new AjaxRequest({
        method: 'DELETE',
        url: url
    });
};

Ajax.params = { };

Ajax.param = function(name, value) {
    Ajax.params[name] = value;
};



function AjaxRequest(args) {
    if (! args)
        throw new Error('no arguments provided');

    Events.call(this);

    // progress
    this._progress = 0.0;
    this.emit('progress', this._progress);

    // xhr
    this._xhr = new XMLHttpRequest();

    // send cookies
    if (args.cookies)
        this._xhr.withCredentials = true;

    // events
    this._xhr.addEventListener('load', this._onLoad.bind(this), false);
    // this._xhr.addEventListener('progress', this._onProgress.bind(this), false);
    this._xhr.upload.addEventListener('progress', this._onProgress.bind(this), false);
    this._xhr.addEventListener('error', this._onError.bind(this), false);
    this._xhr.addEventListener('abort', this._onAbort.bind(this), false);

    // url
    var url = args.url;

    // query
    if (args.query && Object.keys(args.query).length) {
        if (url.indexOf('?') === -1) {
            url += '?';
        }

        var query = [ ];
        for(var key in args.query) {
            query.push(key + '=' + args.query[key]);
        }

        url += query.join('&');
    }

    // templating
    var parts = url.split('{{');
    if (parts.length > 1) {
        for(var i = 1; i < parts.length; i++) {
            var ends = parts[i].indexOf('}}');
            var key = parts[i].slice(0, ends);

            if (Ajax.params[key] === undefined)
                continue;

            // replace
            parts[i] = Ajax.params[key] + parts[i].slice(ends + 2);
        }

        url = parts.join('');
    }

    // open request
    this._xhr.open(args.method || 'GET', url, true);

    this.notJson = args.notJson || false;

    // header for PUT/POST
    if (! args.ignoreContentType && (args.method === 'PUT' || args.method === 'POST' || args.method === 'DELETE'))
        this._xhr.setRequestHeader('Content-Type', 'application/json');

    if (args.auth && config.accessToken) {
        this._xhr.setRequestHeader('Authorization', 'Bearer ' + config.accessToken);
    }

    if (args.headers) {
        for (var key in args.headers)
            this._xhr.setRequestHeader(key, args.headers[key]);
    }

    // stringify data if needed
    if (args.data && typeof(args.data) !== 'string' && ! (args.data instanceof FormData)) {
        args.data = JSON.stringify(args.data);
    }

    // make request
    this._xhr.send(args.data || null);
};
AjaxRequest.prototype = Object.create(Events.prototype);


AjaxRequest.prototype._onLoad = function() {
    this._progress = 1.0;
    this.emit('progress', 1.0);

    if (this._xhr.status === 200 || this._xhr.status === 201) {
        if (this.notJson) {
            this.emit('load', this._xhr.status, this._xhr.responseText);
        } else {
            try {
                var json = JSON.parse(this._xhr.responseText);
            } catch(ex) {
                this.emit('error', this._xhr.status || 0, new Error('invalid json'));
                return;
            }
            this.emit('load', this._xhr.status, json);
        }
    } else {
        try {
            var json = JSON.parse(this._xhr.responseText);
            var msg = json.message;
            if (! msg) {
                msg = json.error || (json.response && json.response.error);
            }

            if (! msg) {
                msg = this._xhr.responseText;
            }

            this.emit('error', this._xhr.status, msg);
        } catch (ex) {
            this.emit('error', this._xhr.status);
        }
    }
};


AjaxRequest.prototype._onError = function(evt) {
    this.emit('error', 0, evt);
};


AjaxRequest.prototype._onAbort = function(evt) {
    this.emit('error', 0, evt);
};


AjaxRequest.prototype._onProgress = function(evt) {
    if (! evt.lengthComputable)
        return;

    var progress = evt.loaded / evt.total;

    if (progress !== this._progress) {
        this._progress = progress;
        this.emit('progress', this._progress);
    }
};


AjaxRequest.prototype.abort = function() {
    this._xhr.abort();
};


/* observer.js */
"use strict";

function Observer(data, options) {
    Events.call(this);
    options = options || { };

    this._destroyed = false;
    this._path = '';
    this._keys = [ ];
    this._data = { };

    this.patch(data);

    this._parent = options.parent || null;
    this._parentPath = options.parentPath || '';
    this._parentField = options.parentField || null;
    this._parentKey = options.parentKey || null;

    this._silent = false;

    var propagate = function(evt) {
        return function(path, arg1, arg2, arg3) {
            if (! this._parent)
                return;

            var key = this._parentKey;
            if (! key && (this._parentField instanceof Array)) {
                key = this._parentField.indexOf(this);

                if (key === -1)
                    return;
            }

            path = this._parentPath + '.' + key + '.' + path;

            var state;
            if (this._silent)
                state = this._parent.silence();

            this._parent.emit(path + ':' + evt, arg1, arg2, arg3);
            this._parent.emit('*:' + evt, path, arg1, arg2, arg3);

            if (this._silent)
                this._parent.silenceRestore(state);
        }
    };

    // propagate set
    this.on('*:set', propagate('set'));
    this.on('*:unset', propagate('unset'));
    this.on('*:insert', propagate('insert'));
    this.on('*:remove', propagate('remove'));
    this.on('*:move', propagate('move'));
}
Observer.prototype = Object.create(Events.prototype);


Observer.prototype.silence = function() {
    this._silent = true;

    // history hook to prevent array values to be recorded
    var historyState = this.history && this.history.enabled;
    if (historyState)
        this.history.enabled = false;

    // sync hook to prevent array values to be recorded as array root already did
    var syncState = this.sync && this.sync.enabled;
    if (syncState)
        this.sync.enabled = false;

    return [ historyState, syncState ];
};


Observer.prototype.silenceRestore = function(state) {
    this._silent = false;

    if (state[0])
        this.history.enabled = true;

    if (state[1])
        this.sync.enabled = true;
};


Observer.prototype._prepare = function(target, key, value, silent, remote) {
    var self = this;
    var state;
    var path = (target._path ? (target._path + '.') : '') + key;
    var type = typeof(value);

    target._keys.push(key);

    if (type === 'object' && (value instanceof Array)) {
        target._data[key] = value.slice(0);

        for(var i = 0; i < target._data[key].length; i++) {
            if (typeof(target._data[key][i]) === 'object' && target._data[key][i] !== null) {
                if (target._data[key][i] instanceof Array) {
                    target._data[key][i].slice(0);
                } else {
                    target._data[key][i] = new Observer(target._data[key][i], {
                        parent: this,
                        parentPath: path,
                        parentField: target._data[key],
                        parentKey: null
                    });
                }
            } else {
                state = this.silence();
                this.emit(path + '.' + i + ':set', target._data[key][i], null, remote);
                this.emit('*:set', path + '.' + i, target._data[key][i], null, remote);
                this.silenceRestore(state);
            }
        }

        if (silent)
            state = this.silence();

        this.emit(path + ':set', target._data[key], null, remote);
        this.emit('*:set', path, target._data[key], null, remote);

        if (silent)
            this.silenceRestore(state);
    } else if (type === 'object' && (value instanceof Object)) {
        if (typeof(target._data[key]) !== 'object') {
            target._data[key] = {
                _path: path,
                _keys: [ ],
                _data: { }
            };
        }

        for(var i in value) {
            if (typeof(value[i]) === 'object') {
                this._prepare(target._data[key], i, value[i], true, remote);
            } else {
                state = this.silence();

                target._data[key]._data[i] = value[i];
                target._data[key]._keys.push(i);

                this.emit(path + '.' + i + ':set', value[i], null, remote);
                this.emit('*:set', path + '.' + i, value[i], null, remote);

                this.silenceRestore(state);
            }
        }

        if (silent)
            state = this.silence();

        // passing undefined as valueOld here
        // but we should get the old value to be consistent
        this.emit(path + ':set', value, undefined, remote);
        this.emit('*:set', path, value, undefined, remote);

        if (silent)
            this.silenceRestore(state);
    } else {
        if (silent)
            state = this.silence();

        target._data[key] = value;

        this.emit(path + ':set', value, undefined, remote);
        this.emit('*:set', path, value, undefined, remote);

        if (silent)
            this.silenceRestore(state);
    }

    return true;
};


Observer.prototype.set = function(path, value, silent, remote) {
    var keys = path.split('.');
    var key = keys[keys.length - 1];
    var node = this;
    var nodePath = '';
    var obj = this;
    var state;

    for(var i = 0; i < keys.length - 1; i++) {
        if (node instanceof Array) {
            node = node[keys[i]];

            if (node instanceof Observer) {
                path = keys.slice(i + 1).join('.');
                obj = node;
            }
        } else {
            if (i < keys.length && typeof(node._data[keys[i]]) !== 'object') {
                if (node._data[keys[i]])
                    obj.unset((node.__path ? node.__path + '.' : '') + keys[i]);

                node._data[keys[i]] = {
                    _path: path,
                    _keys: [ ],
                    _data: { }
                };
                node._keys.push(keys[i]);
            }

            if (i === keys.length - 1 && node.__path)
                nodePath = node.__path + '.' + keys[i];

            node = node._data[keys[i]];
        }
    }

    if (node instanceof Array) {
        var ind = parseInt(key, 10);
        if (node[ind] === value)
            return;

        var valueOld = node[ind];
        if (! (valueOld instanceof Observer))
            valueOld = obj.json(valueOld);

        node[ind] = value;

        if (value instanceof Observer) {
            value._parent = obj;
            value._parentPath = nodePath;
            value._parentField = node;
            value._parentKey = null;
        }

        if (silent)
            state = obj.silence();

        obj.emit(path + ':set', value, valueOld, remote);
        obj.emit('*:set', path, value, valueOld, remote);

        if (silent)
            obj.silenceRestore(state);

        return true;
    } else if (node._data && ! node._data.hasOwnProperty(key)) {
        if (typeof(value) === 'object') {
            return obj._prepare(node, key, value, false, remote);
        } else {
            node._data[key] = value;
            node._keys.push(key);

            if (silent)
                state = obj.silence();

            obj.emit(path + ':set', value, null, remote);
            obj.emit('*:set', path, value, null, remote);

            if (silent)
                obj.silenceRestore(state);

            return true;
        }
    } else {
        if (typeof(value) === 'object' && (value instanceof Array)) {
            if (value.equals(node._data[key]))
                return false;

            var valueOld = node._data[key];
            if (! (valueOld instanceof Observer))
                valueOld = obj.json(valueOld);

            if (node._data[key] && node._data[key].length === value.length) {
                state = obj.silence();

                for(var i = 0; i < node._data[key].length; i++) {
                    if (node._data[key][i] instanceof Observer) {
                        node._data[key][i].patch(value[i]);
                    } else if (node._data[key][i] !== value[i]) {
                        node._data[key][i] = value[i];
                        obj.emit(path + '.' + i + ':set', node._data[key][i], valueOld[i] || null, remote);
                        obj.emit('*:set', path + '.' + i, node._data[key][i], valueOld[i] || null, remote);
                    }
                }

                obj.silenceRestore(state);
            } else {
                node._data[key] = value;

                state = obj.silence();
                for(var i = 0; i < node._data[key].length; i++) {
                    obj.emit(path + '.' + i + ':set', node._data[key][i], valueOld[i] || null, remote);
                    obj.emit('*:set', path + '.' + i, node._data[key][i], valueOld[i] || null, remote);
                }
                obj.silenceRestore(state);
            }

            if (silent)
                state = obj.silence();

            obj.emit(path + ':set', value, valueOld, remote);
            obj.emit('*:set', path, value, valueOld, remote);

            if (silent)
                obj.silenceRestore(state);

            return true;
        } else if (typeof(value) === 'object' && (value instanceof Object)) {
            var changed = false;
            var valueOld = node._data[key];
            if (! (valueOld instanceof Observer))
                valueOld = obj.json(valueOld);

            var keys = Object.keys(value);

            if (! node._data[key] || ! node._data[key]._data) {
                if (node._data[key])
                    obj.unset((node.__path ? node.__path + '.' : '') + key);

                node._data[key] = {
                    _path: path,
                    _keys: [ ],
                    _data: { }
                };
            }

            for(var n in node._data[key]._data) {
                if (! value.hasOwnProperty(n)) {
                    var c = obj.unset(path + '.' + n, true);
                    if (c) changed = true;
                } else if (node._data[key]._data.hasOwnProperty(n)) {
                    if (! obj._equals(node._data[key]._data[n], value[n])) {
                        var c = obj.set(path + '.' + n, value[n], true);
                        if (c) changed = true;
                    }
                } else {
                    var c = obj._prepare(node._data[key], n, value[n], true, remote);
                    if (c) changed = true;
                }
            }

            for(var i = 0; i < keys.length; i++) {
                if (value[keys[i]] === undefined && node._data[key]._data.hasOwnProperty(keys[i])) {
                    var c = obj.unset(path + '.' + keys[i], true);
                    if (c) changed = true;
                } else if (typeof(value[keys[i]]) === 'object') {
                    if (node._data[key]._data.hasOwnProperty(keys[i])) {
                        var c = obj.set(path + '.' + keys[i], value[keys[i]], true);
                        if (c) changed = true;
                    } else {
                        var c = obj._prepare(node._data[key], keys[i], value[keys[i]], true, remote);
                        if (c) changed = true;
                    }
                } else if (! obj._equals(node._data[key]._data[keys[i]], value[keys[i]])) {
                    if (typeof(value[keys[i]]) === 'object') {
                        var c = obj.set(node._data[key]._path + '.' + keys[i], value[keys[i]], true);
                        if (c) changed = true;
                    } else if (node._data[key]._data[keys[i]] !== value[keys[i]]) {
                        changed = true;

                        if (node._data[key]._keys.indexOf(keys[i]) === -1)
                            node._data[key]._keys.push(keys[i]);

                        node._data[key]._data[keys[i]] = value[keys[i]];

                        state = obj.silence();
                        obj.emit(node._data[key]._path + '.' + keys[i] + ':set', node._data[key]._data[keys[i]], null, remote);
                        obj.emit('*:set', node._data[key]._path + '.' + keys[i], node._data[key]._data[keys[i]], null, remote);
                        obj.silenceRestore(state);
                    }
                }
            }

            if (changed) {
                if (silent)
                    state = obj.silence();

                var val = obj.json(node._data[key]);

                obj.emit(node._data[key]._path + ':set', val, valueOld, remote);
                obj.emit('*:set', node._data[key]._path, val, valueOld, remote);

                if (silent)
                    obj.silenceRestore(state);

                return true;
            } else {
                return false;
            }
        } else {
            var data;
            if (! node.hasOwnProperty('_data') && node.hasOwnProperty(key)) {
                data = node;
            } else {
                data = node._data;
            }

            if (data[key] === value)
                return false;

            if (silent)
                state = obj.silence();

            var valueOld = data[key];
            if (! (valueOld instanceof Observer))
                valueOld = obj.json(valueOld);

            data[key] = value;

            obj.emit(path + ':set', value, valueOld, remote);
            obj.emit('*:set', path, value, valueOld, remote);

            if (silent)
                obj.silenceRestore(state);

            return true;
        }
    }

    return false;
};


Observer.prototype.has = function(path) {
    var keys = path.split('.');
    var node = this;
    for (var i = 0; i < keys.length; i++) {
        if (node == undefined)
            return undefined;

        if (node._data) {
            node = node._data[keys[i]];
        } else {
            node = node[keys[i]];
        }
    }

    return node !== undefined;
};


Observer.prototype.get = function(path, raw) {
    var keys = path.split('.');
    var node = this;
    for (var i = 0; i < keys.length; i++) {
        if (node == undefined)
            return undefined;

        if (node._data) {
            node = node._data[keys[i]];
        } else {
            node = node[keys[i]];
        }
    }

    if (raw)
        return node;

    if (node == null) {
        return null;
    } else {
        return this.json(node);
    }
};


Observer.prototype.getRaw = function(path) {
    return this.get(path, true);
};


Observer.prototype._equals = function(a, b) {
    if (a === b) {
        return true;
    } else if (a instanceof Array && b instanceof Array && a.equals(b)) {
        return true;
    } else {
        return false;
    }
};


Observer.prototype.unset = function(path, silent, remote) {
    var keys = path.split('.');
    var key = keys[keys.length - 1];
    var node = this;
    var obj = this;

    for(var i = 0; i < keys.length - 1; i++) {
        if (node instanceof Array) {
            node = node[keys[i]];
            if (node instanceof Observer) {
                path = keys.slice(i + 1).join('.');
                obj = node;
            }
        } else {
            node = node._data[keys[i]];
        }
    }

    if (! node._data || ! node._data.hasOwnProperty(key))
        return false;

    var valueOld = node._data[key];
    if (! (valueOld instanceof Observer))
        valueOld = obj.json(valueOld);

    // recursive
    if (node._data[key] && node._data[key]._data) {
        for(var i = 0; i < node._data[key]._keys.length; i++) {
            obj.unset(path + '.' + node._data[key]._keys[i], true);
        }
    }

    node._keys.splice(node._keys.indexOf(key), 1);
    delete node._data[key];

    var state;
    if (silent)
        state = obj.silence();

    obj.emit(path + ':unset', valueOld, remote);
    obj.emit('*:unset', path, valueOld, remote);

    if (silent)
        obj.silenceRestore(state);

    return true;
};


Observer.prototype.remove = function(path, ind, silent, remote) {
    var keys = path.split('.');
    var key = keys[keys.length - 1];
    var node = this;
    var obj = this;

    for(var i = 0; i < keys.length - 1; i++) {
        if (node instanceof Array) {
            node = node[parseInt(keys[i], 10)];
            if (node instanceof Observer) {
                path = keys.slice(i + 1).join('.');
                obj = node;
            }
        } else if (node._data && node._data.hasOwnProperty(keys[i])) {
            node = node._data[keys[i]];
        } else {
            return;
        }
    }

    if (! node._data || ! node._data.hasOwnProperty(key) || ! (node._data[key] instanceof Array))
        return;

    var arr = node._data[key];
    if (arr.length < ind)
        return;

    var value = arr[ind];
    if (value instanceof Observer) {
        value._parent = null;
    } else {
        value = obj.json(value);
    }

    arr.splice(ind, 1);

    var state;
    if (silent)
        state = obj.silence();

    obj.emit(path + ':remove', value, ind, remote);
    obj.emit('*:remove', path, value, ind, remote);

    if (silent)
        obj.silenceRestore(state);

    return true;
};


Observer.prototype.removeValue = function(path, value, silent, remote) {
    var keys = path.split('.');
    var key = keys[keys.length - 1];
    var node = this;
    var obj = this;

    for(var i = 0; i < keys.length - 1; i++) {
        if (node instanceof Array) {
            node = node[parseInt(keys[i], 10)];
            if (node instanceof Observer) {
                path = keys.slice(i + 1).join('.');
                obj = node;
            }
        } else if (node._data && node._data.hasOwnProperty(keys[i])) {
            node = node._data[keys[i]];
        } else {
            return;
        }
    }

    if (! node._data || ! node._data.hasOwnProperty(key) || ! (node._data[key] instanceof Array))
        return;

    var arr = node._data[key];

    var ind = arr.indexOf(value);
    if (ind === -1)
        return;

    if (arr.length < ind)
        return;

    var value = arr[ind];
    if (value instanceof Observer) {
        value._parent = null;
    } else {
        value = obj.json(value);
    }

    arr.splice(ind, 1);

    var state;
    if (silent)
        state = obj.silence();

    obj.emit(path + ':remove', value, ind, remote);
    obj.emit('*:remove', path, value, ind, remote);

    if (silent)
        obj.silenceRestore(state);

    return true;
};


Observer.prototype.insert = function(path, value, ind, silent, remote) {
    var keys = path.split('.');
    var key = keys[keys.length - 1];
    var node = this;
    var obj = this;

    for(var i = 0; i < keys.length - 1; i++) {
        if (node instanceof Array) {
            node = node[parseInt(keys[i], 10)];
            if (node instanceof Observer) {
                path = keys.slice(i + 1).join('.');
                obj = node;
            }
        } else if (node._data && node._data.hasOwnProperty(keys[i])) {
            node = node._data[keys[i]];
        } else {
            return;
        }
    }

    if (! node._data || ! node._data.hasOwnProperty(key) || ! (node._data[key] instanceof Array))
        return;

    var arr = node._data[key];

    if (typeof(value) === 'object' && ! (value instanceof Observer)) {
        if (value instanceof Array) {
            value = value.slice(0);
        } else {
            value = new Observer(value);
        }
    }

    if (arr.indexOf(value) !== -1)
        return;

    if (ind === undefined) {
        arr.push(value);
        ind = arr.length - 1;
    } else {
        arr.splice(ind, 0, value);
    }

    if (value instanceof Observer) {
        value._parent = obj;
        value._parentPath = node._path + '.' + key;
        value._parentField = arr;
        value._parentKey = null;
    } else {
        value = obj.json(value);
    }

    var state;
    if (silent)
        state = obj.silence();

    obj.emit(path + ':insert', value, ind, remote);
    obj.emit('*:insert', path, value, ind, remote);

    if (silent)
        obj.silenceRestore(state);

    return true;
};


Observer.prototype.move = function(path, indOld, indNew, silent, remote) {
    var keys = path.split('.');
    var key = keys[keys.length - 1];
    var node = this;
    var obj = this;

    for(var i = 0; i < keys.length - 1; i++) {
        if (node instanceof Array) {
            node = node[parseInt(keys[i], 10)];
            if (node instanceof Observer) {
                path = keys.slice(i + 1).join('.');
                obj = node;
            }
        } else if (node._data && node._data.hasOwnProperty(keys[i])) {
            node = node._data[keys[i]];
        } else {
            return;
        }
    }

    if (! node._data || ! node._data.hasOwnProperty(key) || ! (node._data[key] instanceof Array))
        return;

    var arr = node._data[key];

    if (arr.length < indOld || arr.length < indNew || indOld === indNew)
        return;

    var value = arr[indOld];

    arr.splice(indOld, 1);

    if (indNew === -1)
        indNew = arr.length;

    arr.splice(indNew, 0, value);

    if (! (value instanceof Observer))
        value = obj.json(value);

    var state;
    if (silent)
        state = obj.silence();

    obj.emit(path + ':move', value, indNew, indOld, remote);
    obj.emit('*:move', path, value, indNew, indOld, remote);

    if (silent)
        obj.silenceRestore(state);

    return true;
};


Observer.prototype.patch = function(data) {
    if (typeof(data) !== 'object')
        return;

    for(var key in data) {
        if (typeof(data[key]) === 'object' && ! this._data.hasOwnProperty(key)) {
            this._prepare(this, key, data[key]);
        } else if (this._data[key] !== data[key]) {
            this.set(key, data[key]);
        }
    }
};


Observer.prototype.json = function(target) {
    var obj = { };
    var node = target === undefined ? this : target;

    if (node instanceof Object && node._keys) {
        for (var i = 0; i < node._keys.length; i++) {
            var key = node._keys[i];
            var value = node._data[key];
            var type = typeof(value);

            if (type === 'object' && (value instanceof Array)) {
                obj[key] = value.slice(0);

                for(var n = 0; n < obj[key].length; n++) {
                    if (typeof(obj[key][n]) === 'object')
                        obj[key][n] = this.json(obj[key][n]);
                }
            } else if (type === 'object' && (value instanceof Object)) {
                obj[key] = this.json(value);
            } else {
                obj[key] = value;
            }
        }
    } else {
        if (node === null) {
            return null;
        } else if (typeof(node) === 'object' && (node instanceof Array)) {
            obj = node.slice(0);

            for(var n = 0; n < obj.length; n++) {
                obj[n] = this.json(obj[n]);
            }
        } else if (typeof(node) === 'object') {
            for(var key in node) {
                if (node.hasOwnProperty(key))
                    obj[key] = node[key];
            }
        } else {
            obj = node;
        }
    }
    return obj;
};


Observer.prototype.forEach = function(fn, target, path) {
    var node = target || this;
    path = path || '';

    for (var i = 0; i < node._keys.length; i++) {
        var key = node._keys[i];
        var value = node._data[key];
        var type = (this.schema && this.schema.has(path + key) && this.schema.get(path + key).type.name.toLowerCase()) || typeof(value);

        if (type === 'object' && (value instanceof Array)) {
            fn(path + key, 'array', value, key);
        } else if (type === 'object' && (value instanceof Object)) {
            fn(path + key, 'object', value, key);
            this.forEach(fn, value, path + key + '.');
        } else {
            fn(path + key, type, value, key);
        }
    }
};


Observer.prototype.destroy = function() {
    if (this._destroyed) return;
    this._destroyed = true;
    this.emit('destroy');
    this.unbind();
};


/* observer-list.js */
"use strict";

function ObserverList(options) {
    Events.call(this);
    options = options || { };

    this.data = [ ];
    this._indexed = { };
    this.sorted = options.sorted || null;
    this.index = options.index || null;
}

ObserverList.prototype = Object.create(Events.prototype);


Object.defineProperty(ObserverList.prototype, 'length', {
    get: function() {
        return this.data.length;
    }
});


ObserverList.prototype.get = function(index) {
    if (this.index) {
        return this._indexed[index] || null;
    } else {
        return this.data[index] || null;
    }
};


ObserverList.prototype.set = function(index, value) {
    if (this.index) {
        this._indexed[index] = value;
    } else {
        this.data[index] = value;
    }
};


ObserverList.prototype.indexOf = function(item) {
    if (this.index) {
        var index = (item instanceof Observer && item.get(this.index)) || item[this.index]
        return (this._indexed[index] && index) || null;
    } else {
        var ind = this.data.indexOf(item);
        return ind !== -1 ? ind : null;
    }
};


ObserverList.prototype.position = function(b, fn) {
    var l = this.data;
    var min = 0;
    var max = l.length - 1;
    var cur;
    var a, i;
    fn = fn || this.sorted;

    while (min <= max) {
        cur = Math.floor((min + max) / 2);
        a = l[cur];

        i = fn(a, b);

        if (i === 1) {
            max = cur - 1;
        } else if (i === -1) {
            min = cur + 1;
        } else {
            return cur;
        }
    }

    return -1;
};


ObserverList.prototype.positionNextClosest = function(b, fn) {
    var l = this.data;
    var min = 0;
    var max = l.length - 1;
    var cur;
    var a, i;
    fn = fn || this.sorted;

    if (l.length === 0)
        return -1;

    if (fn(l[0], b) === 0)
        return 0;

    while (min <= max) {
        cur = Math.floor((min + max) / 2);
        a = l[cur];

        i = fn(a, b);

        if (i === 1) {
            max = cur - 1;
        } else if (i === -1) {
            min = cur + 1;
        } else {
            return cur;
        }
    }

    if (fn(a, b) === 1)
        return cur;

    if ((cur + 1) === l.length)
        return -1;

    return cur + 1;
};


ObserverList.prototype.has = function(item) {
    if (this.index) {
        var index = (item instanceof Observer && item.get(this.index)) || item[this.index]
        return !! this._indexed[index];
    } else {
        return this.data.indexOf(item) !== -1;
    }
};


ObserverList.prototype.add = function(item) {
    if (this.has(item))
        return null;

    var index = this.data.length;
    if (this.index) {
        index = (item instanceof Observer && item.get(this.index)) || item[this.index];
        this._indexed[index] = item;
    }

    var pos = 0;

    if (this.sorted) {
        pos = this.positionNextClosest(item);
        if (pos !== -1) {
            this.data.splice(pos, 0, item);
        } else {
            this.data.push(item);
        }
    } else {
        this.data.push(item);
        pos = this.data.length - 1;
    }

    this.emit('add', item, index);

    return pos;
};


ObserverList.prototype.move = function(item, pos) {
    var ind = this.data.indexOf(item);
    this.data.splice(ind, 1);
    if (pos === -1) {
        this.data.push(item);
    } else {
        this.data.splice(pos, 0, item);
    }
};


ObserverList.prototype.remove = function(item) {
    if (! this.has(item))
        return;

    var ind = this.data.indexOf(item);

    var index = ind;
    if (this.index) {
        index = (item instanceof Observer && item.get(this.index)) || item[this.index];
        delete this._indexed[index];
    }

    this.data.splice(ind, 1);

    this.emit('remove', item, index);
};


ObserverList.prototype.removeByKey = function(index) {
    if (this.index) {
        var item = this._indexed[index];

        if (! item)
            return;

        var ind = this.data.indexOf(item);
        this.data.splice(ind, 1);

        delete this._indexed[index];

        this.emit('remove', item, ind);
    } else {
        if (this.data.length < index)
            return;

        var item = this.data[index];

        this.data.splice(index, 1);

        this.emit('remove', item, index);
    }
};


ObserverList.prototype.removeBy = function(fn) {
    var i = this.data.length;
    while(i--) {
        if (! fn(this.data[i]))
            continue;

        if (this.index) {
            delete this._indexed[this.data[i][this.index]];
        }
        this.data.splice(i, 1);

        this.emit('remove', this.data[i], i);
    }
};


ObserverList.prototype.clear = function() {
    var items = this.data.slice(0);

    this.data = [ ];
    this._indexed = { };

    var i = items.length;
    while(i--) {
        this.emit('remove', items[i], i);
    }
};


ObserverList.prototype.forEach = function(fn) {
    for(var i = 0; i < this.data.length; i++) {
        fn(this.data[i], (this.index && this.data[i][this.index]) || i);
    }
};


ObserverList.prototype.find = function(fn) {
    var items = [ ];
    for(var i = 0; i < this.data.length; i++) {
        if (! fn(this.data[i]))
            continue;

        var index = i;
        if (this.index)
            index = this.data[i][this.index];

        items.push([ index, this.data[i] ]);
    }
    return items;
};


ObserverList.prototype.findOne = function(fn) {
    for(var i = 0; i < this.data.length; i++) {
        if (! fn(this.data[i]))
            continue;

        var index = i;
        if (this.index)
            index = this.data[i][this.index];

        return [ index, this.data[i] ];
    }
    return null;
};


ObserverList.prototype.map = function(fn) {
    return this.data.map(fn);
};


ObserverList.prototype.sort = function(fn) {
    this.data.sort(fn);
};


ObserverList.prototype.array = function() {
    return this.data.slice(0);
};


ObserverList.prototype.json = function() {
    var items = this.array();
    for(var i = 0; i < items.length; i++) {
        if (items[i] instanceof Observer) {
            items[i] = items[i].json();
        }
    }
    return items;
};


/* observer-sync.js */
function ObserverSync(args) {
    Events.call(this);
    args = args || { };

    this.item = args.item;
    this._enabled = args.enabled || true;
    this._prefix = args.prefix || [ ];
    this._paths = args.paths || null;
    this._sync = args.sync || true;

    this._initialize();
}
ObserverSync.prototype = Object.create(Events.prototype);


ObserverSync.prototype._initialize = function() {
    var self = this;
    var item = this.item;

    // object/array set
    item.on('*:set', function(path, value, valueOld) {
        if (! self._enabled) return;

        // check if path is allowed
        if (self._paths) {
            var allowedPath = false;
            for(var i = 0; i < self._paths.length; i++) {.
                if (path.indexOf(self._paths[i]) !== -1) {
                    allowedPath = true;
                    break;
                }
            }

            // path is not allowed
            if (! allowedPath)
                return;
        }

        // full path
        var p = self._prefix.concat(path.split('.'));

        // need jsonify
        if (value instanceof Observer || value instanceof ObserverList)
            value = value.json();

        // can be array value
        var ind = path.lastIndexOf('.');
        if (ind !== -1 && (this.get(path.slice(0, ind)) instanceof Array)) {
            // array index should be int
            p[p.length - 1] = parseInt(p[p.length - 1], 10);

            // emit operation: list item set
            self.emit('op', {
                p: p,
                li: value,
                ld: valueOld
            });
        } else {
            // emit operation: object item set
            var obj = {
                p: p,
                oi: value
            };

            if (valueOld !== undefined) {
                obj.od = valueOld;
            }

            self.emit('op', obj);
        }
    });

    // unset
    item.on('*:unset', function(path, value) {
        if (! self._enabled) return;

        self.emit('op', {
            p: self._prefix.concat(path.split('.')),
            od: null
        });
    });

    // list move
    item.on('*:move', function(path, value, ind, indOld) {
        if (! self._enabled) return;
        self.emit('op', {
            p: self._prefix.concat(path.split('.')).concat([ indOld ]),
            lm: ind
        });
    });

    // list remove
    item.on('*:remove', function(path, value, ind) {
        if (! self._enabled) return;

        // need jsonify
        if (value instanceof Observer || value instanceof ObserverList)
            value = value.json();

        self.emit('op', {
            p: self._prefix.concat(path.split('.')).concat([ ind ]),
            ld: value
        });
    });

    // list insert
    item.on('*:insert', function(path, value, ind) {
        if (! self._enabled) return;

        // need jsonify
        if (value instanceof Observer || value instanceof ObserverList)
            value = value.json();

        self.emit('op', {
            p: self._prefix.concat(path.split('.')).concat([ ind ]),
            li: value
        });
    });
};


ObserverSync.prototype.write = function(op) {
    // disable history if available
    var historyReEnable = false;
    if (this.item.history && this.item.history.enabled) {
        historyReEnable = true;
        this.item.history.enabled = false;
    }

    if (op.hasOwnProperty('oi')) {
        // set key value
        var path = op.p.slice(this._prefix.length).join('.');

        this._enabled = false;
        this.item.set(path, op.oi, false, true);
        this._enabled = true;


    } else if (op.hasOwnProperty('ld') && op.hasOwnProperty('li')) {
        // set array value
        var path = op.p.slice(this._prefix.length).join('.');

        this._enabled = false;
        this.item.set(path, op.li, false, true);
        this._enabled = true;


    } else if (op.hasOwnProperty('ld')) {
        // delete item
        var path = op.p.slice(this._prefix.length, -1).join('.');

        this._enabled = false;
        this.item.remove(path, op.p[op.p.length - 1], false, true);
        this._enabled = true;


    } else if (op.hasOwnProperty('li')) {
        // add item
        var path = op.p.slice(this._prefix.length, -1).join('.');
        var ind = op.p[op.p.length - 1];

        this._enabled = false;
        this.item.insert(path, op.li, ind, false, true);
        this._enabled = true;


    } else if (op.hasOwnProperty('lm')) {
        // item moved
        var path = op.p.slice(this._prefix.length, -1).join('.');
        var indOld = op.p[op.p.length - 1];
        var ind = op.lm;

        this._enabled = false;
        this.item.move(path, indOld, ind, false, true);
        this._enabled = true;


    } else if (op.hasOwnProperty('od')) {
        // unset key value
        var path = op.p.slice(this._prefix.length).join('.');
        this._enabled = false;
        this.item.unset(path, false, true);
        this._enabled = true;


    } else {
        console.log('unknown operation', op);
    }

    // reenable history
    if (historyReEnable)
        this.item.history.enabled = true;

    this.emit('sync', op);
};

Object.defineProperty(ObserverSync.prototype, 'enabled', {
    get: function() {
        return this._enabled;
    },
    set: function(value) {
        this._enabled = !! value;
    }
});

Object.defineProperty(ObserverSync.prototype, 'prefix', {
    get: function() {
        return this._prefix;
    },
    set: function(value) {
        this._prefix = value || [ ];
    }
});

Object.defineProperty(ObserverSync.prototype, 'paths', {
    get: function() {
        return this._paths;
    },
    set: function(value) {
        this._paths = value || null;
    }
});


/* observer-history.js */
function ObserverHistory(args) {
    Events.call(this);
    args = args || { };

    this.item = args.item;
    this._enabled = args.enabled || true;
    this._combine = args._combine || false;
    this._prefix = args.prefix || '';
    this._getItemFn = args.getItemFn;

    this._events = [];

    this._initialize();
}
ObserverHistory.prototype = Object.create(Events.prototype);


ObserverHistory.prototype._initialize = function() {
    var self = this;

    this._events.push(this.item.on('*:set', function(path, value, valueOld) {
        if (! self._enabled) return;

        // need jsonify
        if (value instanceof Observer)
            value = value.json();

        // action
        var data = {
            name: self._prefix + path,
            combine: self._combine,
            undo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;

                if (valueOld === undefined) {
                    item.unset(path);
                } else {
                    item.set(path, valueOld);
                }

                item.history.enabled = true;
            },
            redo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;

                if (value === undefined) {
                    item.unset(path);
                } else {
                    item.set(path, value);
                }

                item.history.enabled = true;
            }
        };

        if (data.combine && editor.call('history:canUndo') && editor.call('history:list')[editor.call('history:current')].name === data.name) {
            // update
            self.emit('record', 'update', data);
        } else {
            // add
            self.emit('record', 'add', data);
        }
    }));

    this._events.push(this.item.on('*:unset', function(path, valueOld) {
        if (! self._enabled) return;

        // action
        var data = {
            name: self._prefix + path,
            undo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;
                item.set(path, valueOld);
                item.history.enabled = true;
            },
            redo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;
                item.unset(path);
                item.history.enabled = true;
            }
        };

        self.emit('record', 'add', data);
    }));

    this._events.push(this.item.on('*:insert', function(path, value, ind) {
        if (! self._enabled) return;

        // need jsonify
        // if (value instanceof Observer)
        //     value = value.json();

        // action
        var data = {
            name: self._prefix + path,
            undo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;
                item.removeValue(path, value);
                item.history.enabled = true;
            },
            redo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;
                item.insert(path, value, ind);
                item.history.enabled = true;
            }
        };

        self.emit('record', 'add', data);
    }));

    this._events.push(this.item.on('*:remove', function(path, value, ind) {
        if (! self._enabled) return;

        // need jsonify
        // if (value instanceof Observer)
        //     value = value.json();

        // action
        var data = {
            name: self._prefix + path,
            undo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;
                item.insert(path, value, ind);
                item.history.enabled = true;
            },
            redo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;
                item.removeValue(path, value);
                item.history.enabled = true;
            }
        };

        self.emit('record', 'add', data);
    }));

    this._events.push(this.item.on('*:move', function(path, value, ind, indOld) {
        if (! self._enabled) return;

        // action
        var data = {
            name: self._prefix + path,
            undo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;
                item.move(path, ind, indOld);
                item.history.enabled = true;
            },
            redo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;
                item.move(path, indOld, ind);
                item.history.enabled = true;
            }
        };

        self.emit('record', 'add', data);
    }));
};

ObserverHistory.prototype.destroy = function () {
    this._events.forEach(function (evt) {
        evt.unbind();
    });

    this._events.length = 0;
    this.item = null;
};

Object.defineProperty(ObserverHistory.prototype, 'enabled', {
    get: function() {
        return this._enabled;
    },
    set: function(value) {
        this._enabled = !! value;
    }
});


Object.defineProperty(ObserverHistory.prototype, 'prefix', {
    get: function() {
        return this._prefix;
    },
    set: function(value) {
        this._prefix = value || '';
    }
});


Object.defineProperty(ObserverHistory.prototype, 'combine', {
    get: function() {
        return this._combine;
    },
    set: function(value) {
        this._combine = !! value;
    }
});


/* ui.js */
"use strict";

window.ui = { };


/* ui/element.js */
"use strict";

function Element() {
    Events.call(this);
    // this.parent = null;

    this._parent = null;
    var self = this;
    this._parentDestroy = function() {
        self.destroy();
    };

    this._destroyed = false;
    this._element = null;
    this._link = null;
    this.path = '';
    this._linkSet = null;
    this._linkUnset = null;
    this.renderChanges = null;
    // render changes only from next ticks
    setTimeout(function() {
        if (self.renderChanges === null)
            self.renderChanges = true;
    }, 0);

    this.disabledClick = false;
    this._disabled = false;
    this._disabledParent = false;

    this._evtClick = null;

    this._parentDisable = function() {
        if (self._disabledParent)
            return;

        self._disabledParent = true;

        if (! self._disabled) {
            self.emit('disable');
            self.class.add('disabled');
        }
    };
    this._parentEnable = function() {
        if (! self._disabledParent)
            return;

        self._disabledParent = false;

        if (! self._disabled) {
            self.emit('enable');
            self.class.remove('disabled');
        }
    };

    this._onFlashDelay = function() {
        self.class.remove('flash');
    };
}
Element.prototype = Object.create(Events.prototype);

Element.prototype.link = function(link, path) {
    var self = this;

    if (this._link) this.unlink();
    this._link = link;
    this.path = path;

    this.emit('link', path);

    // add :set link
    if (this._onLinkChange) {
        var renderChanges = this.renderChanges;
        this.renderChanges = false;
        this._linkOnSet = this._link.on(this.path + ':set', function(value) {
            self._onLinkChange(value);
        });
        this._linkOnUnset = this._link.on(this.path + ':unset', function(value) {
            self._onLinkChange(value);
        });
        this._onLinkChange(this._link.get(this.path));
        this.renderChanges = renderChanges;
    }
};

Element.prototype.unlink = function() {
    if (! this._link) return;

    this.emit('unlink', this.path);

    // remove :set link
    if (this._linkOnSet) {
        this._linkOnSet.unbind();
        this._linkOnSet = null;

        this._linkOnUnset.unbind();
        this._linkOnUnset = null;
    }

    this._link = null;
    this.path = '';
};

Element.prototype.destroy = function() {
    if (this._destroyed)
        return;

    this._destroyed = true;

    if (this._parent) {
        this._evtParentDestroy.unbind();
        this._evtParentDisable.unbind();
        this._evtParentEnable.unbind();
        this._parent = null;
    }

    if (this._element.parentNode)
        this._element.parentNode.removeChild(this._element);

    this.unlink();

    this.emit('destroy');

    this.unbind();
};

Object.defineProperty(Element.prototype, 'element', {
    get: function() {
        return this._element;
    },
    set: function(value) {
        if (this._element)
            return;

        this._element = value;
        this._element.ui = this;

        var self = this;
        this._evtClick = function(evt) {
            if (self.disabled && ! self.disabledClick) return;
            self.emit('click', evt);
        };
        this._element.addEventListener('click', this._evtClick, false);

        this._evtHover = function(evt) {
            self.emit('hover', evt);
        };
        this._element.addEventListener('mouseover', this._evtHover, false);

        this._evtBlur = function(evt) {
            self.emit('blur', evt);
        };
        this._element.addEventListener('mouseout', this._evtBlur, false);

        if (! this.innerElement)
            this.innerElement = this._element;
    }
});

Object.defineProperty(Element.prototype, 'parent', {
    get: function() {
        return this._parent;
    },
    set: function(value) {
        if (this._parent) {
            this._parent = null;
            this._evtParentDestroy.unbind();
            this._evtParentDisable.unbind();
            this._evtParentEnable.unbind();
        }

        if (value) {
            this._parent = value;
            this._evtParentDestroy = this._parent.once('destroy', this._parentDestroy);
            this._evtParentDisable = this._parent.on('disable', this._parentDisable);
            this._evtParentEnable = this._parent.on('enable', this._parentEnable);

            if (this._disabledParent !== this._parent.disabled) {
                this._disabledParent = this._parent.disabled;

                if (this._disabledParent) {
                    this.class.add('disabled');
                    this.emit('disable');
                } else {
                    this.class.remove('disabled');
                    this.emit('enable');
                }
            }
        }

        this.emit('parent');
    }
});

Object.defineProperty(Element.prototype, 'disabled', {
    get: function() {
        return this._disabled || this._disabledParent;
    },
    set: function(value) {
        if (this._disabled == value)
            return;

        this._disabled = !! value;
        this.emit((this._disabled || this._disabledParent) ? 'disable' : 'enable');

        if ((this._disabled || this._disabledParent)) {
            this.class.add('disabled');
        } else {
            this.class.remove('disabled');
        }
    }
});

Object.defineProperty(Element.prototype, 'disabledSelf', {
    get: function() {
        return this._disabled;
    }
});

Object.defineProperty(Element.prototype, 'enabled', {
    get: function() {
        return ! this._disabled;
    },
    set: function(value) {
        this.disabled = ! value;
    }
});

Object.defineProperty(Element.prototype, 'value', {
    get: function() {
        if (! this._link) return null;
        return this._link.get(this.path);
    },
    set: function(value) {
        if (! this._link) return;
        this._link.set(this.path, value);
    }
});


Object.defineProperty(Element.prototype, 'hidden', {
    get: function() {
        return this._element.classList.contains('hidden');
    },
    set: function(value) {
        if (this._element.classList.contains('hidden') === !! value)
            return;

        if (value) {
            this._element.classList.add('hidden');
            this.emit('hide');
        } else {
            this._element.classList.remove('hidden');
            this.emit('show');
        }
    }
});


Object.defineProperty(Element.prototype, 'style', {
    get: function() {
        return this._element.style;
    }
});


Object.defineProperty(Element.prototype, 'class', {
    get: function() {
        return this._element.classList;
    }
});


Object.defineProperty(Element.prototype, 'flexGrow', {
    get: function() {
        return this._element.style.flexGrow;
    },
    set: function(value) {
        this._element.style.flexGrow = value;
        this._element.style.WebkitFlexGrow = value;
    }
});


Object.defineProperty(Element.prototype, 'flexShrink', {
    get: function() {
        return this._element.style.flexShrink;
    },
    set: function(value) {
        this._element.style.flexShrink = value;
        this._element.style.WebkitFlexShrink = value;
    }
});


Element.prototype.flash = function() {
    this.class.add('flash');
    setTimeout(this._onFlashDelay, 200);
};


window.ui.Element = Element;


/* ui/container-element.js */
"use strict";

function ContainerElement() {
    var self = this;

    ui.Element.call(this);
    this._innerElement = null;

    this._observerChanged = false;

    var observerTimeout = function() {
        self._observerChanged = false;
        self.emit('nodesChanged');
    };

    this._observer = new MutationObserver(function() {
        if (self._observerChanged)
            return;

        self._observerChanged = true;

        setTimeout(observerTimeout, 0);
    });
}
ContainerElement.prototype = Object.create(ui.Element.prototype);


ContainerElement.prototype._observerOptions = {
    childList: true,
    attributes: true,
    characterData: false,
    subtree: true,
    attributeOldValue: false,
    characterDataOldValue: false
};


ContainerElement.prototype.append = function(element) {
    var html = (element instanceof HTMLElement);
    var node = html ? element : element.element;

    this._innerElement.appendChild(node);

    if (! html) {
        element.parent = this;
        this.emit('append', element);
    }
};


ContainerElement.prototype.appendBefore = function(element, reference) {
    var html = (element instanceof HTMLElement);
    var node = html ? element : element.element;

    if (reference instanceof ui.Element)
        reference = reference.element;

    this._innerElement.insertBefore(node, reference);

    if (! html) {
        element.parent = this;
        this.emit('append', element);
    }
};

ContainerElement.prototype.appendAfter = function(element, reference) {
    var html = (element instanceof HTMLElement);
    var node = html ? element : element.element;

    if (reference instanceof ui.Element)
        reference = reference.element;

    reference = reference.nextSibling;

    if (reference) {
        this._innerElement.insertBefore(node, reference);
    } else {
        this._innerElement.appendChild(node);
    }

    if (! html) {
        element.parent = this;
        this.emit('append', element);
    }
};


ContainerElement.prototype.prepend = function(element) {
    var first = this._innerElement.firstChild;
    var html = (element instanceof HTMLElement);
    var node = html ? element : element.element;

    if (first) {
        this._innerElement.insertBefore(node, first);
    } else {
        this._innerElement.appendChild(node);
    }

    if (! html) {
        element.parent = this;
        this.emit('append', element);
    }
};

ContainerElement.prototype.remove = function(element) {
    var html = (element instanceof HTMLElement);
    var node = html ? element : element.element;

    if (! node.parentNode || node.parentNode !== this._innerElement)
        return;

    this._innerElement.removeChild(node);

    if (! html) {
        element.parent = null;
        this.emit('remove', element);
    }
};


Object.defineProperty(ContainerElement.prototype, 'innerElement', {
    get: function() {
        return this._innerElement;
    },
    set: function(value) {
        if (this._innerElement) {
            this._observer.disconnect();
        }

        this._innerElement = value;

        this._observer.observe(this._innerElement, this._observerOptions);
    }
});


ContainerElement.prototype.clear = function() {
    var i, node;

    this._observer.disconnect();

    i = this._innerElement.childNodes.length;
    while(i--) {
        node = this._innerElement.childNodes[i];

        if (! node.ui)
            continue;

        node.ui.destroy();
    }
    this._innerElement.innerHTML = '';

    this._observer.observe(this._innerElement, this._observerOptions);
};


Object.defineProperty(ContainerElement.prototype, 'flexible', {
    get: function() {
        return this._element.classList.contains('flexible');
    },
    set: function(value) {
        if (this._element.classList.contains('flexible') === !! value)
            return;

        if (value) {
            this._element.classList.add('flexible');
        } else {
            this._element.classList.remove('flexible');
        }
    }
});


Object.defineProperty(ContainerElement.prototype, 'flex', {
    get: function() {
        return this._element.classList.contains('flex');
    },
    set: function(value) {
        if (this._element.classList.contains('flex') === !! value)
            return;

        if (value) {
            this._element.classList.add('flex');
        } else {
            this._element.classList.remove('flex');
        }
    }
});


Object.defineProperty(ContainerElement.prototype, 'flexDirection', {
    get: function() {
        return this._innerElement.style.flexDirection;
    },
    set: function(value) {
        this._innerElement.style.flexDirection = value;
        this._innerElement.style.WebkitFlexDirection = value;
    }
});


Object.defineProperty(ContainerElement.prototype, 'flexWrap', {
    get: function() {
        return this._innerElement.style.flexWrap;
    },
    set: function(value) {
        this.flex = true;
        this._innerElement.style.flexWrap = value;
        this._innerElement.style.WebkitFlexWrap = value;
    }
});

Object.defineProperty(ContainerElement.prototype, 'flexGrow', {
    get: function() {
        return this._element.style.flexGrow === 1;
    },
    set: function(value) {
        if (value)
            this.flex = true;

        this._element.style.flexGrow = !! value ? 1 : 0;
        this._element.style.WebkitFlexGrow = !! value ? 1 : 0;
        this._innerElement.style.flexGrow = this._element.style.flexGrow;
        this._innerElement.style.WebkitFlexGrow = this._element.style.flexGrow;
    }
});


Object.defineProperty(ContainerElement.prototype, 'flexShrink', {
    get: function() {
        return this._element.style.flexShrink === 1;
    },
    set: function(value) {
        if (value)
            this.flex = true;

        this._element.style.flexShrink = !! value ? 1 : 0;
        this._element.style.WebkitFlexShrink = !! value ? 1 : 0;
        this._innerElement.style.flexShrink = this._element.style.flexShrink;
        this._innerElement.style.WebkitFlexShrink = this._element.style.flexShrink;
    }
});


Object.defineProperty(ContainerElement.prototype, 'scroll', {
    get: function() {
        return this.class.contains('scrollable');
    },
    set: function() {
        this.class.add('scrollable');
    }
});


window.ui.ContainerElement = ContainerElement;


/* ui/button.js */
"use strict";

function Button(args) {
    var self = this;
    ui.Element.call(this);
    args = args || { };

    this._text = args.text || '';

    this.element = document.createElement('div');
    this._element.classList.add('ui-button');
    this._element.innerHTML = this._text;

    this._element.ui = this;
    this._element.tabIndex = 0;

    // space > click
    this._element.addEventListener('keydown', this._onKeyDown, false);
    this.on('click', this._onClick);
}
Button.prototype = Object.create(ui.Element.prototype);

Button.prototype._onKeyDown = function(evt) {
    if (evt.keyCode === 27)
        return this.blur();

    if (evt.keyCode !== 32 || this.ui.disabled)
        return;

    evt.stopPropagation();
    evt.preventDefault();
    this.ui.emit('click');
};

Button.prototype._onClick = function() {
    this._element.blur();
};

Button.prototype._onLinkChange = function(value) {
    this._element.value = value;
};

Object.defineProperty(Button.prototype, 'text', {
    get: function() {
        return this._text;
    },
    set: function(value) {
        if (this._text === value) return;
        this._text = value;
        this._element.innerHTML = this._text;
    }
});


window.ui.Button = Button;


/* ui/checkbox.js */
"use strict";

function Checkbox(args) {
    ui.Element.call(this);
    args = args || { };

    this._text = args.text || '';

    this.element = document.createElement('div');
    this._element.classList.add('ui-checkbox', 'noSelect');
    this._element.tabIndex = 0;

    this._element.addEventListener('keydown', this._onKeyDown, false);

    this.on('click', this._onClick);
    this.on('change', this._onChange);
}
Checkbox.prototype = Object.create(ui.Element.prototype);


Checkbox.prototype._onClick = function() {
    this.value = ! this.value;
    this._element.blur();
};

Checkbox.prototype._onChange = function() {
    if (! this.renderChanges)
        return;

    this.flash();
};

Checkbox.prototype._onKeyDown = function(evt) {
    if (evt.keyCode === 27)
        return this.blur();

    if (evt.keyCode !== 32 || this.ui.disabled)
        return;

    evt.stopPropagation();
    evt.preventDefault();
    this.ui.value = ! this.ui.value;
};

Checkbox.prototype._onLinkChange = function(value) {
    if (value === null) {
        this._element.classList.remove('checked');
        this._element.classList.add('null');
    } else if (value) {
        this._element.classList.add('checked');
        this._element.classList.remove('null');
    } else {
        this._element.classList.remove('checked', 'null');
    }
    this.emit('change', value);
};


Object.defineProperty(Checkbox.prototype, 'value', {
    get: function() {
        if (this._link) {
            return this._link.get(this.path);
        } else {
            return this._element.classList.contains('checked');
        }
    },
    set: function(value) {
        if (this._link) {
            this._link.set(this.path, value);
        } else {
            if (this._element.classList.contains('checked') !== value)
                this._onLinkChange(value);
        }
    }
});


window.ui.Checkbox = Checkbox;


/* ui/code.js */
"use strict";

function Code() {
    ui.ContainerElement.call(this);

    this.element = document.createElement('pre');
    this._element.classList.add('ui-code');
}
Code.prototype = Object.create(ui.ContainerElement.prototype);


Object.defineProperty(Code.prototype, 'text', {
    get: function() {
        return this._element.textContent;
    },
    set: function(value) {
        this._element.textContent = value;
    }
});


window.ui.Code = Code;


/* ui/label.js */
"use strict";

function Label(args) {
    ui.Element.call(this);
    args = args || { };

    this._text = args.text || '';

    this.element = document.createElement('span');
    this._element.classList.add('ui-label');

    if (this._text)
        this._element.innerHTML = this._text;

    this.on('change', this._onChange);

    if (args.placeholder)
        this.placeholder = args.placeholder;
}
Label.prototype = Object.create(ui.Element.prototype);


Label.prototype._onChange = function() {
    if (! this.renderChanges)
        return;

    this.flash();
};

Label.prototype._onLinkChange = function(value) {
    this.text = value;
    this.emit('change', value);
};


Object.defineProperty(Label.prototype, 'text', {
    get: function() {
        if (this._link) {
            return this._link.get(this.path);
        } else {
            return this._text;
        }
    },
    set: function(value) {
        if (this._link) {
            if (! this._link.set(this.path, value)) {
                value = this._link.get(this.path);
                this._element.innerHTML = value;
            }
        } else {
            if (this._text === value) return;

            this._text = value;
            if (value === undefined || value === null)
                this._text = '';

            this._element.innerHTML = this._text;
            this.emit('change', value);
        }
    }
});

Object.defineProperty(Label.prototype, 'value', {
    get: function () {
        return this.text;
    },
    set: function (value) {
        this.text = value;
    }
});

Object.defineProperty(Label.prototype, 'placeholder', {
    get: function() {
        return this._element.getAttribute('placeholder');
    },
    set: function(value) {
        this._element.setAttribute('placeholder', value);
    }
});


window.ui.Label = Label;


/* ui/number-field.js */
"use strict";

function NumberField(args) {
    ui.Element.call(this);
    args = args || { };

    this.precision = (args.precision != null) ? args.precision : null;
    this.step = (args.step != null) ? args.step : ((args.precision != null) ? 1 / Math.pow(10, args.precision) : 1);

    this.max = (args.max !== null) ? args.max : null;
    this.min = (args.min !== null) ? args.min : null;

    this.element = document.createElement('div');
    this._element.classList.add('ui-number-field');

    this.elementInput = document.createElement('input');
    this.elementInput.ui = this;
    this.elementInput.tabIndex = 0;
    this.elementInput.classList.add('field');
    this.elementInput.type = 'text';
    this.elementInput.addEventListener('focus', this._onInputFocus, false);
    this.elementInput.addEventListener('blur', this._onInputBlur, false);
    this.elementInput.addEventListener('keydown', this._onKeyDown, false);
    this.elementInput.addEventListener('dblclick', this._onFullSelect, false);
    this.elementInput.addEventListener('contextmenu', this._onFullSelect, false);
    this._element.appendChild(this.elementInput);

    if (args.default !== undefined)
        this.value = args.default;

    this.elementInput.addEventListener('change', this._onChange, false);
    // this._element.addEventListener('mousedown', this._onMouseDown.bind(this), false);
    // this._element.addEventListener('mousewheel', this._onMouseDown.bind(this), false);

    this.blurOnEnter = true;
    this.refocusable = true;

    this._lastValue = this.value;
    this._mouseMove = null;
    this._dragging = false;
    this._dragDiff = 0;
    this._dragStart = 0;

    this.on('disable', this._onDisable);
    this.on('enable', this._onEnable);
    this.on('change', this._onChangeField);

    if (args.placeholder)
        this.placeholder = args.placeholder;
}
NumberField.prototype = Object.create(ui.Element.prototype);


NumberField.prototype._onLinkChange = function(value) {
    this.elementInput.value = value || 0;
    this.emit('change', value || 0);
};

NumberField.prototype._onChange = function() {
    var value = parseFloat(this.ui.elementInput.value, 10) || 0;
    this.ui.elementInput.value = value;
    this.ui.value = value;
};

NumberField.prototype.focus = function(select) {
    this.elementInput.focus();
    if (select) this.elementInput.select();
};

NumberField.prototype._onInputFocus = function() {
    this.ui.class.add('focus');
};

NumberField.prototype._onInputBlur = function() {
    this.ui.class.remove('focus');
};

NumberField.prototype._onKeyDown = function(evt) {
    if (evt.keyCode === 27)
        return this.blur();

    if (this.ui.blurOnEnter && evt.keyCode === 13) {
        var focused = false;

        var parent = this.ui.parent;
        while(parent) {
            if (parent.focus) {
                parent.focus();
                focused = true;
                break;
            }

            parent = parent.parent;
        }

        if (! focused)
            this.blur();

        return;
    }

    if (this.ui.disabled || [ 38, 40 ].indexOf(evt.keyCode) === -1)
        return;

    var inc = evt.keyCode === 40 ? -1 : 1;

    if (evt.shiftKey)
        inc *= 10;

    var value = this.ui.value + (this.ui.step || 1) * inc;

    if (this.ui.max != null)
        value = Math.min(this.ui.max, value);

    if (this.ui.min != null)
        value = Math.max(this.ui.min, value);

    if (this.ui.precision != null)
        value = parseFloat(value.toFixed(this.ui.precision), 10);

    this.value = value;
    this.ui.value = value;
};

NumberField.prototype._onFullSelect = function() {
    this.select();
};

NumberField.prototype._onDisable = function() {
    this.elementInput.readOnly = true;
};

NumberField.prototype._onEnable = function() {
    this.elementInput.readOnly = false;
};

NumberField.prototype._onChangeField = function() {
    if (! this.renderChanges)
        return;

    this.flash();
};

Object.defineProperty(NumberField.prototype, 'value', {
    get: function() {
        if (this._link) {
            return this._link.get(this.path);
        } else {
            return this.elementInput.value !== '' ? parseFloat(this.elementInput.value, 10) : null;
        }
    },
    set: function(value) {
        if (this._link) {
            if (! this._link.set(this.path, value)) {
                this.elementInput.value = this._link.get(this.path);
            }
        } else {
            if (this.max !== null && this.max < value)
                value = this.max;

            if (this.min !== null && this.min > value)
                value = this.min;

            value = (value !== null && value !== undefined && (this.precision !== null) ? parseFloat(value.toFixed(this.precision), 10) : value);
            if (value === undefined)
                value = null;

            var different = this._lastValue !== value;

            this._lastValue = value;
            this.elementInput.value = value;

            if (different) {
                this.emit('change', value);
            }
        }
    }
});


Object.defineProperty(NumberField.prototype, 'placeholder', {
    get: function() {
        return this._element.getAttribute('placeholder');
    },
    set: function(value) {
        if (! value) {
            this._element.removeAttribute('placeholder');
        } else {
            this._element.setAttribute('placeholder', value);
        }
    }
});


Object.defineProperty(NumberField.prototype, 'proxy', {
    get: function() {
        return this._element.getAttribute('proxy');
    },
    set: function(value) {
        if (! value) {
            this._element.removeAttribute('proxy');
        } else {
            this._element.setAttribute('proxy', value);
        }
    }
});


window.ui.NumberField = NumberField;


/* ui/overlay.js */
"use strict"

function Overlay(args) {
    ui.ContainerElement.call(this);
    args = args || { };

    this.element = document.createElement('div');
    this._element.classList.add('ui-overlay', 'center');

    this.elementOverlay = document.createElement('div');
    this.elementOverlay.ui = this;
    this.elementOverlay.classList.add('overlay', 'clickable');
    this._element.appendChild(this.elementOverlay);

    this.elementOverlay.addEventListener('mousedown', this._onMouseDown, false);

    this.innerElement = document.createElement('div');
    this.innerElement.classList.add('content');
    this._element.appendChild(this.innerElement);
}
Overlay.prototype = Object.create(ui.ContainerElement.prototype);

Overlay.prototype._onMouseDown = function(evt) {
    if (! this.ui.clickable)
        return false;

    var self = this;

    // some field might be in focus
    document.body.blur();

    // wait till blur takes in account
    requestAnimationFrame(function() {
        // hide overlay
        self.ui.hidden = true;
    }, 0);

    evt.preventDefault();
};


Object.defineProperty(Overlay.prototype, 'center', {
    get: function() {
        return this._element.classList.contains('center');
    },
    set: function(value) {
        if (value) {
            this._element.classList.add('center');
            this.innerElement.style.left = '';
            this.innerElement.style.top = '';
        } else {
            this._element.classList.remove('center');
        }
    }
});


Object.defineProperty(Overlay.prototype, 'transparent', {
    get: function() {
        return this._element.classList.contains('transparent');
    },
    set: function(value) {
        if (value) {
            this._element.classList.add('transparent');
        } else {
            this._element.classList.remove('transparent');
        }
    }
});

Object.defineProperty(Overlay.prototype, 'clickable', {
    get: function() {
        return this.elementOverlay.classList.contains('clickable');
    },
    set: function(value) {
        if (value) {
            this.elementOverlay.classList.add('clickable');
        } else {
            this.elementOverlay.classList.remove('clickable');
        }
    }
});


Object.defineProperty(Overlay.prototype, 'rect', {
    get: function() {
        return this.innerElement.getBoundingClientRect();
    }
});


Overlay.prototype.position = function(x, y) {

    var area = this.elementOverlay.getBoundingClientRect();
    var rect = this.innerElement.getBoundingClientRect();

    x = Math.max(0, Math.min(area.width - rect.width, x));
    y = Math.max(0, Math.min(area.height - rect.height, y));

    this.innerElement.style.left = x + 'px';
    this.innerElement.style.top = y + 'px';
};


window.ui.Overlay = Overlay;


/* ui/panel.js */
"use strict";

function Panel(header) {
    var self = this;

    ui.ContainerElement.call(this);

    this.element = document.createElement('div');
    this._element.classList.add('ui-panel', 'noHeader', 'noAnimation');

    this.headerElement = null;
    this.headerElementTitle = null;

    if (header)
        this.header = header;

    this.on('nodesChanged', this._onNodesChanged);

    // content
    this.innerElement = document.createElement('div');
    this.innerElement.ui = this;
    this.innerElement.classList.add('content');
    this._element.appendChild(this.innerElement);

    this.innerElement.addEventListener('scroll', this._onScroll, false);

    this._resizeEvtMove = function(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        self._resizeMove(evt.clientX, evt.clientY);
    };

    this._resizeEvtEnd = function(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        self._resizeEnd();
    };

    this._resizeEvtTouchMove = function(evt) {
        for(var i = 0; i < evt.changedTouches.length; i++) {
            var touch = evt.changedTouches[i];

            if (touch.identifier !== self._resizeTouchId)
                continue;

            evt.preventDefault();
            evt.stopPropagation();
            self._resizeMove(touch.clientX, touch.clientY);

            return;
        }
    };

    this._resizeEvtTouchEnd = function(evt) {
        for(var i = 0; i < evt.changedTouches.length; i++) {
            var touch = evt.changedTouches[i];

            if (touch.identifier !== self._resizeTouchId)
                continue;

            self._resouzeTouchId = null;

            evt.preventDefault();
            evt.stopPropagation();
            self._resizeEnd();

            return;
        }
    };

    // HACK
    // skip 2 frames before enabling transitions
    requestAnimationFrame(function() {
        requestAnimationFrame(function() {
            self.class.remove('noAnimation');
        });
    });

    // on parent change
    this.on('parent', this._onParent);

    this._handleElement = null;
    this._handle = null;
    this._resizeTouchId = null;
    this._resizeData = null;
    this._resizeLimits = {
        min: 0,
        max: Infinity
    };

    this.headerSize = 0;
}
Panel.prototype = Object.create(ui.ContainerElement.prototype);

Panel.prototype._onNodesChanged = function() {
    if (! this.foldable || this.folded || this.horizontal || this.hidden)
        return;

    this.style.height = (Math.max(0, (this.headerSize || 32)) + this.innerElement.clientHeight) + 'px';
};

Panel.prototype._onParent = function() {
    // HACK
    // wait till DOM parses, then reflow
    requestAnimationFrame(this._reflow.bind(this));
};

Object.defineProperty(Panel.prototype, 'header', {
    get: function() {
        return (this.headerElement && this.headerElementTitle.textContent) || '';
    },
    set: function(value) {
        if (! this.headerElement && value) {
            this.headerElement = document.createElement('header');
            this.headerElement.classList.add('ui-header');

            this.headerElementTitle = document.createElement('span');
            this.headerElementTitle.classList.add('title');
            this.headerElementTitle.textContent = value;
            this.headerElement.appendChild(this.headerElementTitle);

            var first = this._element.firstChild;
            if (first) {
                this._element.insertBefore(this.headerElement, first);
            } else {
                this._element.appendChild(this.headerElement);
            }

            this.class.remove('noHeader');

            var self = this;

            // folding
            this.headerElement.addEventListener('click', function(evt) {
                if (! self.foldable || (evt.target !== self.headerElement && evt.target !== self.headerElementTitle))
                    return;

                self.folded = ! self.folded;
            }, false);
        } else if (! value && this.headerElement) {
            this.headerElement.parentNode.removeChild(this.headerElement);
            this.headerElement = null;
            this.headerElementTitle = null;
            this.class.add('noHeader');
        } else {
            this.headerElementTitle.textContent = value || '';
            this.class.remove('noHeader');
        }
    }
});


Panel.prototype.headerAppend = function(element) {
    if (! this.headerElement)
        return;

    var html = (element instanceof HTMLElement);
    var node = html ? element : element.element;

    this.headerElement.insertBefore(node, this.headerElementTitle);

    if (! html)
        element.parent = this;
};


Panel.prototype._reflow = function() {
    if (this.hidden)
        return;

    if (this.folded) {
        if (this.horizontal) {
            this.style.height = '';
            this.style.width = (this.headerSize || 32) + 'px';
        } else {
            this.style.height = (this.headerSize || 32) + 'px';
        }
    } else if (this.foldable) {
        if (this.horizontal) {
            this.style.height = '';
            this.style.width = this._innerElement.clientWidth + 'px';
        } else {
            this.style.height = ((this.headerSize || 32) + this._innerElement.clientHeight) + 'px';
        }
    }
};


Panel.prototype._onScroll = function(evt) {
    this.ui.emit('scroll', evt);
};


Object.defineProperty(Panel.prototype, 'foldable', {
    get: function() {
        return this.class.contains('foldable');
    },
    set: function(value) {
        if (value) {
            this.class.add('foldable');

            if(this.class.contains('folded'))
                this.emit('fold');
        } else {
            this.class.remove('foldable');

            if (this.class.contains('folded'))
                this.emit('unfold');
        }

        this._reflow();
    }
});


Object.defineProperty(Panel.prototype, 'folded', {
    get: function() {
        return this.class.contains('foldable') && this.class.contains('folded');
    },
    set: function(value) {
        if (this.hidden)
            return;

        if (this.class.contains('folded') === !! value)
            return;

        if (this.headerElement && this.headerSize === 0)
            this.headerSize = this.headerElement.clientHeight;

        if (value) {
            this.class.add('folded');

            if (this.class.contains('foldable'))
                this.emit('fold');
        } else {
            this.class.remove('folded');

            if (this.class.contains('foldable'))
                this.emit('unfold');
        }

        this._reflow();
    }
});


Object.defineProperty(Panel.prototype, 'horizontal', {
    get: function() {
        return this.class.contains('horizontal');
    },
    set: function(value) {
        if (value) {
            this.class.add('horizontal');
        } else {
            this.class.remove('horizontal');
        }
        this._reflow();
    }
});


Object.defineProperty(Panel.prototype, 'resizable', {
    get: function() {
        return this._handle;
    },
    set: function(value) {
        if (this._handle === value)
            return;

        var oldHandle = this._handle;
        this._handle = value;

        if (this._handle) {
            if (! this._handleElement) {
                this._handleElement = document.createElement('div');
                this._handleElement.ui = this;
                this._handleElement.classList.add('handle');
                this._handleElement.addEventListener('mousedown', this._resizeStart, false);
                this._handleElement.addEventListener('touchstart', this._resizeStart, false);
            }

            if (this._handleElement.parentNode)
                this._element.removeChild(this._handleElement);
            // TODO
            // append in right place
            this._element.appendChild(this._handleElement);
            this.class.add('resizable', 'resizable-' + this._handle);
        } else {
            this._element.removeChild(this._handleElement);
            this.class.remove('resizable', 'resizable-' + oldHandle);
        }

        this._reflow();
    }
});


Object.defineProperty(Panel.prototype, 'resizeMin', {
    get: function() {
        return this._resizeLimits.min;
    },
    set: function(value) {
        this._resizeLimits.min = Math.max(0, Math.min(this._resizeLimits.max, value));
    }
});


Object.defineProperty(Panel.prototype, 'resizeMax', {
    get: function() {
        return this._resizeLimits.max;
    },
    set: function(value) {
        this._resizeLimits.max = Math.max(this._resizeLimits.min, value);
    }
});


Panel.prototype._resizeStart = function(evt) {
    if (! this.ui._handle)
        return;

    if (evt.changedTouches) {
        for(var i = 0; i < evt.changedTouches.length; i++) {
            var touch = evt.changedTouches[i];
            if (touch.target !== this)
                continue;

            this.ui._resizeTouchId = touch.identifier;
        }
    }

    this.ui.class.add('noAnimation', 'resizing');
    this.ui._resizeData = null;

    window.addEventListener('mousemove', this.ui._resizeEvtMove, false);
    window.addEventListener('mouseup', this.ui._resizeEvtEnd, false);

    window.addEventListener('touchmove', this.ui._resizeEvtTouchMove, false);
    window.addEventListener('touchend', this.ui._resizeEvtTouchEnd, false);

    evt.preventDefault();
    evt.stopPropagation();
};


Panel.prototype._resizeMove = function(x, y) {
    if (! this._resizeData) {
        this._resizeData = {
            x: x,
            y: y,
            width: this._innerElement.clientWidth,
            height: this._innerElement.clientHeight
        };
    } else {
        if (this._handle === 'left' || this._handle === 'right') {
            // horizontal
            var offsetX = this._resizeData.x - x;

            if (this._handle === 'right')
                offsetX = -offsetX;

            var width = Math.max(this._resizeLimits.min, Math.min(this._resizeLimits.max, (this._resizeData.width + offsetX)));

            this.style.width = (width + 4) + 'px';
            this._innerElement.style.width = (width + 4) + 'px';
        } else {
            // vertical
            var offsetY = this._resizeData.y - y;

            if (this._handle === 'bottom')
                offsetY = -offsetY;

            var height = Math.max(this._resizeLimits.min, Math.min(this._resizeLimits.max, (this._resizeData.height + offsetY)));

            this.style.height = (height + (this.headerSize === -1 ? 0 : this.headerSize || 32)) + 'px';
            this._innerElement.style.height = height + 'px';
        }
    }

    this.emit('resize');
};

Panel.prototype._resizeEnd = function(evt) {
    window.removeEventListener('mousemove', this._resizeEvtMove, false);
    window.removeEventListener('mouseup', this._resizeEvtEnd, false);

    window.removeEventListener('touchmove', this._resizeEvtTouchMove, false);
    window.removeEventListener('touchend', this._resizeEvtTouchEnd, false);

    this.class.remove('noAnimation', 'resizing');
    this._resizeData = null;
};


window.ui.Panel = Panel;


/* ui/select-field.js */
"use strict";

function SelectField(args) {
    var self = this;
    ui.Element.call(this);
    args = args || { };

    this.options = args.options || { };
    this.optionsKeys = [ ];
    if (this.options instanceof Array) {
        var options = { };
        for(var i = 0; i < this.options.length; i++) {
            this.optionsKeys.push(this.options[i].v);
            options[this.options[i].v] = this.options[i].t;
        }
        this.options = options;
    } else {
        this.optionsKeys = Object.keys(this.options);
    }

    this.element = document.createElement('div');
    this._element.tabIndex = 0;
    this._element.classList.add('ui-select-field', 'noSelect');

    this.elementValue = document.createElement('div');
    this.elementValue.ui = this;
    this.elementValue.classList.add('value');
    this._element.appendChild(this.elementValue);

    this._oldValue = null;
    this._value = null;
    this._type = args.type || 'string';

    this.timerClickAway = null;
    this.evtTouchId = null;
    this.evtTouchSecond = false;
    this.evtMouseDist = [ 0, 0 ];
    this.evtMouseUp = function(evt) {
        evt.preventDefault();
        evt.stopPropagation();

        self._onHoldSelect(evt.target, evt.pageX, evt.pageY);
    };

    this.evtTouchEnd = function(evt) {
        for(var i = 0; i < evt.changedTouches.length; i++) {
            var touch = evt.changedTouches[i];
            if (touch.identifier !== self.evtTouchId)
                continue;

            self.evtTouchId = null;

            evt.preventDefault();
            evt.stopPropagation();

            var target = document.elementFromPoint(touch.pageX, touch.pageY);

            self._onHoldSelect(target, touch.pageX, touch.pageY);
        }

        if (self.evtTouchSecond) {
            evt.preventDefault();
            evt.stopPropagation();
            self.close();
        } else if (self._element.classList.contains('active')) {
            self.evtTouchSecond = true;
        }
    };

    this.elementValue.addEventListener('mousedown', this._onMouseDown, false);
    this.elementValue.addEventListener('touchstart', this._onTouchStart, false);

    this.elementOptions = document.createElement('ul');
    this._element.appendChild(this.elementOptions);

    this.optionElements = { };

    if (args.default !== undefined && this.options[args.default] !== undefined) {
        this._value = this.valueToType(args.default);
        this._oldValue = this._value;
    }

    this._optionSelectHandler = null;

    this.on('link', this._onLink);
    this._updateOptions();

    this.on('change', this._onChange);

    // arrows - change
    this._element.addEventListener('keydown', this._onKeyDown, false);
}
SelectField.prototype = Object.create(ui.Element.prototype);


SelectField.prototype._onHoldSelect = function(target, x, y) {
    if (target && target.uiElement && target.uiElement === this && target.classList.contains('selected'))
        return;

    if ((Math.abs(x - this.evtMouseDist[0]) + Math.abs(y - this.evtMouseDist[1])) < 8)
        return;

    if (target && target.uiElement && target.uiElement === this)
        this._onOptionSelect.call(target);

    this.close();
};

SelectField.prototype._onMouseDown = function(evt) {
    if (this.ui.disabled && ! this.ui.disabledClick)
        return;

    if (this.ui.element.classList.contains('active')) {
        this.ui.close();
    } else {
        evt.preventDefault();
        evt.stopPropagation();
        this.ui.evtMouseDist[0] = evt.pageX;
        this.ui.evtMouseDist[1] = evt.pageY;
        this.ui.element.focus();
        this.ui.open();
        window.addEventListener('mouseup', this.ui.evtMouseUp);
    }
};

SelectField.prototype._onTouchStart = function(evt) {
    if (this.ui.disabled && ! this.ui.disabledClick)
        return;

    if (this.ui.element.classList.contains('active')) {
        this.ui.close();
    } else {
        evt.preventDefault();
        evt.stopPropagation();

        var touch;

        for(var i = 0; i < evt.changedTouches.length; i++) {
            if (evt.changedTouches[i].target !== this)
                continue;

            touch = evt.changedTouches[i];

            break;
        }

        if (! touch) return;

        this.ui.evtTouchId = touch.identifier;
        this.ui.evtMouseDist[0] = touch.pageX;
        this.ui.evtMouseDist[1] = touch.pageY;
        this.ui.element.focus();
        this.ui.open();
        window.addEventListener('touchend', this.ui.evtTouchEnd);
    }
};

SelectField.prototype._onLink = function(path) {
    if (this._link.schema && this._link.schema.has(path)) {
        var field = this._link.schema.get(path);
        var options = field.options || { };
        this._updateOptions(options);
    }
};

SelectField.prototype._onChange = function() {
    if (! this.renderChanges)
        return;

    this.flash();
};

SelectField.prototype._onKeyDown = function(evt) {
    if (evt.keyCode === 27) {
        this.ui.close();
        this.blur();
        return;
    }

    if ((this.ui.disabled && ! this.ui.disabledClick) || [ 38, 40 ].indexOf(evt.keyCode) === -1)
        return;

    evt.stopPropagation();
    evt.preventDefault();

    var keys = Object.keys(this.ui.options);
    var ind = keys.indexOf(this.ui.value !== undefined ? this.ui.value.toString() : null);

    var y = evt.keyCode === 38 ? -1 : 1;

    // already first item
    if (y === -1 && ind <= 0)
        return;

    // already last item
    if (y === 1 && ind === (keys.length - 1))
        return

    // set new item
    this.ui.value = keys[ind + y];
};

SelectField.prototype.valueToType = function(value) {
    switch(this._type) {
        case 'boolean':
            return !! value;
            break;
        case 'number':
            return parseInt(value, 10);
            break;
        case 'string':
            return '' + value;
            break;
    }
};


SelectField.prototype.open = function() {
    if ((this.disabled && ! this.disabledClick) || this._element.classList.contains('active'))
        return;

    this._element.classList.add('active');

    var rect = this._element.getBoundingClientRect();

    // left
    var left = Math.round(rect.left) + ((Math.round(rect.width) - this._element.clientWidth) / 2);

    // top
    var top = rect.top;
    if (this.optionElements[this._value]) {
        top -= this.optionElements[this._value].offsetTop;
        top += (Math.round(rect.height) - this.optionElements[this._value].clientHeight) / 2;
    }

    // limit to bottom / top of screen
    if (top + this.elementOptions.clientHeight > window.innerHeight) {
        top = window.innerHeight - this.elementOptions.clientHeight + 1;
    } else if (top < 0) {
        top = 0;
    }

    // top
    this.elementOptions.style.top = Math.max(0, top) + 'px';
    // left
    this.elementOptions.style.left = left + 'px';
    // right
    this.elementOptions.style.width = Math.round(this._element.clientWidth) + 'px';
    // bottom
    if (top <= 0 && this.elementOptions.offsetHeight >= window.innerHeight) {
        this.elementOptions.style.bottom = '0';
        this.elementOptions.style.height = 'auto';

        // scroll to item
        if (this.optionElements[this._value]) {
            var off = this.optionElements[this._value].offsetTop - rect.top;
            this.elementOptions.scrollTop = off;
        }
    } else {
        this.elementOptions.style.bottom = '';
        this.elementOptions.style.height = '';
    }

    var self = this;
    this.timerClickAway = setTimeout(function() {
        var looseActive = function() {
            self.element.classList.remove('active');
            self.element.blur();
            window.removeEventListener('click', looseActive);
        };

        window.addEventListener('click', looseActive);
    }, 300);

    this.emit('open');
};


SelectField.prototype.close = function() {
    if ((this.disabled && ! this.disabledClick) || ! this._element.classList.contains('active'))
        return;

    window.removeEventListener('mouseup', this.evtMouseUp);
    window.removeEventListener('touchend', this.evtTouchEnd);

    if (this.timerClickAway) {
        clearTimeout(this.timerClickAway);
        this.timerClickAway = null;
    }

    this._element.classList.remove('active');

    this.elementOptions.style.top = '';
    this.elementOptions.style.right = '';
    this.elementOptions.style.bottom = '';
    this.elementOptions.style.left = '';
    this.elementOptions.style.width = '';
    this.elementOptions.style.height = '';

    this.emit('close');

    this.evtTouchSecond = false;
};


SelectField.prototype.toggle = function() {
    if (this._element.classList.contains('active')) {
        this.close();
    } else {
        this.open();
    }
};


SelectField.prototype._updateOptions = function(options) {
    if (options !== undefined) {
        if (options instanceof Array) {
            this.options = { };
            this.optionsKeys = [ ];
            for(var i = 0; i < options.length; i++) {
                this.optionsKeys.push(options[i].v);
                this.options[options[i].v] = options[i].t;
            }
        } else {
            this.options = options;
            this.optionsKeys = Object.keys(options);
        }
    }

    if (! this._optionSelectHandler)
        this._optionSelectHandler = this._onOptionSelect.bind(this);

    for(var value in this.optionElements) {
        this.optionElements[value].removeEventListener('click', this._onOptionSelect);
    }

    this.optionElements = { };
    this.elementOptions.innerHTML = '';

    for(var i = 0; i < this.optionsKeys.length; i++) {
        if (! this.options.hasOwnProperty(this.optionsKeys[i]))
            continue;

        var element = document.createElement('li');
        element.textContent = this.options[this.optionsKeys[i]];
        element.uiElement = this;
        element.uiValue = this.optionsKeys[i];
        element.addEventListener('click', this._onOptionSelect);
        element.addEventListener('touchstart', this._onOptionSelect);
        element.addEventListener('mouseover', this._onOptionHover);
        element.addEventListener('mouseout', this._onOptionOut);
        this.elementOptions.appendChild(element);
        this.optionElements[this.optionsKeys[i]] = element;
    }
};

SelectField.prototype._onOptionSelect = function() {
    this.uiElement.value = this.uiValue;
};

SelectField.prototype._onOptionHover = function() {
    this.classList.add('hover');
};

SelectField.prototype._onOptionOut = function() {
    this.classList.remove('hover');
};

SelectField.prototype._onLinkChange = function(value) {
    if (this.optionElements[value] === undefined)
        return;

    if (this.optionElements[this._oldValue]) {
        this.optionElements[this._oldValue].classList.remove('selected');
    }

    this._value = this.valueToType(value);
    this.elementValue.textContent = this.options[value];
    this.optionElements[value].classList.add('selected');
    this.emit('change', value);
};


Object.defineProperty(SelectField.prototype, 'value', {
    get: function() {
        if (this._link) {
            return this._link.get(this.path);
        } else {
            return this._value;
        }
    },
    set: function(raw) {
        var value = this.valueToType(raw);

        if (this._link) {
            this._oldValue = this._value;
            this.emit('change:before', value);
            this._link.set(this.path, value);
        } else {
            if ((value === null || value === undefined || raw === '') && this.optionElements[''])
                value = '';

            if (this._oldValue === value) return;
            if (value !== null && this.options[value] === undefined) return;

            // deselect old one
            if (this.optionElements[this._oldValue])
                this.optionElements[this._oldValue].classList.remove('selected');

            this._value = value;
            if (value !== '')
                this._value = this.valueToType(this._value);

            this.emit('change:before', this._value);
            this._oldValue = this._value;
            if (this.options[this._value]) {
                this.elementValue.textContent = this.options[this._value];
                this.optionElements[this._value].classList.add('selected');
            } else {
                this.elementValue.textContent = '';
            }
            this.emit('change', this._value);
        }
    }
});


window.ui.SelectField = SelectField;


/* ui/text-field.js */
"use strict";

function TextField(args) {
    ui.Element.call(this);
    args = args || { };

    this.element = document.createElement('div');
    this._element.classList.add('ui-text-field');

    this.elementInput = document.createElement('input');
    this.elementInput.ui = this;
    this.elementInput.classList.add('field');
    this.elementInput.type = 'text';
    this.elementInput.tabIndex = 0;
    this.elementInput.addEventListener('focus', this._onInputFocus, false);
    this.elementInput.addEventListener('blur', this._onInputBlur, false);
    this._element.appendChild(this.elementInput);

    if (args.default !== undefined)
        this.value = args.default;

    this.elementInput.addEventListener('change', this._onChange, false);
    this.elementInput.addEventListener('keydown', this._onKeyDown, false);
    this.elementInput.addEventListener('contextmenu', this._onFullSelect, false);
    this.evtKeyChange = false;
    this.ignoreChange = false;

    this.blurOnEnter = true;
    this.refocusable = true;

    this.on('disable', this._onDisable);
    this.on('enable', this._onEnable);
    this.on('change', this._onChangeField);

    if (args.placeholder)
        this.placeholder = args.placeholder;
}
TextField.prototype = Object.create(ui.Element.prototype);


TextField.prototype._onLinkChange = function(value) {
    this.elementInput.value = value;
    this.emit('change', value);
};


TextField.prototype._onChange = function() {
    if (this.ui.ignoreChange) return;

    this.ui.value = this.ui.value || '';

    if (! this.ui._link)
        this.ui.emit('change', this.ui.value);
};


TextField.prototype._onKeyDown = function(evt) {
    if (evt.keyCode === 27) {
        this.blur();
    } else if (this.ui.blurOnEnter && evt.keyCode === 13) {
        var focused = false;

        var parent = this.ui.parent;
        while(parent) {
            if (parent.focus) {
                parent.focus();
                focused = true;
                break;
            }

            parent = parent.parent;
        }

        if (! focused)
            this.blur();
    }
};


TextField.prototype._onFullSelect = function() {
    this.select();
};


TextField.prototype.focus = function(select) {
    this.elementInput.focus();
    if (select) this.elementInput.select();
};


TextField.prototype._onInputFocus = function() {
    this.ui.class.add('focus');
    this.ui.emit('input:focus');
};


TextField.prototype._onInputBlur = function() {
    this.ui.class.remove('focus');
    this.ui.emit('input:blur');
};

TextField.prototype._onDisable = function() {
    this.elementInput.readOnly = true;
};

TextField.prototype._onEnable = function() {
    this.elementInput.readOnly = false;
};

TextField.prototype._onChangeField = function() {
    if (! this.renderChanges)
        return;

    this.flash();
};


Object.defineProperty(TextField.prototype, 'value', {
    get: function() {
        if (this._link) {
            return this._link.get(this.path);
        } else {
            return this.elementInput.value;
        }
    },
    set: function(value) {
        if (this._link) {
            if (! this._link.set(this.path, value)) {
                this.elementInput.value = this._link.get(this.path);
            }
        } else {
            if (this.elementInput.value === value)
                return;

            this.elementInput.value = value || '';
            this.emit('change', value);
        }
    }
});


Object.defineProperty(TextField.prototype, 'placeholder', {
    get: function() {
        return this._element.getAttribute('placeholder');
    },
    set: function(value) {
        if (! value) {
            this._element.removeAttribute('placeholder');
        } else {
            this._element.setAttribute('placeholder', value);
        }
    }
});


Object.defineProperty(TextField.prototype, 'proxy', {
    get: function() {
        return this._element.getAttribute('proxy');
    },
    set: function(value) {
        if (! value) {
            this._element.removeAttribute('proxy');
        } else {
            this._element.setAttribute('proxy', value);
        }
    }
});


Object.defineProperty(TextField.prototype, 'keyChange', {
    get: function() {
        return !! this.evtKeyChange;
    },
    set: function(value) {
        if (!! this.evtKeyChange === !! value)
            return;

        if (value) {
            this.elementInput.addEventListener('keyup', this._onChange, false);
        } else {
            this.elementInput.removeEventListener('keyup', this._onChange);
        }
    }
});


window.ui.TextField = TextField;


/* ui/textarea-field.js */
"use strict";

function TextAreaField(args) {
    ui.Element.call(this);
    args = args || { };

    this.element = document.createElement('div');
    this._element.classList.add('ui-textarea-field');

    this.elementInput = document.createElement('textarea');
    this.elementInput.ui = this;
    this.elementInput.classList.add('field');
    this.elementInput.tabIndex = 0;
    this.elementInput.addEventListener('focus', this._onInputFocus, false);
    this.elementInput.addEventListener('blur', this._onInputBlur, false);
    this._element.appendChild(this.elementInput);

    if (args.default !== undefined)
        this.value = args.default;

    this.elementInput.addEventListener('change', this._onChange, false);
    this.elementInput.addEventListener('keydown', this._onKeyDown, false);
    this.elementInput.addEventListener('contextmenu', this._onFullSelect, false);
    this.evtKeyChange = false;
    this.ignoreChange = false;

    this.blurOnEnter = true;
    this.refocusable = true;

    this.on('disable', this._onDisable);
    this.on('enable', this._onEnable);
    this.on('change', this._onChangeField);

    if (args.placeholder)
        this.placeholder = args.placeholder;
}
TextAreaField.prototype = Object.create(ui.Element.prototype);


TextAreaField.prototype._onLinkChange = function(value) {
    this.elementInput.value = value;
    this.emit('change', value);
};


TextAreaField.prototype._onChange = function() {
    if (this.ui.ignoreChange) return;

    this.ui.value = this.ui.value || '';

    if (! this.ui._link)
        this.ui.emit('change', this.ui.value);
};


TextAreaField.prototype._onKeyDown = function(evt) {
    if (evt.keyCode === 27) {
        this.blur();
    } else if (this.ui.blurOnEnter && evt.keyCode === 13 && ! evt.shiftKey) {
        var focused = false;

        var parent = this.ui.parent;
        while(parent) {
            if (parent.focus) {
                parent.focus();
                focused = true;
                break;
            }

            parent = parent.parent;
        }

        if (! focused)
            this.blur();
    }
};


TextAreaField.prototype._onFullSelect = function() {
    this.select();
};


TextAreaField.prototype.focus = function(select) {
    this.elementInput.focus();
    if (select) this.elementInput.select();
};


TextAreaField.prototype._onInputFocus = function() {
    this.ui.class.add('focus');
    this.ui.emit('input:focus');
};


TextAreaField.prototype._onInputBlur = function() {
    this.ui.class.remove('focus');
    this.ui.emit('input:blur');
};

TextAreaField.prototype._onDisable = function() {
    this.elementInput.readOnly = true;
};

TextAreaField.prototype._onEnable = function() {
    this.elementInput.readOnly = false;
};

TextAreaField.prototype._onChangeField = function() {
    if (! this.renderChanges)
        return;

    this.flash();
};


Object.defineProperty(TextAreaField.prototype, 'value', {
    get: function() {
        if (this._link) {
            return this._link.get(this.path);
        } else {
            return this.elementInput.value;
        }
    },
    set: function(value) {
        if (this._link) {
            if (! this._link.set(this.path, value)) {
                this.elementInput.value = this._link.get(this.path);
            }
        } else {
            if (this.elementInput.value === value)
                return;

            this.elementInput.value = value || '';
            this.emit('change', value);
        }
    }
});


Object.defineProperty(TextAreaField.prototype, 'placeholder', {
    get: function() {
        return this._element.getAttribute('placeholder');
    },
    set: function(value) {
        if (! value) {
            this._element.removeAttribute('placeholder');
        } else {
            this._element.setAttribute('placeholder', value);
        }
    }
});


Object.defineProperty(TextAreaField.prototype, 'keyChange', {
    get: function() {
        return !! this.evtKeyChange;
    },
    set: function(value) {
        if (!! this.evtKeyChange === !! value)
            return;

        if (value) {
            this.elementInput.addEventListener('keyup', this._onChange, false);
        } else {
            this.elementInput.removeEventListener('keyup', this._onChange);
        }
    }
});

window.ui.TextAreaField = TextAreaField;


/* ui/color-field.js */
"use strict"

function ColorField(args) {
    var self = this;
    ui.Element.call(this);
    args = args || { };

    this.element = document.createElement('div');
    this._element.tabIndex = 0;
    this._element.classList.add('ui-color-field', 'rgb');

    this.elementColor = document.createElement('span');
    this.elementColor.classList.add('color');
    this._element.appendChild(this.elementColor);

    this._channels = args.channels || 3;
    this._values = [ 0, 0, 0, 0 ];

    // space > click
    this._element.addEventListener('keydown', this._onKeyDown, false);

    // render color back
    this.on('change', this._onChange);

    // link to channels
    this.evtLinkChannels = [ ];
    this.on('link', this._onLink);
    this.on('unlink', this._onUnlink);
}
ColorField.prototype = Object.create(ui.Element.prototype);

ColorField.prototype._onKeyDown = function(evt) {
    if (evt.keyCode === 27)
        return this.blur();

    if (evt.keyCode !== 13 || this.ui.disabled)
        return;

    evt.stopPropagation();
    evt.preventDefault();
    this.ui.emit('click');
};

ColorField.prototype._onChange = function(color) {
    if (this._channels === 1) {
        this.elementColor.style.backgroundColor = 'rgb(' + [ this.r, this.r, this.r ].join(',') + ')';
    } else if (this._channels === 3) {
        this.elementColor.style.backgroundColor = 'rgb(' + this._values.slice(0, 3).join(',') + ')';
    } else if (this._channels === 4) {
        var rgba = this._values.slice(0, 4);
        rgba[3] /= 255;
        this.elementColor.style.backgroundColor = 'rgba(' + rgba.join(',') + ')';
    } else {
        console.log('unknown channels', color);
    }
};

ColorField.prototype._onLink = function() {
    for(var i = 0; i < 4; i++) {
        this.evtLinkChannels[i] = this._link.on(this.path + '.' + i + ':set', function(value) {
            this._setValue(this._link.get(this.path));
        }.bind(this));
    }
};

ColorField.prototype._onUnlink = function() {
    for(var i = 0; i < this.evtLinkChannels.length; i++)
        this.evtLinkChannels[i].unbind();

    this.evtLinkChannels = [ ];
};

ColorField.prototype._onLinkChange = function(value) {
    if (! value)
        return;

    this._setValue(value);
};

Object.defineProperty(ColorField.prototype, 'value', {
    get: function() {
        if (this._link) {
            return this._link.get(this.path).map(function(channel) {
                return Math.floor(channel * 255);
            });
        } else {
            return this._values.slice(0, this._channels);
        }
    },
    set: function(value) {
        if (! value) {
            this.class.add('null');
            return;
        } else {
            this.class.remove('null');
        }

        if (this._link) {
            this._link.set(this.path, value.map(function(channel) {
                return channel / 255;
            }));
        } else {
            this._setValue(value);
        }
    }
});

ColorField.prototype._setValue = function(value) {
    var changed = false;

    if (! value)
        return;

    if (value.length !== this._channels) {
        changed = true;
        this.channels = value.length;
    }

    for(var i = 0; i < this._channels; i++) {
        if (this._values[i] === Math.floor(value[i]))
            continue;

        changed = true;
        this._values[i] = Math.floor(value[i]);
    }

    if (changed)
        this.emit('change', this._values.slice(0, this._channels));
};


Object.defineProperty(ColorField.prototype, 'channels', {
    get: function() {
        return this._channels;
    },
    set: function(value) {
        if (this._channels === value)
            return;

        this._channels = value;
        this.emit('channels', this._channels);
    }
});


Object.defineProperty(ColorField.prototype, 'r', {
    get: function() {
        if (this._link) {
            return Math.floor(this._link.get(this.path + '.0') * 255);
        } else {
            return this._values[0];
        }
    },
    set: function(value) {
        value = Math.min(0, Math.max(255, value));

        if (this._values[0] === value)
            return;

        this._values[0] = value;
        this.emit('r', this._values[0]);
        this.emit('change', this._values.slice(0, this._channels));
    }
});


Object.defineProperty(ColorField.prototype, 'g', {
    get: function() {
        if (this._link) {
            return Math.floor(this._link.get(this.path + '.1') * 255);
        } else {
            return this._values[1];
        }
    },
    set: function(value) {
        value = Math.min(0, Math.max(255, value));

        if (this._values[1] === value)
            return;

        this._values[1] = value;

        if (this._channels >= 2) {
            this.emit('g', this._values[1]);
            this.emit('change', this._values.slice(0, this._channels));
        }
    }
});


Object.defineProperty(ColorField.prototype, 'b', {
    get: function() {
        if (this._link) {
            return Math.floor(this._link.get(this.path + '.2') * 255);
        } else {
            return this._values[2];
        }
    },
    set: function(value) {
        value = Math.min(0, Math.max(255, value));

        if (this._values[2] === value)
            return;

        this._values[2] = value;

        if (this._channels >= 3) {
            this.emit('b', this._values[2]);
            this.emit('change', this._values.slice(0, this._channels));
        }
    }
});


Object.defineProperty(ColorField.prototype, 'a', {
    get: function() {
        if (this._link) {
            return Math.floor(this._link.get(this.path + '.3') * 255);
        } else {
            return this._values[3];
        }
    },
    set: function(value) {
        value = Math.min(0, Math.max(255, value));

        if (this._values[3] === value)
            return;

        this._values[3] = value;

        if (this._channels >= 4) {
            this.emit('a', this._values[3]);
            this.emit('change', this._values.slice(0, this._channels));
        }
    }
});


Object.defineProperty(ColorField.prototype, 'hex', {
    get: function() {
        var values = this._values;

        if (this._link) {
            values = this._link.get(this.path).map(function(channel) {
                return Math.floor(channel * 255);
            });
        }

        var hex = '';
        for(var i = 0; i < this._channels; i++) {
            hex += ('00' + values[i].toString(16)).slice(-2);
        }
        return hex;
    },
    set: function(value) {
        console.log('todo');
    }
});


window.ui.ColorField = ColorField;


/* ui/image-field.js */
"use strict";

function ImageField(args) {
    var self = this;
    ui.Element.call(this);
    args = args || { };

    this.element = document.createElement('div');
    this._element.classList.add('ui-image-field', 'empty');

    if (args.canvas) {
        this.elementImage = document.createElement('canvas');
        this.elementImage.width = 64;
        this.elementImage.height = 64;
    } else {
        this.elementImage = new Image();
    }

    this.elementImage.classList.add('preview');
    this._element.appendChild(this.elementImage);

    this._value = null;

    this._element.removeEventListener('click', this._evtClick);
    this._element.addEventListener('click', this._onClick, false);
    this.on('change', this._onChange);

    // space > click
    this._element.addEventListener('keydown', this._onKeyDown, false);
}
ImageField.prototype = Object.create(ui.Element.prototype);


ImageField.prototype._onClick = function(evt) {
    this.ui.emit('click', evt);
};

ImageField.prototype._onChange = function() {
    if (! this.renderChanges)
        return;

    this.flash();
};

ImageField.prototype._onKeyDown = function(evt) {
    if (evt.keyCode === 27)
        return this.blur();

    if (evt.keyCode !== 32 || this.ui.disabled)
        return;

    evt.stopPropagation();
    evt.preventDefault();
    this.ui.emit('pick');
};

ImageField.prototype._onLinkChange = function(value) {
    this._value = value;
    this.emit('change', value);
};


Object.defineProperty(ImageField.prototype, 'image', {
    get: function() {
        return this.elementImage.src;
    },
    set: function(value) {
        if (this.elementImage.src === value)
            return;

        this.elementImage.src = value;
    }
});


Object.defineProperty(ImageField.prototype, 'empty', {
    get: function() {
        return this.class.contains('empty');
    },
    set: function(value) {
        if (this.class.contains('empty') === !! value)
            return;

        if (value) {
            this.class.add('empty');
            this.image = '';
        } else {
            this.class.remove('empty');
        }
    }
});


Object.defineProperty(ImageField.prototype, 'value', {
    get: function() {
        if (this._link) {
            return this._link.get(this.path);
        } else {
            return this._value;
        }
    },
    set: function(value) {
        value = value && parseInt(value, 10) || null;

        if (this._link) {
            if (! this._link.set(this.path, value))
                this._value = this._link.get(this.path);
        } else {
            if (this._value === value && ! this.class.contains('null'))
                return;

            this._value = value;
            this.emit('change', value);
        }
    }
});


window.ui.ImageField = ImageField;


/* ui/slider.js */
"use strict";

function Slider(args) {
    var self = this;
    ui.Element.call(this);
    args = args || { };

    this._value = 0;
    this._lastValue = 0;

    this.precision = isNaN(args.precision) ? 2 : args.precision;
    this._min = isNaN(args.min) ? 0 : args.min;
    this._max = isNaN(args.max) ? 1 : args.max;

    this.element = document.createElement('div');
    this.element.classList.add('ui-slider');

    this.elementBar = document.createElement('div');
    this.elementBar.ui = this;
    this.elementBar.classList.add('bar');
    this.element.appendChild(this.elementBar);

    this.elementHandle = document.createElement('div');
    this.elementHandle.ui = this;
    this.elementHandle.tabIndex = 0;
    this.elementHandle.classList.add('handle');
    this.elementBar.appendChild(this.elementHandle);

    this.element.addEventListener('mousedown', this._onMouseDown, false);
    this.element.addEventListener('touchstart', this._onTouchStart, false);

    this.evtMouseMove = function(evt) {
        evt.stopPropagation();
        evt.preventDefault();

        self._onSlideMove(evt.pageX);
    };
    this.evtMouseUp = function(evt) {
        evt.stopPropagation();
        evt.preventDefault();

        self._onSlideEnd(evt.pageX);
    };

    this.evtTouchId = null;

    this.evtTouchMove = function(evt) {
        for(var i = 0; i < evt.changedTouches.length; i++) {
            var touch = evt.changedTouches[i];

            if (touch.identifier !== self.evtTouchId)
                continue;

            evt.stopPropagation();
            evt.preventDefault();

            self._onSlideMove(touch.pageX);
            break;
        }
    };
    this.evtTouchEnd = function(evt) {
        for(var i = 0; i < evt.changedTouches.length; i++) {
            var touch = evt.changedTouches[i];

            if (touch.identifier !== self.evtTouchId)
                continue;

            evt.stopPropagation();
            evt.preventDefault();

            self._onSlideEnd(touch.pageX);
            self.evtTouchId = null;
            break;
        }
    };

    this.on('change', this.__onChange);

    // arrows - change
    this.element.addEventListener('keydown', this._onKeyDown, false);
}
Slider.prototype = Object.create(ui.Element.prototype);


Slider.prototype._onChange = function() {
    if (! this.renderChanges)
        return;

    this.flash();
};


Slider.prototype._onKeyDown = function(evt) {
    if (evt.keyCode === 27)
        return this.ui.elementHandle.blur();

    if (this.ui.disabled || [ 37, 39 ].indexOf(evt.keyCode) === -1)
        return;

    evt.stopPropagation();
    evt.preventDefault();

    var x = evt.keyCode === 37 ? -1 : 1;

    if (evt.shiftKey)
        x *= 10;

    var rect = this.getBoundingClientRect();
    var step = (this.ui._max - this.ui._min) / rect.width;
    var value = Math.max(this.ui._min, Math.min(this.ui._max, this.ui.value + x * step));
    value = parseFloat(value.toFixed(this.ui.precision), 10);

    this.ui.renderChanges = false;
    this.ui._updateHandle(value);
    this.ui.value = value;
    this.ui.renderChanges = true;
};


Slider.prototype._onLinkChange = function(value) {
    this._updateHandle(value);
    this._value = value;
    this.emit('change', value || 0);
};


Slider.prototype._updateHandle = function(value) {
    this.elementHandle.style.left = (Math.max(0, Math.min(1, ((value || 0) - this._min) / (this._max - this._min))) * 100) + '%';
};


Slider.prototype._onMouseDown = function(evt) {
    if (evt.button !== 0 || this.ui.disabled)
        return;

    this.ui._onSlideStart(evt.pageX);
};


Slider.prototype._onTouchStart = function(evt) {
    if (this.ui.disabled)
        return;

    for(var i = 0; i < evt.changedTouches.length; i++) {
        var touch = evt.changedTouches[i];
        if (! touch.target.ui || touch.target.ui !== this.ui)
            continue;

        this.ui.evtTouchId = touch.identifier;
        this.ui._onSlideStart(touch.pageX);
        break;
    }
};


Slider.prototype._onSlideStart = function(pageX) {
    this.elementHandle.focus();

    this.renderChanges = false;

    if (this.evtTouchId === null) {
        window.addEventListener('mousemove', this.evtMouseMove, false);
        window.addEventListener('mouseup', this.evtMouseUp, false);
    } else {
        window.addEventListener('touchmove', this.evtTouchMove, false);
        window.addEventListener('touchend', this.evtTouchEnd, false);
    }

    this.class.add('active');

    this.emit('start', this.value);

    this._onSlideMove(pageX);

    if (this._link && this._link.history)
        this._link.history.combine = true;
};


Slider.prototype._onSlideMove = function(pageX) {
    var rect = this.element.getBoundingClientRect();
    var x = Math.max(0, Math.min(1, (pageX - rect.left) / rect.width));

    var range = this._max - this._min;
    var value = (x * range) + this._min;
    value = parseFloat(value.toFixed(this.precision), 10);

    this._updateHandle(value);
    this.value = value;
};


Slider.prototype._onSlideEnd = function(pageX) {
    this._onSlideMove(pageX);

    this.renderChanges = true;

    this.class.remove('active');

    if (this.evtTouchId === null) {
        window.removeEventListener('mousemove', this.evtMouseMove);
        window.removeEventListener('mouseup', this.evtMouseUp);
    } else {
        window.removeEventListener('touchmove', this.evtTouchMove);
        window.removeEventListener('touchend', this.evtTouchEnd);
    }

    if (this._link && this._link.history)
        this._link.history.combine = false;

    this.emit('end', this.value);
};


Object.defineProperty(Slider.prototype, 'min', {
    get: function() {
        return this._min;
    },
    set: function(value) {
        if (this._min === value)
            return;

        this._min = value;
        this._updateHandle(this._value);
    }
});


Object.defineProperty(Slider.prototype, 'max', {
    get: function() {
        return this._max;
    },
    set: function(value) {
        if (this._max === value)
            return;

        this._max = value;
        this._updateHandle(this._value);
    }
});


Object.defineProperty(Slider.prototype, 'value', {
    get: function() {
        if (this._link) {
            return this._link.get(this.path);
        } else {
            return this._value;
        }
    },
    set: function(value) {
        if (this._link) {
            if (! this._link.set(this.path, value))
                this._updateHandle(this._link.get(this.path));
        } else {
            if (this._max !== null && this._max < value)
                value = this._max;

            if (this._min !== null && this._min > value)
                value = this._min;

            if (value === null) {
                this.class.add('null');
            } else {
                if (typeof value !== 'number')
                    value = undefined;

                value = (value !== undefined && this.precision !== null) ? parseFloat(value.toFixed(this.precision), 10) : value;
                this.class.remove('null');
            }

            this._updateHandle(value);
            this._value = value;

            if (this._lastValue !== value) {
                this._lastValue = value;
                this.emit('change', value);
            }
        }
    }
});


window.ui.Slider = Slider;


/* ui/progress.js */
"use strict";

function Progress(args) {
    ui.Element.call(this);
    args = args || { };

    this._progress = 0;

    if (args.progress)
        this._progress = Math.max(0, Math.min(1, args.progress));

    this._targetProgress = this._progress;

    this._lastProgress = Math.floor(this._progress * 100);

    this.element = document.createElement('div');
    this._element.classList.add('ui-progress');

    this._inner = document.createElement('div');
    this._inner.classList.add('inner');
    this._inner.style.width = (this._progress * 100) + '%';
    this._element.appendChild(this._inner);

    this._speed = args.speed || 1;

    this._now = Date.now();
    this._animating = false;

    this._failed = false;

    var self = this;
    this._animateHandler = function() {
        self._animate();
    };
}
Progress.prototype = Object.create(ui.Element.prototype);


Object.defineProperty(Progress.prototype, 'progress', {
    get: function() {
        return this._progress;
    },
    set: function(value) {
        value = Math.max(0, Math.min(1, value));

        if (this._targetProgress === value)
            return;

        this._targetProgress = value;

        if (this._speed === 0 || this._speed === 1) {
            this._progress = this._targetProgress;
            this._inner.style.width = (this._progress * 100) + '%';

            var progress = Math.max(0, Math.min(100, Math.round(this._progress * 100)));
            if (progress !== this._lastProgress) {
                this._lastProgress = progress;
                this.emit('progress:' + progress);
                this.emit('progress', progress);
            }
        } else if (! this._animating) {
            requestAnimationFrame(this._animateHandler);
        }
    }
});


Object.defineProperty(Progress.prototype, 'speed', {
    get: function() {
        return this._speed;
    },
    set: function(value) {
        this._speed = Math.max(0, Math.min(1, value));
    }
});


Object.defineProperty(Progress.prototype, 'failed', {
    get: function() {
        return this._failed;
    },
    set: function(value) {
        this._failed = !! value;

        if (this._failed) {
            this.class.add('failed');
        } else {
            this.class.remove('failed');
        }
    }
});


Progress.prototype._animate = function() {
    if (Math.abs(this._targetProgress - this._progress) < 0.01) {
        this._progress = this._targetProgress;
        this._animating = false;
    } else {
        if (! this._animating) {
            this._now = Date.now() - (1000 / 60);
            this._animating = true;
        }
        requestAnimationFrame(this._animateHandler);

        var dt = Math.max(0.1, Math.min(3, (Date.now() - this._now) / (1000 / 60)));
        this._now = Date.now();
        this._progress = this._progress + ((this._targetProgress - this._progress) * (this._speed * dt));
    }

    var progress = Math.max(0, Math.min(100, Math.round(this._progress * 100)));
    if (progress !== this._lastProgress) {
        this._lastProgress = progress;
        this.emit('progress:' + progress);
        this.emit('progress', progress);
    }

    this._inner.style.width = (this._progress * 100) + '%';
};


window.ui.Progress = Progress;


/* ui/list.js */
"use strict";

function List(args) {
    args = args || { };
    ui.ContainerElement.call(this);

    this.element = document.createElement('ul');
    this._element.classList.add('ui-list');
    this.selectable = args.selectable !== undefined ? args.selectable : true;

    this._changing = false;
    this._selected = [ ];

    this.on('select', this._onSelect);
    this.on('deselect', this._onDeselect);
    this.on('append', this._onAppend);
}
List.prototype = Object.create(ui.ContainerElement.prototype);


List.prototype._onSelect = function(item) {
    var ind = this._selected.indexOf(item);
    if (ind === -1)
        this._selected.push(item);

    if (this._changing)
        return;

    if (List._ctrl && List._ctrl()) {

    } else if (List._shift && List._shift() && this.selected.length) {

    } else {
        this._changing = true;

        var items = this.selected;

        if (items.length > 1) {
            for(var i = 0; i < items.length; i++) {
                if (items[i] === item)
                    continue;

                items[i].selected = false;
            }
        }

        this._changing = false;
    }

    this.emit('change');
};

List.prototype._onDeselect = function(item) {
    var ind = this._selected.indexOf(item);
    if (ind !== -1) this._selected.splice(ind, 1);

    if (this._changing)
        return;

    if (List._ctrl && List._ctrl()) {

    } else {
        this._changing = true;

        var items = this.selected;

        if (items.length) {
            for(var i = 0; i < items.length; i++)
                items[i].selected = false;

            item.selected = true;
        }

        this._changing = false;
    }

    this.emit('change');
};

List.prototype._onAppend = function(item) {
    if (! item.selected)
        return;

    var ind = this._selected.indexOf(item);
    if (ind === -1) this._selected.push(item);
};

List.prototype.clear = function() {
    this._selected = [ ];
    ContainerElement.prototype.clear.call(this);
};


Object.defineProperty(List.prototype, 'selectable', {
    get: function() {
        return this._selectable;
    },
    set: function(value) {
        if (this._selectable === !! value)
            return;

        this._selectable = value;

        if (this._selectable) {
            this.class.add('selectable');
        } else {
            this.class.remove('selectable');
        }
    }
});


Object.defineProperty(List.prototype, 'selected', {
    get: function() {
        return this._selected.slice(0);
    },
    set: function(value) {
        this._changing = true;

        // deselecting
        var items = this.selected;
        for(var i = 0; i < items.length; i++) {
            if (value.indexOf(items[i]) !== -1)
                continue;

            items[i].selected = false;
        }

        // selecting
        for(var i = 0; i < value.length; i++) {
            value[i].selected = true;
        }

        this._changing = false;
    }
});


window.ui.List = List;


/* ui/list-item.js */
"use strict";

function ListItem(args) {
    ui.Element.call(this);
    args = args || { };

    this._text = args.text || '';
    this._selected = args.selected || false;

    this.element = document.createElement('li');
    this._element.classList.add('ui-list-item');

    this.elementText = document.createElement('span');
    this.elementText.textContent = this._text;
    this._element.appendChild(this.elementText);

    this.on('click', this._onClick);
}
ListItem.prototype = Object.create(ui.Element.prototype);


ListItem.prototype._onClick = function() {
    this.selected = ! this.selected;
};


Object.defineProperty(ListItem.prototype, 'text', {
    get: function() {
        return this._text;
    },
    set: function(value) {
        if (this._text === value) return;
        this._text = value;
        this.elementText.textContent = this._text;
    }
});


Object.defineProperty(ListItem.prototype, 'selected', {
    get: function() {
        return this._selected;
    },
    set: function(value) {
        if (this._selected === value)
            return;

        this._selected = value;

        if (this._selected) {
            this._element.classList.add('selected');
        } else {
            this._element.classList.remove('selected');
        }

        this.emit(this.selected ? 'select' : 'deselect');

        if (this.parent)
            this.parent.emit(this.selected ? 'select' : 'deselect', this);

        this.emit('change', this.selected);
    }
});


window.ui.ListItem = ListItem;


/* ui/grid.js */
"use strict";

function Grid() {
    var self = this;
    ui.ContainerElement.call(this);

    this.element = document.createElement('ul');
    this._element.tabIndex = 0;
    this._element.classList.add('ui-grid');

    this._lastSelect = null;
    this._selecting = false;

    this.on('select', this._onSelect);
    this.on('beforeDeselect', this._onBeforeDeselect);

    this.on('append', this._onAppend);
    this.on('remove', this._onRemove);
}
Grid.prototype = Object.create(ui.ContainerElement.prototype);


Grid.prototype._onSelect = function(item) {
    if (this._selecting)
        return;

    if (Grid._shift && Grid._shift()) {
        var children = Array.prototype.slice.call(this._element.childNodes, 0);

        // multi select from-to
        if (this._lastSelect) {
            this._selecting = true;

            var startInd = children.indexOf(this._lastSelect.element);
            var endInd = children.indexOf(item.element);

            // swap if backwards
            if (startInd > endInd) {
                var t = startInd;
                startInd = endInd;
                endInd = t;
            }

            for(var i = startInd; i < endInd; i++) {
                if (! children[i] || ! children[i].ui || children[i].ui.hidden)
                    continue;

                children[i].ui.selected = true;
            }

            this._selecting = false;
        } else {
            this._lastSelect = item;
        }
    } else if (Grid._ctrl && Grid._ctrl()) {
        // multi select
        this._lastSelect = item;
    } else {
        // single select
        var items = this._element.querySelectorAll('.ui-grid-item.selected');

        if (items.length > 1) {
            for(var i = 0; i < items.length; i++) {
                if (items[i].ui === item)
                    continue;

                items[i].ui.selected = false;
            }
        }

        this._lastSelect = item;
    }
};


Grid.prototype._onBeforeDeselect = function(item) {
    if (this._selecting)
        return;

    this._selecting = true;

    if (Grid._shift && Grid._shift()) {
        this._lastSelect = null;
    } else if (Grid._ctrl && Grid._ctrl()) {
        this._lastSelect = null;
    } else {
        var items = this._element.querySelectorAll('.ui-grid-item.selected');
        if (items.length > 1) {
            for(var i = 0; i < items.length; i++) {
                if (items[i].ui === item)
                    continue;
                items[i].ui.selected = false;
            }
            item._selectPending = true;
            this._lastSelect = item;
        }
    }

    this._selecting = false;
};


Grid.prototype.filter = function(fn) {
    this.forEach(function(item) {
        item.hidden = ! fn(item);
    });
};


Grid.prototype.forEach = function(fn) {
    var child = this._element.firstChild;
    while(child) {
        if (child.ui)
            fn(child.ui);

        child = child.nextSibling;
    };
};

Object.defineProperty(Grid.prototype, 'selected', {
    get: function() {
        var items = [ ];
        var elements = this._element.querySelectorAll('.ui-grid-item.selected');

        for(var i = 0; i < elements.length; i++)
            items.push(elements[i].ui);

        return items;
    },
    set: function(value) {
        if (this._selecting)
            return;

        this._selecting = true;

        // deselecting
        var items = this.selected;
        for(var i = 0; i < items.length; i++) {
            if (value && value.indexOf(items[i]) !== -1)
                continue;
            items[i].selected = false;
        }

        if (! value)
            return;

        // selecting
        for(var i = 0; i < value.length; i++) {
            if (! value[i])
                continue;

            value[i].selected = true;
        }

        this._selecting = false;
    }
});


window.ui.Grid = Grid;


/* ui/grid-item.js */
"use strict";

function GridItem(args) {
    var self = this;
    ui.Element.call(this);
    args = args || { };

    this._text = args.text || '';
    this._selectPending = false;
    this._selected = args.selected || false;
    this._clicked = false;

    this.element = document.createElement('li');
    this._element.ui = this;
    this._element.tabIndex = 0;
    this._element.classList.add('ui-grid-item');
    this._element.innerHTML = this._text;

    this._element.removeEventListener('click', this._evtClick);
    this._element.addEventListener('click', this._onClick, false);

    this.on('select', this._onSelect);
    this.on('deselect', this._onDeselect);
}
GridItem.prototype = Object.create(ui.Element.prototype);


GridItem.prototype._onClick = function() {
    this.ui.emit('click');
    this.ui._clicked = true;
    this.ui.selected = ! this.ui.selected;
    this.ui._clicked = false;
};

GridItem.prototype._onSelect = function() {
    this._element.focus();
};

GridItem.prototype._onDeselect = function() {
    this._element.blur();
};


Object.defineProperty(GridItem.prototype, 'text', {
    get: function() {
        return this._text;
    },
    set: function(value) {
        if (this._text === value) return;
        this._text = value;
        this._element.innerHTML = this._text;
    }
});


Object.defineProperty(GridItem.prototype, 'selected', {
    get: function() {
        return this._selected;
    },
    set: function(value) {
        if (this._selected === value)
            return;

        this._selectPending = value;

        if (this.parent && this._clicked)
            this.parent.emit('before' + (value ? 'Select' : 'Deselect'), this, this._clicked);

        if (this._selected === this._selectPending)
            return;

        this._selected = this._selectPending;

        if (this._selected) {
            this._element.classList.add('selected');
        } else {
            this._element.classList.remove('selected');
        }

        this.emit(this.selected ? 'select' : 'deselect');
        this.emit('change', this.selected);

        if (this.parent)
            this.parent.emit(this.selected ? 'select' : 'deselect', this, this._clicked);
    }
});


window.ui.GridItem = GridItem;


/* ui/tree.js */
"use strict";

function Tree() {
    ui.ContainerElement.call(this);

    this.element = document.createElement('div');
    this._element.classList.add('ui-tree');

    this.elementDrag = document.createElement('div');
    this.elementDrag.classList.add('drag-handle');
    this._element.appendChild(this.elementDrag);

    var self = this;
    this.elementDrag.addEventListener('mousemove', function(evt) {
        evt.preventDefault();
        evt.stopPropagation();

        self._onDragMove(evt);
    });
    this._element.addEventListener('mouseleave', function(evt) {
        self._onDragOut();
    });

    this.on('select', this._onSelect);
    this.on('deselect', this._onDeselect);
    this.on('append', this._onAppend);
    this.on('remove', this._onRemove);

    this.draggable = true;
    this._dragging = false;
    this._dragItems = [ ];
    this._dragOver = null;
    this._dragArea = 'inside';
    this._evtDragMove = null;
    this.reordering = true;
    this.dragInstant = true;

    this._selected = [ ];
}
Tree.prototype = Object.create(ui.ContainerElement.prototype);


Object.defineProperty(Tree.prototype, 'selected', {
    get: function() {
        return this._selected.slice(0);
    },
    set: function(value) {

    }
});


Tree.prototype._onItemClick = function(item) {
    if (Tree._ctrl && Tree._ctrl()) {
        item.selected = ! item.selected;
    } else if (Tree._shift && Tree._shift() && this._selected.length) {
        var from = this._selected[this._selected.length - 1];
        var to = item;

        var up = [ ];
        var down = [ ];

        var prev = function(refItem) {
            var result = null;
            var item = refItem.element.previousSibling;
            if (item)
                item = item.ui;

            if (item) {
                if (refItem.parent && refItem.parent === item && refItem.parent instanceof TreeItem) {
                    result = refItem.parent;
                } else if (item.open && item._children) {
                    // element above is open, find last available element
                    var last = item.element.lastChild;
                    if (last.ui)
                        last = last.ui;

                    if (last) {
                        var findLast = function(inside) {
                            if (inside.open && inside._children) {
                                return inside.element.lastChild.ui || null;
                            } else {
                                return null;
                            }
                        }

                        var found = false;
                        while(! found) {
                            var deeper = findLast(last);
                            if (deeper) {
                                last = deeper;
                            } else {
                                found = true;
                            }
                        }

                        result = last;
                    } else {
                        result = item;
                    }
                } else {
                    result = item;
                }
            }

            return result;
        };

        var next = function(refItem) {
            var result = null;
            var item = refItem.element.nextSibling;
            if (item)
                item = item.ui;

            if (refItem.open && refItem._children) {
                // select a child
                var first = refItem.element.firstChild.nextSibling;
                if (first && first.ui) {
                    result = first.ui;
                } else if (item) {
                    result = item;
                }
            } else if (item) {
                // select next item
                result = item;
            } else if (refItem.parent && refItem.parent instanceof TreeItem) {
                // no next element, go to parent
                var parent = refItem.parent;

                var findNext = function(from) {
                    var next = from.next;
                    if (next) {
                        result = next;
                    } else if (from.parent instanceof TreeItem) {
                        return from.parent;
                    }
                    return false;
                }

                while(parent = findNext(parent)) { }
            }

            return result;
        };

        var done = false;
        var path = null;
        var lookUp = true;
        var lookDown = true;
        var lookingUp = true;
        while(! done && ! path) {
            lookingUp = ! lookingUp;

            var item = null;
            var lookFrom = from;
            if ((! lookDown || lookingUp) && lookUp) {
                // up
                if (up.length)
                    lookFrom = up[up.length - 1];

                item = prev(lookFrom);
                if (item) {
                    up.push(item);

                    if (item === to) {
                        done = true;
                        path = up;
                        break;
                    }
                } else {
                    lookUp = false;
                }
            } else if (lookDown) {
                // down
                if (down.length)
                    lookFrom = down[down.length - 1];

                item = next(lookFrom);
                if (item) {
                    down.push(item);

                    if (item === to) {
                        done = true;
                        path = down;
                        break;
                    }
                } else {
                    lookDown = false;
                }
            } else {
                done = true;
            }
        }

        if (path) {
            for(var i = 0; i < path.length; i++) {
                path[i].selected = true;
            }
        }


    } else {
        var selected = item.selected && ((this._selected.indexOf(item) === -1) || (this._selected.length === 1 && this._selected[0] === item));
        this.clear();

        if (! selected)
            item.selected = true;
    }
};


Tree.prototype._onSelect = function(item) {
    this._selected.push(item);
};


Tree.prototype._onDeselect = function(item) {
    var ind = this._selected.indexOf(item);
    if (ind === -1)
        return;

    this._selected.splice(ind, 1);
};


Tree.prototype.clear = function() {
    if (! this._selected.length)
        return;

    var i = this._selected.length;
    while(i--) {
        this._selected[i].selected = false;
    }
    this._selected = [ ];
}


Tree.prototype._onDragStart = function(item) {
    if (! this.draggable || this._dragging)
        return;

    this._dragItems =  [ ];

    if (this._selected && this._selected.length > 1 && this._selected.indexOf(item) !== -1) {
        var items = [ ];
        var index = { };
        var defaultLevel = -1;

        // build index
        for(var i = 0; i < this._selected.length; i++) {
            // cant drag parent
            if (this._selected[i].parent === this)
                return;

            this._selected[i]._dragId = i + 1;
            index[this._selected[i]._dragId] = this._selected[i];
        }

        for(var i = 0; i < this._selected.length; i++) {
            var s = this._selected[i];
            var level = 0;
            var child = false;
            var parent = this._selected[i].parent;
            if (! (parent instanceof ui.TreeItem))
                parent = null;

            while(parent) {
                if (parent._dragId && index[parent._dragId]) {
                    // child, to be ignored
                    child = true;
                    break;
                }

                parent = parent.parent;
                if (! (parent instanceof ui.TreeItem)) {
                    parent = null;
                    break;
                }

                level++;
            }

            if (! child) {
                if (defaultLevel === -1) {
                    defaultLevel = level;
                } else if (defaultLevel !== level) {
                    // multi-level drag no allowed
                    return;
                }

                items.push(this._selected[i]);
            }
        }

        // clean ids
        for(var i = 0; i < this._selected.length; i++)
            this._selected[i]._dragId = null;

        this._dragItems = items;

        // sort items by their number of apperance in hierarchy
        if (items.length > 1) {
            var commonParent = null;

            // find common parent
            var findCommonParent = function(items) {
                var parents = [ ];
                for(var i = 0; i < items.length; i++) {
                    if (parents.indexOf(items[i].parent) === -1)
                        parents.push(items[i].parent);
                }
                if (parents.length === 1) {
                    commonParent = parents[0];
                } else {
                    return parents;
                }
            };
            var parents = items;
            while(! commonParent && parents)
                parents = findCommonParent(parents);

            // calculate ind number
            for(var i = 0; i < items.length; i++) {
                var ind = 0;

                var countChildren = function(item) {
                    if (! item._children) {
                        return 0;
                    } else {
                        var count = 0;
                        var children = item.innerElement.childNodes;
                        for(var i = 0; i < children.length; i++) {
                            if (children[i].ui)
                                count += countChildren(children[i]) + 1;
                        }
                        return count;
                    }
                };

                var scanUpForIndex = function(item) {
                    ind++;

                    var sibling = item.element.previousSibling;
                    sibling = (sibling && sibling.ui) || null;

                    if (sibling) {
                        ind += countChildren(sibling);
                        return sibling;
                    } else if (item.parent === commonParent) {
                        return null;
                    } else {
                        return item.parent;
                    }
                };

                var prev = scanUpForIndex(items[i]);
                while(prev)
                    prev = scanUpForIndex(prev);

                items[i]._dragInd = ind;
            }

            items.sort(function(a, b) {
                return a._dragInd - b._dragInd;
            });
        }
    } else {
        // single drag
        this._dragItems = [ item ];
    }

    if (this._dragItems.length) {
        this._dragging = true;

        this.class.add('dragging');
        for(var i = 0; i < this._dragItems.length; i++) {
            this._dragItems[i].open = false;
            this._dragItems[i].class.add('dragged');
        }

        this._updateDragHandle();
        this.emit('dragstart');
    }
};


Tree.prototype._onDragOver = function(item, evt) {
    if (! this.draggable || ! this._dragging || (this._dragItems.indexOf(item) !== -1 && ! this._dragOver) || this._dragOver === item)
        return;

    var dragOver = null;

    if (item.allowDrop) {
        if (this._dragItems.indexOf(item) === -1)
            dragOver = item;

        if (this._dragOver === null && dragOver)
            this.emit('dragin');
    }



    this._dragOver = dragOver;

    this._updateDragHandle();
    this._onDragMove(evt);
};


Tree.prototype._hoverCalculate = function(evt) {
    if (! this.draggable || ! this._dragOver)
        return;

    var rect = this.elementDrag.getBoundingClientRect();
    var area = Math.floor((evt.clientY - rect.top) / rect.height * 5);

    var oldArea = this._dragArea;
    var oldDragOver = this._dragOver;

    if (this._dragOver.parent === this) {
        var parent = false;
        for(var i = 0; i < this._dragItems.length; i++) {
            if (this._dragItems[i].parent === this._dragOver) {
                parent = true;
                this._dragOver = null;
                break;
            }
        }
        if (! parent)
            this._dragArea = 'inside';
    } else if (this.reordering && area <= 1 && this._dragItems.indexOf(this._dragOver.prev) === -1) {
        this._dragArea = 'before';
    } else if (this.reordering && area >= 4 && this._dragItems.indexOf(this._dragOver.next) === -1 && (this._dragOver._children === 0 || ! this._dragOver.open)) {
        this._dragArea = 'after';
    } else {
        var parent = false;
        if (this.reordering && this._dragOver.open) {
            for(var i = 0; i < this._dragItems.length; i++) {
                if (this._dragItems[i].parent === this._dragOver) {
                    parent = true;
                    this._dragArea = 'before';
                    break;
                }
            }
        }
        if (! parent)
            this._dragArea = 'inside';
    }

    if (oldArea !== this._dragArea || oldDragOver !== this._dragOver)
        this._updateDragHandle();
};


Tree.prototype._onDragMove = function(evt) {
    if (! this.draggable)
        return;

    this._hoverCalculate(evt);
    this.emit('dragmove', evt);
};


Tree.prototype._onDragOut = function() {
    if (! this.draggable || ! this._dragging || ! this._dragOver)
        return;

    this._dragOver = null;
    this._updateDragHandle();
    this.emit('dragout');
};


Tree.prototype._onDragEnd = function() {
    if (! this.draggable || ! this._dragging)
        return;

    var reparentedItems = [ ];
    this._dragging = false;
    this.class.remove('dragging');

    var lastDraggedItem = this._dragOver;

    for(var i = 0; i < this._dragItems.length; i++) {
        this._dragItems[i].class.remove('dragged');

        if (this._dragOver && this._dragOver !== this._dragItems[i]) {

            var oldParent = this._dragItems[i].parent;

            if (oldParent !== this._dragOver || this._dragArea !== 'inside') {
                var newParent = null;

                if (this.dragInstant) {
                    if (this._dragItems[i].parent)
                        this._dragItems[i].parent.remove(this._dragItems[i]);
                }

                if (this._dragArea === 'before') {
                    newParent = this._dragOver.parent;
                    if (this.dragInstant)
                        this._dragOver.parent.appendBefore(this._dragItems[i], this._dragOver);
                } else if (this._dragArea === 'inside') {
                    newParent = this._dragOver;
                    if (this.dragInstant) {
                        this._dragOver.open = true;
                        this._dragOver.append(this._dragItems[i]);
                    }
                } else if (this._dragArea === 'after') {
                    newParent = this._dragOver.parent;
                    if (this.dragInstant) {
                        this._dragOver.parent.appendAfter(this._dragItems[i], lastDraggedItem);
                        lastDraggedItem = this._dragItems[i];
                    }
                }

                reparentedItems.push({
                    item: this._dragItems[i],
                    old: oldParent,
                    new: newParent
                });
            }
        }
    }

    this.emit('reparent', reparentedItems);

    this._dragItems = [ ];

    if (this._dragOver)
        this._dragOver = null;

    this.emit('dragend');
};


Tree.prototype._updateDragHandle = function() {
    if (! this.draggable || ! this._dragging)
        return;

    if (! this._dragOver) {
        this.elementDrag.classList.add('hidden');
    } else {
        var rect = this._dragOver.elementTitle.getBoundingClientRect();

        this.elementDrag.classList.remove('before', 'inside', 'after', 'hidden')
        this.elementDrag.classList.add(this._dragArea);

        this.elementDrag.style.top = rect.top  + 'px';
        this.elementDrag.style.left = rect.left + 'px';
        this.elementDrag.style.width = (rect.width - 4) + 'px';
    }
};


Tree.prototype._onAppend = function(item) {
    item.tree = this;

    var self = this;

    item.on('dragstart', function() {
        // can't drag root
        if (this.parent === self)
            return;

        self._onDragStart(this);
    });

    item.on('mouseover', function(evt) {
        self._onDragOver(this, evt);
    });

    item.on('dragend', function() {
        self._onDragEnd();
    });
};


Tree.prototype._onRemove = function(item) {
    item.tree = null;

    item.unbind('dragstart');
    item.unbind('mouseover');
    item.unbind('dragend');
};

window.ui.Tree = Tree;


/* ui/tree-item.js */
"use strict";

function TreeItem(args) {
    var self = this;
    ui.Element.call(this);
    args = args || { };

    this.tree = null;

    this.element = document.createElement('div');
    this._element.classList.add('ui-tree-item');

    this.elementTitle = document.createElement('div');
    this.elementTitle.classList.add('title');
    this.elementTitle.draggable = true;
    this.elementTitle.tabIndex = 0;
    this.elementTitle.ui = this;
    this._element.appendChild(this.elementTitle);

    this.elementIcon = document.createElement('span');
    this.elementIcon.classList.add('icon');
    this.elementTitle.appendChild(this.elementIcon);

    this.elementText = document.createElement('span');
    this.elementText.textContent = args.text || '';
    this.elementText.classList.add('text');
    this.elementTitle.appendChild(this.elementText);

    this._children = 0;
    this.selectable = true;

    this._onMouseUp = function(evt) {
        window.removeEventListener('mouseup', self._dragRelease);
        self._dragRelease = null;

        evt.preventDefault();
        evt.stopPropagation();

        self._dragging = false;
        self.emit('dragend');
    };

    this.elementTitle.addEventListener('click', this._onClick, false);
    this.elementTitle.addEventListener('dblclick', this._onDblClick, false);

    this._dragRelease = null;
    this._dragging = false;
    this._allowDrop = (args.allowDrop !== undefined ? !!args.allowDrop : true);

    this.elementTitle.addEventListener('mousedown', this._onMouseDown, false);
    this.elementTitle.addEventListener('dragstart', this._onDragStart, false);
    this.elementTitle.addEventListener('mouseover', this._onMouseOver, false);

    this.on('destroy', this._onDestroy);
    this.on('append', this._onAppend);
    this.on('remove', this._onRemove);
    this.on('select', this._onSelect);
    this.on('deselect', this._onDeselect);

    this.elementTitle.addEventListener('keydown', this._onKeyDown, false);
}
TreeItem.prototype = Object.create(ui.Element.prototype);


TreeItem.prototype.append = function(item) {
    if (this._children === 1) {
        this._element.childNodes[1].classList.remove('single');
    }

    item.parent = this;
    this._element.appendChild(item.element);
    this._children++;

    if (this._children === 1) {
        item.class.add('single');
        this.class.add('container');
    } else if (this._children > 1) {
        item.class.remove('single');
    }

    var appendChildren = function(treeItem) {
        treeItem.emit('append', treeItem);

        if (treeItem._children) {
            for(var i = 1; i < treeItem.element.childNodes.length; i++) {
                appendChildren(treeItem.element.childNodes[i].ui);
            }
        }
    };
    appendChildren(item);
};


TreeItem.prototype.appendBefore = function(item, referenceItem) {
    if (this._children === 1) {
        this._element.childNodes[1].classList.remove('single');
    }

    item.parent = this;
    this._element.insertBefore(item.element, referenceItem.element);
    this._children++;

    if (this._children === 1) {
        item.class.add('single');
        this.class.add('container');
    } else if (this._children > 1) {
        item.class.remove('single');
    }

    var appendChildren = function(treeItem) {
        treeItem.emit('append', treeItem);

        if (treeItem._children) {
            for(var i = 1; i < treeItem.element.childNodes.length; i++) {
                appendChildren(treeItem.element.childNodes[i].ui);
            }
        }
    };
    appendChildren(item);
};


TreeItem.prototype.appendAfter = function(item, referenceItem) {
    item.parent = this;
    referenceItem = referenceItem.element.nextSibling;

    // might be last
    if (! referenceItem)
        this.append(item);

    this._element.insertBefore(item.element, referenceItem);
    this._children++;

    if (this._children === 1) {
        item.class.add('single');
        this.class.add('container');
    } else if (this._children === 2) {
        this._element.childNodes[1].classList.remove('single');
    }

    var appendChildren = function(treeItem) {
        treeItem.emit('append', treeItem);

        if (treeItem._children) {
            for(var i = 1; i < treeItem.element.childNodes.length; i++) {
                appendChildren(treeItem.element.childNodes[i].ui);
            }
        }
    };
    appendChildren(item);
};


TreeItem.prototype.remove = function(item) {
    if (! this._children || ! this._element.contains(item.element))
        return;

    this._element.removeChild(item.element);
    this._children--;

    if (this._children === 0) {
        this.class.remove('container');
    } else if (this._children === 1 && this._element.childNodes.length > 2) {
        this._element.childNodes[1].classList.add('single');
    }

    var removeChildren = function(treeItem) {
        treeItem.emit('remove', treeItem);

        if (treeItem._children) {
            for(var i = 1; i < treeItem.element.childNodes.length; i++) {
                removeChildren(treeItem.element.childNodes[i].ui);
            }
        }
    };
    removeChildren(item);
};


TreeItem.prototype._onDestroy = function() {
    this.elementTitle.removeEventListener('click', this._onClick);
    this.elementTitle.removeEventListener('dblclick', this._onDblClick);
    this.elementTitle.removeEventListener('mousedown', this._onMouseDown);
    this.elementTitle.removeEventListener('dragstart', this._onDragStart);
    this.elementTitle.removeEventListener('mouseover', this._onMouseOver);
    this.elementTitle.removeEventListener('keydown', this._onKeyDown);
};


TreeItem.prototype._onAppend = function(item) {
    if (this.parent)
        this.parent.emit('append', item);
};


TreeItem.prototype._onRemove = function(item) {
    if (this.parent)
        this.parent.emit('remove', item);
};


TreeItem.prototype.focus = function() {
    this.elementTitle.focus();
};

TreeItem.prototype._onRename = function(select) {
    if (select) {
        this.tree.clear();
        this.tree._onItemClick(this);
    }

    var self = this;
    this.class.add('rename');

    // add remaning field
    var field = new ui.TextField();
    field.parent = this;
    field.renderChanges = false;
    field.value = this.text;
    field.elementInput.addEventListener('blur', function() {
        field.destroy();
        self.class.remove('rename');
    }, false);
    field.on('click', function(evt) {
        evt.stopPropagation();
    });
    field.element.addEventListener('dblclick', function(evt) {
        evt.stopPropagation();
    });
    field.on('change', function(value) {
        value = value.trim();
        if (value) {
            if (self.entity) {
                self.entity.set('name', value);
            }

            self.emit('rename', value);
        }

        field.destroy();
        self.class.remove('rename');
    });
    this.elementTitle.appendChild(field.element);
    field.elementInput.focus();
    field.elementInput.select();
};


TreeItem.prototype._onClick = function(evt) {
    if (evt.button !== 0 || ! this.ui.selectable)
        return;

    var rect = this.getBoundingClientRect();

    if (this.ui._children && (evt.clientX - rect.left) < 0) {
        this.ui.open = ! this.ui.open;
    } else {
        this.ui.tree._onItemClick(this.ui);
        evt.stopPropagation();
    }
};

TreeItem.prototype._onDblClick = function(evt) {
    if (! this.ui.tree.allowRenaming || evt.button !== 0 || this.ui.disabled)
        return;

    evt.stopPropagation();
    var rect = this.getBoundingClientRect();

    if (this.ui._children && (evt.clientX - rect.left) < 0) {
        return;
    } else {
        this.ui._onRename(true);
    }
};

TreeItem.prototype._onMouseDown = function(evt) {
    if (this.ui.tree.disabled || ! this.ui.tree.draggable)
        return;

    evt.stopPropagation();
};

TreeItem.prototype._onDragStart = function(evt) {
    if (this.ui.tree.disabled || ! this.ui.tree.draggable) {
        evt.stopPropagation();
        evt.preventDefault();
        return;
    }

    this.ui._dragging = true;

    if (this.ui._dragRelease)
        window.removeEventListener('mouseup', this.ui._dragRelease);

    this.ui._dragRelease = this.ui._onMouseUp;
    window.addEventListener('mouseup', this.ui._dragRelease, false);

    evt.stopPropagation();
    evt.preventDefault();

    this.ui.emit('dragstart');
};

TreeItem.prototype._onMouseOver = function(evt) {
    evt.stopPropagation();
    this.ui.emit('mouseover', evt);
};

TreeItem.prototype._onKeyDown = function(evt) {
    if ((evt.target && evt.target.tagName.toLowerCase() === 'input'))
        return;

    if ([ 9, 38, 40, 37, 39 ].indexOf(evt.keyCode) === -1)
        return;

    evt.preventDefault();
    evt.stopPropagation();

    var selectedItem = null;

    switch(evt.keyCode) {
        case 9: // tab
            break;
        case 40: // down
            var item = this.ui.element.nextSibling;
            if (item)
                item = item.ui;

            if (this.ui._children && this.ui.open) {
                var first = this.ui.element.firstChild.nextSibling;
                if (first && first.ui) {
                    selectedItem = first.ui;
                    // first.ui.selected = true;
                } else if (item) {
                    selectedItem = item;
                    // item.selected = true;
                }
            } else if (item) {
                selectedItem = item;
                // item.selected = true;
            } else if (this.ui.parent && this.ui.parent instanceof TreeItem) {
                var parent = this.ui.parent;

                var findNext = function(from) {
                    var next = from.next;
                    if (next) {
                        selectedItem = next;
                        // next.selected = true;
                    } else if (from.parent instanceof TreeItem) {
                        return from.parent;
                    }
                    return false;
                };

                while(parent = findNext(parent)) { }
            }
            break;
        case 38: // up
            var item = this.ui.element.previousSibling;
            if (item)
                item = item.ui;

            if (item) {
                if (item._children && item.open && item !== this.ui.parent) {
                    var last = item.element.lastChild;
                    if (last.ui)
                        last = last.ui;

                    if (last) {
                        var findLast = function(inside) {
                            if (inside._children && inside.open) {
                                return inside.element.lastChild.ui || null;
                            } else {
                                return null;
                            }
                        }

                        var found = false;
                        while(! found) {
                            var deeper = findLast(last);
                            if (deeper) {
                                last = deeper
                            } else {
                                found = true;
                            }
                        }

                        selectedItem = last;
                        // last.selected = true;
                    } else {
                        selectedItem = item;
                        // item.selected = true;
                    }
                } else {
                    selectedItem = item;
                    // item.selected = true;
                }
            } else if (this.ui.parent && this.ui.parent instanceof TreeItem) {
                selectedItem = this.ui.parent;
                // this.ui.parent.selected = true;
            }

            break;
        case 37: // left (close)
            if (this.ui.parent !== this.ui.tree && this.ui.open)
                this.ui.open = false;
            break;
        case 39: // right (open)
            if (this.ui._children && ! this.ui.open)
                this.ui.open = true;
            break;
    }

    if (selectedItem) {
        if (! (Tree._ctrl && Tree._ctrl()) && ! (Tree._shift && Tree._shift()))
            this.ui.tree.clear();
        selectedItem.selected = true;
    }
};

TreeItem.prototype._onSelect = function() {
    this.elementTitle.focus();
};

TreeItem.prototype._onDeselect = function() {
    this.elementTitle.blur();
};


Object.defineProperty(TreeItem.prototype, 'selected', {
    get: function() {
        return this.class.contains('selected');
    },
    set: function(value) {
        if (this.class.contains('selected') === !! value)
            return;

        if (value) {
            this.class.add('selected');

            this.emit('select');
            if (this.tree)
                this.tree.emit('select', this);

        } else {
            this.class.remove('selected');

            this.emit('deselect');
            if (this.tree)
                this.tree.emit('deselect', this);
        }
    }
});


Object.defineProperty(TreeItem.prototype, 'text', {
    get: function() {
        return this.elementText.textContent;
    },
    set: function(value) {
        if (this.elementText.textContent === value)
            return;

        this.elementText.textContent = value;
    }
});


Object.defineProperty(TreeItem.prototype, 'open', {
    get: function() {
        return this.class.contains('open');
    },
    set: function(value) {
        if (this.class.contains('open') === !! value)
            return;

        if (value) {
            this.class.add('open');
            this.emit('open');
            this.tree.emit('open', this);
        } else {
            this.class.remove('open');
            this.emit('close');
            this.tree.emit('close', this);
        }
    }
});


Object.defineProperty(TreeItem.prototype, 'prev', {
    get: function() {
        return this._element.previousSibling && this._element.previousSibling.ui || null;
    }
});


Object.defineProperty(TreeItem.prototype, 'next', {
    get: function() {
        return this._element.nextSibling && this._element.nextSibling.ui || null;
    }
});

// Default is true. If false then it's not allowed to drop
// other tree items on this item
Object.defineProperty(TreeItem.prototype, 'allowDrop', {
    get: function () {
        return this._allowDrop;
    },
    set: function (value) {
        this._allowDrop = !!value;
    }
});

TreeItem.prototype.child = function(ind) {
    return this._element.childNodes[ind + 1];
};



window.ui.TreeItem = TreeItem;


/* ui/tooltip.js */
"use strict";

function Tooltip(args) {
    var self = this;

    args = args || { };
    ui.ContainerElement.call(this);

    this.element = document.createElement('div');
    this._element.classList.add('ui-tooltip', 'align-left');

    this.innerElement = document.createElement('div');
    this.innerElement.classList.add('inner');
    this._element.appendChild(this.innerElement);

    this.arrow = document.createElement('div');
    this.arrow.classList.add('arrow');
    this._element.appendChild(this.arrow);

    this.hoverable = args.hoverable || false;

    this.x = args.x || 0;
    this.y = args.y || 0;

    this._align = 'left';
    this.align = args.align || 'left';

    this.on('show', this._reflow);
    this.hidden = args.hidden !== undefined ? args.hidden : true;
    if (args.html) {
        this.html = args.html;
    } else {
        this.text = args.text || '';
    }

    this._element.addEventListener('mouseover', this._onMouseOver, false);
    this._element.addEventListener('mouseleave', this._onMouseLeave, false);
}
Tooltip.prototype = Object.create(ui.ContainerElement.prototype);


Tooltip.prototype._onMouseOver = function(evt) {
    if (! this.ui.hoverable)
        return;

    this.ui.hidden = false;
    this.ui.emit('hover', evt);
};


Tooltip.prototype._onMouseLeave = function() {
    if (! this.ui.hoverable)
        return;

    this.ui.hidden = true;
};


Object.defineProperty(Tooltip.prototype, 'align', {
    get: function() {
        return this._align;
    },
    set: function(value) {
        if (this._align === value)
            return;

        this.class.remove('align-' + this._align);
        this._align = value;
        this.class.add('align-' + this._align);

        this._reflow();
    }
});


Object.defineProperty(Tooltip.prototype, 'flip', {
    get: function() {
        return this.class.contains('flip');
    },
    set: function(value) {
        if (this.class.contains('flip') === value)
            return;

        if (value) {
            this.class.add('flip');
        } else {
            this.class.remove('flip');
        }

        this._reflow();
    }
});


Object.defineProperty(Tooltip.prototype, 'text', {
    get: function() {
        return this.innerElement.textContent;
    },
    set: function(value) {
        if (this.innerElement.textContent === value)
            return;

        this.innerElement.textContent = value;
    }
});


Object.defineProperty(Tooltip.prototype, 'html', {
    get: function() {
        return this.innerElement.innerHTML;
    },
    set: function(value) {
        if (this.innerElement.innerHTML === value)
            return;

        this.innerElement.innerHTML = value;
    }
});


Tooltip.prototype._reflow = function() {
    if (this.hidden)
        return;

    this._element.style.top = '';
    this._element.style.right = '';
    this._element.style.bottom = '';
    this._element.style.left = '';

    this.arrow.style.top = '';
    this.arrow.style.right = '';
    this.arrow.style.bottom = '';
    this.arrow.style.left = '';

    this._element.style.display = 'block';

    // alignment
    switch(this._align) {
        case 'top':
            this._element.style.top = this.y + 'px';
            if (this.flip) {
                this._element.style.right = 'calc(100% - ' + this.x + 'px)';
            } else {
                this._element.style.left = this.x + 'px';
            }
            break;
        case 'right':
            this._element.style.top = this.y + 'px';
            this._element.style.right = 'calc(100% - ' + this.x + 'px)';
            break;
        case 'bottom':
            this._element.style.bottom = 'calc(100% - ' + this.y + 'px)';
            if (this.flip) {
                this._element.style.right = 'calc(100% - ' + this.x + 'px)';
            } else {
                this._element.style.left = this.x + 'px';
            }
            break;
        case 'left':
            this._element.style.top = this.y + 'px';
            this._element.style.left = this.x + 'px';
            break;
    }

    // limit to screen bounds
    var rect = this._element.getBoundingClientRect();

    if (rect.left < 0) {
        this._element.style.left = '0px';
        this._element.style.right = '';
    }
    if (rect.top < 0) {
        this._element.style.top = '0px';
        this._element.style.bottom = '';
    }
    if (rect.right > window.innerWidth) {
        this._element.style.right = '0px';
        this._element.style.left = '';
        this.arrow.style.left = Math.floor(rect.right - window.innerWidth + 8) + 'px';
    }
    if (rect.bottom > window.innerHeight) {
        this._element.style.bottom = '0px';
        this._element.style.top = '';
        this.arrow.style.top = Math.floor(rect.bottom - window.innerHeight + 8) + 'px';
    }

    this._element.style.display = '';
};


Tooltip.prototype.position = function(x, y) {
    x = Math.floor(x);
    y = Math.floor(y);

    if (this.x === x && this.y === y)
        return;

    this.x = x;
    this.y = y;

    this._reflow();
};


Tooltip.attach = function(args) {
    var data = {
        align: args.align,
        hoverable: args.hoverable
    };

    if (args.html) {
        data.html = args.html;
    } else {
        data.text = args.text || '';
    }

    var item = new ui.Tooltip(data);

    item.evtHover = function() {
        var rect = args.target.getBoundingClientRect();
        var off = 16;

        switch(item.align) {
            case 'top':
                if (rect.width < 64) off = rect.width / 2;
                item.flip = rect.left + off > window.innerWidth / 2;
                if (item.flip) {
                    item.position(rect.right - off, rect.bottom);
                } else {
                    item.position(rect.left + off, rect.bottom);
                }
                break;
            case 'right':
                if (rect.height < 64) off = rect.height / 2;
                item.flip = false;
                item.position(rect.left, rect.top + off);
                break;
            case 'bottom':
                if (rect.width < 64) off = rect.width / 2;
                item.flip = rect.left + off > window.innerWidth / 2;
                if (item.flip) {
                    item.position(rect.right - off, rect.top);
                } else {
                    item.position(rect.left + off, rect.top);
                }
                break;
            case 'left':
                if (rect.height < 64) off = rect.height / 2;
                item.flip = false;
                item.position(rect.right, rect.top + off);
                break;
        }

        item.hidden = false;
    };

    item.evtBlur = function() {
        item.hidden = true;
    };

    args.target.addEventListener('mouseover', item.evtHover, false);
    args.target.addEventListener('mouseout', item.evtBlur, false);

    item.on('destroy', function() {
        args.target.removeEventListener('mouseover', item.evtHover);
        args.target.removeEventListener('mouseout', item.evtBlur);
    });

    args.root.append(item);

    return item;
};


window.ui.Tooltip = Tooltip;


/* ui/menu.js */
"use strict";

function Menu(args) {
    var self = this;

    args = args || { };
    ui.ContainerElement.call(this);

    this.element = document.createElement('div');
    this._element.tabIndex = 1;
    this._element.classList.add('ui-menu');
    this._element.addEventListener('keydown', this._onKeyDown, false);

    this.elementOverlay = document.createElement('div');
    this.elementOverlay.ui = this;
    this.elementOverlay.classList.add('overlay');
    this.elementOverlay.addEventListener('click', this._onClick, false);
    this.elementOverlay.addEventListener('contextmenu', this._onContextMenu, false);
    this._element.appendChild(this.elementOverlay);

    this.innerElement = document.createElement('div');
    this.innerElement.classList.add('inner');
    this._element.appendChild(this.innerElement);

    this._index = { };
    this._hovered = [ ];

    this.on('select-propagate', this._onSelectPropagate);
    this.on('append', this._onAppend);
    this.on('over', this._onOver);
    this.on('open', this._onOpen);
}
Menu.prototype = Object.create(ui.ContainerElement.prototype);

Menu.prototype._onClick = function() {
    this.ui.open = false;
};

Menu.prototype._onContextMenu = function() {
    this.ui.open = false;
};

Menu.prototype._onKeyDown = function(evt) {
    if (this.ui.open && evt.keyCode === 27)
        this.ui.open = false;
};

Menu.prototype._onSelectPropagate = function(path) {
    this.open = false;
    this.emit(path.join('.') + ':select', path);
    this.emit('select', path);
};

Menu.prototype._onAppend = function(item) {
    var self = this;
    this._index[item._value] = item;

    item.on('value', function(value, valueOld) {
        delete self._index[this.valueOld];
        self._index[value] = item;
    });
    item.once('destroy', function() {
        delete self._index[this._value];
    });
};

Menu.prototype._onOver = function(path) {
    this._updatePath(path);
};

Menu.prototype._onOpen = function(state) {
    if (state) return;
    this._updatePath([ ]);
};


Object.defineProperty(Menu.prototype, 'open', {
    get: function() {
        return this.class.contains('open');
    },
    set: function(value) {
        if (this.class.contains('open') === !! value)
            return;

        if (value) {
            this.class.add('open');
            this._element.focus();
        } else {
            this.class.remove('open');
        }

        this.emit('open', !! value);
    }
});


Menu.prototype.findByPath = function(path) {
    if (! (path instanceof Array))
        path = path.split('.');

    var item = this;

    for(var i = 0; i < path.length; i++) {
        item = item._index[path[i]];
        if (! item)
            return null;
    }

    return item;
};


Menu.prototype._updatePath = function(path) {
    var node = this;

    for(var i = 0; i < this._hovered.length; i++) {
        node = node._index[this._hovered[i]];
        if (! node) break;
        if (path.length <= i || path[i] !== this._hovered[i]) {
            node.class.remove('hover');
            node.innerElement.style.top = '';
            node.innerElement.style.left = '';
            node.innerElement.style.right = '';
        }
    }

    this._hovered = path;
    node = this;

    for(var i = 0; i < this._hovered.length; i++) {
        node = node._index[this._hovered[i]];

        if (! node)
            break;

        node.class.add('hover');
        node.innerElement.style.top = '';
        node.innerElement.style.left = '';
        node.innerElement.style.right = '';

        var rect = node.innerElement.getBoundingClientRect();

        // limit to bottom / top of screen
        if (rect.bottom > window.innerHeight) {
            node.innerElement.style.top = -(rect.bottom - window.innerHeight) + 'px';
        }
        if (rect.right > window.innerWidth) {
            node.innerElement.style.left = 'auto';
            node.innerElement.style.right = (node.parent.innerElement.clientWidth) + 'px';
        }
    }
};


Menu.prototype.position = function(x, y) {
    this._element.style.display = 'block';

    var rect = this.innerElement.getBoundingClientRect();

    var left = (x || 0);
    var top = (y || 0);

    // limit to bottom / top of screen
    if (top + rect.height > window.innerHeight) {
        top = window.innerHeight - rect.height;
    } else if (top < 0) {
        top = 0;
    }
    if (left + rect.width > window.innerWidth) {
        left = window.innerWidth - rect.width;
    } else if (left < 0) {
        left = 0;
    }

    this.innerElement.style.left = left + 'px';
    this.innerElement.style.top = top + 'px';

    this._element.style.display = '';
};

Menu.prototype.createItem = function (key, data) {
    var item = new ui.MenuItem({
        text: data.title || key,
        value: key,
        icon: data.icon
    });

    if (data.select) {
        item.on('select', data.select);
    }

    if (data.filter) {
        this.on('open', function() {
            item.enabled = data.filter();
        });
    }

    if (data.hide) {
        this.on('open', function () {
            item.hidden = data.hide();
        });
    }

    return item;
};


Menu.fromData = function(data) {
    var menu = new ui.Menu();

    var addItem = function(key, data) {

    };

    var listItems = function(data, parent) {
        for(var key in data) {
            var item = menu.createItem(key, data[key]);
            parent.append(item);

            if (data[key].items)
                listItems(data[key].items, item);
        }
    };

    listItems(data, menu);

    return menu;
};


window.ui.Menu = Menu;


/* ui/menu-item.js */
"use strict";

function MenuItem(args) {
    var self = this;

    args = args || { };
    ui.ContainerElement.call(this);

    this._value = args.value || '';

    this.element = document.createElement('div');
    this._element.classList.add('ui-menu-item');

    this.elementTitle = document.createElement('div');
    this.elementTitle.classList.add('title');
    this.elementTitle.ui = this;
    this._element.appendChild(this.elementTitle);

    this.elementIcon = null;

    this.elementText = document.createElement('span');
    this.elementText.classList.add('text');
    this.elementText.textContent = args.text || 'Untitled';
    this.elementTitle.appendChild(this.elementText);

    this.innerElement = document.createElement('div');
    this.innerElement.classList.add('content');
    this._element.appendChild(this.innerElement);

    this._index = { };

    this._container = false;

    this.elementTitle.addEventListener('mouseenter', this._onMouseEnter, false);
    this.elementTitle.addEventListener('touchstart', this._onTouchStart, false);
    this.elementTitle.addEventListener('touchend', this._onTouchEnd, false);
    this.elementTitle.addEventListener('click', this._onClick, false);

    this.on('over', this._onOver);
    this.on('select-propagate', this._onSelectPropagate);
    this.on('append', this._onAppend);

    if (args.icon)
        this.icon = args.icon;
}
MenuItem.prototype = Object.create(ui.ContainerElement.prototype);


MenuItem.prototype._onMouseEnter = function(evt) {
    evt.stopPropagation();
    evt.preventDefault();

    this.ui.parent.emit('over', [ this.ui._value ]);
};

MenuItem.prototype._onOver = function(path) {
    if (! this.parent)
        return;

    path.splice(0, 0, this._value);

    this.parent.emit('over', path);
};

MenuItem.prototype._onClick = function() {
    if (! this.ui.parent || this.ui.disabled)
        return;

    this.ui.emit('select', this.ui._value);
    this.ui.parent.emit('select-propagate', [ this.ui._value ]);
    this.ui.class.remove('hover');
};

MenuItem.prototype._onTouchStart = function(evt) {
    if (! this.ui.parent || this.ui.disabled)
        return;

    if (! this.ui._container || this.ui.class.contains('hover')) {
        this.ui.emit('select', this.ui._value);
        this.ui.parent.emit('select-propagate', [ this.ui._value ]);
        this.ui.class.remove('hover');
    } else {
        this.ui.parent.emit('over', [ this.ui._value ]);
    }
};

MenuItem.prototype._onTouchEnd = function(evt) {
    if (! this.ui.parent || this.ui.disabled)
        return;

    evt.preventDefault();
    evt.stopPropagation();
};

MenuItem.prototype._onSelectPropagate = function(path) {
    if (! this.parent)
        return;

    path.splice(0, 0, this._value);

    this.parent.emit('select-propagate', path);
    this.class.remove('hover');
};

MenuItem.prototype._onAppend = function(item) {
    var self = this;

    this._container = true;
    this.class.add('container');

    this._index[item._value] = item;

    item.on('value', function(value, valueOld) {
        delete self._index[this.valueOld];
        self._index[value] = item;
    });
    item.once('destroy', function() {
        delete self._index[this._value];
    });
};


Object.defineProperty(MenuItem.prototype, 'value', {
    get: function() {
        return this._value;
    },
    set: function(value) {
        if (this._value === value)
            return;

        var valueOld = this._value;
        this._value = value;
        this.emit('value', value, valueOld);
    }
});


Object.defineProperty(MenuItem.prototype, 'text', {
    get: function() {
        return this.elementText.textContent;
    },
    set: function(value) {
        if (this.elementText.textContent === value)
            return;

        this.elementText.textContent = value;
    }
});


Object.defineProperty(MenuItem.prototype, 'icon', {
    get: function() {
        return this.elementIcon.textContent;
    },
    set: function(value) {
        if ((! value && ! this.elementIcon) || (this.elementIcon && this.elementIcon.textContent === value))
            return;

        if (! value) {
            this.elementIcon.parentNode.removeChild(this.elementIcon);
            this.elementIcon = null;
        } else {
            if (! this.elementIcon) {
                this.elementIcon = document.createElement('span');
                this.elementIcon.classList.add('icon');
                this.elementTitle.insertBefore(this.elementIcon, this.elementText);
            }

            this.elementIcon.innerHTML = value;
        }
    }
});


window.ui.MenuItem = MenuItem;


/* ui/canvas.js */
"use strict";

function Canvas(args) {
    ui.Element.call(this);
    args = args || { };

    this.element = document.createElement('canvas');
    this._element.classList.add('ui-canvas');

    if (args.id !== undefined)
        this._element.id = args.id;

    if (args.tabindex !== undefined)
        this._element.setAttribute('tabindex', args.tabindex);

    // Disable I-bar cursor on click+drag
    this._element.onselectstart = this.onselectstart;
}
Canvas.prototype = Object.create(ui.Element.prototype);

Canvas.prototype.onselectstart = function() {
    return false;
};

Canvas.prototype.resize = function(width, height) {
    if (this._element.width === width && this._element.height === height)
        return;

    this._element.width = width;
    this._element.height = height;
    this.emit('resize', this._element.width, this._element.height);
};

Object.defineProperty(Canvas.prototype, 'width', {
    get: function() {
        return this._element.width;
    },
    set: function(value) {
        if (this._element.width === value)
            return;

        this._element.width = value;
        this.emit('resize', this._element.width, this._element.height);
    }
});


Object.defineProperty(Canvas.prototype, 'height', {
    get: function() {
        return this._element.height;
    },
    set: function(value) {
        if (this._element.height === value)
            return;

        this._element.height = value;
        this.emit('resize', this._element.width, this._element.height);
    }
});


window.ui.Canvas = Canvas;


/* ui/curve-field.js */
"use strict"

function CurveField(args) {
    var self = this;

    ui.Element.call(this);
    args = args || { };

    this.element = document.createElement('div');
    this._element.classList.add('ui-curve-field');
    this._element.tabIndex = 0;
    this._element.addEventListener('keydown', this._onKeyDown, false);

    // canvas to render mini version of curves
    this.canvas = new ui.Canvas();
    this._element.appendChild(this.canvas.element);
    this.canvas.on('resize', this._render.bind(this));

    // create checkerboard pattern
    this.checkerboardCanvas = new ui.Canvas();
    var size = 17;
    var halfSize = size/2;
    this.checkerboardCanvas.width = size;
    this.checkerboardCanvas.height = size;
    var ctx = this.checkerboardCanvas.element.getContext('2d');
    ctx.fillStyle = '#'
    ctx.fillStyle = "#949a9c";
    ctx.fillRect(0,0,halfSize,halfSize);
    ctx.fillRect(halfSize,halfSize,halfSize,halfSize);
    ctx.fillStyle = "#657375";
    ctx.fillRect(halfSize,0,halfSize,halfSize);
    ctx.fillRect(0,halfSize,halfSize,halfSize);

    this.checkerboard = this.canvas.element.getContext('2d').createPattern(this.checkerboardCanvas.element, 'repeat');

    this._value = null;

    // curve field can contain multiple curves
    this._paths = [];

    this._linkSetHandlers = [];
    this._resizeInterval = null;
    this._suspendEvents = false;

    this._name = args.name;

    this.curveNames = args.curves;

    this.gradient = !!(args.gradient);

    this.min = 0;
    if (args.min !== undefined) {
        this.min = args.min;
    } else if (args.verticalValue !== undefined) {
        this.min = -args.verticalValue;
    }

    this.max = 1;
    if (args.max !== undefined) {
        this.max = args.max;
    } else if (args.verticalValue !== undefined) {
        this.max = args.verticalValue;
    }
}
CurveField.prototype = Object.create(ui.Element.prototype);

CurveField.prototype._onKeyDown = function(evt) {
    // esc
    if (evt.keyCode === 27)
        return this.blur();

    // enter
    if (evt.keyCode !== 32 || this.ui.disabled)
        return;

    evt.stopPropagation();
    evt.preventDefault();
    this.ui.emit('click');
};

CurveField.prototype._resize = function(width, height) {
    var changed = false;
    if (this.canvas.width !== width) {
        this.canvas.width = width;
        changed = true;
    }

    if (this.canvas.height !== height) {
        this.canvas.height = height;
        changed = true;
    }

    if (changed)
        this._render();
};

// Override link method to use multiple paths instead of one
CurveField.prototype.link = function(link, paths) {
    if (this._link) this.unlink();
    this._link = link;
    this._paths = paths;

    this.emit('link', paths);

    // handle canvas resizing
    // 20 times a second
    // if size is already same, nothing will happen
    if (this._resizeInterval)
        clearInterval(this._resizeInterval);

    this._resizeInterval = setInterval(function() {
        var rect = this._element.getBoundingClientRect();
        this.canvas.resize(rect.width, rect.height);
    }.bind(this), 1000 / 20);

    if (this._onLinkChange) {
        var renderChanges = this.renderChanges;
        this.renderChanges = false;
        this._linkSetHandlers.push(this._link.on('*:set', function (path) {
            var paths = this._paths;
            var len = paths.length;
            for (var i = 0; i < len; i++) {
                if (path.indexOf(paths[i]) === 0) {
                    this._onLinkChange();
                    break;
                }
            }
        }.bind(this)));

        this._onLinkChange();

        this.renderChanges = renderChanges;
    }
};

// Override unlink method to use multiple paths instead of one
CurveField.prototype.unlink = function() {
    if (! this._link) return;

    this.emit('unlink', this._paths);

    this._linkSetHandlers.forEach(function (handler) {
        handler.unbind();
    });

    this._linkSetHandlers.length = 0;

    clearInterval(this._resizeInterval);

    this._link = null;
    this._value = null;
    this._paths.length = 0;
};


CurveField.prototype._onLinkChange = function () {
    if (this._suspendEvents) return;

    // gather values of all paths and set new value
    var values = [];

    for (var i = 0; i < this._paths.length; i++) {
        var value = this._link.get(this._paths[i]);
        if (value !== undefined) {
            values.push(value);
        } else {
            values.push(null);
        }
    }

    this._setValue(values);
};

Object.defineProperty(CurveField.prototype, 'value', {
    get: function() {
        return this._value;
    },
    set: function(value) {
        this._setValue(value);
    }
});

CurveField.prototype._setValue = function (value) {
    this._value = value;
    this._render();
    this.emit('change', value);
};

CurveField.prototype._render = function () {
    if (this.gradient) {
        this._renderGradient();
    } else {
        this._renderCurves();
    }
};

// clamp val between min and max only if it's less / above them but close to them
// this is mostly to allow splines to go over the limit but if they are too close to
// the edge then they will avoid rendering half-height lines
CurveField.prototype._clampEdge = function (val, min, max) {
    if (val < min && val > min - 2) return min;
    if (val > max && val < max + 2) return max;
    return val;
};

// Renders all curves
CurveField.prototype._renderCurves = function () {
    var canvas = this.canvas.element;
    var context = canvas.ctx = canvas.ctx || canvas.getContext('2d');
    var value = this.value;

    // draw background
    context.clearRect(0, 0, canvas.width, canvas.height);

    var curveColors = ['rgb(255, 0, 0)', 'rgb(0, 255, 0)', 'rgb(133, 133, 252)', 'rgb(255, 255, 255)'];
    var fillColors = ['rgba(255, 0, 0, 0.5)', 'rgba(0, 255, 0, 0.5)', 'rgba(133, 133, 252, 0.5)', 'rgba(255, 255, 255, 0.5)'];

    var minMax = this._getMinMaxValues(value);

    // draw curves
    if (value && value[0]) {
        var primaryCurves = this._valueToCurves(value[0]);

        if (! primaryCurves)
            return;

        var secondaryCurves = value[0].betweenCurves && value.length > 1 ? this._valueToCurves(value[1]) : null;

        var minValue = minMax[0];
        var maxValue = minMax[1];

        context.lineWidth = 1;

        var height = canvas.height;

        for (var i = 0; i < primaryCurves.length; i++) {
            var val, x;

            context.strokeStyle = curveColors[i];
            context.fillStyle = fillColors[i];

            context.beginPath();
            context.moveTo(0, this._clampEdge(height * (1 - (primaryCurves[i].value(0) - minValue) / (maxValue - minValue)), 1, height - 1));

            var precision = 1;

            for(x = 0; x < Math.floor(canvas.width / precision); x++) {
                val = primaryCurves[i].value(x * precision / canvas.width);
                context.lineTo(x * precision, this._clampEdge(height * (1 - (val - minValue) / (maxValue - minValue)), 1, height - 1));
            }

            if (secondaryCurves) {
                for(x = Math.floor(canvas.width / precision) ; x >= 0; x--) {
                    val = secondaryCurves[i].value(x * precision / canvas.width);
                    context.lineTo(x * precision, this._clampEdge(height * (1 - (val - minValue) / (maxValue - minValue)), 1, height - 1));
                }

                context.closePath();
                context.fill();
            }

            context.stroke();
        }
    }
};

// Renders color-type graph as a gradient
CurveField.prototype._renderGradient = function () {
    var canvas = this.canvas.element;
    var context = canvas.ctx = canvas.cxt || canvas.getContext('2d');
    var value = this.value && this.value.length ? this.value[0] : null;

    context.fillStyle = this.checkerboard;
    context.fillRect(0, 0, canvas.width, canvas.height);

    var swizzle = [0, 1, 2, 3];
    if (this.curveNames && this.curveNames.length === 1) {
        if (this.curveNames[0] === 'g') {
            swizzle = [1, 0, 2, 3];
        } else if (this.curveNames[0] === 'b') {
            swizzle = [2, 1, 0, 3];
        } else if (this.curveNames[0] === 'a') {
            swizzle = [3, 1, 2, 0];
        }
    }


    if (value && value.keys && value.keys.length) {
        var rgb = [];

        var curve = this.curveNames && this.curveNames.length === 1 ? new pc.CurveSet([value.keys]) : new pc.CurveSet(value.keys);
        curve.type = value.type;

        var precision = 2;

        var gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);

        for (var t = precision; t < canvas.width; t += precision) {
            curve.value(t / canvas.width, rgb);

            var rgba = Math.round((rgb[swizzle[0]] || 0) * 255) + ',' +
                Math.round((rgb[swizzle[1]] || 0) * 255) + ',' +
                Math.round((rgb[swizzle[2]] || 0) * 255) + ',' +
                (isNaN(rgb[swizzle[3]]) ? 1 : rgb[swizzle[3]]);

            gradient.addColorStop(t / canvas.width, 'rgba(' + rgba + ')');
        }

        context.fillStyle = gradient;
        context.fillRect(0, 0, canvas.width, canvas.height);

    } else {
        // no keys in the curve so just render black color
        context.fillStyle = 'black';
        context.fillRect(0, 0, canvas.width, canvas.height);
    }
},

// Returns minimum and maximum values for all curves
    CurveField.prototype._getMinMaxValues = function (curves) {
        var minValue = Infinity;
        var maxValue = -Infinity;
        var i, len;

        if (curves) {
            if (curves.length === undefined) {
                curves = [curves];
            }

            curves.forEach(function (value) {
                if (value && value.keys && value.keys.length) {
                    if (value.keys[0].length !== undefined) {
                        value.keys.forEach(function (data) {

                            for (i = 1, len = data.length; i < len; i += 2) {
                                if (data[i] > maxValue) {
                                    maxValue = data[i];
                                }

                                if (data[i] < minValue) {
                                    minValue = data[i];
                                }
                            }
                        });
                    } else {
                        for (i = 1, len = value.keys.length; i < len; i += 2) {
                            if (value.keys[i] > maxValue) {
                                maxValue = value.keys[i];
                            }

                            if (value.keys[i] < minValue) {
                                minValue = value.keys[i];
                            }
                        }
                    }
                }
            });
        }

        if (minValue === Infinity) {
            minValue = this.min;
        }

        if (maxValue === -Infinity) {
            maxValue = this.max;
        }

        // try to limit minValue and maxValue
        // between the min / max values for the curve field
        if (minValue > this.min) {
            minValue = this.min;
        }

        if (maxValue < this.max) {
            maxValue = this.max;
        }

        return [minValue, maxValue];
    };

CurveField.prototype._valueToCurves = function (value) {
    var curves = null;

    if (value && value.keys && value.keys.length) {
        curves = [];
        var curve;
        if (value.keys[0].length !== undefined) {
            value.keys.forEach(function (data, index) {
                curve = new pc.Curve(data);
                curve.type = value.type;
                curves.push(curve);
            });
        } else {
            curve = new pc.Curve(value.keys);
            curve.type = value.type;
            curves.push(curve);
        }
    }

    return curves;
},

    window.ui.CurveField = CurveField;


/* ui/autocomplete-element.js */
"use strict";

function AutoCompleteElement() {
    ui.Element.call(this);

    this.element = document.createElement('div');
    this._element.classList.add('ui-autocomplete', 'hidden');

    this._inputField = null;
    this._inputFieldPosition = null;

    this.innerElement = document.createElement('ul');
    this._element.appendChild(this.innerElement);

    // list of strings to show in the dropdown
    this._items = null;

    // child li elements
    this._childElements = null;

    // elements that are currently shown
    this._visibleElements = null;

    this._highlightedElement = null;

    this._filter = '';
}

AutoCompleteElement.prototype = Object.create(ui.Element.prototype);

// Get / Set list of strings to show in the dropdown
Object.defineProperty(AutoCompleteElement.prototype, 'items', {
    get: function () {
        return this._items;
    },

    set: function (value) {
        // delete existing elements
        if (this._childElements) {
            this._childElements.forEach(function (element) {
                element.parentElement.removeChild(element);
            });

            this._childElements = null;
            this._highlight(null);
        }

        this._items = value;

        if (value) {
            // sort items
            this._items.sort();

            // create new li elements for each string
            this._childElements = [];
            this._visibleElements = [];
            value.forEach(function (item) {
                var element = document.createElement('li');
                element.innerHTML = item;
                this._childElements.push(element);
                this._visibleElements.push(element);
                this.innerElement.appendChild(element);

                // click
                element.addEventListener('mousedown', function (e) {
                    e.preventDefault(); // prevent blur
                    this._select(element);
                }.bind(this), true);

                // hover
                element.addEventListener('mouseover', function () {
                    this._highlight(element, true);
                }.bind(this));

            }.bind(this));
        }
    }
});

// True if the autocomplete is visible and has a highlighted element
Object.defineProperty(AutoCompleteElement.prototype, 'isFocused', {
    get: function () {
        return !this.hidden && this._highlightedElement;
    }
});

// Attach the autocomplete element to an input field
AutoCompleteElement.prototype.attach = function (inputField) {
    this._inputField = inputField;

    // set 'relative' position
    this._inputFieldPosition = inputField.style.position;
    inputField.style.position = 'relative';
    inputField.element.appendChild(this.element);

    // fire 'change' on every keystroke
    inputField.keyChange = true;

    // add event handlers
    inputField.element.addEventListener('keydown', this.onInputKey.bind(this));
    inputField.element.addEventListener('blur', this.onInputBlur.bind(this));
    inputField.elementInput.addEventListener('blur', this.onInputBlur.bind(this));
    inputField.on('change', this.onInputChange.bind(this));
};

// Detach event handlers and clear the attached input field
AutoCompleteElement.prototype.detach = function () {
    if (!this._inputField) return;

    this._inputField.style.position = this._inputFieldPosition;
    this._inputField.element.removeChild(this.element);

    this._inputField.off('change', this.onInputChange.bind(this));
    this._inputField.element.removeEventListener('keydown', this.onInputKey.bind(this));
    this._inputField.elementInput.removeEventListener('blur', this.onInputBlur.bind(this));

    this._inputField = null;
};

AutoCompleteElement.prototype.onInputKey = function (e) {
    var index;

    // enter: select highlighted element
    if (e.keyCode === 13) {
        if (!this.hidden && this._highlightedElement) {
            this._select(this._highlightedElement);
        }
    }
    // up: show dropdown or move highlight up
    else if (e.keyCode === 38) {
        if (this.hidden) {
            this.filter(this._inputField.value);
        } else {
            if (this._highlightedElement) {
                index = this._visibleElements.indexOf(this._highlightedElement) - 1;
                if (index < 0) {
                    index = this._visibleElements.length - 1;
                }
            } else {
                index = this._visibleElements.length - 1;
            }

            this._highlight(this._visibleElements[index]);
        }
    }
    // down: show dropdown or move highlight down
    else if (e.keyCode === 40 ) {

        if (this.hidden) {
            this.filter(this._inputField.value);
        } else {
            if (this._highlightedElement) {
                index = this._visibleElements.indexOf(this._highlightedElement) + 1;
                if (index >= this._visibleElements.length) {
                    index = 0;
                }
            } else {
                index = 0;
            }

            this._highlight(this._visibleElements[index]);
        }
    }
};

AutoCompleteElement.prototype.onInputBlur = function () {
    return;
    // hide the dropdown in a timeout
    // to avoid conflicts with key handlers
    setTimeout(function () {
        this.hidden = true;
    }.bind(this), 50);
};

AutoCompleteElement.prototype.onInputChange = function (value) {
    // filter based on new input field value
    if (value !== this._filter) {
        this.filter(value);
    }
};

// Only show elements that start with the specified value
AutoCompleteElement.prototype.filter = function (value) {
    if (!this._childElements) return;

    this.hidden = false;

    this._filter = value;

    this._visibleElements = [];

    value = value.toLowerCase();

    this._childElements.forEach(function (element, i) {
        if (value && element.innerHTML.toLowerCase().indexOf(value) === 0) {
            element.classList.remove('hidden');
            this._visibleElements.push(element);
        } else {
            element.classList.add('hidden');
            if (element === this._highlightedElement)
                this._highlight(null);
        }
    }.bind(this));
};

// Highlight specified element
AutoCompleteElement.prototype._highlight = function (element, silent) {
    // unhighlight previous element
    if (this._highlightedElement === element) return;

    if (this._highlightedElement)
        this._highlightedElement.classList.remove('selected');

    this._highlightedElement = element;

    if (element) {
        element.classList.add('selected');

        if (! silent) {
            this.emit('highlight', element.innerHTML);
        }
    }
};

// Select specified element
AutoCompleteElement.prototype._select = function (element) {
    if (this._inputField) {
        this._inputField.value = element.innerHTML;
        this._inputField.elementInput.focus();
    }

    this.emit('select', element.innerHTML);

    // hide in a timeout to avoid conflicts with key handlers
    setTimeout(function () {
        this.hidden = true;
    }.bind(this));
};

window.ui.AutoCompleteElement = AutoCompleteElement;


/* ui/bubble.js */
"use strict";

function Bubble(args) {
    ui.Element.call(this);
    args = args || { };

    this.element = document.createElement('div');
    this._element.classList.add('ui-bubble');

    var pulseCircle = document.createElement('div');
    pulseCircle.classList.add('pulse');
    this._element.appendChild(pulseCircle);

    var centerCircle = document.createElement('div');
    centerCircle.classList.add('center');
    this._element.appendChild(centerCircle);

    this.on('click', this._onClick);

    if (args.id !== undefined)
        this._element.id = args.id;

    if (args.tabindex !== undefined)
        this._element.setAttribute('tabindex', args.tabindex);
}
Bubble.prototype = Object.create(ui.Element.prototype);

Bubble.prototype._onClick = function() {
    if (this.class.contains('active')) {
        this.deactivate();
    } else {
        this.activate();
    }
};

Bubble.prototype.activate = function () {
    this.class.add('active');
    this.emit('activate');
};

Bubble.prototype.deactivate = function () {
    this.class.remove('active');
    this.emit('deactivate');
};

Bubble.prototype.position = function (x, y) {
    var rect = this._element.getBoundingClientRect();

    var left = (x || 0);
    var top = (y || 0);

    this._element.style.left = (typeof left === 'number') ? left + 'px' : left;
    this._element.style.top = (typeof top === 'number') ? top + 'px' : top;
};

window.ui.Bubble = Bubble;


/* editor/editor.js */
(function() {
    'use strict';

    function Editor() {
        Events.call(this);

        this._hooks = { };
    }
    Editor.prototype = Object.create(Events.prototype);


    Editor.prototype.method = function(name, fn) {
        if (this._hooks[name] !== undefined) {
            throw new Error('can\'t override hook: ' + name);
        }
        this._hooks[name] = fn;
    };


    Editor.prototype.methodRemove = function(name) {
        delete this._hooks[name];
    };


    Editor.prototype.call = function(name) {
        if (this._hooks[name]) {
            var args = Array.prototype.slice.call(arguments, 1);

            try {
                return this._hooks[name].apply(null, args);
            } catch(ex) {
                console.info('%c%s %c(editor.method error)', 'color: #06f', name, 'color: #f00');
                console.log(ex.stack);
            }
        }
        return null;
    };


    // editor
    window.editor = new Editor();
})();


// config
(function() {
    'use strict';

    var applyConfig = function(path, value) {
        if (typeof(value) === 'object') {
            for(var key in value) {
                applyConfig((path ? path + '.' : '') + key, value[key]);
            }
        } else {
            Ajax.param(path, value);
        }
    };

    applyConfig('', config);
})();


/* editor/first-load.js */
(function() {
    // first load
    document.addEventListener('DOMContentLoaded', function() {
        editor.call('status:text', 'loading');
        editor.emit('load');
        editor.call('status:text', 'starting');
        editor.emit('start');

        editor.call('status:text', 'ready');
    }, false);
})();


/* editor/hotkeys.js */
editor.once('load', function() {
    'use strict';

    var hotkeys = { };
    var keyIndex = { };
    var keysDown = { };
    var ctrl = false;
    var shift = false;
    var alt = false;

    var isMac = navigator.userAgent.indexOf('Mac OS X') !== -1;

    var keyByKeyCode = { };
    var keyByCode = { };

    var keyMap = {
        'backspace': {
            keyCode: 8,
            code: 'Backspace'
        },
        'tab': {
            keyCode: 9,
            code: 'Tab',
        },
        'enter': {
            keyCode: 13,
            code: [ 'enter', 'NumpadEnter' ],
        },
        'shift': {
            keyCode: 16,
            code: [ 'ShiftLeft', 'ShiftRight' ],
        },
        'ctrl': {
            keyCode: 17,
            code: [ 'CtrlLeft', 'CtrlRight' ],
        },
        'alt': {
            keyCode: 18,
            code: [ 'AltLeft', 'AltRight' ],
        },
        'pause/break': {
            keyCode: 19,
            code: 'Pause',
        },
        'caps lock': {
            keyCode: 20,
            code: 'CapsLock',
        },
        'esc': {
            keyCode: 27,
            code: 'Escape',
        },
        'space': {
            keyCode: 32,
            code: 'Space',
        },
        'page up': {
            keyCode: 33,
            code: 'PageUp'
        },
        'page down': {
            keyCode: 34,
            code: 'PageDown'
        },
        'end': {
            keyCode: 35,
            code: 'End'
        },
        'home': {
            keyCode: 36,
            code: 'Home'
        },
        'left arrow': {
            keyCode: 37,
            code: 'ArrowLeft'
        },
        'up arrow': {
            keyCode: 38,
            code: 'ArrowUp'
        },
        'right arrow': {
            keyCode: 39,
            code: 'ArrowRight'
        },
        'down arrow': {
            keyCode: 40,
            code: 'ArrowDown'
        },
        'insert': {
            keyCode: 45,
            code: 'Insert'
        },
        'delete': {
            keyCode: 46,
            code: 'Delete'
        },
        '0': {
            keyCode: 48,
            code: 'Digit0'
        },
        '1': {
            keyCode: 49,
            code: 'Digit1'
        },
        '2': {
            keyCode: 50,
            code: 'Digit2'
        },
        '3': {
            keyCode: 51,
            code: 'Digit3'
        },
        '4': {
            keyCode: 52,
            code: 'Digit4'
        },
        '5': {
            keyCode: 53,
            code: 'Digit5'
        },
        '6': {
            keyCode: 54,
            code: 'Digit6'
        },
        '7': {
            keyCode: 55,
            code: 'Digit7'
        },
        '8': {
            keyCode: 56,
            code: 'Digit8'
        },
        '9': {
            keyCode: 57,
            code: 'Digit9'
        },
        'a': {
            keyCode: 65,
            code: 'KeyA'
        },
        'b': {
            keyCode: 66,
            code: 'KeyB'
        },
        'c': {
            keyCode: 67,
            code: 'KeyC'
        },
        'd': {
            keyCode: 68,
            code: 'KeyD'
        },
        'e': {
            keyCode: 69,
            code: 'KeyE'
        },
        'f': {
            keyCode: 70,
            code: 'KeyF'
        },
        'g': {
            keyCode: 71,
            code: 'KeyG'
        },
        'h': {
            keyCode: 72,
            code: 'KeyH'
        },
        'i': {
            keyCode: 73,
            code: 'KeyI'
        },
        'j': {
            keyCode: 74,
            code: 'KeyJ'
        },
        'k': {
            keyCode: 75,
            code: 'KeyK'
        },
        'l': {
            keyCode: 76,
            code: 'KeyL'
        },
        'm': {
            keyCode: 77,
            code: 'KeyM'
        },
        'n': {
            keyCode: 78,
            code: 'KeyN'
        },
        'o': {
            keyCode: 79,
            code: 'KeyO'
        },
        'p': {
            keyCode: 80,
            code: 'KeyP'
        },
        'q': {
            keyCode: 81,
            code: 'KeyQ'
        },
        'r': {
            keyCode: 82,
            code: 'KeyR'
        },
        's': {
            keyCode: 83,
            code: 'KeyS'
        },
        't': {
            keyCode: 84,
            code: 'KeyT'
        },
        'u': {
            keyCode: 85,
            code: 'KeyU'
        },
        'v': {
            keyCode: 86,
            code: 'KeyV'
        },
        'w': {
            keyCode: 87,
            code: 'KeyW'
        },
        'x': {
            keyCode: 88,
            code: 'KeyX'
        },
        'y': {
            keyCode: 89,
            code: 'KeyY'
        },
        'z': {
            keyCode: 90,
            code: 'KeyZ'
        },
        'left window key': {
            keyCode: 91,
            code: 'MetaLeft'
        },
        'right window key': {
            keyCode: 92,
            code: 'MetaRight'
        },
        'select key': {
            keyCode: 93,
            code: 'ContextMenu'
        },
        'numpad 0': {
            keyCode: 96,
            code: 'Numpad0'
        },
        'numpad 1': {
            keyCode: 97,
            code: 'Numpad1'
        },
        'numpad 2': {
            keyCode: 98,
            code: 'Numpad2'
        },
        'numpad 3': {
            keyCode: 99,
            code: 'Numpad3'
        },
        'numpad 4': {
            keyCode: 100,
            code: 'Numpad4'
        },
        'numpad 5': {
            keyCode: 101,
            code: 'Numpad5'
        },
        'numpad 6': {
            keyCode: 102,
            code: 'Numpad6'
        },
        'numpad 7': {
            keyCode: 103,
            code: 'Numpad7'
        },
        'numpad 8': {
            keyCode: 104,
            code: 'Numpad8'
        },
        'numpad 9': {
            keyCode: 105,
            code: 'Numpad9'
        },
        'multiply': {
            keyCode: 106,
            code: 'NumpadMultiply'
        },
        'add': {
            keyCode: 107,
            code: 'NumpadAdd'
        },
        'subtract': {
            keyCode: 109,
            code: 'NumpadSubtract'
        },
        'decimal point': {
            keyCode: 110,
            code: 'NumpadDecimal'
        },
        'divide': {
            keyCode: 111,
            code: 'NumpadDivide'
        },
        'f1': {
            keyCode: 112,
            code: 'F1'
        },
        'f2': {
            keyCode: 113,
            code: 'F2'
        },
        'f3': {
            keyCode: 114,
            code: 'F3'
        },
        'f4': {
            keyCode: 115,
            code: 'F4'
        },
        'f5': {
            keyCode: 116,
            code: 'F5'
        },
        'f6': {
            keyCode: 117,
            code: 'F6'
        },
        'f7': {
            keyCode: 118,
            code: 'F7'
        },
        'f8': {
            keyCode: 119,
            code: 'F8'
        },
        'f9': {
            keyCode: 120,
            code: 'F9'
        },
        'f10': {
            keyCode: 121,
            code: 'F10'
        },
        'f11': {
            keyCode: 122,
            code: 'F11'
        },
        'f12': {
            keyCode: 123,
            code: 'F12'
        },
        'num lock': {
            keyCode: 144,
            code: 'NumLock'
        },
        'scroll lock': {
            keyCode: 145,
            code: 'ScrollLock'
        },
        'semi-colon': {
            keyCode: 186,
            code: 'Semicolon'
        },
        'equal sign': {
            keyCode: 187,
            code: 'Equal'
        },
        'comma': {
            keyCode: 188,
            code: 'Comma'
        },
        'dash': {
            keyCode: 189,
            code: 'Minus'
        },
        'period': {
            keyCode: 190,
            code: 'Period'
        },
        'forward slash': {
            keyCode: 191,
            code: ''
        },
        'grave accent': {
            keyCode: 192,
            code: 'Backquote'
        },
        'open bracket': {
            keyCode: 219,
            code: 'BracketLeft'
        },
        'back slash': {
            keyCode: 220,
            code: [ 'Backslash', 'IntlBackslash' ]
        },
        'close bracket': {
            keyCode: 221,
            code: 'BracketRight'
        },
        'single quote': {
            keyCode: 222,
            code: 'Quote'
        },
    };

    for(var key in keyMap) {
        keyByKeyCode[keyMap[key].keyCode] = key;

        if (keyMap[key].code instanceof Array) {
            for(var i = 0; i < keyMap[key].code.length; i++) {
                keyByCode[keyMap[key].code[i]] = key;
            }
        } else {
            keyByCode[keyMap[key].code] = key;
        }
    }


    editor.method('hotkey:register', function(name, args) {
        hotkeys[name] = args;

        // keys list
        var keys = [ args.ctrl ? 1 : 0, args.alt ? 1 : 0, args.shift ? 1 : 0 ];

        // map keyCode to key
        if (typeof(args.key) === 'number')
            args.key = keyByKeyCode[args.key];

        // unknown key
        if (! args.key) {
            console.error('unknown key: ' + name + ', ' + args.key);
            return;
        }

        keys.push(args.key);

        args.index = keys.join('+');

        if (! keyIndex[args.index])
            keyIndex[args.index] = [ ];

        keyIndex[args.index].push(name);
    });


    editor.method('hotkey:unregister', function(name) {
        var hotkey = hotkeys[name];
        if (! hotkey) return;

        if (keyIndex[hotkey.index].length === 1) {
            delete keyIndex[hotkey.index];
        } else {
            keyIndex[hotkey.index].splice(keyIndex[hotkey.index].indexOf(name), 1);
        }

        delete hotkeys[name];
    });


    editor.method('hotkey:shift', function() {
        return shift;
    });

    editor.method('hotkey:ctrl', function() {
        return ctrl;
    });

    editor.method('hotkey:alt', function() {
        return alt;
    });


    var updateModifierKeys = function(evt) {
        if (shift !== evt.shiftKey) {
            shift = evt.shiftKey;
            editor.emit('hotkey:shift', shift);
        }

        if (ctrl !== (evt.ctrlKey || evt.metaKey)) {
            ctrl = evt.ctrlKey || evt.metaKey;
            editor.emit('hotkey:ctrl', ctrl);
        }

        if (alt !== evt.altKey) {
            alt = evt.altKey;
            editor.emit('hotkey:alt', alt);
        }
    };
    editor.method('hotkey:updateModifierKeys', updateModifierKeys);


    window.addEventListener('keydown', function(evt) {
        if (evt.target) {
            var tag = evt.target.tagName;
            if (/(input)|(textarea)/i.test(tag) && ! evt.target.classList.contains('hotkeys'))
                return;
        }

        updateModifierKeys(evt);

        var key = evt.code ? keyByCode[evt.code] : keyByKeyCode[evt.keyCode];

        if (evt.keyCode === 92 || evt.keyCode === 93)
            return;

        var index = [ ctrl+0, alt+0, shift+0, key ].join('+');

        if (keyIndex[index]) {
            var skipPreventDefault = false;
            for(var i = 0; i < keyIndex[index].length; i++) {
                hotkeys[keyIndex[index][i]].callback(evt);
                if (! skipPreventDefault && hotkeys[keyIndex[index][i]].skipPreventDefault)
                    skipPreventDefault = true;
            }
            if (! skipPreventDefault)
                evt.preventDefault();
        }
    }, false);


    // Returns Ctrl or Cmd for Mac
    editor.method('hotkey:ctrl:string', function () {
        return isMac ? 'Cmd' : 'Ctrl';
    });


    window.addEventListener('keyup', updateModifierKeys, false);
    window.addEventListener('mousedown', updateModifierKeys, false);
    window.addEventListener('mouseup', updateModifierKeys, false);
    window.addEventListener('click', updateModifierKeys, false);


    ui.Grid._ctrl = function() {
        return ctrl;
    };
    ui.Grid._shift = function() {
        return shift;
    };

    ui.Tree._ctrl = function() {
        return ctrl;
    };
    ui.Tree._shift = function() {
        return shift;
    };

    ui.List._ctrl = function() {
        return ctrl;
    };
    ui.List._shift = function() {
        return shift;
    };
});


/* editor/layout.js */
editor.on('load', function() {
    'use strict';

    var ignoreClasses = /(ui-list-item)|(ui-button)|(ui-text-field)|(ui-number-field)/i;
    var ignoreElements = /(input)|(textarea)/i;

    // prevent drag'n'select
    window.addEventListener('mousedown', function(evt) {
        // don't prevent for certain cases
        if (evt.target) {
            if (ignoreClasses.test(evt.target.className)) {
                return;
            } else if (ignoreElements.test(evt.target.tagName)) {
                return;
            } else if (evt.target.classList.contains('selectable')) {
                return;
            }
        }

        // blur inputs
        if (window.getSelection) {
            var focusNode = window.getSelection().focusNode;
            if (focusNode) {
                if (focusNode.tagName === 'INPUT') {
                    focusNode.blur();
                } else if (focusNode.firstChild && focusNode.firstChild.tagName === 'INPUT') {
                    focusNode.firstChild.blur();
                }
            }
        }

        // prevent default will prevent blur, dragstart and selection
        evt.preventDefault();
    }, false);


    // main container
    var root = new ui.Panel();
    root.element.id = 'ui-root';
    root.flex = true;
    root.flexDirection = 'column';
    root.flexWrap = 'nowrap';
    root.scroll = true;
    document.body.appendChild(root.element);
    // expose
    editor.method('layout.root', function() { return root; });

    var top = new ui.Panel();
    top.style.backgroundColor = '#5f6f72';
    top.style.cursor = 'pointer';
    top.element.id = 'ui-top';
    top.flexShrink = false;
    top.once('click', function() {
        top.destroy();
        toolbar.style.marginTop = '';
    });
    root.append(top);

    // middle
    var middle = new ui.Panel();
    middle.element.id = 'ui-middle';
    middle.flexible = true;
    middle.flexGrow = true;
    root.append(middle);

    // bottom (status)
    var bottom = new ui.Panel();
    bottom.element.id = 'ui-bottom';
    bottom.flexShrink = false;
    root.append(bottom);
    // expose
    editor.method('layout.bottom', function() { return bottom; });


    // toolbar (left)
    var toolbar = new ui.Panel();
    toolbar.element.id = 'ui-toolbar';
    toolbar.flexShrink = false;
    toolbar.style.width = '45px';
    middle.append(toolbar);
    // expose
    editor.method('layout.toolbar', function() { return toolbar; });


    // hierarchy
    var hierarchyPanel = new ui.Panel('HIERARCHY');
    hierarchyPanel.enabled = false;
    hierarchyPanel.class.add('hierarchy');
    hierarchyPanel.flexShrink = false;
    hierarchyPanel.style.width = '256px';
    hierarchyPanel.innerElement.style.width = '256px';
    hierarchyPanel.foldable = true;
    hierarchyPanel.horizontal = true;
    hierarchyPanel.scroll = true;
    hierarchyPanel.resizable = 'right';
    hierarchyPanel.resizeMin = 196;
    hierarchyPanel.resizeMax = 512;
    middle.append(hierarchyPanel);
    // expose
    editor.method('layout.left', function() { return hierarchyPanel; });
    editor.on('permissions:writeState', function(state) {
        hierarchyPanel.enabled = state;
    });
    if (window.innerWidth <= 480)
        hierarchyPanel.folded = true;


    // center
    var center = new ui.Panel();
    center.flexible = true;
    center.flexGrow = true;
    center.flexDirection = 'column';
    middle.append(center);

    // viewport
    var viewport = new ui.Panel();
    viewport.flexible = true;
    viewport.flexGrow = true;
    viewport.class.add('viewport');
    center.append(viewport);
    // expose
    editor.method('layout.viewport', function() { return viewport; });

    // assets
    var assetsPanel = new ui.Panel('ASSETS');
    assetsPanel.class.add('assets');
    assetsPanel.foldable = true;
    assetsPanel.flexShrink = false;
    assetsPanel.innerElement.style.height = '212px';
    assetsPanel.scroll = true;
    assetsPanel.resizable = 'top';
    assetsPanel.resizeMin = 106;
    assetsPanel.resizeMax = 106 * 6;
    assetsPanel.headerSize = -1;
    center.append(assetsPanel);
    // expose
    editor.method('layout.assets', function() { return assetsPanel; });
    if (window.innerHeight <= 480)
        assetsPanel.folded = true;


    // attributes
    var attributesPanel = new ui.Panel('INSPECTOR');
    attributesPanel.enabled = false;
    attributesPanel.class.add('attributes');
    attributesPanel.flexShrink = false;
    attributesPanel.style.width = '320px';
    attributesPanel.innerElement.style.width = '320px';
    attributesPanel.horizontal = true;
    attributesPanel.foldable = true;
    attributesPanel.scroll = true;
    attributesPanel.resizable = 'left';
    attributesPanel.resizeMin = 256;
    attributesPanel.resizeMax = 512;
    middle.append(attributesPanel);
    // expose
    editor.method('layout.right', function() { return attributesPanel; });
    editor.on('permissions:writeState', function(state) {
        attributesPanel.enabled = state;
    });
    if (window.innerWidth <= 720)
        attributesPanel.folded = true;
});


/* editor/messenger.js */
editor.on('start', function() {
    'use strict';

    if (typeof(Messenger) === 'undefined')
        return;

    var messenger = new Messenger();

    messenger.connect(config.url.messenger.ws);

    messenger.on('connect', function() {
        this.authenticate(config.accessToken, 'designer');
    });

    messenger.on('welcome', function() {
        this.projectWatch(config.project.id);
    });

    messenger.on('message', function(evt) {
        editor.emit('messenger:' + evt.name, evt.data);
    });

    window.msg = messenger;
});


/* editor/history.js */
editor.once('load', function() {
    'use strict';

    var actions = [ ];
    var current = -1;
    var canUndo = false;
    var canRedo = false;


    var checkCanUndoRedo = function() {
        if (canUndo && current == -1) {
            canUndo = false;
            editor.emit('history:canUndo', false);
        } else if (! canUndo && current >= 0) {
            canUndo = true;
            editor.emit('history:canUndo', true);
        }

        if (canRedo && current === actions.length - 1) {
            canRedo = false;
            editor.emit('history:canRedo', false);
        } else if (! canRedo && current < actions.length - 1) {
            canRedo = true;
            editor.emit('history:canRedo', true);
        }
    };

    editor.method('history:canUndo', function() {
        return canUndo;
    });
    editor.method('history:canRedo', function() {
        return canRedo;
    });


    // current
    editor.method('history:current', function() {
        if (current === -1)
            return null;

        return current;
    });


    // clear
    editor.method('history:clear', function() {
        if (! actions.length)
            return;

        actions = [ ];
        current = -1;
        checkCanUndoRedo();
    });


    // add action
    editor.method('history:add', function(action) {
        // some history needs erasing
        if (current !== actions.length - 1)
            actions = actions.slice(0, current + 1);

        // add action
        actions.push(action);

        editor.call('status:text', action.name);

        // current action state
        current = actions.length - 1;

        checkCanUndoRedo();
    });


    // update action
    editor.method('history:update', function(action) {
        if (current === -1 || actions[current].name !== action.name)
            return;

        actions[current].redo = action.redo;

        editor.call('status:text', action.name);
    });


    // undo
    editor.method('history:undo', function() {
        // no history
        if (current === -1)
            return;

        actions[current].undo();
        current--;

        if (current >= 0) {
            editor.call('status:text', actions[current].name);
        } else {
            editor.call('status:text', '');
        }

        editor.emit('history:undo', name);
        checkCanUndoRedo();
    });


    // redo
    editor.method('history:redo', function() {
        if (current === actions.length - 1)
            return;

        current++;
        actions[current].redo();
        editor.call('status:text', actions[current].name);

        editor.emit('history:redo', name);
        checkCanUndoRedo();
    });

    // list history
    editor.method('history:list', function() {
        return actions;
    });

    // hotkey undo
    editor.call('hotkey:register', 'history:undo', {
        key: 'z',
        ctrl: true,
        callback: function() {
            if (! editor.call('permissions:write'))
                return;

            editor.call('history:undo');
        }
    });

    // hotkey redo
    editor.call('hotkey:register', 'history:redo', {
        key: 'z',
        ctrl: true,
        shift: true,
        callback: function() {
            if (! editor.call('permissions:write'))
                return;

            editor.call('history:redo');
        }
    });

    // hotkey redo
    editor.call('hotkey:register', 'history:redo:y', {
        key: 'y',
        ctrl: true,
        callback: function() {
            if (! editor.call('permissions:write'))
                return;

            editor.call('history:redo');
        }
    });
});





/* editor/status.js */
editor.once('load', function() {
    'use strict';

    var jobs = { };
    var panel = editor.call('layout.bottom');


    // status
    var status = new ui.Label({
        text: 'PlayCanvas'
    });
    status.renderChanges = false;
    status.class.add('status');
    panel.append(status);

    // progress
    var progress = new ui.Progress();
    progress.class.add('jobsProgress');
    panel.append(progress);

    // jobs
    var jobsCount = new ui.Label({
        text: '0'
    });
    jobsCount.renderChanges = false;
    jobsCount.class.add('jobsCount');
    panel.append(jobsCount);


    // status text
    editor.method('status:text', function(text) {
        status.text = text;
        status.class.remove('error');
    });


    // status error
    editor.method('status:error', function(text) {
        status.text = text;
        status.class.add('error');
    });



    // update jobs
    var updateJobs = function() {
        var count = Object.keys(jobs).length;
        jobsCount.text = count;

        if (count > 0) {
            var least = 1;
            for(var key in jobs) {
                if (jobs[key] < least)
                    least = jobs[key];
            }
            progress.progress = least;
            progress.class.add('active');
        } else {
            progress.class.remove('active');
            progress.progress = 1;
        }
    };

    // status job
    editor.method('status:job', function(id, value) {
        if (jobs.hasOwnProperty(id) && value === undefined) {
            delete jobs[id];
        } else {
            jobs[id] = value;
        }

        updateJobs();
    });
});


/* editor/permissions.js */
editor.once('load', function() {
    'use strict';

    var permissions = { };

    // cache permissions in a dictionary
    ['read', 'write', 'admin'].forEach(function (access) {
        config.project.permissions[access].forEach(function (id) {
            permissions[id] = access;
        });
    });

    editor.method('permissions', function () {
        return config.project.permissions;
    });

    editor.method('permissions:read', function (userId) {
        if (! userId) userId = config.self.id;
        return permissions.hasOwnProperty(userId);
    });

    editor.method('permissions:write', function (userId) {
        if (!userId) userId = config.self.id;

        return permissions[userId] === 'write' || permissions[userId] === 'admin';
    });

    editor.method('permissions:admin', function (userId) {
        if (!userId) userId = config.self.id;

        return permissions[userId] === 'admin';
    });

    // subscribe to messenger
    editor.on('messenger:project.permissions', function (msg) {
        var userId = msg.user.id;

        // remove from read
        var ind = config.project.permissions.read.indexOf(userId);
        if (ind !== -1)
            config.project.permissions.read.splice(ind, 1);

        // remove from write
        ind = config.project.permissions.write.indexOf(userId);
        if (ind !== -1) {
            config.project.permissions.write.splice(ind, 1);
        }

        // remove from admin
        ind = config.project.permissions.admin.indexOf(userId);
        if (ind !== -1) {
            config.project.permissions.admin.splice(ind, 1);
        }

        delete permissions[userId];

        var accessLevel = msg.user.permission;

        // add new permission
        if (accessLevel) {
            config.project.permissions[accessLevel].push(userId);
            permissions[userId] = accessLevel;
        } else {
            // lock out user if private project
            if (config.self.id === userId && config.project.private)
                window.location.reload();
        }

        editor.emit('permissions:set:' + userId, accessLevel);
        if (userId === config.self.id)
            editor.emit('permissions:set', accessLevel);
    });

    // subscribe to project private changes
    editor.on('messenger:project.private', function (msg) {
        var projectId = msg.project.id;
        if (config.project.id !== projectId)
            return;

        config.project.private = msg.project.private;

        if (msg.project.private && ! editor.call('permissions:read', config.self.id)) {
            // refresh page so that user gets locked out
            window.location.reload();
        }
    });

    editor.on('messenger:user.logout', function (msg) {
        if (msg.user.id === config.self.id) {
            window.location.reload();
        }
    });

    editor.on('permissions:set:' + config.self.id, function (accessLevel) {
        var connection = editor.call('realtime:connection');
        editor.emit('permissions:writeState', connection && connection.state === 'connected' && (accessLevel === 'write' || accessLevel === 'admin'));
    });

    // emit initial event
    if (editor.call('permissions:write')) {
        editor.emit('permissions:set:' + config.self.id, 'write');
    }
});


/* editor/error.js */
editor.once('load', function() {
    'use strict';

    window.addEventListener('error', function(evt) {
        // console.log(evt);
        editor.call('status:error', evt.message);
    }, false);
});


/* editor/contextmenu.js */
editor.once('load', function() {
    'use strict';

    window.addEventListener('contextmenu', function(evt) {
        evt.preventDefault();
    }, false);
});


/* editor/drop.js */
editor.once('load', function() {
    'use strict';

    // overlay
    var overlay = document.createElement('div');
    overlay.classList.add('drop-overlay');
    editor.call('layout.root').append(overlay);

    var imgDrag = new Image();
    // imgDrag.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAACWCAYAAAAfduJyAAAAFUlEQVQoU2NkYGBgYBwlRsNgJKQDAOAfAJflUZweAAAAAElFTkSuQmCC';
    // imgDrag.style.display = 'none';

    var parts = [ 'top', 'right', 'bottom', 'left' ];
    for(var i = 0; i < parts.length; i++) {
        var part = document.createElement('div');
        part.classList.add('drop-overlay-hole-part', parts[i]);
        editor.call('layout.root').append(part);
        parts[i] = part;
    }

    // areas
    var areas = document.createElement('div');
    areas.classList.add('drop-areas');
    editor.call('layout.root').append(areas);


    var active = false;
    var currentType = '';
    var currentData = { };
    var currentElement = null;
    var dragOver = false;
    var items = [ ];
    var itemOver = null;

    var activate = function(state) {
        if (! editor.call('permissions:write'))
            return;

        if (active === state)
            return;

        active = state;

        if (active) {
            overlay.classList.add('active');
            areas.classList.add('active');
            editor.call('cursor:set', 'grabbing');
        } else {
            overlay.classList.remove('active');
            areas.classList.remove('active');
            dragOver = false;
            currentType = '';
            currentData = { };
            editor.emit('drop:set', currentType, currentData);
            editor.call('cursor:clear');
        }

        var onMouseUp = function() {
            window.removeEventListener('mouseup', onMouseUp);
            activate(false);
        };
        window.addEventListener('mouseup', onMouseUp, false);

        editor.emit('drop:active', active);
    };

    editor.method('drop:activate', activate);
    editor.method('drop:active', function() {
        return active;
    });


    // prevent drop file of redirecting
    window.addEventListener('dragenter', function(evt) {
        evt.preventDefault();

        if (! editor.call('permissions:write'))
            return;

        if (dragOver) return;
        dragOver = true;

        if (! currentType) {
            currentType = 'files';
            editor.emit('drop:set', currentType, currentData);
        }

        activate(true);
    }, false);

    window.addEventListener('dragover', function(evt) {
        evt.preventDefault();

        if (! editor.call('permissions:write'))
            return;

        evt.dataTransfer.dropEffect = 'move';

        if (dragOver) return;
        dragOver = true;

        activate(true);
    }, false);

    window.addEventListener('dragleave', function(evt) {
        evt.preventDefault();

        if (evt.clientX !== 0 || evt.clientY !== 0)
            return;

        if (! editor.call('permissions:write'))
            return;

        if (! dragOver) return;
        dragOver = false;

        setTimeout(function() {
            if (dragOver)
                return;

            activate(false);
        }, 0);
    }, false);

    window.addEventListener('drop', function(evt) {
        evt.preventDefault();
        activate(false);
    }, false);


    var evtDragOver = function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.classList.add('over');

        if (itemOver && itemOver !== this)
            evtDragLeave.call(itemOver);

        itemOver = this;

        if (this._ref && this._ref.over && currentType) {
            var data = currentData;
            if (currentType == 'files' && e.dataTransfer)
                data = e.dataTransfer.files;
            this._ref.over(currentType, data);
        }
    };
    var evtDragLeave = function(e) {
        if (e) e.preventDefault();
        this.classList.remove('over');

        if (this._ref && this._ref.leave && currentType)
            this._ref.leave();

        if (itemOver === this)
            itemOver = null;
    };

    var fixChromeFlexBox = function(item) {
        // workaround for chrome
        // for z-index + flex-grow weird reflow bug
        // need to force reflow in next frames

        if (! window.chrome)
            return;

        // only for those who have flexgrow
        var flex = item.style.flexGrow;
        if (flex) {
            // changing overflow triggers reflow
            var overflow = item.style.overflow;
            item.style.overflow = 'hidden';
            // need to skip 2 frames, 1 is not enough
            requestAnimationFrame(function() {
                requestAnimationFrame(function() {
                    // change back to what it was
                    item.style.overflow = overflow;
                });
            });
        }
    };


    editor.method('drop:target', function(obj) {
        items.push(obj);
        obj.element = document.createElement('div');
        obj.element._ref = obj;
        obj.element.classList.add('drop-area');
        if (obj.hole)
            obj.element.classList.add('hole');

        if (obj.passThrough)
            obj.element.style.pointerEvents = 'none';

        areas.appendChild(obj.element);

        obj.evtDrop = function(e) {
            e.preventDefault();

            if (! currentType)
                return;

            // leave event
            if (obj.element.classList.contains('over')) {
                if (obj.leave && currentType) obj.leave();
                obj.element.classList.remove('over');
            }

            var data = currentData;
            if (currentType == 'files' && e.dataTransfer)
                data = e.dataTransfer.files;

            if (obj.drop)
                obj.drop(currentType, data);
        };

        obj.element.addEventListener('dragenter', evtDragOver, false);
        obj.element.addEventListener('mouseenter', evtDragOver, false);

        obj.element.addEventListener('dragleave', evtDragLeave, false);
        obj.element.addEventListener('mouseleave', evtDragLeave, false);

        var dropOn = obj.element;
        if (obj.passThrough)
            dropOn = obj.ref;

        dropOn.addEventListener('drop', obj.evtDrop, false);
        dropOn.addEventListener('mouseup', obj.evtDrop, false);

        obj.unregister = function() {
            if (! obj.element.classList.contains('drop-area'))
                return;

            obj.element.removeEventListener('dragenter', evtDragOver);
            obj.element.removeEventListener('mouseenter', evtDragOver);

            obj.element.removeEventListener('dragleave', evtDragLeave);
            obj.element.removeEventListener('mouseleave', evtDragLeave);

            dropOn.removeEventListener('drop', obj.evtDrop);
            dropOn.removeEventListener('mouseup', obj.evtDrop);

            var ind = items.indexOf(obj);
            if (ind !== -1)
                items.splice(ind, 1);

            if (obj.ref.classList.contains('drop-ref-highlight')) {
                obj.ref.classList.remove('drop-ref-highlight');
                fixChromeFlexBox(obj.ref);
            }

            obj.element.classList.remove('drop-area');
            areas.removeChild(obj.element);
        };

        return obj;
    });


    editor.method('drop:item', function(args) {
        args.element.draggable = true;

        args.element.addEventListener('mousedown', function(evt) {
            evt.stopPropagation();
        }, false);

        args.element.addEventListener('dragstart', function(evt) {
            evt.preventDefault();
            evt.stopPropagation();

            if (! editor.call('permissions:write'))
                return;

            currentType = args.type;
            currentData = args.data;
            itemOver = null;
            editor.emit('drop:set', currentType, currentData);

            activate(true);
        }, false);
    });


    editor.method('drop:set', function(type, data) {
        currentType = type || '',
            currentData = data || { };

        editor.emit('drop:set', currentType, currentData);
    });


    editor.on('drop:active', function(state) {
        areas.style.pointerEvents = '';

        if (state) {
            var bottom = 0;
            var top = window.innerHeight;
            var left = window.innerWidth;
            var right = 0;

            for(var i = 0; i < items.length; i++) {
                var visible = ! items[i].disabled;

                if (visible) {
                    if (items[i].filter) {
                        visible = items[i].filter(currentType, currentData);
                    } else if (items[i].type !== currentType) {
                        visible = false;
                    }
                }

                if (visible) {
                    var rect = items[i].ref.getBoundingClientRect();
                    var depth = 4;
                    var parent = items[i].ref;
                    while(depth--) {
                        if (! rect.width || ! rect.height || ! parent.offsetHeight || window.getComputedStyle(parent).getPropertyValue('visibility') === 'hidden') {
                            visible = false;
                            break;
                        }
                        parent = parent.parentNode;
                    }
                }

                if (visible) {
                    items[i].element.style.display = 'block';

                    if (items[i].hole) {
                        items[i].element.style.left = (rect.left + 2) + 'px';
                        items[i].element.style.top = (rect.top + 2) + 'px';
                        items[i].element.style.width = (rect.width - 4) + 'px';
                        items[i].element.style.height = (rect.height - 4) + 'px';

                        overlay.classList.remove('active');

                        if (top > rect.top)
                            top = rect.top;

                        if (bottom < rect.bottom)
                            bottom = rect.bottom;

                        if (left > rect.left)
                            left = rect.left;

                        if (right < rect.right)
                            right = rect.right;

                        parts[0].classList.add('active');
                        parts[0].style.height = top + 'px';

                        parts[1].classList.add('active');
                        parts[1].style.top = top + 'px';
                        parts[1].style.bottom = (window.innerHeight - bottom) + 'px';
                        parts[1].style.width = (window.innerWidth - right) + 'px';

                        parts[2].classList.add('active');
                        parts[2].style.height = (window.innerHeight - bottom) + 'px';

                        parts[3].classList.add('active');
                        parts[3].style.top = top + 'px';
                        parts[3].style.bottom = (window.innerHeight - bottom) + 'px';
                        parts[3].style.width = left + 'px';

                        if (items[i].passThrough)
                            areas.style.pointerEvents = 'none';
                    } else {
                        items[i].element.style.left = (rect.left + 1) + 'px';
                        items[i].element.style.top = (rect.top + 1) + 'px';
                        items[i].element.style.width = (rect.width - 2) + 'px';
                        items[i].element.style.height = (rect.height - 2) + 'px';
                        items[i].ref.classList.add('drop-ref-highlight');
                    }
                } else {
                    items[i].element.style.display = 'none';

                    if (items[i].ref.classList.contains('drop-ref-highlight')) {
                        items[i].ref.classList.remove('drop-ref-highlight');
                        fixChromeFlexBox(items[i].ref);
                    }
                }
            }
        } else {
            for(var i = 0; i < parts.length; i++)
                parts[i].classList.remove('active');

            for(var i = 0; i < items.length; i++) {
                if (! items[i].ref.classList.contains('drop-ref-highlight'))
                    continue;

                items[i].ref.classList.remove('drop-ref-highlight');
                fixChromeFlexBox(items[i].ref);
            }
        }
    });
});


/* editor/cursor.js */
editor.once('load', function() {
    'use strict';

    var cursorType = '';

    editor.method('cursor:set', function(type) {
        if (cursorType === type)
            return;

        cursorType = type;
        document.body.style.setProperty('cursor', type, 'important');
        document.body.style.setProperty('cursor', '-moz-' + type, 'important');
        document.body.style.setProperty('cursor', '-webkit-' + type, 'important');
    });

    editor.method('cursor:clear', function() {
        if (! cursorType)
            return;

        cursorType = '';
        document.body.style.cursor = '';
    });

    var hiddenTime = 0;
    var tooltip = new ui.Label();
    tooltip.class.add('cursor-tooltip');
    tooltip.renderChanges = false;
    tooltip.hidden = true;
    editor.call('layout.root').append(tooltip);

    var lastX = 0;
    var lastY = 0;

    // move tooltip
    var onMove = function(evt) {
        lastX = evt.clientX;
        lastY = evt.clientY;

        if (tooltip.hidden && (Date.now() - hiddenTime) > 100)
            return;

        tooltip.style.transform = 'translate(' + evt.clientX + 'px,' + evt.clientY + 'px)';
    };
    window.addEventListener('mousemove', onMove, false);
    window.addEventListener('dragover', onMove, false);

    // set tooltip text
    editor.method('cursor:text', function(text) {
        if (text) tooltip.text = text;
        tooltip.hidden = ! text;

        tooltip.style.transform = 'translate(' + lastX + 'px,' + lastY + 'px)';

        if (! text)
            hiddenTime = Date.now();
    });
});


/* editor/datetime.js */
editor.once('load', function () {
    'use strict';

    // convert passed time to a local time with moment.js
    editor.method('datetime:convert', function (date) {
        return new Date(date).toLocaleString();
    });
});

/* editor/search.js */
editor.once('load', function() {
    'use strict';

    // calculate, how many string `a`
    // requires edits, to become string `b`
    editor.method('search:stringEditDistance', function(a, b) {
        // Levenshtein distance
        // https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
        if(a.length === 0) return b.length;
        if(b.length === 0) return a.length;
        if(a === b) return 0;

        var i, j;
        var matrix = [];

        for(i = 0; i <= b.length; i++)
            matrix[i] = [i];

        for(j = 0; j <= a.length; j++)
            matrix[0][j] = j;

        for(i = 1; i <= b.length; i++){
            for(j = 1; j <= a.length; j++){
                if(b.charAt(i-1) === a.charAt(j-1)){
                    matrix[i][j] = matrix[i-1][j-1];
                } else {
                    matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, Math.min(matrix[i][j-1] + 1, matrix[i-1][j] + 1));
                }
            }
        }

        return matrix[b.length][a.length];
    });


    // calculate, how many characters string `b`
    // contains of a string `a`
    editor.method('search:charsContains', function(a, b) {
        if (a === b)
            return a.length;

        var contains = 0;
        var ind = { };
        var i;

        for(i = 0; i < b.length; i++)
            ind[b.charAt(i)] = true;

        for(i = 0; i < a.length; i++) {
            if(ind[a.charAt(i)])
                contains++;
        }

        return contains;
    });


    // tokenize string into array of tokens
    editor.method('search:stringTokenize', function(name) {
        var tokens = [ ];

        // camelCase
        // upperCASE123
        var string = name.replace(/([^A-Z])([A-Z][^A-Z])/g, '$1 $2').replace(/([A-Z0-9]{2,})/g, ' $1');

        // space notation
        // dash-notation
        // underscore_notation
        var parts = string.split(/(\s|\-|_)/g);

        // filter valid tokens
        for(var i = 0; i < parts.length; i++) {
            parts[i] = parts[i].toLowerCase().trim();
            if (parts[i] && parts[i] !== '-' && parts[i] !== '_')
                tokens.push(parts[i]);
        }

        return tokens;
    });


    var searchItems = function(items, search, args) {
        var results = [ ];

        for(var i = 0; i < items.length; i++) {
            var item = items[i];

            // direct hit
            if (item.subFull !== Infinity) {
                results.push(item);

                if (item.edits === Infinity)
                    item.edits = 0;

                if (item.sub === Infinity)
                    item.sub = item.subFull;

                continue;
            } else if (item.name === search || item.name.indexOf(search) === 0) {
                results.push(item);

                if (item.edits === Infinity)
                    item.edits = 0;

                if (item.sub === Infinity)
                    item.sub = 0;

                continue;
            }

            // check if name contains enough of search characters
            var contains = editor.call('search:charsContains', search, item.name);
            if (contains / search.length < args.containsCharsTolerance)
                continue;

            var editsCandidate = Infinity;
            var subCandidate = Infinity;

            // for each token
            for(var t = 0; t < item.tokens.length; t++) {
                // direct token match
                if (item.tokens[t] === search) {
                    editsCandidate = 0;
                    subCandidate = t;
                    break;
                }

                var edits = editor.call('search:stringEditDistance', search, item.tokens[t]);

                if ((subCandidate === Infinity || edits < editsCandidate) && item.tokens[t].indexOf(search) !== -1) {
                    // search is a substring of a token
                    subCandidate = t;
                    editsCandidate = edits;
                    continue;
                } else if (subCandidate === Infinity && edits < editsCandidate) {
                    // new edits candidate, not a substring of a token
                    if ((edits / Math.max(search.length, item.tokens[t].length)) <= args.editsDistanceTolerance) {
                        // check if edits tolerance is satisfied
                        editsCandidate = edits;
                    }
                }
            }

            // no match candidate
            if (editsCandidate === Infinity)
                continue;

            // add new result
            results.push(item);
            item.edits = item.edits === Infinity ? editsCandidate : item.edits + editsCandidate;
            item.sub = item.sub === Infinity ? subCandidate : item.sub + subCandidate;
        }

        return results;
    };

    // perform search through items
    // items is an array with arrays of two values
    // where first value is a string to be searched by
    // and second value is an object to be found
    /*
    [
        [ 'camera', {object} ],
        [ 'New Entity', {object} ],
        [ 'Sun', {object} ]
    ]
    */
    editor.method('search:items', function(items, search, args) {
        search = (search || '').toLowerCase().trim();

        if (! search)
            return [ ];

        var searchTokens = editor.call('search:stringTokenize', search);
        if (! searchTokens.length)
            return [ ];

        args = args || { };
        args.limitResults = args.limitResults || 16;
        args.containsCharsTolerance = args.containsCharsTolerance || 0.5;
        args.editsDistanceTolerance = args.editsDistanceTolerance || 0.5;

        var result = [ ];
        var records = [ ];

        for(var i = 0; i < items.length; i++) {
            var subInd = items[i][0].toLowerCase().trim().indexOf(search);

            records.push({
                name: items[i][0],
                item: items[i][1],
                tokens: editor.call('search:stringTokenize', items[i][0]),
                edits: Infinity,
                subFull: (subInd !== -1) ? subInd : Infinity,
                sub: Infinity
            });
        }

        // search each token
        for(var i = 0; i < searchTokens.length; i++)
            records = searchItems(records, searchTokens[i], args);

        // sort result first by substring? then by edits number
        records.sort(function(a, b) {
            if (a.subFull !== b.subFull) {
                return a.subFull - b.subFull;
            } else if (a.sub !== b.sub) {
                return a.sub - b.sub;
            } else if (a.edits !== b.edits) {
                return a.edits - b.edits;
            } else {
                return a.name.length - b.name.length;
            }
        });

        // return only items without match information
        for(var i = 0; i < records.length; i++)
            records[i] = records[i].item;

        // limit number of results
        if (records.length > args.limitResults)
            records = records.slice(0, args.limitResults);

        return records;
    });
});


/* editor/notifications.js */
editor.once('load', function() {
    'use strict';

    var TIMEOUT = 5000;
    var TIMEOUT_OVERLAP = 500;
    var last;
    var logo = 'https://s3-eu-west-1.amazonaws.com/static.playcanvas.com/platform/images/logo/playcanvas-logo-360.jpg';
    var visible = ! document.hidden;

    document.addEventListener('visibilitychange', function() {
        if (visible === ! document.hidden)
            return;

        visible = ! document.hidden;
        if (visible) {
            editor.emit('visible');
        } else {
            editor.emit('hidden');
        }
        editor.emit('visibility', visible);
    }, false);

    editor.method('visibility', function() {
        return visible;
    });

    editor.method('notify:state', function() {
        if (! window.Notification)
            return null;

        return Notification.permission;
    });

    editor.method('notify:permission', function(fn) {
        if (! window.Notification)
            return;

        if (Notification.permission !== 'denied') {
            Notification.requestPermission(function(permission) {
                editor.emit('notify:permission', permission);
                if (fn) fn();
            });
        }
    });

    editor.method('notify', function(args) {
        // no supported
        if (! window.Notification || ! args.title || visible)
            return;

        args = args || { };

        var timeout;
        var queueClose = function(item) {
            setTimeout(function() {
                item.close();
            }, TIMEOUT_OVERLAP);
        };
        var notify = function() {
            if (last) {
                queueClose(last);
                last = null;
            }

            var notification = last = new Notification(args.title, {
                body: args.body,
                icon: args.icon || logo
            });

            timeout = setTimeout(function() {
                notification.close();
            }, args.timeout || TIMEOUT);

            notification.onclick = function(evt) {
                evt.preventDefault();
                notification.close();

                if (args.click)
                    args.click(evt);
            };

            notification.onclose = function(evt) {
                clearTimeout(timeout);
                timeout = null;

                if (last === notification)
                    last = null;
            };
        };

        if (Notification.permission === 'granted') {
            // allowed
            notify();
        } else if (Notification.permission !== 'denied') {
            // ask for permission
            editor.call('notify:permission', function(permission) {
                if (permission === 'granted')
                    notify();
            });
        } else {
            // no permission
        }
    });

    editor.method('notify:title', function(title) {
        document.title = title;
    });
});


/* editor/refocus.js */
editor.once('load', function() {
    'use strict';

    var last = null;
    var timeout = null;

    var onClear = function() {
        last = null;

        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
    };

    window.addEventListener('focus', onClear, true);

    window.addEventListener('blur', function(evt) {
        if (! evt.target || ! evt.target.ui || ! evt.target.ui.focus || ! evt.target.ui.refocusable) {
            onClear();
        } else {
            timeout = setTimeout(function() {
                last = evt.target.ui;
            }, 0);
        }
    }, true);

    window.addEventListener('keydown', function(evt) {
        if (! last)
            return;

        if (evt.keyCode === 13) {
            last.focus(true);
        } else {
            onClear();
        }
    }, false)

    window.addEventListener('mousedown', function() {
        if (last) onClear();
    }, false);
});


/* realtime/share.uncompressed.js */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.sharejs = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    var Doc = require('./doc').Doc;
    var Query = require('./query').Query;
    var emitter = require('./emitter');


    /**
     * Handles communication with the sharejs server and provides queries and
     * documents.
     *
     * We create a connection with a socket object
     *   connection = new sharejs.Connection(sockset)
     * The socket may be any object handling the websocket protocol. See the
     * documentation of bindToSocket() for details. We then wait for the connection
     * to connect
     *   connection.on('connected', ...)
     * and are finally able to work with shared documents
     *   connection.get('food', 'steak') // Doc
     *
     * @param socket @see bindToSocket
     */
    var Connection = exports.Connection = function (socket) {
        emitter.EventEmitter.call(this);

        // Map of collection -> docName -> doc object for created documents.
        // (created documents MUST BE UNIQUE)
        this.collections = {};

        // Each query is created with an id that the server uses when it sends us
        // info about the query (updates, etc).
        //this.nextQueryId = (Math.random() * 1000) |0;
        this.nextQueryId = 1;

        // Map from query ID -> query object.
        this.queries = {};

        // State of the connection. The correspoding events are emmited when this
        // changes. Available states are:
        // - 'connecting'   The connection has been established, but we don't have our
        //                  client ID yet
        // - 'connected'    We have connected and recieved our client ID. Ready for data.
        // - 'disconnected' The connection is closed, but it will reconnect automatically.
        // - 'stopped'      The connection is closed, and should not reconnect.
        this.state = 'disconnected';

        // This is a helper variable the document uses to see whether we're currently
        // in a 'live' state. It is true if we're connected, or if you're using
        // browserchannel and connecting.
        this.canSend = false;

        // Private variable to support clearing of op retry interval
        this._retryInterval = null;

        // Reset some more state variables.
        this.reset();

        this.debug = false;

        // I'll store the most recent 100 messages so when errors occur we can see
        // what happened.
        this.messageBuffer = [];

        this.bindToSocket(socket);
    }
    emitter.mixin(Connection);


    /**
     * Use socket to communicate with server
     *
     * Socket is an object that can handle the websocket protocol. This method
     * installs the onopen, onclose, onmessage and onerror handlers on the socket to
     * handle communication and sends messages by calling socket.send(msg). The
     * sockets `readyState` property is used to determine the initaial state.
     *
     * @param socket Handles the websocket protocol
     * @param socket.readyState
     * @param socket.close
     * @param socket.send
     * @param socket.onopen
     * @param socket.onclose
     * @param socket.onmessage
     * @param socket.onerror
     */
    Connection.prototype.bindToSocket = function(socket) {
        if (this.socket) {
            delete this.socket.onopen
            delete this.socket.onclose
            delete this.socket.onmessage
            delete this.socket.onerror
        }

        // TODO: Check that the socket is in the 'connecting' state.

        this.socket = socket;
        // This logic is replicated in setState - consider calling setState here
        // instead.
        this.state = (socket.readyState === 0 || socket.readyState === 1) ? 'connecting' : 'disconnected';
        this.canSend = this.state === 'connecting' && socket.canSendWhileConnecting;
        this._setupRetry();

        var connection = this

        socket.onmessage = function(msg) {
            var data = msg.data;

            // Fall back to supporting old browserchannel 1.x API which implemented the
            // websocket API incorrectly. This will be removed at some point
            if (!data) data = msg;

            // Some transports don't need parsing.
            if (typeof data === 'string') data = JSON.parse(data);

            if (connection.debug) console.log('RECV', JSON.stringify(data));

            connection.messageBuffer.push({
                t: (new Date()).toTimeString(),
                recv:JSON.stringify(data)
            });
            while (connection.messageBuffer.length > 100) {
                connection.messageBuffer.shift();
            }

            try {
                connection.handleMessage(data);
            } catch (err) {
                connection.emit('error', err, data);
                // We could also restart the connection here, although that might result
                // in infinite reconnection bugs.
            }
        }

        socket.onopen = function() {
            connection._setState('connecting');
        };

        socket.onerror = function(e) {
            // This isn't the same as a regular error, because it will happen normally
            // from time to time. Your connection should probably automatically
            // reconnect anyway, but that should be triggered off onclose not onerror.
            // (onclose happens when onerror gets called anyway).
            connection.emit('connection error', e);
        };

        socket.onclose = function(reason) {
            // reason values:
            //   'Closed' - The socket was manually closed by calling socket.close()
            //   'Stopped by server' - The server sent the stop message to tell the client not to try connecting
            //   'Request failed' - Server didn't respond to request (temporary, usually offline)
            //   'Unknown session ID' - Server session for client is missing (temporary, will immediately reestablish)
            connection._setState('disconnected', reason);
            if (reason === 'Closed' || reason === 'Stopped by server') {
                connection._setState('stopped', reason);
            }
        };
    };



    /**
     * @param {object} msg
     * @param {String} msg.a action
     */
    Connection.prototype.handleMessage = function(msg) {
        // Switch on the message action. Most messages are for documents and are
        // handled in the doc class.
        switch (msg.a) {
            case 'init':
                // Client initialization packet. This bundle of joy contains our client
                // ID.
                if (msg.protocol !== 0) throw new Error('Invalid protocol version');
                if (typeof msg.id != 'string') throw new Error('Invalid client id');

                this.id = msg.id;
                this._setState('connected');
                break;

            case 'qfetch':
            case 'qsub':
            case 'q':
            case 'qunsub':
                // Query message. Pass this to the appropriate query object.
                var query = this.queries[msg.id];
                if (query) query._onMessage(msg);
                break;

            case 'bs':
                // Bulk subscribe response. The responses for each document are contained within.
                var result = msg.s;
                // vaios: check if there is a global msg error
                var error = msg.error;
                if (error) {
                    this.emit('bs error', error);
                }

                if (result) {
                    for (var cName in result) {
                        for (var docName in result[cName]) {
                            var doc = this.get(cName, docName);
                            if (!doc) {
                                console.warn('Message for unknown doc. Ignoring.', msg);
                                break;
                            }

                            var msg = result[cName][docName];
                            if (typeof msg === 'object') {
                                // vaios: change this to handle global error too
                                doc._handleSubscribe(msg ? msg.error : error, msg);
                            } else {
                                // The msg will be true if we simply resubscribed.
                                doc._handleSubscribe(null, null);
                            }
                        }
                    }
                }


                break;

            default:
                // Document message. Pull out the referenced document and forward the
                // message.
                var doc = this.getExisting(msg.c, msg.d);
                if (doc) doc._onMessage(msg);
        }
    };


    Connection.prototype.reset = function() {
        this.id = null;
        this.seq = 1;
    };


    Connection.prototype._setupRetry = function() {
        if (!this.canSend) {
            clearInterval(this._retryInterval);
            this._retryInterval = null;
            return;
        }
        if (this._retryInterval != null) return;

        var connection = this;
        this._retryInterval = setInterval(function() {
            for (var collectionName in connection.collections) {
                var collection = connection.collections[collectionName];
                for (var docName in collection) {
                    collection[docName].retry();
                }
            }
        }, 1000);
    };


// Set the connection's state. The connection is basically a state machine.
    Connection.prototype._setState = function(newState, data) {
        if (this.state === newState) return;

        // I made a state diagram. The only invalid transitions are getting to
        // 'connecting' from anywhere other than 'disconnected' and getting to
        // 'connected' from anywhere other than 'connecting'.
        if (
            (newState === 'connecting' && this.state !== 'disconnected' && this.state !== 'stopped') ||
            (newState === 'connected' && this.state !== 'connecting')
        ) {
            throw new Error("Cannot transition directly from " + this.state + " to " + newState);
        }

        this.state = newState;
        this.canSend =
            (newState === 'connecting' && this.socket.canSendWhileConnecting) ||
            (newState === 'connected');
        this._setupRetry();

        if (newState === 'disconnected') this.reset();

        this.emit(newState, data);

        // Group all subscribes together to help server make more efficient calls
        this.bsStart();
        // Emit the event to all queries
        for (var id in this.queries) {
            var query = this.queries[id];
            query._onConnectionStateChanged(newState, data);
        }
        // Emit the event to all documents
        for (var c in this.collections) {
            var collection = this.collections[c];
            for (var docName in collection) {
                collection[docName]._onConnectionStateChanged(newState, data);
            }
        }
        this.bsEnd();
    };

    Connection.prototype.bsStart = function() {
        this.subscribeData = this.subscribeData || {};
    };

    Connection.prototype.bsEnd = function() {
        // Only send bulk subscribe if not empty
        if (hasKeys(this.subscribeData)) {
            this.send({a:'bs', s:this.subscribeData});
        }
        this.subscribeData = null;
    };

    Connection.prototype.sendSubscribe = function(doc, version) {
        // Ensure the doc is registered so that it receives the reply message
        this._addDoc(doc);
        if (this.subscribeData) {
            // Bulk subscribe
            var data = this.subscribeData;
            if (!data[doc.collection]) data[doc.collection] = {};
            data[doc.collection][doc.name] = version || null;
        } else {
            // Send single subscribe message
            var msg = {a: 'sub', c: doc.collection, d: doc.name};
            if (version != null) msg.v = version;
            this.send(msg);
        }
    };

    Connection.prototype.sendFetch = function(doc, version) {
        // Ensure the doc is registered so that it receives the reply message
        this._addDoc(doc);
        var msg = {a: 'fetch', c: doc.collection, d: doc.name};
        if (version != null) msg.v = version;
        this.send(msg);
    };

    Connection.prototype.sendUnsubscribe = function(doc) {
        // Ensure the doc is registered so that it receives the reply message
        this._addDoc(doc);
        var msg = {a: 'unsub', c: doc.collection, d: doc.name};
        this.send(msg);
    };

    Connection.prototype.sendOp = function(doc, data) {
        // Ensure the doc is registered so that it receives the reply message
        this._addDoc(doc);
        var msg = {
            a: 'op',
            c: doc.collection,
            d: doc.name,
            v: doc.version,
            src: data.src,
            seq: data.seq
        };
        if (data.op) msg.op = data.op;
        if (data.create) msg.create = data.create;
        if (data.del) msg.del = data.del;
        this.send(msg);
    };


    /**
     * Sends a message down the socket
     */
    Connection.prototype.send = function(msg) {
        if (this.debug) console.log("SEND", JSON.stringify(msg));

        this.messageBuffer.push({t:Date.now(), send:JSON.stringify(msg)});
        while (this.messageBuffer.length > 100) {
            this.messageBuffer.shift();
        }

        if (!this.socket.canSendJSON)
            msg = JSON.stringify(msg);

        if (this.socket.readyState === 1)
            this.socket.send(msg);
    };


    /**
     * Closes the socket and emits 'disconnected'
     */
    Connection.prototype.disconnect = function() {
        this.socket.close();
    };

    Connection.prototype.getExisting = function(collection, name) {
        if (this.collections[collection]) return this.collections[collection][name];
    };


    /**
     * @deprecated
     */
    Connection.prototype.getOrCreate = function(collection, name, data) {
        console.trace('getOrCreate is deprecated. Use get() instead');
        return this.get(collection, name, data);
    };


    /**
     * Get or create a document.
     *
     * @param collection
     * @param name
     * @param [data] ingested into document if created
     * @return {Doc}
     */
    Connection.prototype.get = function(collection, name, data) {
        var collectionObject = this.collections[collection];
        if (!collectionObject)
            collectionObject = this.collections[collection] = {};

        var doc = collectionObject[name];
        if (!doc) {
            doc = collectionObject[name] = new Doc(this, collection, name);
            this.emit('doc', doc);
        }

        // Even if the document isn't new, its possible the document was created
        // manually and then tried to be re-created with data (suppose a query
        // returns with data for the document). We should hydrate the document
        // immediately if we can because the query callback will expect the document
        // to have data.
        if (data && data.data !== undefined && !doc.state) {
            doc.ingestData(data);
        }

        return doc;
    };


    /**
     * Remove document from this.collections
     *
     * @private
     */
    Connection.prototype._destroyDoc = function(doc) {
        var collectionObject = this.collections[doc.collection];
        if (!collectionObject) return;

        delete collectionObject[doc.name];

        // Delete the collection container if its empty. This could be a source of
        // memory leaks if you slowly make a billion collections, which you probably
        // won't do anyway, but whatever.
        if (!hasKeys(collectionObject))
            delete this.collections[doc.collection];
    };

    Connection.prototype._addDoc = function(doc) {
        var collectionObject = this.collections[doc.collection];
        if (!collectionObject) {
            collectionObject = this.collections[doc.collection] = {};
        }
        if (collectionObject[doc.name] !== doc) {
            collectionObject[doc.name] = doc;
        }
    };


    function hasKeys(object) {
        for (var key in object) return true;
        return false;
    };


// Helper for createFetchQuery and createSubscribeQuery, below.
    Connection.prototype._createQuery = function(type, collection, q, options, callback) {
        if (type !== 'fetch' && type !== 'sub')
            throw new Error('Invalid query type: ' + type);

        if (!options) options = {};
        var id = this.nextQueryId++;
        var query = new Query(type, this, id, collection, q, options, callback);
        this.queries[id] = query;
        query._execute();
        return query;
    };

// Internal function. Use query.destroy() to remove queries.
    Connection.prototype._destroyQuery = function(query) {
        delete this.queries[query.id];
    };

// The query options object can contain the following fields:
//
// docMode: What to do with documents that are in the result set. Can be
//   null/undefined (default), 'fetch' or 'subscribe'. Fetch mode indicates
//   that the server should send document snapshots to the client for all query
//   results. These will be hydrated into the document objects before the query
//   result callbacks are returned. Subscribe mode gets document snapshots and
//   automatically subscribes the client to all results. Note that the
//   documents *WILL NOT* be automatically unsubscribed when the query is
//   destroyed. (ShareJS doesn't have enough information to do that safely).
//   Beware of memory leaks when using this option.
//
// poll: Forcably enable or disable polling mode. Polling mode will reissue the query
//   every time anything in the collection changes (!!) so, its quite
//   expensive.  It is automatically enabled for paginated and sorted queries.
//   By default queries run with polling mode disabled; which will only check
//   changed documents to test if they now match the specified query.
//   Set to false to disable polling mode, or true to enable it. If you don't
//   specify a poll option, polling mode is enabled or disabled automatically
//   by the query's backend.
//
// backend: Set the backend source for the query. You can attach different
//   query backends to livedb and pick which one the query should hit using
//   this parameter.
//
// results: (experimental) Initial list of resultant documents. This is
//   useful for rehydrating queries when you're using autoFetch / autoSubscribe
//   so the server doesn't have to send over snapshots for documents the client
//   already knows about. This is experimental - the API may change in upcoming
//   versions.

// Create a fetch query. Fetch queries are only issued once, returning the
// results directly into the callback.
//
// The index is specific to the source, but if you're using mongodb it'll be
// the collection to which the query is made.
// The callback should have the signature function(error, results, extraData)
// where results is a list of Doc objects.
    Connection.prototype.createFetchQuery = function(index, q, options, callback) {
        return this._createQuery('fetch', index, q, options, callback);
    };

// Create a subscribe query. Subscribe queries return with the initial data
// through the callback, then update themselves whenever the query result set
// changes via their own event emitter.
//
// If present, the callback should have the signature function(error, results, extraData)
// where results is a list of Doc objects.
    Connection.prototype.createSubscribeQuery = function(index, q, options, callback) {
        return this._createQuery('sub', index, q, options, callback);
    };

},{"./doc":2,"./emitter":3,"./query":5}],2:[function(require,module,exports){
    var types = require('../types').ottypes;
    var emitter = require('./emitter');

    /**
     * A Doc is a client's view on a sharejs document.
     *
     * It is is uniquely identified by its `name` and `collection`.  Documents
     * should not be created directly. Create them with Connection.get()
     *
     *
     *
     * Subscriptions
     * -------------
     *
     * We can subscribe a document to stay in sync with the server.
     *   doc.subscribe(function(error) {
 *     doc.state // = 'ready'
 *     doc.subscribed // = true
 *   })
     * The server now sends us all changes concerning this document and these are
     * applied to our snapshot. If the subscription was successful the initial
     * snapshot and version sent by the server are loaded into the document.
     *
     * To stop listening to the changes we call `doc.unsubscribe()`.
     *
     * If we just want to load the data but not stay up-to-date, we call
     *   doc.fetch(function(error) {
 *     doc.snapshot // sent by server
 *   })
     *
     * TODO What happens when the document does not exist yet.
     *
     *
     *
     * Editing documents
     * ------------------
     *
     * To edit a document we have to create an editing context
     *   context = doc.context()
     * The context is an object exposing the type API of the documents OT type.
     *   doc.type = 'text'
     *   context.insert(0, 'In the beginning')
     *   doc.snapshot // 'In the beginning...'
     *
     * If a operation is applied on the snapshot the `_onOp` on the context is
     * called. The type implementation then usually triggers a corresponding event.
     *
     *
     *
     *
     * Events
     * ------
     *
     * You can use doc.on(eventName, callback) to subscribe to the following events:
     * - `before op (op, localContext)` Fired before an operation is applied to the
     *   snapshot. The document is already in locked state, so it is not allowed to
     *   submit further operations. It may be used to read the old snapshot just
     *   before applying an operation. The callback is passed the operation and the
     *   editing context if the operation originated locally and `false` otherwise
     * - `after op (op, localContext)` Fired after an operation has been applied to
     *   the snapshot. The arguments are the same as for `before op`
     * - `op (op, localContext)` The same as `after op` unless incremental updates
     *   are enabled. In this case it is fired after every partial operation with
     *   this operation as the first argument. When fired the document is in a
     *   locked state which only allows reading operations.
     * - `subscribed (error)` The document was subscribed
     * - `created (localContext)` The document was created. That means its type was
     *   set and it has some initial data.
     * - `del (localContext, snapshot)` Fired after the document is deleted, that is
     *   the snapshot is null. It is passed the snapshot before delteion as an
     *   arguments
     * - `error`
     *
     * TODO rename `op` to `after partial op`
     */
    var Doc = exports.Doc = function(connection, collection, name) {
        emitter.EventEmitter.call(this);

        this.connection = connection;

        this.collection = collection;
        this.name = name;

        this.version = this.type = null;
        this.snapshot = undefined;

        // **** State in document:

        // The action the document tries to perform with the server
        //
        // - subscribe
        // - unsubscribe
        // - fetch
        // - submit: send an operation
        this.action = null;

        // The data the document object stores can be in one of the following three states:
        //   - No data. (null) We honestly don't know whats going on.
        //   - Floating ('floating'): we have a locally created document that hasn't
        //     been created on the server yet)
        //   - Live ('ready') (we have data thats current on the server at some version).
        this.state = null;

        // Our subscription status. Either we're subscribed on the server, or we aren't.
        this.subscribed = false;
        // Either we want to be subscribed (true), we want a new snapshot from the
        // server ('fetch'), or we don't care (false). This is also used when we
        // disconnect & reconnect to decide what to do.
        this.wantSubscribe = false;
        // This list is used for subscribe and unsubscribe, since we'll only want to
        // do one thing at a time.
        this._subscribeCallbacks = [];


        // *** end state stuff.

        // This doesn't provide any standard API access right now.
        this.provides = {};

        // The editing contexts. These are usually instances of the type API when the
        // document is ready for edits.
        this.editingContexts = [];

        // The op that is currently roundtripping to the server, or null.
        //
        // When the connection reconnects, the inflight op is resubmitted.
        //
        // This has the same format as an entry in pendingData, which is:
        // {[create:{...}], [del:true], [op:...], callbacks:[...], src:, seq:}
        this.inflightData = null;

        // All ops that are waiting for the server to acknowledge this.inflightData
        // This used to just be a single operation, but creates & deletes can't be
        // composed with regular operations.
        //
        // This is a list of {[create:{...}], [del:true], [op:...], callbacks:[...]}
        this.pendingData = [];

        // The OT type of this document.
        //
        // The document also responds to the api provided by the type
        this.type = null;

        // For debouncing getLatestOps calls
        this._getLatestTimeout = null;
    };
    emitter.mixin(Doc);

    /**
     * Unsubscribe and remove all editing contexts
     */
    Doc.prototype.destroy = function(callback) {
        var doc = this;
        this.unsubscribe(function() {
            // Don't care if there's an error unsubscribing.

            if (doc.hasPending()) {
                doc.once('nothing pending', function() {
                    doc.connection._destroyDoc(doc);
                });
            } else {
                doc.connection._destroyDoc(doc);
            }
            doc.removeContexts();
            if (callback) callback();
        });
    };


// ****** Manipulating the document snapshot, version and type.

// Set the document's type, and associated properties. Most of the logic in
// this function exists to update the document based on any added & removed API
// methods.
//
// @param newType OT type provided by the ottypes library or its name or uri
    Doc.prototype._setType = function(newType) {
        if (typeof newType === 'string') {
            if (!types[newType]) throw new Error("Missing type " + newType + ' ' + this.collection + ' ' + this.name);
            newType = types[newType];
        }
        this.removeContexts();

        // Set the new type
        this.type = newType;

        // If we removed the type from the object, also remove its snapshot.
        if (!newType) {
            this.provides = {};
            this.snapshot = undefined;
        } else if (newType.api) {
            // Register the new type's API.
            this.provides = newType.api.provides;
        }
    };

// Injest snapshot data. This data must include a version, snapshot and type.
// This is used both to ingest data that was exported with a webpage and data
// that was received from the server during a fetch.
//
// @param data.v    version
// @param data.data
// @param data.type
// @fires ready
    Doc.prototype.ingestData = function(data) {
        if (typeof data.v !== 'number') {
            throw new Error('Missing version in ingested data ' + this.collection + ' ' + this.name);
        }
        if (this.state) {
            // Silently ignore if doc snapshot version is equal or newer
            // TODO: Investigate whether this should happen in practice or not
            if (this.version >= data.v) return;
            console.warn('Ignoring ingest data for', this.collection, this.name,
                '\n  in state:', this.state, '\n  version:', this.version,
                '\n  snapshot:\n', this.snapshot, '\n  incoming data:\n', data);
            return;
        }

        this.version = data.v;
        // data.data is what the server will actually send. data.snapshot is the old
        // field name - supported now for backwards compatibility.
        this.snapshot = data.data;
        this._setType(data.type);

        this.state = 'ready';
        this.emit('ready');
    };

// Get and return the current document snapshot.
    Doc.prototype.getSnapshot = function() {
        return this.snapshot;
    };

// The callback will be called at a time when the document has a snapshot and
// you can start applying operations. This may be immediately.
    Doc.prototype.whenReady = function(fn) {
        if (this.state === 'ready') {
            fn();
        } else {
            this.once('ready', fn);
        }
    };

    Doc.prototype.hasPending = function() {
        return this.action != null || this.inflightData != null || !!this.pendingData.length;
    };

    Doc.prototype._emitNothingPending = function() {
        if (this.hasPending()) return;
        this.emit('nothing pending');
    };


// **** Helpers for network messages

// This function exists so connection can call it directly for bulk subscribes.
// It could just make a temporary object literal, thats pretty slow.
    Doc.prototype._handleSubscribe = function(err, data) {
        if (err && err !== 'Already subscribed') {
            console.error('Could not subscribe:', err, this.collection, this.name);
            this.emit('error', err);
            // There's probably a reason we couldn't subscribe. Don't retry.
            this._setWantSubscribe(false, null, err);
            return;
        }
        if (data) this.ingestData(data);
        this.subscribed = true;
        this._clearAction();
        this.emit('subscribe');
        this._finishSub();
    };

// This is called by the connection when it receives a message for the document.
    Doc.prototype._onMessage = function(msg) {
        if (!(msg.c === this.collection && msg.d === this.name)) {
            // This should never happen - its a sanity check for bugs in the connection code.
            var err = 'Got message for wrong document.';
            console.error(err, this.collection, this.name, msg);
            throw new Error(err);
        }

        // msg.a = the action.
        switch (msg.a) {
            case 'fetch':
                // We're done fetching. This message has no other information.
                if (msg.data) this.ingestData(msg.data);
                if (this.wantSubscribe === 'fetch') this.wantSubscribe = false;
                this._clearAction();
                this._finishSub(msg.error);
                break;

            case 'sub':
                // Subscribe reply.
                this._handleSubscribe(msg.error, msg.data);
                break;

            case 'unsub':
                // Unsubscribe reply
                this.subscribed = false;
                this.emit('unsubscribe');

                this._clearAction();
                this._finishSub(msg.error);
                break;

            case 'ack':
                // Acknowledge a locally submitted operation.
                //
                // Usually we do nothing here - all the interesting logic happens when we
                // get sent our op back in the op stream (which happens even if we aren't
                // subscribed)
                if (msg.error && msg.error !== 'Op already submitted') {
                    // The server has rejected an op from the client for an unexpected reason.
                    // We'll send the error message to the user and try to roll back the change.
                    if (this.inflightData) {
                        console.warn('Operation was rejected (' + msg.error + '). Trying to rollback change locally.');
                        this._tryRollback(this.inflightData);
                        this._clearInflightOp(msg.error);
                    } else {
                        // I managed to get into this state once. I'm not sure how it happened.
                        // The op was maybe double-acknowledged?
                        console.warn('Second acknowledgement message (error) received', msg, this);
                    }
                }
                break;

            case 'op':
                if (this.inflightData &&
                    msg.src === this.inflightData.src &&
                    msg.seq === this.inflightData.seq) {
                    // This one is mine. Accept it as acknowledged.
                    this._opAcknowledged(msg);
                    break;
                }

                if (this.version == null || msg.v > this.version) {
                    // This will happen in normal operation if we become subscribed to a
                    // new document via a query. It can also happen if we get an op for
                    // a future version beyond the version we are expecting next. This
                    // could happen if the server doesn't publish an op for whatever reason
                    // or because of a race condition. In any case, we can send a fetch
                    // command to catch back up.
                    this._getLatestOps();
                    break;
                }

                if (msg.v < this.version) {
                    // This will happen naturally in the following (or similar) cases:
                    //
                    // Client is not subscribed to document.
                    // -> client submits an operation (v=10)
                    // -> client subscribes to a query which matches this document. Says we
                    //    have v=10 of the doc.
                    //
                    // <- server acknowledges the operation (v=11). Server acknowledges the
                    //    operation because the doc isn't subscribed
                    // <- server processes the query, which says the client only has v=10.
                    //    Server subscribes at v=10 not v=11, so we get another copy of the
                    //    v=10 operation.
                    //
                    // In this case, we can safely ignore the old (duplicate) operation.
                    break;
                }

                if (this.inflightData) xf(this.inflightData, msg);

                for (var i = 0; i < this.pendingData.length; i++) {
                    xf(this.pendingData[i], msg);
                }

                this.version++;
                this._otApply(msg, false);
                break;

            case 'meta':
                console.warn('Unhandled meta op:', msg);
                break;

            default:
                console.warn('Unhandled document message:', msg);
                break;
        }
    };

    Doc.prototype._getLatestOps = function() {
        var doc = this;
        var debounced = false;
        if (doc._getLatestTimeout) {
            debounced = true;
        } else {
            // Send a fetch command, which will get us the missing ops to catch back up
            // or the full doc if our version is currently null
            doc.connection.sendFetch(doc, doc.version);
        }
        // Debounce calls, since we are likely to get multiple future operations
        // in a rapid sequence
        clearTimeout(doc._getLatestTimeout);
        doc._getLatestTimeout = setTimeout(function() {
            doc._getLatestTimeout = null;
            // Send another fetch at the end of the final timeout interval if we were
            // debounced to make sure we didn't miss anything
            if (debounced) {
                doc.connection.sendFetch(doc, doc.version);
            }
        }, 5000);
        return;
    };

// Called whenever (you guessed it!) the connection state changes. This will
// happen when we get disconnected & reconnect.
    Doc.prototype._onConnectionStateChanged = function() {
        if (this.connection.canSend) {
            this.flush();
        } else {
            this.subscribed = false;
            this._clearAction();
        }
    };

    Doc.prototype._clearAction = function() {
        this.action = null;
        this.flush();
        this._emitNothingPending();
    };

// Send the next pending op to the server, if we can.
//
// Only one operation can be in-flight at a time. If an operation is already on
// its way, or we're not currently connected, this method does nothing.
    Doc.prototype.flush = function() {
        // Ignore if we can't send or we are already sending an op
        if (!this.connection.canSend || this.inflightData) return;

        // Pump and dump any no-ops from the front of the pending op list.
        var opData;
        while (this.pendingData.length && isNoOp(opData = this.pendingData[0])) {
            var callbacks = opData.callbacks;
            for (var i = 0; i < callbacks.length; i++) {
                callbacks[i](opData.error);
            }
            this.pendingData.shift();
        }

        // Send first pending op unless paused
        if (!this.paused && this.pendingData.length) {
            this._sendOpData();
            return;
        }

        // Ignore if an action is already in process
        if (this.action) return;
        // Once all ops are sent, perform subscriptions and fetches
        var version = (this.state === 'ready') ? this.version : null;

        if (this.subscribed && !this.wantSubscribe) {
            this.action = 'unsubscribe';
            this.connection.sendUnsubscribe(this);

        } else if (!this.subscribed && this.wantSubscribe === 'fetch') {
            this.action = 'fetch';
            this.connection.sendFetch(this, version);

        } else if (!this.subscribed && this.wantSubscribe) {
            this.action = 'subscribe';
            this.connection.sendSubscribe(this, version);
        }
    };


// ****** Subscribing, unsubscribing and fetching

// Value is true, false or 'fetch'.
    Doc.prototype._setWantSubscribe = function(value, callback, err) {
        if (this.subscribed === this.wantSubscribe &&
            (this.subscribed === value || value === 'fetch' && this.subscribed)) {
            if (callback) callback(err);
            return;
        }

        // If we want to subscribe, don't weaken it to a fetch.
        if (value !== 'fetch' || this.wantSubscribe !== true) {
            this.wantSubscribe = value;
        }

        if (callback) this._subscribeCallbacks.push(callback);
        this.flush();
    };

// Open the document. There is no callback and no error handling if you're
// already connected.
//
// Only call this once per document.
    Doc.prototype.subscribe = function(callback) {
        this._setWantSubscribe(true, callback);
    };

// Unsubscribe. The data will stay around in local memory, but we'll stop
// receiving updates.
    Doc.prototype.unsubscribe = function(callback) {
        this._setWantSubscribe(false, callback);
    };

// Call to request fresh data from the server.
    Doc.prototype.fetch = function(callback) {
        this._setWantSubscribe('fetch', callback);
    };

// Called when our subscribe, fetch or unsubscribe messages are acknowledged.
    Doc.prototype._finishSub = function(err) {
        if (!this._subscribeCallbacks.length) return;
        for (var i = 0; i < this._subscribeCallbacks.length; i++) {
            this._subscribeCallbacks[i](err);
        }
        this._subscribeCallbacks.length = 0;
    };


// Operations


// ************ Dealing with operations.

// Helper function to set opData to contain a no-op.
    var setNoOp = function(opData) {
        delete opData.op;
        delete opData.create;
        delete opData.del;
    };

    var isNoOp = function(opData) {
        return !opData.op && !opData.create && !opData.del;
    }

// Try to compose data2 into data1. Returns truthy if it succeeds, otherwise falsy.
    var tryCompose = function(type, data1, data2) {
        if (data1.create && data2.del) {
            setNoOp(data1);
        } else if (data1.create && data2.op) {
            // Compose the data into the create data.
            var data = (data1.create.data === undefined) ? type.create() : data1.create.data;
            data1.create.data = type.apply(data, data2.op);
        } else if (isNoOp(data1)) {
            data1.create = data2.create;
            data1.del = data2.del;
            data1.op = data2.op;
        } else if (data1.op && data2.op && type.compose) {
            data1.op = type.compose(data1.op, data2.op);
        } else {
            return false;
        }
        return true;
    };

// Transform server op data by a client op, and vice versa. Ops are edited in place.
    var xf = function(client, server) {
        // In this case, we're in for some fun. There are some local operations
        // which are totally invalid - either the client continued editing a
        // document that someone else deleted or a document was created both on the
        // client and on the server. In either case, the local document is way
        // invalid and the client's ops are useless.
        //
        // The client becomes a no-op, and we keep the server op entirely.
        if (server.create || server.del) return setNoOp(client);
        if (client.create) throw new Error('Invalid state. This is a bug. ' + this.collection + ' ' + this.name);

        // The client has deleted the document while the server edited it. Kill the
        // server's op.
        if (client.del) return setNoOp(server);

        // We only get here if either the server or client ops are no-op. Carry on,
        // nothing to see here.
        if (!server.op || !client.op) return;

        // They both edited the document. This is the normal case for this function -
        // as in, most of the time we'll end up down here.
        //
        // You should be wondering why I'm using client.type instead of this.type.
        // The reason is, if we get ops at an old version of the document, this.type
        // might be undefined or a totally different type. By pinning the type to the
        // op data, we make sure the right type has its transform function called.
        if (client.type.transformX) {
            var result = client.type.transformX(client.op, server.op);
            client.op = result[0];
            server.op = result[1];
        } else {
            var _c = client.type.transform(client.op, server.op, 'left');
            var _s = client.type.transform(server.op, client.op, 'right');
            client.op = _c; server.op = _s;
        }
    };

    /**
     * Applies the operation to the snapshot
     *
     * If the operation is create or delete it emits `create` or `del`.  Then the
     * operation is applied to the snapshot and `op` and `after op` are emitted.  If
     * the type supports incremental updates and `this.incremental` is true we fire
     * `op` after every small operation.
     *
     * This is the only function to fire the above mentioned events.
     *
     * @private
     */
    Doc.prototype._otApply = function(opData, context) {
        this.locked = true;

        if (opData.create) {
            // If the type is currently set, it means we tried creating the document
            // and someone else won. client create x server create = server create.
            var create = opData.create;
            this._setType(create.type);
            this.snapshot = this.type.create(create.data);

            // This is a bit heavyweight, but I want the created event to fire outside of the lock.
            this.once('unlock', function() {
                this.emit('create', context);
            });
        } else if (opData.del) {
            // The type should always exist in this case. del x _ = del
            var oldSnapshot = this.snapshot;
            this._setType(null);
            this.once('unlock', function() {
                this.emit('del', context, oldSnapshot);
            });
        } else if (opData.op) {
            if (!this.type) throw new Error('Document does not exist. ' + this.collection + ' ' + this.name);

            var type = this.type;

            var op = opData.op;

            // The context needs to be told we're about to edit, just in case it needs
            // to store any extra data. (text-tp2 has this constraint.)
            for (var i = 0; i < this.editingContexts.length; i++) {
                var c = this.editingContexts[i];
                if (c != context && c._beforeOp) c._beforeOp(opData.op);
            }

            this.emit('before op', op, context);

            // This exists so clients can pull any necessary data out of the snapshot
            // before it gets changed.  Previously we kept the old snapshot object and
            // passed it to the op event handler. However, apply no longer guarantees
            // the old object is still valid.
            //
            // Because this could be totally unnecessary work, its behind a flag. set
            // doc.incremental to enable.
            if (this.incremental && type.incrementalApply) {
                var _this = this;
                type.incrementalApply(this.snapshot, op, function(o, snapshot) {
                    _this.snapshot = snapshot;
                    _this.emit('op', o, context);
                });
            } else {
                // This is the most common case, simply applying the operation to the local snapshot.
                this.snapshot = type.apply(this.snapshot, op);
                this.emit('op', op, context);
            }
        }
        // Its possible for none of the above cases to match, in which case the op is
        // a no-op. This will happen when a document has been deleted locally and
        // remote ops edit the document.


        this.locked = false;
        this.emit('unlock');

        if (opData.op) {
            var contexts = this.editingContexts;
            // Notify all the contexts about the op (well, all the contexts except
            // the one which initiated the submit in the first place).
            // NOTE Handle this with events?
            for (var i = 0; i < contexts.length; i++) {
                var c = contexts[i];
                if (c != context && c._onOp) c._onOp(opData.op);
            }
            for (var i = 0; i < contexts.length; i++) {
                if (contexts[i].shouldBeRemoved) contexts.splice(i--, 1);
            }

            return this.emit('after op', opData.op, context);
        }
    };



// ***** Sending operations

    Doc.prototype.retry = function() {
        if (!this.inflightData) return;
        var threshold = 5000 * Math.pow(2, this.inflightData.retries);
        if (this.inflightData.sentAt < Date.now() - threshold) {
            this.connection.emit('retry', this);
            this._sendOpData();
        }
    };

// Actually send op data to the server.
    Doc.prototype._sendOpData = function() {
        // Wait until we have a src id from the server
        var src = this.connection.id;
        if (!src) return;

        // When there is no inflightData, send the first item in pendingData. If
        // there is inflightData, try sending it again
        if (!this.inflightData) {
            // Send first pending op
            this.inflightData = this.pendingData.shift();
        }
        var data = this.inflightData;
        if (!data) {
            throw new Error('no data to send on call to _sendOpData');
        }

        // Track data for retrying ops
        data.sentAt = Date.now();
        data.retries = (data.retries == null) ? 0 : data.retries + 1;

        // The src + seq number is a unique ID representing this operation. This tuple
        // is used on the server to detect when ops have been sent multiple times and
        // on the client to match acknowledgement of an op back to the inflightData.
        // Note that the src could be different from this.connection.id after a
        // reconnect, since an op may still be pending after the reconnection and
        // this.connection.id will change. In case an op is sent multiple times, we
        // also need to be careful not to override the original seq value.
        if (data.seq == null) data.seq = this.connection.seq++;

        this.connection.sendOp(this, data);

        // src isn't needed on the first try, since the server session will have the
        // same id, but it must be set on the inflightData in case it is sent again
        // after a reconnect and the connection's id has changed by then
        if (data.src == null) data.src = src;
    };


// Queues the operation for submission to the server and applies it locally.
//
// Internal method called to do the actual work for submitOp(), create() and del().
// @private
//
// @param opData
// @param [opData.op]
// @param [opData.del]
// @param [opData.create]
// @param [context] the editing context
// @param [callback] called when operation is submitted
    Doc.prototype._submitOpData = function(opData, context, callback) {
        if (typeof context === 'function') {
            callback = context;
            context = true; // The default context is true.
        }
        if (context == null) context = true;

        if (this.locked) {
            var err = "Cannot call submitOp from inside an 'op' event handler. " + this.collection + ' ' + this.name;
            if (callback) return callback(err);
            throw new Error(err);
        }

        // The opData contains either op, create, delete, or none of the above (a no-op).
        if (opData.op) {
            if (!this.type) {
                var err = 'Document has not been created';
                if (callback) return callback(err);
                throw new Error(err);
            }
            // Try to normalize the op. This removes trailing skip:0's and things like that.
            if (this.type.normalize) opData.op = this.type.normalize(opData.op);
        }

        if (!this.state) {
            this.state = 'floating';
        }

        opData.type = this.type;
        opData.callbacks = [];

        // If the type supports composes, try to compose the operation onto the end
        // of the last pending operation.
        var operation;
        var previous = this.pendingData[this.pendingData.length - 1];

        if (previous && tryCompose(this.type, previous, opData)) {
            operation = previous;
        } else {
            operation = opData;
            this.pendingData.push(opData);
        }
        if (callback) operation.callbacks.push(callback);

        this._otApply(opData, context);

        // The call to flush is in a timeout so if submitOp() is called multiple
        // times in a closure all the ops are combined before being sent to the
        // server. It doesn't matter if flush is called a bunch of times.
        var _this = this;
        setTimeout((function() { _this.flush(); }), 0);
    };


// *** Client OT entrypoints.

// Submit an operation to the document.
//
// @param operation handled by the OT type
// @param [context] editing context
// @param [callback] called after operation submitted
//
// @fires before op, op, after op
    Doc.prototype.submitOp = function(op, context, callback) {
        this._submitOpData({op: op}, context, callback);
    };

// Create the document, which in ShareJS semantics means to set its type. Every
// object implicitly exists in the database but has no data and no type. Create
// sets the type of the object and can optionally set some initial data on the
// object, depending on the type.
//
// @param type  OT type
// @param data  initial
// @param context  editing context
// @param callback  called when operation submitted
    Doc.prototype.create = function(type, data, context, callback) {
        if (typeof data === 'function') {
            // Setting the context to be the callback function in this case so _submitOpData
            // can handle the default value thing.
            context = data;
            data = undefined;
        }

        if (this.type) {
            var err = 'Document already exists';
            if (callback) return callback(err);
            throw new Error(err);
        }

        var op = {create: {type:type, data:data}};
        this._submitOpData(op, context, callback);
    };

// Delete the document. This creates and submits a delete operation to the
// server. Deleting resets the object's type to null and deletes its data. The
// document still exists, and still has the version it used to have before you
// deleted it (well, old version +1).
//
// @param context   editing context
// @param callback  called when operation submitted
    Doc.prototype.del = function(context, callback) {
        if (!this.type) {
            var err = 'Document does not exist';
            if (callback) return callback(err);
            throw new Error(err);
        }

        this._submitOpData({del: true}, context, callback);
    };


// Stops the document from sending any operations to the server.
    Doc.prototype.pause = function() {
        this.paused = true;
    };

// Continue sending operations to the server
    Doc.prototype.resume = function() {
        this.paused = false;
        this.flush();
    };


// *** Receiving operations


// This will be called when the server rejects our operations for some reason.
// There's not much we can do here if the OT type is noninvertable, but that
// shouldn't happen too much in real life because readonly documents should be
// flagged as such. (I should probably figure out a flag for that).
//
// This does NOT get called if our op fails to reach the server for some reason
// - we optimistically assume it'll make it there eventually.
    Doc.prototype._tryRollback = function(opData) {
        // This is probably horribly broken.
        if (opData.create) {
            this._setType(null);

            // I don't think its possible to get here if we aren't in a floating state.
            if (this.state === 'floating')
                this.state = null;
            else
                console.warn('Rollback a create from state ' + this.state);

        } else if (opData.op && opData.type.invert) {
            opData.op = opData.type.invert(opData.op);

            // Transform the undo operation by any pending ops.
            for (var i = 0; i < this.pendingData.length; i++) {
                xf(this.pendingData[i], opData);
            }

            // ... and apply it locally, reverting the changes.
            //
            // This operation is applied to look like it comes from a remote context.
            // I'm still not 100% sure about this functionality, because its really a
            // local op. Basically, the problem is that if the client's op is rejected
            // by the server, the editor window should update to reflect the undo.
            this._otApply(opData, false);
        } else if (opData.op || opData.del) {
            // This is where an undo stack would come in handy.
            this._setType(null);
            this.version = null;
            this.state = null;
            this.subscribed = false;
            this.emit('error', "Op apply failed and the operation could not be reverted");

            // Trigger a fetch. In our invalid state, we can't really do anything.
            this.fetch();
            this.flush();
        }
    };

    Doc.prototype._clearInflightOp = function(error) {
        var callbacks = this.inflightData.callbacks;
        for (var i = 0; i < callbacks.length; i++) {
            callbacks[i](error || this.inflightData.error);
        }

        this.inflightData = null;
        this.flush();
        this._emitNothingPending();
    };

// This is called when the server acknowledges an operation from the client.
    Doc.prototype._opAcknowledged = function(msg) {
        // Our inflight op has been acknowledged, so we can throw away the inflight data.
        // (We were only holding on to it incase we needed to resend the op.)
        if (!this.state) {
            throw new Error('opAcknowledged called from a null state. This should never happen. ' + this.collection + ' ' + this.name);
        } else if (this.state === 'floating') {
            if (!this.inflightData.create) throw new Error('Cannot acknowledge an op. ' + this.collection + ' ' + this.name);

            // Our create has been acknowledged. This is the same as ingesting some data.
            this.version = msg.v;
            this.state = 'ready';
            var _this = this;
            setTimeout(function() { _this.emit('ready'); }, 0);
        } else {
            // We already have a snapshot. The snapshot should be at the acknowledged
            // version, because the server has sent us all the ops that have happened
            // before acknowledging our op.

            // This should never happen - something is out of order.
            if (msg.v !== this.version) {
                // by vaios
                // instead of throwing exception here just get the latest ops
                // from the server, which should allow us to continue as normal
                // This error can happen when multiple clients edit the document
                // and when they re-connect they expect their last inflight op to have
                // a specific version but this might have a different client id (src field)
                // in the server depending on the order that inflight ops arrived there before disconnection.
                // The server will try to transform those ops and in doing so it will change the op version
                // thus causing this error... This seems to be handled the same way in the latest sharedb
                console.warn('Invalid version from server. This can happen when you submit ops in a submitOp callback. Expected: ' + this.version + ' Message version: ' + msg.v + ' ' + this.collection + ' ' + this.name);
                return this._getLatestOps();
            }
        }

        // The op was committed successfully. Increment the version number
        this.version++;

        this._clearInflightOp();
    };


// Creates an editing context
//
// The context is an object responding to getSnapshot(), submitOp() and
// destroy(). It also has all the methods from the OT type mixed in.
// If the document is destroyed, the detach() method is called on the context.
    Doc.prototype.createContext = function() {
        var type = this.type;
        if (!type) throw new Error('Missing type ' + this.collection + ' ' + this.name);

        // I could use the prototype chain to do this instead, but Object.create
        // isn't defined on old browsers. This will be fine.
        var doc = this;
        var context = {
            getSnapshot: function() {
                return doc.snapshot;
            },
            submitOp: function(op, callback) {
                doc.submitOp(op, context, callback);
            },
            destroy: function() {
                if (this.detach) {
                    this.detach();
                    // Don't double-detach.
                    delete this.detach;
                }
                // It will be removed from the actual editingContexts list next time
                // we receive an op on the document (and the list is iterated through).
                //
                // This is potentially dodgy, allowing a memory leak if you create &
                // destroy a whole bunch of contexts without receiving or sending any ops
                // to the document.
                //
                // NOTE Why can't we destroy contexts immediately?
                delete this._onOp;
                this.shouldBeRemoved = true;
            },

            // This is dangerous, but really really useful for debugging. I hope people
            // don't depend on it.
            _doc: this,
        };

        if (type.api) {
            // Copy everything else from the type's API into the editing context.
            for (var k in type.api) {
                context[k] = type.api[k];
            }
        } else {
            context.provides = {};
        }

        this.editingContexts.push(context);

        return context;
    };


    /**
     * Destroy all editing contexts
     */
    Doc.prototype.removeContexts = function() {
        for (var i = 0; i < this.editingContexts.length; i++) {
            this.editingContexts[i].destroy();
        }
        this.editingContexts.length = 0;
    };

},{"../types":7,"./emitter":3}],3:[function(require,module,exports){
    var EventEmitter = require('events').EventEmitter;

    exports.EventEmitter = EventEmitter;
    exports.mixin = mixin;

    function mixin(Constructor) {
        for (var key in EventEmitter.prototype) {
            Constructor.prototype[key] = EventEmitter.prototype[key];
        }
    }

},{"events":10}],4:[function(require,module,exports){
// Entry point for the client
//
// Usage:
//
//    <script src="dist/share.js"></script>

    exports.Connection = require('./connection').Connection;
    exports.Doc = require('./doc').Doc;
    require('./textarea');

    var types = require('../types');
    exports.ottypes = types.ottypes;
    exports.registerType = types.registerType;

},{"../types":7,"./connection":1,"./doc":2,"./textarea":6}],5:[function(require,module,exports){
    var emitter = require('./emitter');

// Queries are live requests to the database for particular sets of fields.
//
// The server actively tells the client when there's new data that matches
// a set of conditions.
    var Query = exports.Query = function(type, connection, id, collection, query, options, callback) {
        emitter.EventEmitter.call(this);

        // 'fetch' or 'sub'
        this.type = type;

        this.connection = connection;
        this.id = id;
        this.collection = collection;

        // The query itself. For mongo, this should look something like {"data.x":5}
        this.query = query;

        // Resultant document action for the server. Fetch mode will automatically
        // fetch all results. Subscribe mode will automatically subscribe all
        // results. Results are never unsubscribed.
        this.docMode = options.docMode; // undefined, 'fetch' or 'sub'.
        if (this.docMode === 'subscribe') this.docMode = 'sub';

        // Do we repoll the entire query whenever anything changes? (As opposed to
        // just polling the changed item). This needs to be enabled to be able to use
        // ordered queries (sortby:) and paginated queries. Set to undefined, it will
        // be enabled / disabled automatically based on the query's properties.
        this.poll = options.poll;

        // The backend we actually hit. If this isn't defined, it hits the snapshot
        // database. Otherwise this can be used to hit another configured query
        // index.
        this.backend = options.backend || options.source;

        // A list of resulting documents. These are actual documents, complete with
        // data and all the rest. If fetch is false, these documents will not
        // have any data. You should manually call fetch() or subscribe() on them.
        //
        // Calling subscribe() might be a good idea anyway, as you won't be
        // subscribed to the documents by default.
        this.knownDocs = options.knownDocs || [];
        this.results = [];

        // Do we have some initial data?
        this.ready = false;

        this.callback = callback;
    };
    emitter.mixin(Query);

    Query.prototype.action = 'qsub';

// Helper for subscribe & fetch, since they share the same message format.
//
// This function actually issues the query.
    Query.prototype._execute = function() {
        if (!this.connection.canSend) return;

        if (this.docMode) {
            var collectionVersions = {};
            // Collect the version of all the documents in the current result set so we
            // don't need to be sent their snapshots again.
            for (var i = 0; i < this.knownDocs.length; i++) {
                var doc = this.knownDocs[i];
                if (doc.version == null) continue;
                var c = collectionVersions[doc.collection] =
                    (collectionVersions[doc.collection] || {});
                c[doc.name] = doc.version;
            }
        }

        var msg = {
            a: 'q' + this.type,
            id: this.id,
            c: this.collection,
            o: {},
            q: this.query,
        };

        if (this.docMode) {
            msg.o.m = this.docMode;
            // This should be omitted if empty, but whatever.
            msg.o.vs = collectionVersions;
        }
        if (this.backend != null) msg.o.b = this.backend;
        if (this.poll !== undefined) msg.o.p = this.poll;

        this.connection.send(msg);
    };

// Make a list of documents from the list of server-returned data objects
    Query.prototype._dataToDocs = function(data) {
        var results = [];
        var lastType;
        for (var i = 0; i < data.length; i++) {
            var docData = data[i];

            // Types are only put in for the first result in the set and every time the type changes in the list.
            if (docData.type) {
                lastType = docData.type;
            } else {
                docData.type = lastType;
            }

            // This will ultimately call doc.ingestData(), which is what populates
            // the doc snapshot and version with the data returned by the query
            var doc = this.connection.get(docData.c || this.collection, docData.d, docData);
            results.push(doc);
        }
        return results;
    };

// Destroy the query object. Any subsequent messages for the query will be
// ignored by the connection. You should unsubscribe from the query before
// destroying it.
    Query.prototype.destroy = function() {
        if (this.connection.canSend && this.type === 'sub') {
            this.connection.send({a:'qunsub', id:this.id});
        }

        this.connection._destroyQuery(this);
    };

    Query.prototype._onConnectionStateChanged = function(state, reason) {
        if (this.connection.state === 'connecting') {
            this._execute();
        }
    };

// Internal method called from connection to pass server messages to the query.
    Query.prototype._onMessage = function(msg) {
        if ((msg.a === 'qfetch') !== (this.type === 'fetch')) {
            console.warn('Invalid message sent to query', msg, this);
            return;
        }

        if (msg.error) this.emit('error', msg.error);

        switch (msg.a) {
            case 'qfetch':
                var results = msg.data ? this._dataToDocs(msg.data) : undefined;
                if (this.callback) this.callback(msg.error, results, msg.extra);
                // Once a fetch query gets its data, it is destroyed.
                this.connection._destroyQuery(this);
                break;

            case 'q':
                // Query diff data (inserts and removes)
                if (msg.diff) {
                    // We need to go through the list twice. First, we'll ingest all the
                    // new documents and set them as subscribed.  After that we'll emit
                    // events and actually update our list. This avoids race conditions
                    // around setting documents to be subscribed & unsubscribing documents
                    // in event callbacks.
                    for (var i = 0; i < msg.diff.length; i++) {
                        var d = msg.diff[i];
                        if (d.type === 'insert') d.values = this._dataToDocs(d.values);
                    }

                    for (var i = 0; i < msg.diff.length; i++) {
                        var d = msg.diff[i];
                        switch (d.type) {
                            case 'insert':
                                var newDocs = d.values;
                                Array.prototype.splice.apply(this.results, [d.index, 0].concat(newDocs));
                                this.emit('insert', newDocs, d.index);
                                break;
                            case 'remove':
                                var howMany = d.howMany || 1;
                                var removed = this.results.splice(d.index, howMany);
                                this.emit('remove', removed, d.index);
                                break;
                            case 'move':
                                var howMany = d.howMany || 1;
                                var docs = this.results.splice(d.from, howMany);
                                Array.prototype.splice.apply(this.results, [d.to, 0].concat(docs));
                                this.emit('move', docs, d.from, d.to);
                                break;
                        }
                    }
                }

                if (msg.extra !== void 0) {
                    this.emit('extra', msg.extra);
                }
                break;
            case 'qsub':
                // This message replaces the entire result set with the set passed.
                if (!msg.error) {
                    var previous = this.results;

                    // Then add everything in the new result set.
                    this.results = this.knownDocs = this._dataToDocs(msg.data);
                    this.extra = msg.extra;

                    this.ready = true;
                    this.emit('change', this.results, previous);
                }
                if (this.callback) {
                    this.callback(msg.error, this.results, this.extra);
                    delete this.callback;
                }
                break;
        }
    };

// Change the thing we're searching for. This isn't fully supported on the
// backend (it destroys the old query and makes a new one) - but its
// programatically useful and I might add backend support at some point.
    Query.prototype.setQuery = function(q) {
        if (this.type !== 'sub') throw new Error('cannot change a fetch query');

        this.query = q;
        if (this.connection.canSend) {
            // There's no 'change' message to send to the server. Just resubscribe.
            this.connection.send({a:'qunsub', id:this.id});
            this._execute();
        }
    };

},{"./emitter":3}],6:[function(require,module,exports){
    /* This contains the textarea binding for ShareJS. This binding is really
 * simple, and a bit slow on big documents (Its O(N). However, it requires no
 * changes to the DOM and no heavy libraries like ace. It works for any kind of
 * text input field.
 *
 * You probably want to use this binding for small fields on forms and such.
 * For code editors or rich text editors or whatever, I recommend something
 * heavier.
 */

    var Doc = require('./doc').Doc;

    /* applyChange creates the edits to convert oldval -> newval.
 *
 * This function should be called every time the text element is changed.
 * Because changes are always localised, the diffing is quite easy. We simply
 * scan in from the start and scan in from the end to isolate the edited range,
 * then delete everything that was removed & add everything that was added.
 * This wouldn't work for complex changes, but this function should be called
 * on keystroke - so the edits will mostly just be single character changes.
 * Sometimes they'll paste text over other text, but even then the diff
 * generated by this algorithm is correct.
 *
 * This algorithm is O(N). I suspect you could speed it up somehow using regular expressions.
 */
    var applyChange = function(ctx, oldval, newval) {
        // Strings are immutable and have reference equality. I think this test is O(1), so its worth doing.
        if (oldval === newval) return;

        var commonStart = 0;
        while (oldval.charAt(commonStart) === newval.charAt(commonStart)) {
            commonStart++;
        }

        var commonEnd = 0;
        while (oldval.charAt(oldval.length - 1 - commonEnd) === newval.charAt(newval.length - 1 - commonEnd) &&
        commonEnd + commonStart < oldval.length && commonEnd + commonStart < newval.length) {
            commonEnd++;
        }

        if (oldval.length !== commonStart + commonEnd) {
            ctx.remove(commonStart, oldval.length - commonStart - commonEnd);
        }
        if (newval.length !== commonStart + commonEnd) {
            ctx.insert(commonStart, newval.slice(commonStart, newval.length - commonEnd));
        }
    };

// Attach a textarea to a document's editing context.
//
// The context is optional, and will be created from the document if its not
// specified.
    Doc.prototype.attachTextarea = function(elem, ctx) {
        if (!ctx) ctx = this.createContext();

        if (!ctx.provides.text) throw new Error('Cannot attach to non-text document');

        elem.value = ctx.get();

        // The current value of the element's text is stored so we can quickly check
        // if its been changed in the event handlers. This is mostly for browsers on
        // windows, where the content contains \r\n newlines. applyChange() is only
        // called after the \r\n newlines are converted, and that check is quite
        // slow. So we also cache the string before conversion so we can do a quick
        // check incase the conversion isn't needed.
        var prevvalue;

        // Replace the content of the text area with newText, and transform the
        // current cursor by the specified function.
        var replaceText = function(newText, transformCursor) {
            if (transformCursor) {
                var newSelection = [transformCursor(elem.selectionStart), transformCursor(elem.selectionEnd)];
            }

            // Fixate the window's scroll while we set the element's value. Otherwise
            // the browser scrolls to the element.
            var scrollTop = elem.scrollTop;
            elem.value = newText;
            prevvalue = elem.value; // Not done on one line so the browser can do newline conversion.
            if (elem.scrollTop !== scrollTop) elem.scrollTop = scrollTop;

            // Setting the selection moves the cursor. We'll just have to let your
            // cursor drift if the element isn't active, though usually users don't
            // care.
            if (newSelection && window.document.activeElement === elem) {
                elem.selectionStart = newSelection[0];
                elem.selectionEnd = newSelection[1];
            }
        };

        replaceText(ctx.get());


        // *** remote -> local changes

        ctx.onInsert = function(pos, text) {
            var transformCursor = function(cursor) {
                return pos < cursor ? cursor + text.length : cursor;
            };

            // Remove any window-style newline characters. Windows inserts these, and
            // they mess up the generated diff.
            var prev = elem.value.replace(/\r\n/g, '\n');
            replaceText(prev.slice(0, pos) + text + prev.slice(pos), transformCursor);
        };

        ctx.onRemove = function(pos, length) {
            var transformCursor = function(cursor) {
                // If the cursor is inside the deleted region, we only want to move back to the start
                // of the region. Hence the Math.min.
                return pos < cursor ? cursor - Math.min(length, cursor - pos) : cursor;
            };

            var prev = elem.value.replace(/\r\n/g, '\n');
            replaceText(prev.slice(0, pos) + prev.slice(pos + length), transformCursor);
        };


        // *** local -> remote changes

        // This function generates operations from the changed content in the textarea.
        var genOp = function(event) {
            // In a timeout so the browser has time to propogate the event's changes to the DOM.
            setTimeout(function() {
                if (elem.value !== prevvalue) {
                    prevvalue = elem.value;
                    applyChange(ctx, ctx.get(), elem.value.replace(/\r\n/g, '\n'));
                }
            }, 0);
        };

        var eventNames = ['textInput', 'keydown', 'keyup', 'select', 'cut', 'paste'];
        for (var i = 0; i < eventNames.length; i++) {
            var e = eventNames[i];
            if (elem.addEventListener) {
                elem.addEventListener(e, genOp, false);
            } else {
                elem.attachEvent('on' + e, genOp);
            }
        }

        ctx.detach = function() {
            for (var i = 0; i < eventNames.length; i++) {
                var e = eventNames[i];
                if (elem.removeEventListener) {
                    elem.removeEventListener(e, genOp, false);
                } else {
                    elem.detachEvent('on' + e, genOp);
                }
            }
        };

        return ctx;
    };

},{"./doc":2}],7:[function(require,module,exports){

    exports.ottypes = {};
    exports.registerType = function(type) {
        if (type.name) exports.ottypes[type.name] = type;
        if (type.uri) exports.ottypes[type.uri] = type;
    };

    exports.registerType(require('ot-json0').type);
    exports.registerType(require('ot-text').type);
    exports.registerType(require('ot-text-tp2').type);

// The types register themselves on their respective types.
    require('./text-api');
    require('./text-tp2-api');

// The JSON API is buggy!! Please submit a pull request fixing it if you want to use it.
//require('./json-api');

},{"./text-api":8,"./text-tp2-api":9,"ot-json0":12,"ot-text":18,"ot-text-tp2":15}],8:[function(require,module,exports){
// Text document API for the 'text' type.

// The API implements the standard text API methods. In particular:
//
// - getLength() returns the length of the document in characters
// - getText() returns a string of the document
// - insert(pos, text, [callback]) inserts text at position pos in the document
// - remove(pos, length, [callback]) removes length characters at position pos
//
// Events are implemented by just adding the appropriate methods to your
// context object.
// onInsert(pos, text): Called when text is inserted.
// onRemove(pos, length): Called when text is removed.

    var type = require('ot-text').type;

    type.api = {
        provides: {text: true},

        // Returns the number of characters in the string
        getLength: function() { return this.getSnapshot().length; },


        // Returns the text content of the document
        get: function() { return this.getSnapshot(); },

        getText: function() {
            console.warn("`getText()` is deprecated; use `get()` instead.");
            return this.get();
        },

        // Insert the specified text at the given position in the document
        insert: function(pos, text, callback) {
            return this.submitOp([pos, text], callback);
        },

        remove: function(pos, length, callback) {
            return this.submitOp([pos, {d:length}], callback);
        },

        // When you use this API, you should implement these two methods
        // in your editing context.
        //onInsert: function(pos, text) {},
        //onRemove: function(pos, removedLength) {},

        _onOp: function(op) {
            var pos = 0;
            var spos = 0;
            for (var i = 0; i < op.length; i++) {
                var component = op[i];
                switch (typeof component) {
                    case 'number':
                        pos += component;
                        spos += component;
                        break;
                    case 'string':
                        if (this.onInsert) this.onInsert(pos, component);
                        pos += component.length;
                        break;
                    case 'object':
                        if (this.onRemove) this.onRemove(pos, component.d);
                        spos += component.d;
                }
            }
        }
    };

},{"ot-text":18}],9:[function(require,module,exports){
// Text document API for text-tp2

    var type = require('ot-text-tp2').type;
    var takeDoc = type._takeDoc;
    var append = type._append;

    var appendSkipChars = function(op, doc, pos, maxlength) {
        while ((maxlength == null || maxlength > 0) && pos.index < doc.data.length) {
            var part = takeDoc(doc, pos, maxlength, true);
            if (maxlength != null && typeof part === 'string') {
                maxlength -= part.length;
            }
            append(op, part.length || part);
        }
    };

    type.api = {
        provides: {text: true},

        // Number of characters in the string
        getLength: function() { return this.getSnapshot().charLength; },

        // Flatten the document into a string
        get: function() {
            var snapshot = this.getSnapshot();
            var strings = [];

            for (var i = 0; i < snapshot.data.length; i++) {
                var elem = snapshot.data[i];
                if (typeof elem == 'string') {
                    strings.push(elem);
                }
            }

            return strings.join('');
        },

        getText: function() {
            console.warn("`getText()` is deprecated; use `get()` instead.");
            return this.get();
        },

        // Insert text at pos
        insert: function(pos, text, callback) {
            if (pos == null) pos = 0;

            var op = [];
            var docPos = {index: 0, offset: 0};
            var snapshot = this.getSnapshot();

            // Skip to the specified position
            appendSkipChars(op, snapshot, docPos, pos);

            // Append the text
            append(op, {i: text});
            appendSkipChars(op, snapshot, docPos);
            this.submitOp(op, callback);
            return op;
        },

        // Remove length of text at pos
        remove: function(pos, len, callback) {
            var op = [];
            var docPos = {index: 0, offset: 0};
            var snapshot = this.getSnapshot();

            // Skip to the position
            appendSkipChars(op, snapshot, docPos, pos);

            while (len > 0) {
                var part = takeDoc(snapshot, docPos, len, true);

                // We only need to delete actual characters. This should also be valid if
                // we deleted all the tombstones in the document here.
                if (typeof part === 'string') {
                    append(op, {d: part.length});
                    len -= part.length;
                } else {
                    append(op, part);
                }
            }

            appendSkipChars(op, snapshot, docPos);
            this.submitOp(op, callback);
            return op;
        },

        _beforeOp: function() {
            // Its a shame we need this. This also currently relies on snapshots being
            // cloned during apply(). This is used in _onOp below to figure out what
            // text was _actually_ inserted and removed.
            //
            // Maybe instead we should do all the _onOp logic here and store the result
            // then play the events when _onOp is actually called or something.
            this.__prevSnapshot = this.getSnapshot();
        },

        _onOp: function(op) {
            var textPos = 0;
            var docPos = {index:0, offset:0};
            // The snapshot we get here is the document state _AFTER_ the specified op
            // has been applied. That means any deleted characters are now tombstones.
            var prevSnapshot = this.__prevSnapshot;

            for (var i = 0; i < op.length; i++) {
                var component = op[i];
                var part, remainder;

                if (typeof component == 'number') {
                    // Skip
                    for (remainder = component;
                         remainder > 0;
                         remainder -= part.length || part) {

                        part = takeDoc(prevSnapshot, docPos, remainder);
                        if (typeof part === 'string')
                            textPos += part.length;
                    }
                } else if (component.i != null) {
                    // Insert
                    if (typeof component.i == 'string') {
                        // ... and its an insert of text, not insert of tombstones
                        if (this.onInsert) this.onInsert(textPos, component.i);
                        textPos += component.i.length;
                    }
                } else {
                    // Delete
                    for (remainder = component.d;
                         remainder > 0;
                         remainder -= part.length || part) {

                        part = takeDoc(prevSnapshot, docPos, remainder);
                        if (typeof part == 'string' && this.onRemove)
                            this.onRemove(textPos, part.length);
                    }
                }
            }
        }
    };

},{"ot-text-tp2":15}],10:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

    function EventEmitter() {
        this._events = this._events || {};
        this._maxListeners = this._maxListeners || undefined;
    }
    module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
    EventEmitter.EventEmitter = EventEmitter;

    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
    EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function(n) {
        if (!isNumber(n) || n < 0 || isNaN(n))
            throw TypeError('n must be a positive number');
        this._maxListeners = n;
        return this;
    };

    EventEmitter.prototype.emit = function(type) {
        var er, handler, len, args, i, listeners;

        if (!this._events)
            this._events = {};

        // If there is no 'error' event listener then throw.
        if (type === 'error') {
            if (!this._events.error ||
                (isObject(this._events.error) && !this._events.error.length)) {
                er = arguments[1];
                if (er instanceof Error) {
                    throw er; // Unhandled 'error' event
                }
                throw TypeError('Uncaught, unspecified "error" event.');
            }
        }

        handler = this._events[type];

        if (isUndefined(handler))
            return false;

        if (isFunction(handler)) {
            switch (arguments.length) {
                // fast cases
                case 1:
                    handler.call(this);
                    break;
                case 2:
                    handler.call(this, arguments[1]);
                    break;
                case 3:
                    handler.call(this, arguments[1], arguments[2]);
                    break;
                // slower
                default:
                    len = arguments.length;
                    args = new Array(len - 1);
                    for (i = 1; i < len; i++)
                        args[i - 1] = arguments[i];
                    handler.apply(this, args);
            }
        } else if (isObject(handler)) {
            len = arguments.length;
            args = new Array(len - 1);
            for (i = 1; i < len; i++)
                args[i - 1] = arguments[i];

            listeners = handler.slice();
            len = listeners.length;
            for (i = 0; i < len; i++)
                listeners[i].apply(this, args);
        }

        return true;
    };

    EventEmitter.prototype.addListener = function(type, listener) {
        var m;

        if (!isFunction(listener))
            throw TypeError('listener must be a function');

        if (!this._events)
            this._events = {};

        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (this._events.newListener)
            this.emit('newListener', type,
                isFunction(listener.listener) ?
                    listener.listener : listener);

        if (!this._events[type])
        // Optimize the case of one listener. Don't need the extra array object.
            this._events[type] = listener;
        else if (isObject(this._events[type]))
        // If we've already got an array, just append.
            this._events[type].push(listener);
        else
        // Adding the second element, need to change to array.
            this._events[type] = [this._events[type], listener];

        // Check for listener leak
        if (isObject(this._events[type]) && !this._events[type].warned) {
            var m;
            if (!isUndefined(this._maxListeners)) {
                m = this._maxListeners;
            } else {
                m = EventEmitter.defaultMaxListeners;
            }

            if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
                if (typeof console.trace === 'function') {
                    // not supported in IE 10
                    console.trace();
                }
            }
        }

        return this;
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addListener;

    EventEmitter.prototype.once = function(type, listener) {
        if (!isFunction(listener))
            throw TypeError('listener must be a function');

        var fired = false;

        function g() {
            this.removeListener(type, g);

            if (!fired) {
                fired = true;
                listener.apply(this, arguments);
            }
        }

        g.listener = listener;
        this.on(type, g);

        return this;
    };

// emits a 'removeListener' event iff the listener was removed
    EventEmitter.prototype.removeListener = function(type, listener) {
        var list, position, length, i;

        if (!isFunction(listener))
            throw TypeError('listener must be a function');

        if (!this._events || !this._events[type])
            return this;

        list = this._events[type];
        length = list.length;
        position = -1;

        if (list === listener ||
            (isFunction(list.listener) && list.listener === listener)) {
            delete this._events[type];
            if (this._events.removeListener)
                this.emit('removeListener', type, listener);

        } else if (isObject(list)) {
            for (i = length; i-- > 0;) {
                if (list[i] === listener ||
                    (list[i].listener && list[i].listener === listener)) {
                    position = i;
                    break;
                }
            }

            if (position < 0)
                return this;

            if (list.length === 1) {
                list.length = 0;
                delete this._events[type];
            } else {
                list.splice(position, 1);
            }

            if (this._events.removeListener)
                this.emit('removeListener', type, listener);
        }

        return this;
    };

    EventEmitter.prototype.removeAllListeners = function(type) {
        var key, listeners;

        if (!this._events)
            return this;

        // not listening for removeListener, no need to emit
        if (!this._events.removeListener) {
            if (arguments.length === 0)
                this._events = {};
            else if (this._events[type])
                delete this._events[type];
            return this;
        }

        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
            for (key in this._events) {
                if (key === 'removeListener') continue;
                this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = {};
            return this;
        }

        listeners = this._events[type];

        if (isFunction(listeners)) {
            this.removeListener(type, listeners);
        } else {
            // LIFO order
            while (listeners.length)
                this.removeListener(type, listeners[listeners.length - 1]);
        }
        delete this._events[type];

        return this;
    };

    EventEmitter.prototype.listeners = function(type) {
        var ret;
        if (!this._events || !this._events[type])
            ret = [];
        else if (isFunction(this._events[type]))
            ret = [this._events[type]];
        else
            ret = this._events[type].slice();
        return ret;
    };

    EventEmitter.listenerCount = function(emitter, type) {
        var ret;
        if (!emitter._events || !emitter._events[type])
            ret = 0;
        else if (isFunction(emitter._events[type]))
            ret = 1;
        else
            ret = emitter._events[type].length;
        return ret;
    };

    function isFunction(arg) {
        return typeof arg === 'function';
    }

    function isNumber(arg) {
        return typeof arg === 'number';
    }

    function isObject(arg) {
        return typeof arg === 'object' && arg !== null;
    }

    function isUndefined(arg) {
        return arg === void 0;
    }

},{}],11:[function(require,module,exports){
// These methods let you build a transform function from a transformComponent
// function for OT types like JSON0 in which operations are lists of components
// and transforming them requires N^2 work. I find it kind of nasty that I need
// this, but I'm not really sure what a better solution is. Maybe I should do
// this automatically to types that don't have a compose function defined.

// Add transform and transformX functions for an OT type which has
// transformComponent defined.  transformComponent(destination array,
// component, other component, side)
    module.exports = bootstrapTransform
    function bootstrapTransform(type, transformComponent, checkValidOp, append) {
        var transformComponentX = function(left, right, destLeft, destRight) {
            transformComponent(destLeft, left, right, 'left');
            transformComponent(destRight, right, left, 'right');
        };

        var transformX = type.transformX = function(leftOp, rightOp) {
            checkValidOp(leftOp);
            checkValidOp(rightOp);
            var newRightOp = [];

            for (var i = 0; i < rightOp.length; i++) {
                var rightComponent = rightOp[i];

                // Generate newLeftOp by composing leftOp by rightComponent
                var newLeftOp = [];
                var k = 0;
                while (k < leftOp.length) {
                    var nextC = [];
                    transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);
                    k++;

                    if (nextC.length === 1) {
                        rightComponent = nextC[0];
                    } else if (nextC.length === 0) {
                        for (var j = k; j < leftOp.length; j++) {
                            append(newLeftOp, leftOp[j]);
                        }
                        rightComponent = null;
                        break;
                    } else {
                        // Recurse.
                        var pair = transformX(leftOp.slice(k), nextC);
                        for (var l = 0; l < pair[0].length; l++) {
                            append(newLeftOp, pair[0][l]);
                        }
                        for (var r = 0; r < pair[1].length; r++) {
                            append(newRightOp, pair[1][r]);
                        }
                        rightComponent = null;
                        break;
                    }
                }

                if (rightComponent != null) {
                    append(newRightOp, rightComponent);
                }
                leftOp = newLeftOp;
            }
            return [leftOp, newRightOp];
        };

        // Transforms op with specified type ('left' or 'right') by otherOp.
        type.transform = function(op, otherOp, type) {
            if (!(type === 'left' || type === 'right'))
                throw new Error("type must be 'left' or 'right'");

            if (otherOp.length === 0) return op;

            if (op.length === 1 && otherOp.length === 1)
                return transformComponent([], op[0], otherOp[0], type);

            if (type === 'left')
                return transformX(op, otherOp)[0];
            else
                return transformX(otherOp, op)[1];
        };
    };

},{}],12:[function(require,module,exports){
// Only the JSON type is exported, because the text type is deprecated
// otherwise. (If you want to use it somewhere, you're welcome to pull it out
// into a separate module that json0 can depend on).

    module.exports = {
        type: require('./json0')
    };

},{"./json0":13}],13:[function(require,module,exports){
    /*
 This is the implementation of the JSON OT type.

 Spec is here: https://github.com/josephg/ShareJS/wiki/JSON-Operations

 Note: This is being made obsolete. It will soon be replaced by the JSON2 type.
*/

    /**
     * UTILITY FUNCTIONS
     */

    /**
     * Checks if the passed object is an Array instance. Can't use Array.isArray
     * yet because its not supported on IE8.
     *
     * @param obj
     * @returns {boolean}
     */
    var isArray = function(obj) {
        return Object.prototype.toString.call(obj) == '[object Array]';
    };

    /**
     * Checks if the passed object is an Object instance.
     * No function call (fast) version
     *
     * @param obj
     * @returns {boolean}
     */
    var isObject = function(obj) {
        return (!!obj) && (obj.constructor === Object);
    };

    /**
     * Clones the passed object using JSON serialization (which is slow).
     *
     * hax, copied from test/types/json. Apparently this is still the fastest way
     * to deep clone an object, assuming we have browser support for JSON.  @see
     * http://jsperf.com/cloning-an-object/12
     */
    var clone = function(o) {
        return JSON.parse(JSON.stringify(o));
    };

    /**
     * JSON OT Type
     * @type {*}
     */
    var json = {
        name: 'json0',
        uri: 'http://sharejs.org/types/JSONv0'
    };

// You can register another OT type as a subtype in a JSON document using
// the following function. This allows another type to handle certain
// operations instead of the builtin JSON type.
    var subtypes = {};
    json.registerSubtype = function(subtype) {
        subtypes[subtype.name] = subtype;
    };

    json.create = function(data) {
        // Null instead of undefined if you don't pass an argument.
        return data === undefined ? null : clone(data);
    };

    json.invertComponent = function(c) {
        var c_ = {p: c.p};

        // handle subtype ops
        if (c.t && subtypes[c.t]) {
            c_.t = c.t;
            c_.o = subtypes[c.t].invert(c.o);
        }

        if (c.si !== void 0) c_.sd = c.si;
        if (c.sd !== void 0) c_.si = c.sd;
        if (c.oi !== void 0) c_.od = c.oi;
        if (c.od !== void 0) c_.oi = c.od;
        if (c.li !== void 0) c_.ld = c.li;
        if (c.ld !== void 0) c_.li = c.ld;
        if (c.na !== void 0) c_.na = -c.na;

        if (c.lm !== void 0) {
            c_.lm = c.p[c.p.length-1];
            c_.p = c.p.slice(0,c.p.length-1).concat([c.lm]);
        }

        return c_;
    };

    json.invert = function(op) {
        var op_ = op.slice().reverse();
        var iop = [];
        for (var i = 0; i < op_.length; i++) {
            iop.push(json.invertComponent(op_[i]));
        }
        return iop;
    };

    json.checkValidOp = function(op) {
        for (var i = 0; i < op.length; i++) {
            if (!isArray(op[i].p)) throw new Error('Missing path');
        }
    };

    json.checkList = function(elem) {
        if (!isArray(elem))
            throw new Error('Referenced element not a list');
    };

    json.checkObj = function(elem) {
        if (!isObject(elem)) {
            throw new Error("Referenced element not an object (it was " + JSON.stringify(elem) + ")");
        }
    };

// helper functions to convert old string ops to and from subtype ops
    function convertFromText(c) {
        c.t = 'text0';
        var o = {p: c.p.pop()};
        if (c.si != null) o.i = c.si;
        if (c.sd != null) o.d = c.sd;
        c.o = [o];
    }

    function convertToText(c) {
        c.p.push(c.o[0].p);
        if (c.o[0].i != null) c.si = c.o[0].i;
        if (c.o[0].d != null) c.sd = c.o[0].d;
        delete c.t;
        delete c.o;
    }

    json.apply = function(snapshot, op) {
        json.checkValidOp(op);

        op = clone(op);

        var container = {
            data: snapshot
        };

        for (var i = 0; i < op.length; i++) {
            var c = op[i];

            // convert old string ops to use subtype for backwards compatibility
            if (c.si != null || c.sd != null)
                convertFromText(c);

            var parent = null;
            var parentKey = null;
            var elem = container;
            var key = 'data';

            for (var j = 0; j < c.p.length; j++) {
                var p = c.p[j];

                parent = elem;
                parentKey = key;
                elem = elem[key];
                key = p;

                if (parent == null)
                    throw new Error('Path invalid');
            }

            // handle subtype ops
            if (c.t && c.o !== void 0 && subtypes[c.t]) {
                elem[key] = subtypes[c.t].apply(elem[key], c.o);

                // Number add
            } else if (c.na !== void 0) {
                if (typeof elem[key] != 'number')
                    throw new Error('Referenced element not a number');

                elem[key] += c.na;
            }

            // List replace
            else if (c.li !== void 0 && c.ld !== void 0) {
                json.checkList(elem);
                // Should check the list element matches c.ld
                elem[key] = c.li;
            }

            // List insert
            else if (c.li !== void 0) {
                json.checkList(elem);
                elem.splice(key,0, c.li);
            }

            // List delete
            else if (c.ld !== void 0) {
                json.checkList(elem);
                // Should check the list element matches c.ld here too.
                elem.splice(key,1);
            }

            // List move
            else if (c.lm !== void 0) {
                json.checkList(elem);
                if (c.lm != key) {
                    var e = elem[key];
                    // Remove it...
                    elem.splice(key,1);
                    // And insert it back.
                    elem.splice(c.lm,0,e);
                }
            }

            // Object insert / replace
            else if (c.oi !== void 0) {
                json.checkObj(elem);

                // Should check that elem[key] == c.od
                elem[key] = c.oi;
            }

            // Object delete
            else if (c.od !== void 0) {
                json.checkObj(elem);

                // Should check that elem[key] == c.od
                delete elem[key];
            }

            else {
                throw new Error('invalid / missing instruction in op');
            }
        }

        return container.data;
    };

// Helper to break an operation up into a bunch of small ops.
    json.shatter = function(op) {
        var results = [];
        for (var i = 0; i < op.length; i++) {
            results.push([op[i]]);
        }
        return results;
    };

// Helper for incrementally applying an operation to a snapshot. Calls yield
// after each op component has been applied.
    json.incrementalApply = function(snapshot, op, _yield) {
        for (var i = 0; i < op.length; i++) {
            var smallOp = [op[i]];
            snapshot = json.apply(snapshot, smallOp);
            // I'd just call this yield, but thats a reserved keyword. Bah!
            _yield(smallOp, snapshot);
        }

        return snapshot;
    };

// Checks if two paths, p1 and p2 match.
    var pathMatches = json.pathMatches = function(p1, p2, ignoreLast) {
        if (p1.length != p2.length)
            return false;

        for (var i = 0; i < p1.length; i++) {
            if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1))
                return false;
        }

        return true;
    };

    json.append = function(dest,c) {
        c = clone(c);

        if (dest.length === 0) {
            dest.push(c);
            return;
        }

        var last = dest[dest.length - 1];

        // convert old string ops to use subtype for backwards compatibility
        if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {
            convertFromText(c);
            convertFromText(last);
        }

        if (pathMatches(c.p, last.p)) {
            // handle subtype ops
            if (c.t && last.t && c.t === last.t && subtypes[c.t]) {
                last.o = subtypes[c.t].compose(last.o, c.o);

                // convert back to old string ops
                if (c.si != null || c.sd != null) {
                    var p = c.p;
                    for (var i = 0; i < last.o.length - 1; i++) {
                        c.o = [last.o.pop()];
                        c.p = p.slice();
                        convertToText(c);
                        dest.push(c);
                    }

                    convertToText(last);
                }
            } else if (last.na != null && c.na != null) {
                dest[dest.length - 1] = {p: last.p, na: last.na + c.na};
            } else if (last.li !== undefined && c.li === undefined && c.ld === last.li) {
                // insert immediately followed by delete becomes a noop.
                if (last.ld !== undefined) {
                    // leave the delete part of the replace
                    delete last.li;
                } else {
                    dest.pop();
                }
            } else if (last.od !== undefined && last.oi === undefined && c.oi !== undefined && c.od === undefined) {
                last.oi = c.oi;
            } else if (last.oi !== undefined && c.od !== undefined) {
                // The last path component inserted something that the new component deletes (or replaces).
                // Just merge them.
                if (c.oi !== undefined) {
                    last.oi = c.oi;
                } else if (last.od !== undefined) {
                    delete last.oi;
                } else {
                    // An insert directly followed by a delete turns into a no-op and can be removed.
                    dest.pop();
                }
            } else if (c.lm !== undefined && c.p[c.p.length - 1] === c.lm) {
                // don't do anything
            } else {
                dest.push(c);
            }
        } else {
            // convert string ops back
            if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {
                convertToText(c);
                convertToText(last);
            }

            dest.push(c);
        }
    };

    json.compose = function(op1,op2) {
        json.checkValidOp(op1);
        json.checkValidOp(op2);

        var newOp = clone(op1);

        for (var i = 0; i < op2.length; i++) {
            json.append(newOp,op2[i]);
        }

        return newOp;
    };

    json.normalize = function(op) {
        var newOp = [];

        op = isArray(op) ? op : [op];

        for (var i = 0; i < op.length; i++) {
            var c = op[i];
            if (c.p == null) c.p = [];

            json.append(newOp,c);
        }

        return newOp;
    };

// Returns the common length of the paths of ops a and b
    json.commonLengthForOps = function(a, b) {
        var alen = a.p.length;
        var blen = b.p.length;
        if (a.na != null || a.t)
            alen++;

        if (b.na != null || b.t)
            blen++;

        if (alen === 0) return -1;
        if (blen === 0) return null;

        alen--;
        blen--;

        for (var i = 0; i < alen; i++) {
            var p = a.p[i];
            if (i >= blen || p !== b.p[i])
                return null;
        }

        return alen;
    };

// Returns true if an op can affect the given path
    json.canOpAffectPath = function(op, path) {
        return json.commonLengthForOps({p:path}, op) != null;
    };

// transform c so it applies to a document with otherC applied.
    json.transformComponent = function(dest, c, otherC, type) {
        c = clone(c);

        var common = json.commonLengthForOps(otherC, c);
        var common2 = json.commonLengthForOps(c, otherC);
        var cplength = c.p.length;
        var otherCplength = otherC.p.length;

        if (c.na != null || c.t)
            cplength++;

        if (otherC.na != null || otherC.t)
            otherCplength++;

        // if c is deleting something, and that thing is changed by otherC, we need to
        // update c to reflect that change for invertibility.
        if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {
            if (c.ld !== void 0) {
                var oc = clone(otherC);
                oc.p = oc.p.slice(cplength);
                c.ld = json.apply(clone(c.ld),[oc]);
            } else if (c.od !== void 0) {
                var oc = clone(otherC);
                oc.p = oc.p.slice(cplength);
                c.od = json.apply(clone(c.od),[oc]);
            }
        }

        if (common != null) {
            var commonOperand = cplength == otherCplength;

            // backward compatibility for old string ops
            var oc = otherC;
            if ((c.si != null || c.sd != null) && (otherC.si != null || otherC.sd != null)) {
                convertFromText(c);
                oc = clone(otherC);
                convertFromText(oc);
            }

            // handle subtype ops
            if (oc.t && subtypes[oc.t]) {
                if (c.t && c.t === oc.t) {
                    var res = subtypes[c.t].transform(c.o, oc.o, type);

                    if (res.length > 0) {
                        // convert back to old string ops
                        if (c.si != null || c.sd != null) {
                            var p = c.p;
                            for (var i = 0; i < res.length; i++) {
                                c.o = [res[i]];
                                c.p = p.slice();
                                convertToText(c);
                                json.append(dest, c);
                            }
                        } else {
                            c.o = res;
                            json.append(dest, c);
                        }
                    }

                    return dest;
                }
            }

            // transform based on otherC
            else if (otherC.na !== void 0) {
                // this case is handled below
            } else if (otherC.li !== void 0 && otherC.ld !== void 0) {
                if (otherC.p[common] === c.p[common]) {
                    // noop

                    if (!commonOperand) {
                        return dest;
                    } else if (c.ld !== void 0) {
                        // we're trying to delete the same element, -> noop
                        if (c.li !== void 0 && type === 'left') {
                            // we're both replacing one element with another. only one can survive
                            c.ld = clone(otherC.li);
                        } else {
                            return dest;
                        }
                    }
                }
            } else if (otherC.li !== void 0) {
                if (c.li !== void 0 && c.ld === undefined && commonOperand && c.p[common] === otherC.p[common]) {
                    // in li vs. li, left wins.
                    if (type === 'right')
                        c.p[common]++;
                } else if (otherC.p[common] <= c.p[common]) {
                    c.p[common]++;
                }

                if (c.lm !== void 0) {
                    if (commonOperand) {
                        // otherC edits the same list we edit
                        if (otherC.p[common] <= c.lm)
                            c.lm++;
                        // changing c.from is handled above.
                    }
                }
            } else if (otherC.ld !== void 0) {
                if (c.lm !== void 0) {
                    if (commonOperand) {
                        if (otherC.p[common] === c.p[common]) {
                            // they deleted the thing we're trying to move
                            return dest;
                        }
                        // otherC edits the same list we edit
                        var p = otherC.p[common];
                        var from = c.p[common];
                        var to = c.lm;
                        if (p < to || (p === to && from < to))
                            c.lm--;

                    }
                }

                if (otherC.p[common] < c.p[common]) {
                    c.p[common]--;
                } else if (otherC.p[common] === c.p[common]) {
                    if (otherCplength < cplength) {
                        // we're below the deleted element, so -> noop
                        return dest;
                    } else if (c.ld !== void 0) {
                        if (c.li !== void 0) {
                            // we're replacing, they're deleting. we become an insert.
                            delete c.ld;
                        } else {
                            // we're trying to delete the same element, -> noop
                            return dest;
                        }
                    }
                }

            } else if (otherC.lm !== void 0) {
                if (c.lm !== void 0 && cplength === otherCplength) {
                    // lm vs lm, here we go!
                    var from = c.p[common];
                    var to = c.lm;
                    var otherFrom = otherC.p[common];
                    var otherTo = otherC.lm;
                    if (otherFrom !== otherTo) {
                        // if otherFrom == otherTo, we don't need to change our op.

                        // where did my thing go?
                        if (from === otherFrom) {
                            // they moved it! tie break.
                            if (type === 'left') {
                                c.p[common] = otherTo;
                                if (from === to) // ugh
                                    c.lm = otherTo;
                            } else {
                                return dest;
                            }
                        } else {
                            // they moved around it
                            if (from > otherFrom) c.p[common]--;
                            if (from > otherTo) c.p[common]++;
                            else if (from === otherTo) {
                                if (otherFrom > otherTo) {
                                    c.p[common]++;
                                    if (from === to) // ugh, again
                                        c.lm++;
                                }
                            }

                            // step 2: where am i going to put it?
                            if (to > otherFrom) {
                                c.lm--;
                            } else if (to === otherFrom) {
                                if (to > from)
                                    c.lm--;
                            }
                            if (to > otherTo) {
                                c.lm++;
                            } else if (to === otherTo) {
                                // if we're both moving in the same direction, tie break
                                if ((otherTo > otherFrom && to > from) ||
                                    (otherTo < otherFrom && to < from)) {
                                    if (type === 'right') c.lm++;
                                } else {
                                    if (to > from) c.lm++;
                                    else if (to === otherFrom) c.lm--;
                                }
                            }
                        }
                    }
                } else if (c.li !== void 0 && c.ld === undefined && commonOperand) {
                    // li
                    var from = otherC.p[common];
                    var to = otherC.lm;
                    p = c.p[common];
                    if (p > from) c.p[common]--;
                    if (p > to) c.p[common]++;
                } else {
                    // ld, ld+li, si, sd, na, oi, od, oi+od, any li on an element beneath
                    // the lm
                    //
                    // i.e. things care about where their item is after the move.
                    var from = otherC.p[common];
                    var to = otherC.lm;
                    p = c.p[common];
                    if (p === from) {
                        c.p[common] = to;
                    } else {
                        if (p > from) c.p[common]--;
                        if (p > to) c.p[common]++;
                        else if (p === to && from > to) c.p[common]++;
                    }
                }
            }
            else if (otherC.oi !== void 0 && otherC.od !== void 0) {
                if (c.p[common] === otherC.p[common]) {
                    if (c.oi !== void 0 && commonOperand) {
                        // we inserted where someone else replaced
                        if (type === 'right') {
                            // left wins
                            return dest;
                        } else {
                            // we win, make our op replace what they inserted
                            c.od = otherC.oi;
                        }
                    } else {
                        // -> noop if the other component is deleting the same object (or any parent)
                        return dest;
                    }
                }
            } else if (otherC.oi !== void 0) {
                if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {
                    // left wins if we try to insert at the same place
                    if (type === 'left') {
                        json.append(dest,{p: c.p, od:otherC.oi});
                    } else {
                        return dest;
                    }
                }
            } else if (otherC.od !== void 0) {
                if (c.p[common] == otherC.p[common]) {
                    if (!commonOperand)
                        return dest;
                    if (c.oi !== void 0) {
                        delete c.od;
                    } else {
                        return dest;
                    }
                }
            }
        }

        json.append(dest,c);
        return dest;
    };

    require('./bootstrapTransform')(json, json.transformComponent, json.checkValidOp, json.append);

    /**
     * Register a subtype for string operations, using the text0 type.
     */
    var text = require('./text0');

    json.registerSubtype(text);
    module.exports = json;


},{"./bootstrapTransform":11,"./text0":14}],14:[function(require,module,exports){
// DEPRECATED!
//
// This type works, but is not exported. Its included here because the JSON0
// embedded string operations use this library.


// A simple text implementation
//
// Operations are lists of components. Each component either inserts or deletes
// at a specified position in the document.
//
// Components are either:
//  {i:'str', p:100}: Insert 'str' at position 100 in the document
//  {d:'str', p:100}: Delete 'str' at position 100 in the document
//
// Components in an operation are executed sequentially, so the position of components
// assumes previous components have already executed.
//
// Eg: This op:
//   [{i:'abc', p:0}]
// is equivalent to this op:
//   [{i:'a', p:0}, {i:'b', p:1}, {i:'c', p:2}]

    var text = module.exports = {
        name: 'text0',
        uri: 'http://sharejs.org/types/textv0',
        create: function(initial) {
            if ((initial != null) && typeof initial !== 'string') {
                throw new Error('Initial data must be a string');
            }
            return initial || '';
        }
    };

    /** Insert s2 into s1 at pos. */
    var strInject = function(s1, pos, s2) {
        return s1.slice(0, pos) + s2 + s1.slice(pos);
    };

    /** Check that an operation component is valid. Throws if its invalid. */
    var checkValidComponent = function(c) {
        if (typeof c.p !== 'number')
            throw new Error('component missing position field');

        if ((typeof c.i === 'string') === (typeof c.d === 'string'))
            throw new Error('component needs an i or d field');

        if (c.p < 0)
            throw new Error('position cannot be negative');
    };

    /** Check that an operation is valid */
    var checkValidOp = function(op) {
        for (var i = 0; i < op.length; i++) {
            checkValidComponent(op[i]);
        }
    };

    /** Apply op to snapshot */
    text.apply = function(snapshot, op) {
        var deleted;

        checkValidOp(op);
        for (var i = 0; i < op.length; i++) {
            var component = op[i];
            if (component.i != null) {
                snapshot = strInject(snapshot, component.p, component.i);
            } else {
                deleted = snapshot.slice(component.p, component.p + component.d.length);
                if (component.d !== deleted)
                    throw new Error("Delete component '" + component.d + "' does not match deleted text '" + deleted + "'");

                snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);
            }
        }
        return snapshot;
    };

    /**
     * Append a component to the end of newOp. Exported for use by the random op
     * generator and the JSON0 type.
     */
    var append = text._append = function(newOp, c) {
        if (c.i === '' || c.d === '') return;

        if (newOp.length === 0) {
            newOp.push(c);
        } else {
            var last = newOp[newOp.length - 1];

            if (last.i != null && c.i != null && last.p <= c.p && c.p <= last.p + last.i.length) {
                // Compose the insert into the previous insert
                newOp[newOp.length - 1] = {i:strInject(last.i, c.p - last.p, c.i), p:last.p};

            } else if (last.d != null && c.d != null && c.p <= last.p && last.p <= c.p + c.d.length) {
                // Compose the deletes together
                newOp[newOp.length - 1] = {d:strInject(c.d, last.p - c.p, last.d), p:c.p};

            } else {
                newOp.push(c);
            }
        }
    };

    /** Compose op1 and op2 together */
    text.compose = function(op1, op2) {
        checkValidOp(op1);
        checkValidOp(op2);
        var newOp = op1.slice();
        for (var i = 0; i < op2.length; i++) {
            append(newOp, op2[i]);
        }
        return newOp;
    };

    /** Clean up an op */
    text.normalize = function(op) {
        var newOp = [];

        // Normalize should allow ops which are a single (unwrapped) component:
        // {i:'asdf', p:23}.
        // There's no good way to test if something is an array:
        // http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
        // so this is probably the least bad solution.
        if (op.i != null || op.p != null) op = [op];

        for (var i = 0; i < op.length; i++) {
            var c = op[i];
            if (c.p == null) c.p = 0;

            append(newOp, c);
        }

        return newOp;
    };

// This helper method transforms a position by an op component.
//
// If c is an insert, insertAfter specifies whether the transform
// is pushed after the insert (true) or before it (false).
//
// insertAfter is optional for deletes.
    var transformPosition = function(pos, c, insertAfter) {
        // This will get collapsed into a giant ternary by uglify.
        if (c.i != null) {
            if (c.p < pos || (c.p === pos && insertAfter)) {
                return pos + c.i.length;
            } else {
                return pos;
            }
        } else {
            // I think this could also be written as: Math.min(c.p, Math.min(c.p -
            // otherC.p, otherC.d.length)) but I think its harder to read that way, and
            // it compiles using ternary operators anyway so its no slower written like
            // this.
            if (pos <= c.p) {
                return pos;
            } else if (pos <= c.p + c.d.length) {
                return c.p;
            } else {
                return pos - c.d.length;
            }
        }
    };

// Helper method to transform a cursor position as a result of an op.
//
// Like transformPosition above, if c is an insert, insertAfter specifies
// whether the cursor position is pushed after an insert (true) or before it
// (false).
    text.transformCursor = function(position, op, side) {
        var insertAfter = side === 'right';
        for (var i = 0; i < op.length; i++) {
            position = transformPosition(position, op[i], insertAfter);
        }

        return position;
    };

// Transform an op component by another op component. Asymmetric.
// The result will be appended to destination.
//
// exported for use in JSON type
    var transformComponent = text._tc = function(dest, c, otherC, side) {
        //var cIntersect, intersectEnd, intersectStart, newC, otherIntersect, s;

        checkValidComponent(c);
        checkValidComponent(otherC);

        if (c.i != null) {
            // Insert.
            append(dest, {i:c.i, p:transformPosition(c.p, otherC, side === 'right')});
        } else {
            // Delete
            if (otherC.i != null) {
                // Delete vs insert
                var s = c.d;
                if (c.p < otherC.p) {
                    append(dest, {d:s.slice(0, otherC.p - c.p), p:c.p});
                    s = s.slice(otherC.p - c.p);
                }
                if (s !== '')
                    append(dest, {d: s, p: c.p + otherC.i.length});

            } else {
                // Delete vs delete
                if (c.p >= otherC.p + otherC.d.length)
                    append(dest, {d: c.d, p: c.p - otherC.d.length});
                else if (c.p + c.d.length <= otherC.p)
                    append(dest, c);
                else {
                    // They overlap somewhere.
                    var newC = {d: '', p: c.p};

                    if (c.p < otherC.p)
                        newC.d = c.d.slice(0, otherC.p - c.p);

                    if (c.p + c.d.length > otherC.p + otherC.d.length)
                        newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);

                    // This is entirely optional - I'm just checking the deleted text in
                    // the two ops matches
                    var intersectStart = Math.max(c.p, otherC.p);
                    var intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);
                    var cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);
                    var otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);
                    if (cIntersect !== otherIntersect)
                        throw new Error('Delete ops delete different text in the same region of the document');

                    if (newC.d !== '') {
                        newC.p = transformPosition(newC.p, otherC);
                        append(dest, newC);
                    }
                }
            }
        }

        return dest;
    };

    var invertComponent = function(c) {
        return (c.i != null) ? {d:c.i, p:c.p} : {i:c.d, p:c.p};
    };

// No need to use append for invert, because the components won't be able to
// cancel one another.
    text.invert = function(op) {
        // Shallow copy & reverse that sucka.
        op = op.slice().reverse();
        for (var i = 0; i < op.length; i++) {
            op[i] = invertComponent(op[i]);
        }
        return op;
    };

    require('./bootstrapTransform')(text, transformComponent, checkValidOp, append);

},{"./bootstrapTransform":11}],15:[function(require,module,exports){
    module.exports = {
        type: require('./text-tp2')
    };

},{"./text-tp2":16}],16:[function(require,module,exports){
// A TP2 implementation of text, following this spec:
// http://code.google.com/p/lightwave/source/browse/trunk/experimental/ot/README
//
// A document is made up of a string and a set of tombstones inserted throughout
// the string. For example, 'some ', (2 tombstones), 'string'.
//
// This is encoded in a document as ['some ', (2 tombstones), 'string']
// (It should be encoded as {s:'some string', t:[5, -2, 6]} because thats
// faster in JS, but its not.)
//
// Ops are lists of components which iterate over the whole document. (I might
// change this at some point, but a version thats less strict is backwards
// compatible.)
//
// Components are either:
//   N:         Skip N characters in the original document
//   {i:'str'}: Insert 'str' at the current position in the document
//   {i:N}:     Insert N tombstones at the current position in the document
//   {d:N}:     Delete (tombstone) N characters at the current position in the document
//
// Eg: [3, {i:'hi'}, 5, {d:8}]
//
// Snapshots are lists with characters and tombstones. Characters are stored in strings
// and adjacent tombstones are flattened into numbers.
//
// Eg, the document: 'Hello .....world' ('.' denotes tombstoned (deleted) characters)
// would be represented by a document snapshot of ['Hello ', 5, 'world']

    var type = module.exports = {
        name: 'text-tp2',
        tp2: true,
        uri: 'http://sharejs.org/types/text-tp2v1',
        create: function(initial) {
            if (initial == null) {
                initial = '';
            } else {
                if (typeof initial != 'string') throw new Error('Initial data must be a string');
            }

            return {
                charLength: initial.length,
                totalLength: initial.length,
                data: initial.length ? [initial] : []
            };
        },

        serialize: function(doc) {
            if (!doc.data) {
                throw new Error('invalid doc snapshot');
            }
            return doc.data;
        },

        deserialize: function(data) {
            var doc = type.create();
            doc.data = data;

            for (var i = 0; i < data.length; i++) {
                var component = data[i];

                if (typeof component === 'string') {
                    doc.charLength += component.length;
                    doc.totalLength += component.length;
                } else {
                    doc.totalLength += component;
                }
            }

            return doc;
        }
    };

    var isArray = Array.isArray || function(obj) {
        return Object.prototype.toString.call(obj) == '[object Array]';
    };

    var checkOp = function(op) {
        if (!isArray(op)) throw new Error('Op must be an array of components');

        var last = null;
        for (var i = 0; i < op.length; i++) {
            var c = op[i];
            if (typeof c == 'object') {
                // The component is an insert or a delete.
                if (c.i !== undefined) { // Insert.
                    if (!((typeof c.i === 'string' && c.i.length > 0) // String inserts
                            || (typeof c.i === 'number' && c.i > 0))) // Tombstone inserts
                        throw new Error('Inserts must insert a string or a +ive number');

                } else if (c.d !== undefined) { // Delete
                    if (!(typeof c.d === 'number' && c.d > 0))
                        throw new Error('Deletes must be a +ive number');

                } else throw new Error('Operation component must define .i or .d');

            } else {
                // The component must be a skip.
                if (typeof c != 'number') throw new Error('Op components must be objects or numbers');

                if (c <= 0) throw new Error('Skip components must be a positive number');
                if (typeof last === 'number') throw new Error('Adjacent skip components should be combined');
            }

            last = c;
        }
    };

// Take the next part from the specified position in a document snapshot.
// position = {index, offset}. It will be updated.
    var takeDoc = type._takeDoc = function(doc, position, maxlength, tombsIndivisible) {
        if (position.index >= doc.data.length)
            throw new Error('Operation goes past the end of the document');

        var part = doc.data[position.index];

        // This can be written as an ugly-arsed giant ternary statement, but its much
        // more readable like this. Uglify will convert it into said ternary anyway.
        var result;
        if (typeof part == 'string') {
            if (maxlength != null) {
                result = part.slice(position.offset, position.offset + maxlength);
            } else {
                result = part.slice(position.offset);
            }
        } else {
            if (maxlength == null || tombsIndivisible) {
                result = part - position.offset;
            } else {
                result = Math.min(maxlength, part - position.offset);
            }
        }

        var resultLen = result.length || result;

        if ((part.length || part) - position.offset > resultLen) {
            position.offset += resultLen;
        } else {
            position.index++;
            position.offset = 0;
        }

        return result;
    };

// Append a part to the end of a document
    var appendDoc = type._appendDoc = function(doc, p) {
        if (p === 0 || p === '') return;

        if (typeof p === 'string') {
            doc.charLength += p.length;
            doc.totalLength += p.length;
        } else {
            doc.totalLength += p;
        }

        var data = doc.data;
        if (data.length === 0) {
            data.push(p);
        } else if (typeof data[data.length - 1] === typeof p) {
            data[data.length - 1] += p;
        } else {
            data.push(p);
        }
    };

// Apply the op to the document. The document is not modified in the process.
    type.apply = function(doc, op) {
        if (doc.totalLength == null || doc.charLength == null || !isArray(doc.data)) {
            throw new Error('Snapshot is invalid');
        }
        checkOp(op);

        var newDoc = type.create();
        var position = {index: 0, offset: 0};

        for (var i = 0; i < op.length; i++) {
            var component = op[i];
            var remainder, part;

            if (typeof component == 'number') { // Skip
                remainder = component;
                while (remainder > 0) {
                    part = takeDoc(doc, position, remainder);
                    appendDoc(newDoc, part);
                    remainder -= part.length || part;
                }

            } else if (component.i !== undefined) { // Insert
                appendDoc(newDoc, component.i);

            } else if (component.d !== undefined) { // Delete
                remainder = component.d;
                while (remainder > 0) {
                    part = takeDoc(doc, position, remainder);
                    remainder -= part.length || part;
                }
                appendDoc(newDoc, component.d);
            }
        }
        return newDoc;
    };

// Append an op component to the end of the specified op.  Exported for the
// randomOpGenerator.
    var append = type._append = function(op, component) {
        var last;

        if (component === 0 || component.i === '' || component.i === 0 || component.d === 0) {
            // Drop the new component.
        } else if (op.length === 0) {
            op.push(component);
        } else {
            last = op[op.length - 1];
            if (typeof component == 'number' && typeof last == 'number') {
                op[op.length - 1] += component;
            } else if (component.i != null && (last.i != null) && typeof last.i === typeof component.i) {
                last.i += component.i;
            } else if (component.d != null && (last.d != null)) {
                last.d += component.d;
            } else {
                op.push(component);
            }
        }
    };

    var take = function(op, cursor, maxlength, insertsIndivisible) {
        if (cursor.index === op.length) return null;
        var e = op[cursor.index];
        var current;
        var result;

        var offset = cursor.offset;

        // if the current element is a skip, an insert of a number or a delete
        if (typeof (current = e) == 'number' || typeof (current = e.i) == 'number' || (current = e.d) != null) {
            var c;
            if ((maxlength == null) || current - offset <= maxlength || (insertsIndivisible && e.i != null)) {
                // Return the rest of the current element.
                c = current - offset;
                ++cursor.index;
                cursor.offset = 0;
            } else {
                cursor.offset += maxlength;
                c = maxlength;
            }

            // Package the component back up.
            if (e.i != null) {
                return {i: c};
            } else if (e.d != null) {
                return {d: c};
            } else {
                return c;
            }
        } else { // Insert of a string.
            if ((maxlength == null) || e.i.length - offset <= maxlength || insertsIndivisible) {
                result = {i: e.i.slice(offset)};
                ++cursor.index;
                cursor.offset = 0;
            } else {
                result = {i: e.i.slice(offset, offset + maxlength)};
                cursor.offset += maxlength;
            }
            return result;
        }
    };

// Find and return the length of an op component
    var componentLength = function(component) {
        if (typeof component === 'number') {
            return component;
        } else if (typeof component.i === 'string') {
            return component.i.length;
        } else {
            return component.d || component.i;
        }
    };

// Normalize an op, removing all empty skips and empty inserts / deletes.
// Concatenate adjacent inserts and deletes.
    type.normalize = function(op) {
        var newOp = [];
        for (var i = 0; i < op.length; i++) {
            append(newOp, op[i]);
        }
        return newOp;
    };

// This is a helper method to transform and prune. goForwards is true for transform, false for prune.
    var transformer = function(op, otherOp, goForwards, side) {
        checkOp(op);
        checkOp(otherOp);

        var newOp = [];

        // Cursor moving over op. Used by take
        var cursor = {index:0, offset:0};

        for (var i = 0; i < otherOp.length; i++) {
            var component = otherOp[i];
            var len = componentLength(component);
            var chunk;

            if (component.i != null) { // Insert text or tombs
                if (goForwards) { // Transform - insert skips over deleted parts.
                    if (side === 'left') {
                        // The left side insert should go first.
                        var next;
                        while ((next = op[cursor.index]) && next.i != null) {
                            append(newOp, take(op, cursor));
                        }
                    }
                    // In any case, skip the inserted text.
                    append(newOp, len);

                } else { // Prune. Remove skips for inserts.
                    while (len > 0) {
                        chunk = take(op, cursor, len, true);

                        // The chunk will be null if we run out of components in the other op.
                        if (chunk === null) throw new Error('The transformed op is invalid');
                        if (chunk.d != null)
                            throw new Error('The transformed op deletes locally inserted characters - it cannot be purged of the insert.');

                        if (typeof chunk == 'number')
                            len -= chunk;
                        else
                            append(newOp, chunk);
                    }
                }
            } else { // Skips or deletes.
                while (len > 0) {
                    chunk = take(op, cursor, len, true);
                    if (chunk === null) throw new Error('The op traverses more elements than the document has');

                    append(newOp, chunk);
                    if (!chunk.i) len -= componentLength(chunk);
                }
            }
        }

        // Append extras from op1.
        var component;
        while ((component = take(op, cursor))) {
            if (component.i === undefined) {
                throw new Error("Remaining fragments in the op: " + component);
            }
            append(newOp, component);
        }
        return newOp;
    };

// transform op1 by op2. Return transformed version of op1. op1 and op2 are
// unchanged by transform. Side should be 'left' or 'right', depending on if
// op1.id <> op2.id.
//
// 'left' == client op for ShareJS.
    type.transform = function(op, otherOp, side) {
        if (side != 'left' && side != 'right')
            throw new Error("side (" + side + ") should be 'left' or 'right'");

        return transformer(op, otherOp, true, side);
    };

    type.prune = function(op, otherOp) {
        return transformer(op, otherOp, false);
    };

    type.compose = function(op1, op2) {
        //var chunk, chunkLength, component, length, result, take, _, _i, _len, _ref;
        if (op1 == null) return op2;

        checkOp(op1);
        checkOp(op2);

        var result = [];

        // Cursor over op1.
        var cursor = {index:0, offset:0};

        var component;

        for (var i = 0; i < op2.length; i++) {
            component = op2[i];
            var len, chunk;

            if (typeof component === 'number') { // Skip
                // Just copy from op1.
                len = component;
                while (len > 0) {
                    chunk = take(op1, cursor, len);
                    if (chunk === null)
                        throw new Error('The op traverses more elements than the document has');

                    append(result, chunk);
                    len -= componentLength(chunk);
                }

            } else if (component.i !== undefined) { // Insert
                append(result, {i: component.i});

            } else { // Delete
                len = component.d;
                while (len > 0) {
                    chunk = take(op1, cursor, len);
                    if (chunk === null)
                        throw new Error('The op traverses more elements than the document has');

                    var chunkLength = componentLength(chunk);

                    if (chunk.i !== undefined)
                        append(result, {i: chunkLength});
                    else
                        append(result, {d: chunkLength});

                    len -= chunkLength;
                }
            }
        }

        // Append extras from op1.
        while ((component = take(op1, cursor))) {
            if (component.i === undefined) {
                throw new Error("Remaining fragments in op1: " + component);
            }
            append(result, component);
        }
        return result;
    };


},{}],17:[function(require,module,exports){
// Text document API for the 'text' type. This implements some standard API
// methods for any text-like type, so you can easily bind a textarea or
// something without being fussy about the underlying OT implementation.
//
// The API is desigend as a set of functions to be mixed in to some context
// object as part of its lifecycle. It expects that object to have getSnapshot
// and submitOp methods, and call _onOp when an operation is received.
//
// This API defines:
//
// - getLength() returns the length of the document in characters
// - getText() returns a string of the document
// - insert(pos, text, [callback]) inserts text at position pos in the document
// - remove(pos, length, [callback]) removes length characters at position pos
//
// A user can define:
// - onInsert(pos, text): Called when text is inserted.
// - onRemove(pos, length): Called when text is removed.

    module.exports = api;
    function api(getSnapshot, submitOp) {
        return {
            // Returns the text content of the document
            get: function() { return getSnapshot(); },

            // Returns the number of characters in the string
            getLength: function() { return getSnapshot().length; },

            // Insert the specified text at the given position in the document
            insert: function(pos, text, callback) {
                return submitOp([pos, text], callback);
            },

            remove: function(pos, length, callback) {
                return submitOp([pos, {d:length}], callback);
            },

            // When you use this API, you should implement these two methods
            // in your editing context.
            //onInsert: function(pos, text) {},
            //onRemove: function(pos, removedLength) {},

            _onOp: function(op) {
                var pos = 0;
                var spos = 0;
                for (var i = 0; i < op.length; i++) {
                    var component = op[i];
                    switch (typeof component) {
                        case 'number':
                            pos += component;
                            spos += component;
                            break;
                        case 'string':
                            if (this.onInsert) this.onInsert(pos, component);
                            pos += component.length;
                            break;
                        case 'object':
                            if (this.onRemove) this.onRemove(pos, component.d);
                            spos += component.d;
                    }
                }
            }
        };
    };
    api.provides = {text: true};

},{}],18:[function(require,module,exports){
    var type = require('./text');
    type.api = require('./api');

    module.exports = {
        type: type
    };

},{"./api":17,"./text":19}],19:[function(require,module,exports){
    /* Text OT!
 *
 * This is an OT implementation for text. It is the standard implementation of
 * text used by ShareJS.
 *
 * This type is composable but non-invertable. Its similar to ShareJS's old
 * text-composable type, but its not invertable and its very similar to the
 * text-tp2 implementation but it doesn't support tombstones or purging.
 *
 * Ops are lists of components which iterate over the document.
 * Components are either:
 *   A number N: Skip N characters in the original document
 *   "str"     : Insert "str" at the current position in the document
 *   {d:N}     : Delete N characters at the current position in the document
 *
 * Eg: [3, 'hi', 5, {d:8}]
 *
 * The operation does not have to skip the last characters in the document.
 *
 * Snapshots are strings.
 *
 * Cursors are either a single number (which is the cursor position) or a pair of
 * [anchor, focus] (aka [start, end]). Be aware that end can be before start.
 */

    /** @module text */

    exports.name = 'text';
    exports.uri = 'http://sharejs.org/types/textv1';

    /** Create a new text snapshot.
     *
     * @param {string} initial - initial snapshot data. Optional. Defaults to ''.
     */
    exports.create = function(initial) {
        if ((initial != null) && typeof initial !== 'string') {
            throw Error('Initial data must be a string');
        }
        return initial || '';
    };

    var isArray = Array.isArray || function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
    };

    /** Check the operation is valid. Throws if not valid. */
    var checkOp = function(op) {
        if (!isArray(op)) throw Error('Op must be an array of components');

        var last = null;
        for (var i = 0; i < op.length; i++) {
            var c = op[i];
            switch (typeof c) {
                case 'object':
                    // The only valid objects are {d:X} for +ive values of X.
                    if (!(typeof c.d === 'number' && c.d > 0)) throw Error('Object components must be deletes of size > 0');
                    break;
                case 'string':
                    // Strings are inserts.
                    if (!(c.length > 0)) throw Error('Inserts cannot be empty');
                    break;
                case 'number':
                    // Numbers must be skips. They have to be +ive numbers.
                    if (!(c > 0)) throw Error('Skip components must be >0');
                    if (typeof last === 'number') throw Error('Adjacent skip components should be combined');
                    break;
            }
            last = c;
        }

        if (typeof last === 'number') throw Error('Op has a trailing skip');
    };

    /** Check that the given selection range is valid. */
    var checkSelection = function(selection) {
        // This may throw from simply inspecting selection[0] / selection[1]. Thats
        // sort of ok, though it'll generate the wrong message.
        if (typeof selection !== 'number'
            && (typeof selection[0] !== 'number' || typeof selection[1] !== 'number'))
            throw Error('Invalid selection');
    };

    /** Make a function that appends to the given operation. */
    var makeAppend = function(op) {
        return function(component) {
            if (!component || component.d === 0) {
                // The component is a no-op. Ignore!

            } else if (op.length === 0) {
                return op.push(component);

            } else if (typeof component === typeof op[op.length - 1]) {
                if (typeof component === 'object') {
                    return op[op.length - 1].d += component.d;
                } else {
                    return op[op.length - 1] += component;
                }
            } else {
                return op.push(component);
            }
        };
    };

    /** Makes and returns utility functions take and peek. */
    var makeTake = function(op) {
        // The index of the next component to take
        var idx = 0;
        // The offset into the component
        var offset = 0;

        // Take up to length n from the front of op. If n is -1, take the entire next
        // op component. If indivisableField == 'd', delete components won't be separated.
        // If indivisableField == 'i', insert components won't be separated.
        var take = function(n, indivisableField) {
            // We're at the end of the operation. The op has skips, forever. Infinity
            // might make more sense than null here.
            if (idx === op.length)
                return n === -1 ? null : n;

            var part;
            var c = op[idx];
            if (typeof c === 'number') {
                // Skip
                if (n === -1 || c - offset <= n) {
                    part = c - offset;
                    ++idx;
                    offset = 0;
                    return part;
                } else {
                    offset += n;
                    return n;
                }
            } else if (typeof c === 'string') {
                // Insert
                if (n === -1 || indivisableField === 'i' || c.length - offset <= n) {
                    part = c.slice(offset);
                    ++idx;
                    offset = 0;
                    return part;
                } else {
                    part = c.slice(offset, offset + n);
                    offset += n;
                    return part;
                }
            } else {
                // Delete
                if (n === -1 || indivisableField === 'd' || c.d - offset <= n) {
                    part = {d: c.d - offset};
                    ++idx;
                    offset = 0;
                    return part;
                } else {
                    offset += n;
                    return {d: n};
                }
            }
        };

        // Peek at the next op that will be returned.
        var peekType = function() { return op[idx]; };

        return [take, peekType];
    };

    /** Get the length of a component */
    var componentLength = function(c) {
        // Uglify will compress this down into a ternary
        if (typeof c === 'number') {
            return c;
        } else {
            return c.length || c.d;
        }
    };

    /** Trim any excess skips from the end of an operation.
     *
     * There should only be at most one, because the operation was made with append.
     */
    var trim = function(op) {
        if (op.length > 0 && typeof op[op.length - 1] === 'number') {
            op.pop();
        }
        return op;
    };

    exports.normalize = function(op) {
        var newOp = [];
        var append = makeAppend(newOp);
        for (var i = 0; i < op.length; i++) {
            append(op[i]);
        }
        return trim(newOp);
    };

    /** Apply an operation to a document snapshot */
    exports.apply = function(str, op) {
        if (typeof str !== 'string') {
            throw Error('Snapshot should be a string');
        }
        checkOp(op);

        // We'll gather the new document here and join at the end.
        var newDoc = [];

        for (var i = 0; i < op.length; i++) {
            var component = op[i];
            switch (typeof component) {
                case 'number':
                    if (component > str.length) throw Error('The op is too long for this document');

                    newDoc.push(str.slice(0, component));
                    // This might be slow for big strings. Consider storing the offset in
                    // str instead of rewriting it each time.
                    str = str.slice(component);
                    break;
                case 'string':
                    newDoc.push(component);
                    break;
                case 'object':
                    str = str.slice(component.d);
                    break;
            }
        }

        return newDoc.join('') + str;
    };

    /** Transform op by otherOp.
     *
     * @param op - The operation to transform
     * @param otherOp - Operation to transform it by
     * @param side - Either 'left' or 'right'
     */
    exports.transform = function(op, otherOp, side) {
        if (side != 'left' && side != 'right') throw Error("side (" + side + ") must be 'left' or 'right'");

        checkOp(op);
        checkOp(otherOp);

        var newOp = [];
        var append = makeAppend(newOp);

        var _fns = makeTake(op);
        var take = _fns[0],
            peek = _fns[1];

        for (var i = 0; i < otherOp.length; i++) {
            var component = otherOp[i];

            var length, chunk;
            switch (typeof component) {
                case 'number': // Skip
                    length = component;
                    while (length > 0) {
                        chunk = take(length, 'i');
                        append(chunk);
                        if (typeof chunk !== 'string') {
                            length -= componentLength(chunk);
                        }
                    }
                    break;

                case 'string': // Insert
                    if (side === 'left') {
                        // The left insert should go first.
                        if (typeof peek() === 'string') {
                            append(take(-1));
                        }
                    }

                    // Otherwise skip the inserted text.
                    append(component.length);
                    break;

                case 'object': // Delete
                    length = component.d;
                    while (length > 0) {
                        chunk = take(length, 'i');
                        switch (typeof chunk) {
                            case 'number':
                                length -= chunk;
                                break;
                            case 'string':
                                append(chunk);
                                break;
                            case 'object':
                                // The delete is unnecessary now - the text has already been deleted.
                                length -= chunk.d;
                        }
                    }
                    break;
            }
        }

        // Append any extra data in op1.
        while ((component = take(-1)))
            append(component);

        return trim(newOp);
    };

    /** Compose op1 and op2 together and return the result */
    exports.compose = function(op1, op2) {
        checkOp(op1);
        checkOp(op2);

        var result = [];
        var append = makeAppend(result);
        var take = makeTake(op1)[0];

        for (var i = 0; i < op2.length; i++) {
            var component = op2[i];
            var length, chunk;
            switch (typeof component) {
                case 'number': // Skip
                    length = component;
                    while (length > 0) {
                        chunk = take(length, 'd');
                        append(chunk);
                        if (typeof chunk !== 'object') {
                            length -= componentLength(chunk);
                        }
                    }
                    break;

                case 'string': // Insert
                    append(component);
                    break;

                case 'object': // Delete
                    length = component.d;

                    while (length > 0) {
                        chunk = take(length, 'd');

                        switch (typeof chunk) {
                            case 'number':
                                append({d: chunk});
                                length -= chunk;
                                break;
                            case 'string':
                                length -= chunk.length;
                                break;
                            case 'object':
                                append(chunk);
                        }
                    }
                    break;
            }
        }

        while ((component = take(-1)))
            append(component);

        return trim(result);
    };

// Calculate the cursor position after the given operation
    function applyToCursor(op) {
        var pos = 0;
        for (var i = 0; i < op.length; i++) {
            var c = op[i];
            switch (typeof c) {
                case 'number':
                    pos += c;
                    break;
                case 'string':
                    pos += c.length;
                    break;
                case 'object':
                    //pos -= c.d;
                    break;
            }
        }
        return pos;
    };


// Generate an operation that semantically inverts the given operation
// when applied to the provided snapshot.
// It needs a snapshot of the document before the operation
// was applied to invert delete operations.
    exports.semanticInvert = function (str, op) {
        if (typeof str !== 'string') {
            throw Error('Snapshot should be a string');
        }
        checkOp(op);

        // Save copy
        var originalOp = op.slice();

        // Shallow copy
        op = op.slice();

        var len = op.length;
        var cursor, prevOps, tmpStr;
        for (var i = 0; i < len; i++) {
            var c = op[i];
            switch (typeof c) {
                case 'number':
                    // In case we have cursor movement we do nothing
                    break;
                case 'string':
                    // In case we have string insertion we generate a string deletion
                    op[i] = {d: c.length};
                    break;
                case 'object':
                    // In case of a deletion we need to reinsert the deleted string
                    prevOps = originalOp.slice(0, i);
                    cursor = applyToCursor(prevOps);
                    tmpStr = exports.apply(str, trim(prevOps));
                    op[i] = tmpStr.substring(cursor, cursor + c.d);
                    break;
            }
        }

        return exports.normalize(op);
    };



    var transformPosition = function(cursor, op) {
        var pos = 0;
        for (var i = 0; i < op.length; i++) {
            var c = op[i];
            if (cursor <= pos) break;

            // I could actually use the op_iter stuff above - but I think its simpler
            // like this.
            switch (typeof c) {
                case 'number':
                    if (cursor <= pos + c)
                        return cursor;
                    pos += c;
                    break;

                case 'string':
                    pos += c.length;
                    cursor += c.length;
                    break;

                case 'object':
                    cursor -= Math.min(c.d, cursor - pos);
                    break;
            }
        }
        return cursor;
    };

    exports.transformSelection = function(selection, op, isOwnOp) {
        var pos = 0;
        if (isOwnOp) {
            // Just track the position. We'll teleport the cursor to the end anyway.
            // This works because text ops don't have any trailing skips at the end - so the last
            // component is the last thing.
            for (var i = 0; i < op.length; i++) {
                var c = op[i];
                switch (typeof c) {
                    case 'number':
                        pos += c;
                        break;
                    case 'string':
                        pos += c.length;
                        break;
                    // Just eat deletes.
                }
            }
            return pos;
        } else {
            return typeof selection === 'number' ?
                transformPosition(selection, op) : [transformPosition(selection[0], op), transformPosition(selection[1], op)];
        }
    };

    exports.selectionEq = function(c1, c2) {
        if (c1[0] != null && c1[0] === c1[1]) c1 = c1[0];
        if (c2[0] != null && c2[0] === c2[1]) c2 = c2[0];
        return c1 === c2 || (c1[0] != null && c2[0] != null && c1[0] === c2[0] && c1[1] == c2[1]);
    };



},{}]},{},[4])(4)
});


/* editor/realtime.js */
editor.once('load', function() {
    'use strict';

    editor.once('start', function() {
        var auth = false;

        var socket, connection;
        var scene = null;
        var data;
        var reconnectAttempts = 0;
        var reconnectInterval = 3;

        editor.method('realtime:connection', function () {
            return connection;
        });

        var connect = function () {
            if (reconnectAttempts > 4) {
                editor.emit('realtime:cannotConnect');
                return;
            }

            reconnectAttempts++;
            editor.emit('realtime:connecting', reconnectAttempts);

            var sharejsMessage = connection.socket.onmessage;

            connection.socket.onmessage = function(msg) {
                try {
                    if (msg.data.startsWith('auth')) {
                        if (!auth) {
                            auth = true;
                            data = JSON.parse(msg.data.slice(4));

                            editor.emit('realtime:authenticated');

                            // load scene
                            if (! scene && config.scene.id)
                                editor.call('realtime:loadScene', config.scene.id);
                        }
                    } else if (msg.data.startsWith('whoisonline:')) {
                        var parts = msg.data.split(':');
                        if (parts.length === 5 && parts[1] === 'scene') {
                            var data;
                            var scene = parts[2];
                            var op = parts[3];
                            if (op === 'set') {
                                data = JSON.parse(parts[4]);
                            } else if (op === 'add' || op === 'remove') {
                                data = parseInt(parts[4], 10);
                            }
                            editor.call('whoisonline:' + op, data);
                        }
                    } else if (msg.data.startsWith('chat:')) {
                        data = msg.data.slice('chat:'.length);

                        var ind = data.indexOf(':');
                        if (ind !== -1) {
                            var op = data.slice(0, ind);
                            data = JSON.parse(data.slice(ind + 1));

                            if (op === 'typing') {
                                editor.call('chat:sync:typing', data);
                            } else if (op === 'msg') {
                                editor.call('chat:sync:msg', data);
                            }
                        }
                    } else if (msg.data.startsWith('selection')) {
                        var data = msg.data.slice('selection:'.length);
                        editor.emit('selector:sync:raw', data);
                    } else if (msg.data.startsWith('fs:')) {
                        data = msg.data.slice('fs:'.length);
                        var ind = data.indexOf(':');
                        if (ind !== -1) {
                            var op = data.slice(0, ind);
                            if (op === 'paths') {
                                data = JSON.parse(data.slice(ind + 1));
                                editor.call('assets:fs:paths:patch', data);
                            }
                        } else {
                            sharejsMessage(msg);
                        }
                    } else {
                        sharejsMessage(msg);
                    }
                } catch (e) {
                    console.error(e);
                }

            };

            connection.on('connected', function() {
                reconnectAttempts = 0;
                reconnectInterval = 3;

                this.socket.send('auth' + JSON.stringify({
                    accessToken: config.accessToken
                }));

                editor.emit('realtime:connected');
            });

            connection.on('error', function(msg) {
                if (connection.state === 'connected')
                    return;

                editor.emit('realtime:error', msg);
            });

            connection.on('bs error', function (msg) {
                editor.call('status:error', msg);
            });

            var onConnectionClosed = connection.socket.onclose;
            connection.socket.onclose = function (reason) {
                auth = false;

                if (scene) {
                    scene.destroy();
                    scene = null;
                }

                editor.emit('realtime:disconnected', reason);
                onConnectionClosed(reason);

                // try to reconnect after a while
                editor.emit('realtime:nextAttempt', reconnectInterval);

                if (editor.call('visibility')) {
                    setTimeout(reconnect, reconnectInterval * 1000);
                } else {
                    editor.once('visible', reconnect);
                }

                reconnectInterval++;
            };
        };

        var reconnect = function () {
            // create new socket...
            socket = new WebSocket(config.url.realtime.http);
            // ... and new sharejs connection
            connection = new sharejs.Connection(socket);
            // connect again
            connect();
        };

        if (editor.call('visibility')) {
            reconnect();
        } else {
            editor.once('visible', reconnect);
        }

        var emitOp = function(type, op) {
            // console.log('in: [ ' + Object.keys(op).filter(function(i) { return i !== 'p' }).join(', ') + ' ]', op.p.join('.'));
            // console.log(op);

            if (op.p[0])
                editor.emit('realtime:' + type + ':op:' + op.p[0], op);
        };

        editor.method('realtime:loadScene', function (id) {
            scene = connection.get('scenes', '' + id);

            // error
            scene.on('error', function(err) {
                editor.emit('realtime:scene:error', err);
            });

            // ready to sync
            scene.on('ready', function() {
                // notify of operations
                scene.on('after op', function(ops, local) {
                    if (local) return;

                    for (var i = 0; i < ops.length; i++)
                        emitOp('scene', ops[i]);
                });

                // notify of scene load
                editor.emit('scene:load', id);
                editor.emit('scene:raw', scene.getSnapshot());
            });

            // subscribe for realtime events
            scene.subscribe();
        });

        // write scene operations
        editor.method('realtime:scene:op', function(op) {
            if (! editor.call('permissions:write') || ! scene)
                return;

            // console.trace();
            // console.log('out: [ ' + Object.keys(op).filter(function(i) { return i !== 'p' }).join(', ') + ' ]', op.p.join('.'));
            // console.log(op)

            try {
                scene.submitOp([ op ]);
            } catch (e) {
                console.error(e);
                editor.emit('realtime:scene:error', e);
            }
        });

        editor.method('realtime:send', function(name, data) {
            // console.log(name, data);
            if (socket.readyState === 1)
                socket.send(name + JSON.stringify(data));
        });

        editor.on('realtime:disconnected', function () {
            editor.emit('permissions:writeState', false);
        });

        editor.on('realtime:connected', function () {
            editor.emit('permissions:writeState', editor.call('permissions:write'));
        });

        editor.on('scene:unload', function (id) {
            if (scene) {
                scene.destroy();
                scene = null;

                connection.socket.send('close:scene:' + id);
            }
        });
    });
});


/* editor/project/project.js */
editor.once('load', function() {
    'use strict';

    // Saves specified data to server
    editor.method('project:save', function (data, success, error) {
        Ajax({
            url: '{{url.api}}/projects/{{project.id}}',
            auth: true,
            method: 'PUT',
            data: data
        })
            .on('load', function () {
                if (success)
                    success();
            })
            .on('error', function () {
                if (error)
                    error();
            });
    });

    editor.method('project:setPrimaryScene', function (sceneId, success, error) {
        var prevPrimary = config.project.primaryScene;
        config.project.primaryScene = parseInt(sceneId, 10);
        editor.call('project:save', {
            primary_pack: config.project.primaryScene
        }, success, function (err) {
            config.project.primaryScene = prevPrimary;
            error(err);
        });
    });

    editor.on('messenger:project.primary_pack', function (data) {
        var primaryScene = parseInt(data.project.primary_pack, 10);
        var prev = config.project.primaryScene;

        config.project.primaryScene = primaryScene;

        editor.emit('project:primaryScene', primaryScene, prev);
    });

    editor.method('project:setPrimaryApp', function (appId, success, error) {
        var prevPrimary = config.project.primaryApp;
        config.project.primaryApp = parseInt(appId, 10);
        editor.call('project:save', {
            primary_app: config.project.primaryApp
        }, success, function (err) {
            config.project.primaryApp = prevPrimary;
            error(err);
        });
    });

    editor.on('messenger:project.primary_app', function (data) {
        var primaryApp = parseInt(data.project.primary_app, 10);
        var prev = config.project.primaryApp;

        config.project.primaryApp = primaryApp;

        editor.emit('project:primaryApp', primaryApp, prev);
    });

});


/* editor/settings/settings.js */
editor.once('load', function () {
    'use strict';

    editor.method('settings:create', function (args) {
        // settings observer
        var settings = new Observer(args.data);
        settings.scopeId = args.scopeId;

        // Get settings
        editor.method('settings:' + args.name, function () {
            return settings;
        });

        var doc;

        settings.reload = function (scopeId) {
            settings.scopeId = scopeId;

            var connection = editor.call('realtime:connection');
            var name = args.scopeType + '_' + args.scopeId;
            if (args.userId)
                name += '_' + args.userId;

            if (doc)
                doc.destroy();

            doc = connection.get('settings', name);

            // handle errors
            doc.on('error', function (err) {
                console.error(err);
                editor.emit('settings:' + args.scopeType + ':error', err);
            });

            // load settings
            doc.on('subscribe', function () {
                doc.whenReady(function () {
                    var data = doc.getSnapshot();

                    // remove unnecessary fields
                    delete data._id;
                    delete data.name;
                    delete data.user;
                    delete data.project;

                    if (! settings.sync) {
                        settings.sync = new ObserverSync({
                            item: settings,
                            paths: Object.keys(settings._data)
                        });

                        // local -> server
                        settings.sync.on('op', function (op) {
                            if (doc)
                                doc.submitOp([ op ]);
                        });
                    }

                    var history = settings.history;
                    if (history) {
                        settings.history = false;
                    }

                    settings.sync._enabled = false;
                    for (var key in data) {
                        if (data[key] instanceof Array) {
                            settings.set(key, data[key].slice(0));
                        } else {
                            settings.set(key, data[key]);
                        }
                    }
                    settings.sync._enabled = true;
                    if (history)
                        settings.history = true;

                    // server -> local
                    doc.on('after op', function (ops, local) {
                        if (local) return;

                        var history = settings.history;
                        if (history)
                            settings.history = false;
                        for (var i = 0; i < ops.length; i++) {
                            settings.sync.write(ops[i]);
                        }
                        if (history)
                            settings.history = true;
                    });

                    editor.emit('settings:' + args.scopeType + ':load');
                });
            });

            // subscribe for realtime events
            doc.subscribe();
        };

        if (! args.deferLoad) {
            editor.on('realtime:authenticated', function () {
                settings.reload(settings.scopeId);
            });
        }

        editor.on('realtime:disconnected', function () {
            if (doc) {
                doc.destroy();
                doc = null;
            }
        });

        settings.disconnect = function () {
            if (doc) {
                doc.destroy();
                doc = null;
            }

            if (settings.sync) {
                settings.sync.unbind();
                delete settings.sync;
            }
        };


        return settings;
    });

});


/* editor/settings/user-settings.js */
editor.once('load', function () {
    'use strict';

    var settings = editor.call('settings:create', {
        name: 'user',
        scopeType: 'user',
        scopeId: config.self.id,
        data: {
            editor: {
                howdoi: true,
                iconSize: 0.2
            }
        }
    });

    // add history
    settings.history = true;
    settings.on('*:set', function(path, value, oldValue) {
        if (! settings.history)
            return;

        editor.call('history:add', {
            name: 'user settings:' + path,
            undo: function() {
                settings.history = false;
                settings.set(path, oldValue);
                settings.history = true;
            },
            redo: function() {
                settings.history = false;
                settings.set(path, value);
                settings.history = true;
            }
        });
    });
});


/* editor/settings/project-user-settings.js */
editor.once('load', function () {
    'use strict';

    var settings = editor.call('settings:create', {
        name: 'projectUser',
        scopeType: 'project',
        scopeId: config.project.id,
        data: {
            editor: {
                cameraNearClip: 0.1,
                cameraFarClip: 1000,
                cameraClearColor: [
                    0.118,
                    0.118,
                    0.118,
                    1
                ],
                gridDivisions: 8,
                gridDivisionSize: 1,
                snapIncrement: 1,
                localServer: 'http://localhost:51000',
                launchDebug: true
            }
        },
        userId: config.self.id
    });

    // add history
    settings.history = true;
    settings.on('*:set', function(path, value, oldValue) {
        if (! settings.history)
            return;

        editor.call('history:add', {
            name: 'project user settings:' + path,
            undo: function() {
                settings.history = false;
                settings.set(path, oldValue);
                settings.history = true;
            },
            redo: function() {
                settings.history = false;
                settings.set(path, value);
                settings.history = true;
            }
        });
    });
});


/* editor/settings/editor-settings-attributes.js */
editor.once('load', function() {
    'use strict';

    var settings = editor.call('settings:projectUser');
    var userSettings = editor.call('settings:user');

    var sceneName = 'Untitled';
    editor.on('scene:raw', function(data) {
        editor.emit('scene:name', data.name);
    });
    editor.on('realtime:scene:op:name', function(op) {
        editor.emit('scene:name', op.oi);
    });
    editor.on('scene:name', function(name) {
        sceneName = name;
    });

    var foldStates = {
        'editor': true
    };

    // inspecting
    editor.on('attributes:inspect[editorSettings]', function() {

        var panelScene = editor.call('attributes:addPanel');
        panelScene.class.add('component');

        // scene name
        var fieldName = editor.call('attributes:addField', {
            parent: panelScene,
            name: 'Scene Name',
            type: 'string',
            value: sceneName
        });
        var changingName = false;
        fieldName.on('change', function(value) {
            if (changingName)
                return;

            editor.call('realtime:scene:op', {
                p: [ 'name' ],
                od: sceneName || '',
                oi: value || ''
            });
            editor.emit('scene:name', value);
        });
        var evtNameChange = editor.on('realtime:scene:op:name', function(op) {
            changingName = true;
            fieldName.value = op.oi;
            changingName = false;
        });
        fieldName.on('destroy', function() {
            evtNameChange.unbind();
        });
        // reference
        editor.call('attributes:reference:attach', 'settings:name', fieldName.parent.innerElement.firstChild.ui);


        // editor
        var panel = editor.call('attributes:addPanel', {
            name: 'Editor'
        });
        panel.foldable = true;
        panel.folded = foldStates['editor'];
        panel.on('fold', function() { foldStates['editor'] = true; });
        panel.on('unfold', function() { foldStates['editor'] = false; });
        panel.class.add('component');
        // reference
        editor.call('attributes:reference:attach', 'settings:projectUser', panel, panel.headerElement);

        // grid divisions
        var fieldGrid = editor.call('attributes:addField', {
            parent: panel,
            name: 'Grid',
            placeholder: 'Divisions',
            type: 'number',
            precision: 1,
            step: 1,
            min: 0,
            link: settings,
            path: 'editor.gridDivisions'
        });
        fieldGrid.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'settings:grid', fieldGrid.parent.innerElement.firstChild.ui);


        // grid divisions size
        var fieldGridDivisionSize = new ui.NumberField({
            precision: 1,
            step: 1,
            min: 0
        });
        fieldGridDivisionSize.placeholder = 'Size';
        fieldGridDivisionSize.style.width = '32px';
        fieldGridDivisionSize.flexGrow = 1;
        fieldGridDivisionSize.link(settings, 'editor.gridDivisionSize');
        fieldGrid.parent.append(fieldGridDivisionSize);


        // snap increment
        var fieldSnap = editor.call('attributes:addField', {
            parent: panel,
            name: 'Snap',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            placeholder: 'Increment',
            link: settings,
            path: 'editor.snapIncrement'
        });
        // reference
        editor.call('attributes:reference:attach', 'settings:snap', fieldSnap.parent.innerElement.firstChild.ui);


        // camera near clip
        var fieldClip = editor.call('attributes:addField', {
            parent: panel,
            name: 'Camera Clip',
            placeholder: 'Near',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            link: settings,
            path: 'editor.cameraNearClip'
        });
        fieldClip.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'settings:cameraClip', fieldClip.parent.innerElement.firstChild.ui);


        // camera far clip
        var fieldFarClip = new ui.NumberField({
            precision: 2,
            step: 1,
            min: 0
        });
        fieldFarClip.placeholder = 'Far';
        fieldFarClip.style.width = '32px';
        fieldFarClip.flexGrow = 1;
        fieldFarClip.link(settings, 'editor.cameraFarClip');
        fieldClip.parent.append(fieldFarClip);


        // clear color
        var fieldClearColor = editor.call('attributes:addField', {
            parent: panel,
            name: 'Clear Color',
            type: 'rgb',
            link: settings,
            path: 'editor.cameraClearColor'
        });
        // reference
        editor.call('attributes:reference:attach', 'settings:clearColor', fieldClearColor.parent.innerElement.firstChild.ui);


        // icons size
        var fieldIconsSize = editor.call('attributes:addField', {
            parent: panel,
            name: 'Icons Size',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            link: userSettings,
            path: 'editor.iconSize'
        });
        // reference
        editor.call('attributes:reference:attach', 'settings:iconsSize', fieldIconsSize.parent.innerElement.firstChild.ui);


        // local server
        var fieldLocalServer = editor.call('attributes:addField', {
            parent: panel,
            name: 'Local Server',
            type: 'string',
            link: settings,
            path: 'editor.localServer'
        });

        var changingLocalServer = false;
        var oldLocalServer = fieldLocalServer.value;
        fieldLocalServer.on('change', function (value) {
            if (changingLocalServer) return;

            changingLocalServer = true;
            if (! /^http(s)?:\/\/\S+/.test(value)) {
                fieldLocalServer.value = oldLocalServer;
            } else {
                oldLocalServer = value;
            }

            changingLocalServer = false;
        });

        // reference
        editor.call('attributes:reference:attach', 'settings:localServer', fieldLocalServer.parent.innerElement.firstChild.ui);


        // chat notification
        var fieldChatNotification = editor.call('attributes:addField', {
            parent: panel,
            name: 'Chat Notification',
            type: 'checkbox'
        });
        var checkChatNotificationState = function() {
            var permission = editor.call('notify:state');

            fieldChatNotification.disabled = permission === 'denied';

            if (permission !== 'granted' && permission !== 'denied')
                fieldChatNotification.value = null;

            if (permission === 'granted') {
                // restore localstorage state
                var granted = editor.call('localStorage:get', 'editor:notifications:chat');
                if (granted === null) {
                    fieldChatNotification.value = true;
                } else {
                    fieldChatNotification.value = granted;
                }
            }
        };
        var evtPermission = editor.on('notify:permission', checkChatNotificationState);
        var evtChatNofityState = editor.on('chat:notify', checkChatNotificationState);
        checkChatNotificationState();
        fieldChatNotification.on('change', function(value) {
            if (editor.call('notify:state') !== 'granted') {
                editor.call('notify:permission');
            } else {
                editor.call('localStorage:set', 'editor:notifications:chat', value);
                editor.emit('chat:notify', value);
                checkChatNotificationState();
            }
        });
        fieldChatNotification.once('destroy', function() {
            evtPermission.unbind();
            evtChatNofityState.unbind();
            evtPermission = null;
            evtChatNofityState = null;
        });
    });
});


/* editor/settings/project-settings.js */
editor.once('load', function () {
    'use strict';

    var syncPaths = [
        'antiAlias',
        'fillMode',
        'resolutionMode',
        'height',
        'width',
        'use3dPhysics',
        'preferWebGl2',
        'preserveDrawingBuffer',
        'scripts',
        'transparentCanvas',
        'useDevicePixelRatio',
        'useLegacyScripts',
        'vr',
        'loadingScreenScript',
        'plugins',
        'useModelV2'
    ];

    var data = {};
    for (var i = 0; i < syncPaths.length; i++)
        data[syncPaths[i]] = config.project.settings.hasOwnProperty(syncPaths[i]) ? config.project.settings[syncPaths[i]] : null;

    var settings = editor.call('settings:create', {
        name: 'project',
        scopeType: 'project',
        scopeId: config.project.id,
        data: data
    });

    if (! settings.get('useLegacyScripts')) {
        pc.script.legacy = false;
    } else {
        pc.script.legacy = true;
    }

    // add history
    settings.history = true;
    settings.on('*:set', function(path, value, oldValue) {
        // update config.project.settings
        config.project.settings[path] = value;

        if (! settings.history)
            return;

        editor.call('history:add', {
            name: 'project settings:' + path,
            undo: function() {
                settings.history = false;
                settings.set(path, oldValue);
                settings.history = true;
            },
            redo: function() {
                settings.history = false;
                settings.set(path, value);
                settings.history = true;
            }
        });
    });
});


/* editor/settings/project-private-settings.js */
editor.once('load', function () {
    'use strict';

    var defaultData = {
        facebook: {
            appId: '',
            uploadToken: '',
            sdkVersion: ''
        }
    };

    var isConnected = false;

    var settings = editor.call('settings:create', {
        name: 'projectPrivate',
        scopeType: 'project-private',
        scopeId: config.project.id,
        deferLoad: true,
        data: defaultData
    });


    // add history
    settings.history = true;
    settings.on('*:set', function(path, value, oldValue) {
        if (! settings.history)
            return;

        editor.call('history:add', {
            name: 'private project settings:' + path,
            undo: function() {
                settings.history = false;
                settings.set(path, oldValue);
                settings.history = true;
            },
            redo: function() {
                settings.history = false;
                settings.set(path, value);
                settings.history = true;
            }
        });
    });

    settings.on('facebook.appId:set', function (value) {
        if (value && ! settings.get('facebook.sdkVersion')) {
            // set default sdk version
            var history = settings.history;
            settings.set('facebook.sdkVersion', config.facebook.version);
            settings.history = history;
        }
    });


    var reload = function () {
        if (! isConnected) return;

        if (config.project.hasPrivateSettings && editor.call('permissions:write')) {
            settings.reload(settings.scopeId);
        }

        if (! config.project.hasPrivateSettings) {
            var pendingChanges = {};

            var evtOnSet = settings.on('*:set', function (path, value, valueOld) {
                // store pending changes until we load document from C3 in order to send
                // them to the server
                if (! settings.sync) {
                    pendingChanges[path] = value;
                }

                if (! config.project.hasPrivateSettings) {
                    config.project.hasPrivateSettings = true;
                    settings.reload(settings.scopeId);
                }
            });

            // when settings are created and loaded from the server sync any pending changes
            editor.once('settings:project-private:load', function () {
                evtOnSet.unbind();

                var history = settings.history;
                settings.history = false;
                for (var key in pendingChanges) {
                    settings.set(key, pendingChanges[key]);
                }
                settings.history = history;

                pendingChanges = null;
            });
        }
    };

    // handle permission changes
    editor.on('permissions:set:' + config.self.id, function (accesslevel) {
        if (accesslevel !== 'admin' && accesslevel !== 'write') {
            // unset private settings
            settings.disconnect();
            settings.history = false;
            settings.unset('facebook');
        } else {
            // reload settings
            settings.history = true;
            reload();
        }
    });

    editor.on('realtime:authenticated', function () {
        isConnected = true;
        reload();
    });

    editor.on('realtime:disconnected', function () {
        isConnected = false;
    });

    if (! config.project.hasPrivateSettings) {
        editor.on('messenger:settings.create', function (msg) {
            if (config.project.hasPrivateSettings) return; // skip if we've already created the settings locally

            if (msg.settings.name === 'project-private') {
                config.project.hasPrivateSettings = true;
                reload();
            }
        });
    }

});


/* editor/selector/selector.js */
editor.once('load', function() {
    'use strict';

    var enabled = true;
    var legacyScripts = editor.call('settings:project').get('useLegacyScripts');
    var selector = new ObserverList();
    selector.type = null;


    var index = { };

    var keyByType = function(type) {
        switch(type) {
            case 'entity':
                return 'resource_id';
            case 'asset':
                return 'id';
        }
        return null;
    };

    var setIndex = function(type, item) {
        var key = keyByType(type);
        if (! key) return;

        if (! index[type])
            index[type] = { };

        index[type][item.get[key]] = item.once('destroy', function() {
            var state = editor.call('selector:history');
            if (state)
                editor.call('selector:history', false);

            selector.remove(item);
            delete index[type][item.get[key]];

            if (state)
                editor.call('selector:history', true);
        });
    };

    var removeIndex = function(type, item) {
        if (! index[type]) return;

        var key = keyByType(type);
        if (! key) return;

        var ind = index[type][item.get[key]];
        if (! ind) return;

        ind.unbind();
    };

    var evtChange = false;
    var evtChangeFn = function() {
        evtChange = false;
        editor.emit('selector:change', selector.type, selector.array());
    };

    // adding
    selector.on('add', function(item) {
        // add index
        setIndex(this.type, item);

        editor.emit('selector:add', item, this.type);

        if (! evtChange) {
            evtChange = true;
            setTimeout(evtChangeFn, 0);
        }
    });


    // removing
    selector.on('remove', function(item) {
        editor.emit('selector:remove', item, this.type);

        // remove index
        removeIndex(this.type, item);

        if (this.length === 0)
            this.type = null;

        if (! evtChange) {
            evtChange = true;
            setTimeout(evtChangeFn, 0);
        }
    });


    // selecting item (toggle)
    editor.method('selector:toggle', function(type, item) {
        if (! enabled)
            return;

        if (selector.length && selector.type !== type) {
            selector.clear();
        }
        selector.type = type;

        if (selector.has(item)) {
            selector.remove(item);
        } else {
            selector.add(item);
        }
    });


    // selecting list of items
    editor.method('selector:set', function(type, items) {
        if (! enabled)
            return;

        selector.clear();

        if (! type || ! items.length)
            return;

        // make sure items still exist
        if (type === 'asset') {
            items = items.filter(function(item) {
                return (legacyScripts && item.get('type') === 'script') || !! editor.call('assets:get', item.get('id'));
            });
        } else if (type === 'entity') {
            items = items.filter(function(item) {
                return !! editor.call('entities:get', item.get('resource_id'));
            });
        }

        if (! items.length)
            return;

        // type
        selector.type = type;

        // remove
        selector.find(function(item) {
            return items.indexOf(item) === -1;
        }).forEach(function(item) {
            selector.remove(item);
        });

        // add
        for(var i = 0; i < items.length; i++)
            selector.add(items[i]);
    });


    // selecting item
    editor.method('selector:add', function(type, item) {
        if (! enabled)
            return;

        if (selector.has(item))
            return;

        if (selector.length && selector.type !== type)
            selector.clear();

        selector.type = type;
        selector.add(item);
    });


    // deselecting item
    editor.method('selector:remove', function(item) {
        if (! enabled)
            return;

        if (! selector.has(item))
            return;

        selector.remove(item);
    });


    // deselecting
    editor.method('selector:clear', function(item) {
        if (! enabled)
            return;

        selector.clear();
    });


    // return select type
    editor.method('selector:type', function() {
        return selector.type;
    });


    // return selected count
    editor.method('selector:count', function() {
        return selector.length;
    });


    // return selected items
    editor.method('selector:items', function() {
        return selector.array();
    });

    // return selected items without making copy of array
    editor.method('selector:itemsRaw', function() {
        return selector.data;
    });

    // return if it has item
    editor.method('selector:has', function(item) {
        return selector.has(item);
    });


    editor.method('selector:enabled', function(state) {
        enabled = state;
    });
});


/* editor/selector/selector-sync.js */
editor.once('load', function() {
    'use strict';

    var lastSelectionType = null;
    var lastIds = [ ];
    var selection = { };
    var timeout;
    var lastCheck = 0;


    var checkSelector = function() {
        timeout = null;
        lastCheck = Date.now();

        var type = editor.call('selector:type');
        var items = editor.call('selector:items');

        var selectionType = editor.call('selector:type');
        var ids = [ ];

        if (type === 'entity') {
            for(var i = 0; i < items.length; i++)
                ids.push(items[i].get('resource_id'));
        } else if (type === 'asset') {
            for(var i = 0; i < items.length; i++) {
                var id = items[i].get('id');
                if (items[i].get('type') === 'script' && ! id) {
                    ids.push(items[i].get('filename'));
                } else {
                    ids.push(id);
                }
            }
        } else if (type === 'editorSettings') {
            // editor settings always single
        } else {
            selectionType = null;
        }

        var changed = false;
        if (lastSelectionType !== selectionType)
            changed = true;

        if (! changed) {
            if (ids.length !== lastIds.length) {
                changed = true;
            } else {
                for(var i = 0; i < ids.length; i++) {
                    if (ids[i] !== lastIds[i]) {
                        changed = true;
                        break;
                    }
                }
            }
        }

        lastSelectionType = selectionType;
        lastIds = ids;

        if (changed) {
            editor.call('realtime:send', 'selection', {
                t: selectionType,
                ids: ids
            });
        }
    };

    editor.on('selector:change', function(type, items) {
        if (timeout)
            return;

        if ((Date.now() - lastCheck) > 500) {
            checkSelector();
        } else {
            timeout = setTimeout(checkSelector, 500);
        }
    });

    editor.on('selector:sync:raw', function(data) {
        data = JSON.parse(data);
        var id = data.u;

        // select
        selection[id] = {
            type: data.t,
            ids: data.ids
        };

        editor.emit('selector:sync[' + id + ']', selection[id]);
        editor.emit('selector:sync', id, selection[id]);
    });
});


/* editor/selector/selector-history.js */
editor.once('load', function() {
    'use strict';

    var selectorHistory = true;
    var changing = false;

    var newType = editor.call('selector:type');
    var newItems = editor.call('selector:items');

    var onSelectorChange = function() {
        changing = false;

        var oldType = newType;
        var oldItems = newItems;

        var type = editor.call('selector:type');
        var items = editor.call('selector:items');

        newType = type;
        newItems = items;

        editor.call('history:add', {
            name: (items.length === 0) ? 'deselect' : ('select ' + type),
            select: true,
            undo: function() {
                var prev = selectorHistory;
                selectorHistory = false;
                editor.call('selector:set', oldType, oldItems);
                editor.once('selector:change', function() {
                    selectorHistory = prev;
                });
            },
            redo: function() {
                var prev = selectorHistory;
                selectorHistory = false;
                editor.call('selector:set', type, items);
                editor.once('selector:change', function() {
                    selectorHistory = prev;
                });
            }
        });
    };

    editor.on('selector:change', function(type, items) {
        if (! selectorHistory) {
            newType = type;
            newItems = items;
            return;
        }

        if (changing)
            return;

        changing = true;
        setTimeout(onSelectorChange, 0);
    });

    editor.method('selector:history', function (toggle) {
        if (toggle === undefined)
            return selectorHistory;

        selectorHistory = toggle;
    });
});


/* editor/scene-settings/scene-settings.js */
editor.once('load', function() {
    'use strict';

    var sceneSettings = new Observer();

    // get scene settings
    editor.method('sceneSettings', function() {
        return sceneSettings;
    });


    // loaded scene
    editor.on('scene:raw', function(data) {
        var sync = sceneSettings.sync ? sceneSettings.sync.enabled : false;
        if (sync)
            sceneSettings.sync.enabled = false;

        var history = sceneSettings.history ? sceneSettings.history.enabled : false;
        if (history)
            sceneSettings.history.enabled = false;

        sceneSettings.patch(data.settings);

        if (data.settings.priority_scripts === undefined && sceneSettings.has('priority_scripts'))
            sceneSettings.unset('priority_scripts');

        if (sync)
            sceneSettings.sync.enabled = sync;

        if (history)
            sceneSettings.history.enabled = true;

        editor.emit('sceneSettings:load', sceneSettings);
    });

    // migrations
    editor.on('sceneSettings:ready', function() {
        // lightmapSizeMultiplier
        if (! sceneSettings.has('render.lightmapSizeMultiplier'))
            sceneSettings.set('render.lightmapSizeMultiplier', 16);

        // lightmapMaxResolution
        if (! sceneSettings.has('render.lightmapMaxResolution'))
            sceneSettings.set('render.lightmapMaxResolution', 2048);

        // lightmapMode
        if (! sceneSettings.has('render.lightmapMode'))
            sceneSettings.set('render.lightmapMode', 0);

        // skyboxIntensity
        if (! sceneSettings.has('render.skyboxIntensity'))
            sceneSettings.set('render.skyboxIntensity', 1);

        // skyboxMip
        if (! sceneSettings.has('render.skyboxMip'))
            sceneSettings.set('render.skyboxMip', 0);
    });

    var onUnload = function() {
        if (sceneSettings.history)
            sceneSettings.history.enabled = false;
        if (sceneSettings.sync)
            sceneSettings.sync.enabled = false;

        sceneSettings.set('render.skybox', null);

        if (sceneSettings.history)
            sceneSettings.history.enabled = true;
        if (sceneSettings.sync)
            sceneSettings.sync.enabled = true;
    };

    editor.on('realtime:disconnected', onUnload);
    editor.on('scene:unload', onUnload);
});


/* editor/scene-settings/scene-settings-history.js */
editor.once('load', function() {
    'use strict';

    editor.on('sceneSettings:load', function(settings) {
        if (settings.history)
            settings.history.destroy();

        settings.history = new ObserverHistory({
            item: settings,
            prefix: 'settings.',
            getItemFn: function () {
                return editor.call('sceneSettings');
            }
        });

        // record history
        settings.history.on('record', function(action, data) {
            editor.call('history:' + action, data);
        });
    });
});


/* editor/scene-settings/scene-settings-sync.js */
editor.once('load', function() {
    'use strict';

    editor.on('sceneSettings:load', function(settings) {
        settings.sync = new ObserverSync({
            item: settings,
            prefix: [ 'settings' ]
        });

        var events = [ ];

        // client > server
        events.push(settings.sync.on('op', function(op) {
            editor.call('realtime:scene:op', op);
        }));

        // server > client
        events.push(editor.on('realtime:scene:op:settings', function(op) {
            settings.sync.write(op);
        }));

        editor.on('scene:unload', function () {
            for (var i = 0; i < events.length; i++)
                events[i].unbind();
        });

        editor.emit('sceneSettings:ready');
    });
});


/* editor/scene-settings/scene-settings-attributes.js */
editor.once('load', function() {
    'use strict';

    var sceneSettings = editor.call('sceneSettings');
    var projectSettings = editor.call('settings:project');

    editor.method('editorSettings:panel:unfold', function(panel) {
        var element = editor.call('layout.right').innerElement.querySelector('.ui-panel.component.foldable.' + panel);
        if (element && element.ui) {
            element.ui.folded = false;
        }
    });

    var foldStates = {
        'physics': true,
        'rendering': true,
        'lightmapping': true,
        'loading': true,
        'audio': true
    };

    editor.on('attributes:inspect[editorSettings]', function() {
        editor.call('attributes:header', 'Settings');

        var app = editor.call('viewport:app');
        if (! app) return; // webgl not available

        var root = editor.call('layout.root');

        var filteredFields = [ ];

        var addFiltered = function (field, filter) {
            filteredFields.push({
                element: field.length ? field[0].parent : field.parent,
                filter: filter
            });
            return field;
        };

        var filter = function () {
            filteredFields.forEach(function (f) {
                f.element.hidden = !f.filter();
            });
        };


        // physics
        var physicsPanel = editor.call('attributes:addPanel', {
            name: 'Physics'
        });
        physicsPanel.foldable = true;
        physicsPanel.folded = foldStates['physics'];
        physicsPanel.on('fold', function() { foldStates['physics'] = true; });
        physicsPanel.on('unfold', function() { foldStates['physics'] = false; });
        physicsPanel.class.add('component');

        // enable 3d physics
        var fieldPhysics = editor.call('attributes:addField', {
            parent: physicsPanel,
            name: 'Enable',
            type: 'checkbox',
            link: projectSettings,
            path: 'use3dPhysics'
        });
        editor.call('attributes:reference:attach', 'settings:project:physics', fieldPhysics.parent.innerElement.firstChild.ui);

        // gravity
        var fieldGravity = editor.call('attributes:addField', {
            parent: physicsPanel,
            name: 'Gravity',
            placeholder: [ 'X', 'Y', 'Z' ],
            precision: 2,
            step: .1,
            type: 'vec3',
            link: sceneSettings,
            path: 'physics.gravity'
        });
        // reference
        editor.call('attributes:reference:attach', 'settings:gravity', fieldGravity[0].parent.innerElement.firstChild.ui);


        // environment
        var panelRendering = editor.call('attributes:addPanel', {
            name: 'Rendering'
        });
        panelRendering.foldable = true;
        panelRendering.folded = foldStates['rendering'];
        panelRendering.on('fold', function() { foldStates['rendering'] = true; });
        panelRendering.on('unfold', function() { foldStates['rendering'] = false; });
        panelRendering.class.add('component', 'rendering');


        // ambient
        var fieldGlobalAmbient = editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Ambient Color',
            type: 'rgb',
            link: sceneSettings,
            path: 'render.global_ambient'
        });
        // reference
        editor.call('attributes:reference:attach', 'settings:ambientColor', fieldGlobalAmbient.parent.innerElement.firstChild.ui);


        // skyboxHover
        var skyboxOld = null;
        var hoverSkybox = null;
        var setSkybox = function() {
            if (! hoverSkybox)
                return;

            app.scene.setSkybox(hoverSkybox.resources);
            editor.call('viewport:render');
        }
        // skybox
        var fieldSkybox = editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Skybox',
            type: 'asset',
            kind: 'cubemap',
            link: sceneSettings,
            path: 'render.skybox',
            over: function(type, data) {
                skyboxOld = app.assets.get(sceneSettings.get('render.skybox')) || null;

                hoverSkybox = app.assets.get(parseInt(data.id, 10));
                if (hoverSkybox) {
                    if (sceneSettings.get('render.skyboxMip') === 0)
                        hoverSkybox.loadFaces = true;

                    app.assets.load(hoverSkybox);
                    hoverSkybox.on('load', setSkybox);
                    setSkybox();
                }
            },
            leave: function() {
                if (skyboxOld) {
                    app.scene.setSkybox(skyboxOld.resources)
                    skyboxOld = null;
                    editor.call('viewport:render');
                }
                if (hoverSkybox) {
                    hoverSkybox.off('load', setSkybox);
                    hoverSkybox = null;
                }
            }
        });
        // reference
        editor.call('attributes:reference:attach', 'settings:skybox', fieldSkybox._label);


        // skyboxIntensity
        var fieldSkyboxIntensity = editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Intensity',
            type: 'number',
            precision: 3,
            step: .05,
            min: 0,
            link: sceneSettings,
            path: 'render.skyboxIntensity'
        });
        fieldSkyboxIntensity.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'settings:skyboxIntensity', fieldSkyboxIntensity.parent.innerElement.firstChild.ui);

        // skyboxIntensity slider
        var fieldExposureSlider = new ui.Slider({
            min: 0,
            max: 8,
            precision: 3
        });
        fieldExposureSlider.flexGrow = 4;
        fieldExposureSlider.link(sceneSettings, 'render.skyboxIntensity');
        fieldSkyboxIntensity.parent.append(fieldExposureSlider);


        // skyboxMip
        var fieldSkyboxMip = editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Mip',
            type: 'number',
            enum: {
                0: '1',
                1: '2',
                2: '3',
                3: '4',
                4: '5'
            },
            link: sceneSettings,
            path: 'render.skyboxMip'
        });
        // reference
        editor.call('attributes:reference:attach', 'settings:skyboxMip', fieldSkyboxMip.parent.innerElement.firstChild.ui);


        // divider
        var divider = document.createElement('div');
        divider.classList.add('fields-divider');
        panelRendering.append(divider);


        // tonemapping
        var fieldTonemapping = editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Tonemapping',
            type: 'number',
            enum: {
                0: 'Linear',
                1: 'Filmic',
                2: 'Hejl',
                3: 'ACES'
            },
            link: sceneSettings,
            path: 'render.tonemapping'
        });
        // reference
        editor.call('attributes:reference:attach', 'settings:toneMapping', fieldTonemapping.parent.innerElement.firstChild.ui);


        // exposure
        var fieldExposure = editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Exposure',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            link: sceneSettings,
            path: 'render.exposure'
        });
        fieldExposure.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'settings:exposure', fieldExposure.parent.innerElement.firstChild.ui);


        // exposure slider
        var fieldExposureSlider = new ui.Slider({
            min: 0,
            max: 8,
            precision: 2
        });
        fieldExposureSlider.flexGrow = 4;
        fieldExposureSlider.link(sceneSettings, 'render.exposure');
        fieldExposure.parent.append(fieldExposureSlider);


        // gamma correction
        var fieldGammaCorrection = editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Gamma',
            type: 'number',
            enum: {
                0: '1.0',
                1: '2.2'
            },
            link: sceneSettings,
            path: 'render.gamma_correction'
        });
        // reference
        editor.call('attributes:reference:attach', 'settings:gammaCorrection', fieldGammaCorrection.parent.innerElement.firstChild.ui);


        // divider
        var divider = document.createElement('div');
        divider.classList.add('fields-divider');
        panelRendering.append(divider);


        // fog type
        var fieldFogType = editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Fog',
            type: 'string',
            enum: {
                'none': 'None',
                'linear': 'Linear',
                'exp': 'Exponential',
                'exp2': 'Exponential Squared'
            },
            link: sceneSettings,
            path: 'render.fog'
        });
        // reference
        editor.call('attributes:reference:attach', 'settings:fog', fieldFogType.parent.innerElement.firstChild.ui);


        // fog density
        var fieldFogDensity = addFiltered(editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Density',
            type: 'number',
            precision: 3,
            step: .01,
            min: 0,
            link: sceneSettings,
            path: 'render.fog_density'
        }), function () {
            return /^exp/.test(sceneSettings.get('render.fog'));
        });
        // reference
        editor.call('attributes:reference:attach', 'settings:fogDensity', fieldFogDensity.parent.innerElement.firstChild.ui);


        // fog distance near
        var fieldFogDistance = editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Distance',
            placeholder: 'Start',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            link: sceneSettings,
            path: 'render.fog_start'
        });
        fieldFogDistance.style.width = '32px';
        addFiltered(fieldFogDistance, function () {
            return sceneSettings.get('render.fog') === 'linear';
        });
        // reference
        editor.call('attributes:reference:attach', 'settings:fogDistance', fieldFogDistance.parent.innerElement.firstChild.ui);


        // fog dinstance far
        var fieldFogEnd = new ui.NumberField({
            precision: 2,
            step: 1,
            min: 0
        });
        fieldFogEnd.placeholder = 'End';
        fieldFogEnd.style.width = '32px';
        fieldFogEnd.flexGrow = 1;
        fieldFogEnd.link(sceneSettings, 'render.fog_end');
        fieldFogDistance.parent.append(fieldFogEnd);

        // fog color
        var fieldFogColor = addFiltered(editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Color',
            type: 'rgb',
            link: sceneSettings,
            path: 'render.fog_color'
        }), function () {
            return sceneSettings.get('render.fog') !== 'none';
        });
        // reference
        editor.call('attributes:reference:attach', 'settings:fogColor', fieldFogColor.parent.innerElement.firstChild.ui);

        // divider
        var divider = document.createElement('div');
        divider.classList.add('fields-divider');
        panelRendering.append(divider);

        // Resolution related
        var fieldWidth = editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Resolution',
            placeholder: 'w',
            type: 'number',
            link: projectSettings,
            path: 'width',
            precision: 0,
            min: 1
        });

        editor.call('attributes:reference:attach', 'settings:project:width', fieldWidth);

        var fieldHeight = editor.call('attributes:addField', {
            panel: fieldWidth.parent,
            placeholder: 'h',
            type: 'number',
            link: projectSettings,
            path: 'height',
            precision: 0,
            min: 1
        });
        editor.call('attributes:reference:attach', 'settings:project:height', fieldHeight);

        var fieldResolutionMode = editor.call('attributes:addField', {
            panel: fieldWidth.parent,
            type: 'string',
            enum: {
                'FIXED': 'Fixed',
                'AUTO': 'Auto'
            },
            link: projectSettings,
            path: 'resolutionMode'
        });
        editor.call('attributes:reference:attach', 'settings:project:resolutionMode', fieldResolutionMode);


        var fieldFillMode = editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Fill mode',
            type: 'string',
            enum: {
                'NONE': 'None',
                'KEEP_ASPECT': 'Keep aspect ratio',
                'FILL_WINDOW': 'Fill window',
            },
            link: projectSettings,
            path: 'fillMode'
        });
        editor.call('attributes:reference:attach', 'settings:project:fillMode', fieldFillMode.parent.innerElement.firstChild.ui);


        var fieldPreferWebGl2 = editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Prefer WebGL 2.0',
            type: 'checkbox',
            link: projectSettings,
            path: 'preferWebGl2'
        });
        fieldPreferWebGl2.parent.innerElement.firstChild.style.width = 'auto';
        editor.call('attributes:reference:attach', 'settings:project:preferWebGl2', fieldPreferWebGl2.parent.innerElement.firstChild.ui);


        var fieldAntiAlias = editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Anti-Alias',
            type: 'checkbox',
            link: projectSettings,
            path: 'antiAlias'
        });
        fieldAntiAlias.parent.innerElement.firstChild.style.width = 'auto';
        editor.call('attributes:reference:attach', 'settings:project:antiAlias', fieldAntiAlias.parent.innerElement.firstChild.ui);

        var fieldPixelRatio = editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Device Pixel Ratio',
            type: 'checkbox',
            link: projectSettings,
            path: 'useDevicePixelRatio'
        });
        fieldPixelRatio.parent.innerElement.firstChild.style.width = 'auto';
        editor.call('attributes:reference:attach', 'settings:project:pixelRatio', fieldPixelRatio.parent.innerElement.firstChild.ui);


        var fieldTransparentCanvas = editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Transparent Canvas',
            type: 'checkbox',
            link: projectSettings,
            path: 'transparentCanvas'
        });
        fieldTransparentCanvas.parent.innerElement.firstChild.style.width = 'auto';
        editor.call('attributes:reference:attach', 'settings:project:transparentCanvas', fieldTransparentCanvas.parent.innerElement.firstChild.ui);

        var fieldPreserveDrawingBuffer = editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Preserve Drawing Buffer',
            type: 'checkbox',
            link: projectSettings,
            path: 'preserveDrawingBuffer'
        });
        fieldPreserveDrawingBuffer.parent.innerElement.firstChild.style.width = 'auto';
        editor.call('attributes:reference:attach', 'settings:project:preserveDrawingBuffer', fieldPreserveDrawingBuffer.parent.innerElement.firstChild.ui);

        var fieldVr = editor.call('attributes:addField', {
            parent: panelRendering,
            name: 'Enable VR',
            type: 'checkbox',
            link: projectSettings,
            path: 'vr'
        });
        fieldVr.parent.innerElement.firstChild.style.width = 'auto';
        editor.call('attributes:reference:attach', 'settings:project:vr', fieldVr.parent.innerElement.firstChild.ui);

        filter();

        // filter fields when scene settings change
        var evtFilter = sceneSettings.on('*:set', filter);

        // clean up filter event when one of the panels is destroyed
        physicsPanel.on('destroy', function () {
            evtFilter.unbind();
        });

        if (projectSettings.has('useLegacyAudio')) {

            var panelAudio = editor.call('attributes:addPanel', {
                name: 'Audio'
            });
            panelAudio.foldable = true;
            panelAudio.folded = foldStates['audio'];
            panelAudio.on('fold', function() { foldStates['audio'] = true; });
            panelAudio.on('unfold', function() { foldStates['audio'] = false; });
            panelAudio.class.add('component', 'audio');

            var fieldLegacyAudio = editor.call('attributes:addField', {
                parent: panelAudio,
                name: 'Use Legacy Audio',
                type: 'checkbox',
                link: projectSettings,
                path: 'useLegacyAudio'
            });
            fieldLegacyAudio.parent.innerElement.firstChild.style.width = 'auto';
            editor.call('attributes:reference:attach', 'settings:project:useLegacyAudio', fieldLegacyAudio.parent.innerElement.firstChild.ui);
        }



        // lightmapping
        var panelLightmapping = editor.call('attributes:addPanel', {
            name: 'Lightmapping'
        });
        panelLightmapping.foldable = true;
        panelLightmapping.folded = foldStates['lightmapping'];
        panelLightmapping.on('fold', function() { foldStates['lightmapping'] = true; });
        panelLightmapping.on('unfold', function() { foldStates['lightmapping'] = false; });
        panelLightmapping.class.add('component', 'lightmapping');

        // lightmapSizeMultiplier
        var fieldLightmapSizeMultiplier = editor.call('attributes:addField', {
            parent: panelLightmapping,
            name: 'Size Multiplier',
            type: 'number',
            min: 0,
            link: sceneSettings,
            path: 'render.lightmapSizeMultiplier'
        });
        // reference
        editor.call('attributes:reference:attach', 'settings:lightmapSizeMultiplier', fieldLightmapSizeMultiplier.parent.innerElement.firstChild.ui);

        // lightmapMaxResolution
        var fieldLightmapMaxResolution = editor.call('attributes:addField', {
            parent: panelLightmapping,
            name: 'Max Resolution',
            type: 'number',
            min: 2,
            link: sceneSettings,
            path: 'render.lightmapMaxResolution'
        });
        // reference
        editor.call('attributes:reference:attach', 'settings:lightmapMaxResolution', fieldLightmapMaxResolution.parent.innerElement.firstChild.ui);


        // lightmapMode
        var fieldLightmapMode = editor.call('attributes:addField', {
            parent: panelLightmapping,
            name: 'Mode',
            type: 'number',
            enum: {
                0: "Color Only",
                1: "Color and Direction"
            },
            link: sceneSettings,
            path: 'render.lightmapMode'
        });
        // reference
        editor.call('attributes:reference:attach', 'settings:lightmapMode', fieldLightmapMode.parent.innerElement.firstChild.ui);



        // loading screen
        var panelLoadingScreen = editor.call('attributes:addPanel', {
            name: 'Loading Screen'
        });
        panelLoadingScreen.foldable = true;
        panelLoadingScreen.folded = foldStates['loading'];
        panelLoadingScreen.on('fold', function() { foldStates['loading'] = true; });
        panelLoadingScreen.on('unfold', function() { foldStates['loading'] = false; });
        panelLoadingScreen.class.add('component', 'loading-screen');

        // custom loading screen script
        if (editor.call("users:isSuperUser") || config.owner.plan.type === 'org' || config.owner.plan.type === 'organization') {
            var panelButtons = new ui.Panel();
            panelButtons.class.add('flex', 'component');
            panelLoadingScreen.append(panelButtons);

            var btnDefaultScript = new ui.Button({
                text: 'Create default'
            });
            btnDefaultScript.class.add('add');
            btnDefaultScript.class.add('loading-screen');

            panelButtons.append(btnDefaultScript);

            var tooltipText = 'Create a default loading screen script.';

            if (projectSettings.get('useLegacyScripts')) {
                var repositories = editor.call('repositories');
                // disable create button for non directory repos
                btnDefaultScript.disabled = repositories.get('current') !== 'directory';

                if (btnDefaultScript.disabled) {
                    tooltipText += '<br/><small><em>(Disabled because you are synced to an external code repository)</em></small>';
                }

                btnDefaultScript.on('click', function () {
                    editor.call('selector:enabled', false);
                    editor.call('sourcefiles:new', editor.call('sourcefiles:loadingScreen:skeleton'));
                    var evtNew = editor.once('sourcefiles:add', function (file) {
                        setLoadingScreen(file.get('filename'));
                        evtNew = null;
                    });

                    editor.once('sourcefiles:new:close', function () {
                        editor.call('selector:enabled', true);
                        if (evtNew) {
                            evtNew.unbind();
                            evtNew = null;
                        }
                    });
                });

                var setLoadingScreen = function (data) {
                    var loadingScreen = data && data.get ? data.get('filename') : data;
                    projectSettings.set('loadingScreenScript', loadingScreen);
                    fieldScriptPicker.text = loadingScreen ? loadingScreen : 'Select loading screen script';
                    if (loadingScreen) {
                        btnRemove.class.remove('not-visible');
                    } else {
                        btnRemove.class.add('not-visible');
                    }
                };
            } else {

                var setLoadingScreen = function (asset) {
                    if (asset) {
                        if (! asset.get('data.loading'))
                            return;

                        asset.set('preload', false);
                    }

                    projectSettings.set('loadingScreenScript', asset ? asset.get('id') : null);
                    fieldScriptPicker.text = asset ? asset.get('name') : 'Select loading screen script';
                    if (asset) {
                        btnRemove.class.remove('not-visible');
                    } else {
                        btnRemove.class.add('not-visible');
                    }
                };

                btnDefaultScript.on('click', function () {
                    // editor.call('selector:enabled', false);

                    editor.call('picker:script-create', function(filename) {
                        editor.call('assets:create:script', {
                            filename: filename,
                            content: editor.call('sourcefiles:loadingScreen:skeleton'),
                            callback: function (err, asset) {
                                if (err)
                                    return;

                                setLoadingScreen(asset);
                            }
                        });

                    });

                });
            }

            Tooltip.attach({
                target: btnDefaultScript.element,
                html:  tooltipText,
                align: 'right',
                root: root
            });

            var btnSelectScript = new ui.Button({
                text: 'Select existing'
            });
            btnSelectScript.class.add('loading-screen');
            panelButtons.append(btnSelectScript);

            btnSelectScript.on('click', function () {
                var evtPick = editor.once("picker:asset", function (asset) {
                    setLoadingScreen(asset);
                    evtPick = null;
                });

                // show asset picker
                editor.call("picker:asset", "script", null);

                editor.once('picker:asset:close', function () {
                    if (evtPick) {
                        evtPick.unbind();
                        evtPick = null;
                    }
                });
            });

            Tooltip.attach({
                target: btnSelectScript.element,
                text: 'Select an existing loading screen script',
                align: 'bottom',
                root: root
            });

            var fieldScriptPicker = editor.call('attributes:addField', {
                parent: panelLoadingScreen,
                name: 'Script',
                type: 'button'
            });
            fieldScriptPicker.class.add('script-picker');

            fieldScriptPicker.style['font-size'] = '11px';
            fieldScriptPicker.parent.hidden = true;

            var btnRemove = new ui.Button();
            btnRemove.class.add('remove');
            fieldScriptPicker.parent.append(btnRemove);
            btnRemove.on("click", function () {
                setLoadingScreen(null);
            });


            var onLoadingScreen = function (loadingScreen) {
                var text;
                var missing = false;
                if (projectSettings.get('useLegacyScripts')) {
                    text = loadingScreen;
                } else if (loadingScreen) {
                    var asset = editor.call('assets:get', loadingScreen);
                    if (asset) {
                        text = asset.get('name');
                    } else {
                        missing = true;
                        text = 'Missing';
                    }
                }

                if (text) {
                    fieldScriptPicker.text = text;
                    fieldScriptPicker.parent.hidden = false;
                    panelButtons.hidden = true;
                } else {
                    fieldScriptPicker.parent.hidden = true;
                    panelButtons.hidden = false;
                }

                if (missing) {
                    fieldScriptPicker.class.add('error');
                } else {
                    fieldScriptPicker.class.remove('error');
                }
            };

            var evtLoadingScreen = projectSettings.on('loadingScreenScript:set', onLoadingScreen);

            panelLoadingScreen.on('destroy', function () {
                evtLoadingScreen.unbind();
            });

            onLoadingScreen(projectSettings.get('loadingScreenScript'));

            fieldScriptPicker.on('click', function () {
                var evtPick = editor.once("picker:asset", function (asset) {
                    setLoadingScreen(asset);
                    evtPick = null;
                });

                // show asset picker
                editor.call("picker:asset", "script", null);

                editor.once('picker:asset:close', function () {
                    if (evtPick) {
                        evtPick.unbind();
                        evtPick = null;
                    }
                });
            });

            // reference
            editor.call('attributes:reference:attach', 'settings:loadingScreenScript', fieldScriptPicker.parent.innerElement.firstChild.ui);

            // drag drop
            var dropRef = editor.call('drop:target', {
                ref: panelLoadingScreen.element,
                filter: function(type, data) {
                    var rectA = root.innerElement.getBoundingClientRect();
                    var rectB = panelLoadingScreen.element.getBoundingClientRect();
                    if (type === 'asset.script' && rectB.top > rectA.top && rectB.bottom < rectA.bottom) {

                        if (projectSettings.get('useLegacyScripts')) {
                            return data.filename !== fieldScriptPicker.text;
                        } else {
                            var asset = editor.call('assets:get', data.id);
                            return asset && asset.get('data.loading');
                        }
                    }

                    return false;
                },
                drop: function(type, data) {
                    if (type !== 'asset.script')
                        return;

                    if (projectSettings.get('useLegacyScripts')) {
                        setLoadingScreen(data.filename);
                    } else {
                        var asset = editor.call('assets:get', data.id);
                        if (asset && asset.get('data.loading'))
                            setLoadingScreen(asset);
                    }
                }
            });
        } else {
            var labelUpgrade = new ui.Label({
                text: 'This is an ORGANIZATION account feature. <a href="/upgrade?plan=organization&account=' + config.owner.username + '" target="_blank">UPGRADE</a> to create custom loading screens.'
            });
            labelUpgrade.style.fontSize = '12px';
            labelUpgrade.style.color = '#fff';
            panelLoadingScreen.append(labelUpgrade);
        }
    });
});


/* editor/scene-settings/scene-settings-priority-scripts.js */
editor.once('load', function() {
    'use strict';

    if (! editor.call('settings:project').get('useLegacyScripts'))
        return;

    var sceneSettings = editor.call('sceneSettings');
    var sourcefiles = null;
    var priorityScripts = [];

    var refreshPriorityList = function () {
        priorityList.clear();

        if (priorityScripts.length === 0) {
            var item = new ui.ListItem();
            priorityList.append(item);
        } else {
            priorityScripts.forEach(function (script, index) {
                var item = new ui.ListItem();
                item.text = script;

                var moveUp = new ui.Button();
                moveUp.class.add('move-up');
                if (index) {
                    moveUp.on("click", function () {
                        var index = priorityScripts.indexOf(script);
                        priorityScripts.splice(index, 1);
                        priorityScripts.splice(index-1, 0, script);
                        sceneSettings.set("priority_scripts", priorityScripts);
                        refreshPriorityList();
                    });
                } else {
                    moveUp.class.add('not-visible')
                }

                var moveDown = new ui.Button();
                moveDown.class.add('move-down');
                if (index < priorityScripts.length-1) {
                    moveDown.on("click", function () {
                        var index = priorityScripts.indexOf(script);
                        priorityScripts.splice(index, 1);
                        priorityScripts.splice(index+1, 0, script);
                        sceneSettings.set("priority_scripts", priorityScripts);
                        refreshPriorityList();
                    });
                } else {
                    moveDown.class.add('not-visible');
                }

                var remove = new ui.Button();
                remove.class.add('remove');
                remove.on("click", function () {
                    var index = priorityScripts.indexOf(script);
                    priorityScripts.splice(index, 1);
                    sceneSettings.set("priority_scripts", priorityScripts);
                    refreshPriorityList();
                });

                item.element.insertBefore(remove.element, item.element.lastChild);
                item.element.insertBefore(moveDown.element, item.element.lastChild);
                item.element.insertBefore(moveUp.element, item.element.lastChild);

                priorityList.append(item);
            });
        }
    };

    editor.on('sourcefiles:load', function (obs) {
        sourcefiles = obs;
    });

    var root = editor.call('layout.root');

    var overlay = new ui.Overlay();
    overlay.class.add("script-priorities");
    overlay.hidden = true;

    var label = new ui.Label();
    label.text = "Script Loading Priority";
    label.class.add('title');
    overlay.append(label);

    var description = new ui.Label();
    description.text = "Scripts in the priority list are loaded first in the order that they are listed. Other scripts are loaded in an unspecified order.";
    description.class.add('description');
    overlay.append(description);

    var panel = new ui.Panel();
    overlay.append(panel);

    // Add new script button
    var button = new ui.Button();
    button.text = "Add Script";
    button.class.add('add-script');
    button.on("click", function (evt) {
        // use asset-picker to select script
        overlay.hidden = true;
        editor.once("picker:asset", function (asset) {
            overlay.hidden = false;
            var value = asset.get("filename");
            if (priorityScripts.indexOf(value) < 0) {
                priorityScripts.push(value);
                if (sceneSettings.has('priority_scripts')) {
                    sceneSettings.insert("priority_scripts", value);
                } else {
                    sceneSettings.set('priority_scripts', priorityScripts);
                }
                refreshPriorityList();
            }
        });
        editor.once("picker:asset:close", function (asset) {
            overlay.hidden = false;
        });

        // show asset picker
        editor.call("picker:asset", "script", null);
    });
    overlay.append(button);

    var priorityList = new ui.List();
    sceneSettings.on("priority_scripts:set", function (scripts) {
        priorityScripts = scripts.slice();
        refreshPriorityList();
    });
    sceneSettings.on("priority_scripts:unset", function () {
        priorityScripts = [];
        refreshPriorityList();
    });
    panel.append(priorityList);

    root.append(overlay);

    // esc > no
    editor.call('hotkey:register', 'sceneSettings:priorityScripts:close', {
        key: 'esc',
        callback: function() {
            if (overlay.hidden)
                return;

            overlay.hidden = true;
        }
    });

    editor.method('sceneSettings:priorityScripts', function () {
        overlay.hidden = false;
        refreshPriorityList();
    });
});


/* editor/repositories/repositories.js */
editor.once('load', function() {
    'use strict';

    if (! editor.call('settings:project').get('useLegacyScripts'))
        return;

    var repositories = new Observer();

    // Load repositories
    editor.once('start', function() {
        Ajax({
            url: '{{url.api}}/projects/{{project.id}}/repositories',
            auth: true
        })
            .on('load', function(status, data) {
                var response = data;
                for (var key in response) {
                    if (response.hasOwnProperty(key)) {
                        repositories.set(key, response[key]);
                    }
                }

                editor.emit('repositories:load', repositories);
            });
    });

    // get repositories
    editor.method('repositories', function () {
        return repositories;
    });
});


/* editor/sourcefiles/sourcefiles.js */
editor.once('repositories:load', function (repositories) {
    'use strict';

    if(! editor.call('settings:project').get('useLegacyScripts'))
        return;

    var sourcefiles = new ObserverList();

    var scriptNamePattern = new RegExp("^(?:[\\w\\d\\.-]+\\\/)*[\\w\\d\\.-]+(?:\\.js(?:on)?)?$", 'i');

    // get listing of sourcefiles
    Ajax({
        url: '{{url.api}}/projects/{{project.id}}/repositories/' + repositories.get('current') + '/sourcefiles',
        auth: true
    })
        .on('load', function (status, data) {
            if (data.result && data.result.length) {
                data.result.forEach(function (sourcefile) {
                    var observer = new Observer(sourcefile);
                    sourcefiles.add(observer);
                    editor.emit('sourcefiles:add', observer);
                });
            }

            editor.emit('sourcefiles:load', sourcefiles);
        });

    editor.method('sourcefiles:list', function () {
        return sourcefiles.array();
    });

    editor.method('sourcefiles:get', function (filename) {
        var entry = sourcefiles.findOne(function (file) {
            return file.get('filename') === filename;
        });

        return entry ? entry[1] : null;
    });

    // get script full URL
    editor.method('sourcefiles:url', function (relativeUrl) {
        var services = {
            directory: 'directory',
            bitbucket: 'bitbucket.org',
            github: 'github.com'
        };

        var fullUrl = [
            config.url.api,
            'projects',
            config.project.id,
            'repositories',
            repositories.get('current'),
            'sourcefiles',
            relativeUrl
        ].join('/');

        return fullUrl;
    });

    // get script content
    editor.method('sourcefiles:content', function (relativeUrl, callback) {
        var fullUrl = editor.call('sourcefiles:url', relativeUrl);

        Ajax({
            url: fullUrl,
            auth: true,
            notJson: true
        })
            .on('load', function(status, data) {
                if (callback)
                    callback(null, data);
            })
            .on('error', function (status) {
                if (callback)
                    callback(status);
            });
    });

    editor.method('sourcefiles:create', function (url, content, callback) {
        if (repositories.get('current') !== 'directory') return;

        var data = {
            filename: url,
            content: content
        };

        var createUrl = [config.url.api, 'projects', config.project.id, 'repositories', repositories.get('current'), 'sourcefiles', url].join('/');

        Ajax({
            url: createUrl,
            auth: true,
            method: "PUT",
            data: data
        })
            .on('load', function (status, data) {

                var file = sourcefiles.findOne(function(f) {
                    return f.get('filename') === url;
                });

                if (! file) {
                    file = new Observer({
                        filename: url
                    });

                    sourcefiles.add(file);
                    editor.emit('sourcefiles:add', file);
                }

                if (callback)
                    callback(null, file);
            })
            .on('error', function (status, msg) {
                if (callback)
                    callback(msg);
            });
    });

    editor.method('sourcefiles:rename', function (oldFilename, newFilename, callback) {
        if (repositories.get('current') !== 'directory') return;

        var data = {
            filename: newFilename
        };

        var renameUrl = [
            config.url.api,
            'projects',
            config.project.id,
            'repositories',
            repositories.get('current'),
            'sourcefiles',
            'rename',
            oldFilename
        ].join('/');

        Ajax({
            url: renameUrl,
            auth: true,
            method: 'PUT',
            data: data
        })
            .on('load', function (status, data) {
                if (callback)
                    callback();
            })
            .on('error', function (err) {
                if (callback)
                    callback(err);
            });
    });

    // save source file content
    editor.method('sourcefiles:save', function (content, relativeUrl, callback) {
        var saveUrl = [
            config.url.api,
            'projects',
            config.project.id,
            'repositories',
            repositories.get('current'),
            'sourcefiles',
            relativeUrl
        ].join('/');

        var data = {
            url: saveUrl,
            method: 'PUT',
            auth: true,
            data: {
                filename: relativeUrl,
                content: content
            },
            ignoreContentType: true,
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json'
            }
        };

        Ajax(data)
            .on('load', function () {
                if (callback)
                    callback(null);
            })
            .on('error', function (err) {
                if (callback)
                    callback(err);
            });
    });

    // rename on filename set
    editor.on('sourcefiles:add', function (file) {
        var setting = false;
        file.on('filename:set', function (value, oldValue) {
            if (!editor.call('permissions:write') || setting)
                return;

            if (! value) {
                setting = true;
                file.set('filename', oldValue);
                setting = false;
                return;
            }


            if (! value.toLowerCase().endsWith('.js')) {
                value += '.js';
                setting = true;
                file.set('filename', value);
                setting = false;
            }

            if (! scriptNamePattern.test(value)) {
                setting = true;
                file.set('filename', oldValue);
                setting = false;
                setTimeout(function () {
                    editor.call('status:error', 'Invalid script name');
                });
                return;
            }

            editor.call('sourcefiles:rename', oldValue, value, function (err) {
                if (err) {
                    setting = true;
                    file.set('filename', oldValue);
                    setting = false;
                    editor.call('status:error', 'Could not rename script: ' + err);
                } else {
                    // get script and if its content is the same as the skeleton script
                    // then recreate it
                    editor.call('sourcefiles:content', value, function (err, content) {
                        var newContents = null;
                        if (!err && content === editor.call('sourcefiles:skeleton', oldValue)) {
                            newContents = editor.call('sourcefiles:skeleton', value);
                            editor.call('sourcefiles:save', newContents, value);
                        }
                    });

                }
            });

        });
    });

    editor.on('sourcefiles:remove', function (sourcefile) {
        sourcefiles.remove(sourcefile);
    });

});


/* editor/sourcefiles/sourcefiles-skeleton.js */
editor.once('load', function () {
    'use strict';

    // returns skeleton script for a script with the specified url
    editor.method('sourcefiles:skeleton', function (url) {
        var parts = url.split('/');
        // remove .js extension
        var scriptName = parts[parts.length-1].slice(0,-3).replace(/[\.-]+/g, '_');
        var objectName = scriptName.charAt(0).toUpperCase() + scriptName.slice(1);

        var result = [
            "pc.script.create('" + scriptName + "', function (app) {",
            "    // Creates a new " + objectName + " instance",
            "    var " + objectName + " = function (entity) {",
            "        this.entity = entity;",
            "    };",
            "",
            "    " + objectName + ".prototype = {",
            "        // Called once after all resources are loaded and before the first update",
            "        initialize: function () {",
            "        },",
            "",
            "        // Called every frame, dt is time in seconds since last update",
            "        update: function (dt) {",
            "        }",
            "    };",
            "",
            "    return " + objectName + ";",
            "});"].join('\n');

        return result;
    });

    editor.method('sourcefiles:loadingScreen:skeleton', function () {
        return [
            "pc.script.createLoadingScreen(function (app) {",
            "    var showSplash = function () {",
            "        // splash wrapper",
            "        var wrapper = document.createElement('div');",
            "        wrapper.id = 'application-splash-wrapper';",
            "        document.body.appendChild(wrapper);",
            "",
            "        // splash",
            "        var splash = document.createElement('div');",
            "        splash.id = 'application-splash';",
            "        wrapper.appendChild(splash);",
            "        splash.style.display = 'none';",
            "",
            "        var logo = document.createElement('img');",
            "        logo.src = 'https://s3-eu-west-1.amazonaws.com/static.playcanvas.com/images/play_text_252_white.png';",
            "        splash.appendChild(logo);",
            "        logo.onload = function () {",
            "            splash.style.display = 'block';",
            "        };",
            "",
            "        var container = document.createElement('div');",
            "        container.id = 'progress-bar-container';",
            "        splash.appendChild(container);",
            "",
            "        var bar = document.createElement('div');",
            "        bar.id = 'progress-bar';",
            "        container.appendChild(bar);",
            "",
            "    };",
            "",
            "    var hideSplash = function () {",
            "        var splash = document.getElementById('application-splash-wrapper');",
            "        splash.parentElement.removeChild(splash);",
            "    };",
            "",
            "    var setProgress = function (value) {",
            "        var bar = document.getElementById('progress-bar');",
            "        if(bar) {",
            "            value = Math.min(1, Math.max(0, value));",
            "            bar.style.width = value * 100 + '%';",
            "        }",
            "    };",
            "",
            "    var createCss = function () {",
            "        var css = [",
            "            'body {',",
            "            '    background-color: #283538;',",
            "            '}',",
            "",
            "            '#application-splash-wrapper {',",
            "            '    position: absolute;',",
            "            '    top: 0;',",
            "            '    left: 0;',",
            "            '    height: 100%;',",
            "            '    width: 100%;',",
            "            '    background-color: #283538;',",
            "            '}',",
            "",
            "            '#application-splash {',",
            "            '    position: absolute;',",
            "            '    top: calc(50% - 28px);',",
            "            '    width: 264px;',",
            "            '    left: calc(50% - 132px);',",
            "            '}',",
            "",
            "            '#application-splash img {',",
            "            '    width: 100%;',",
            "            '}',",
            "",
            "            '#progress-bar-container {',",
            "            '    margin: 20px auto 0 auto;',",
            "            '    height: 2px;',",
            "            '    width: 100%;',",
            "            '    background-color: #1d292c;',",
            "            '}',",
            "",
            "            '#progress-bar {',",
            "            '    width: 0%;',",
            "            '    height: 100%;',",
            "            '    background-color: #f60;',",
            "            '}',",
            "            '@media (max-width: 480px) {',",
            "            '    #application-splash {',",
            "            '        width: 170px;',",
            "            '        left: calc(50% - 85px);',",
            "            '    }',",
            "            '}'",
            "        ].join(\"\\n\");",
            "",
            "        var style = document.createElement('style');",
            "        style.type = 'text/css';",
            "        if (style.styleSheet) {",
            "          style.styleSheet.cssText = css;",
            "        } else {",
            "          style.appendChild(document.createTextNode(css));",
            "        }",
            "",
            "        document.head.appendChild(style);",
            "    };",
            "",
            "",
            "    createCss();",
            "",
            "    showSplash();",
            "        ",
            "    app.on('preload:end', function () {",
            "        app.off('preload:progress');",
            "    });",
            "    app.on('preload:progress', setProgress);",
            "    app.on('start', hideSplash);",
            "});"
        ].join('\n');
    });
});


/* editor/sourcefiles/sourcefiles-attributes-scan.js */
editor.once('load', function () {
    if(! editor.call('settings:project').get('useLegacyScripts'))
        return;

    var VALID_TYPES = [
        'number',
        'string',
        'boolean',
        'asset',
        'rgb',
        'rgba',
        'vector',
        'vec2',
        'vec3',
        'vec4',
        'enumeration',
        'entity',
        'curve',
        'colorcurve'
    ];

    var REGEX_GUID = /^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$/i;
    var REGEX_COLOR_CURVE = /^((r((gba?)?))|g|b|a)$/; // r or g or b or rgb or rgba

    var validators = {
        'number': function (url, attribute) {
            validateValue(url, attribute, 'number', 0);
        },

        'string': function (url, attribute) {
            validateValue(url, attribute, 'string', '');

            if (attribute.defaultValue.length > 512) {
                throw attributeErrorMsg(url, attribute, "Value exceeds 512 characters");
            }
        },

        'boolean': function (url, attribute) {
            validateValue(url, attribute, 'boolean', false);
        },

        'asset': function (url, attribute) {
            // TODO check max array length
            validateArrayValue(url, attribute, [], -1, 'number');
        },

        'vector': function (url, attribute) {
            validateArrayValue(url, attribute, [0,0,0], 3, 'number');
        },

        'vec2': function (url, attribute) {
            validateArrayValue(url, attribute, [0,0], 2, 'number');
        },

        'vec3': function (url, attribute) {
            validateArrayValue(url, attribute, [0,0,0], 3, 'number');
        },

        'vec4': function (url, attribute) {
            validateArrayValue(url, attribute, [0,0,0,0], 4, 'number');
        },

        'rgb': function (url, attribute) {
            validateArrayValue(url, attribute, [0,0,0], 3, 'number');
        },

        'rgba': function (url, attribute) {
            validateArrayValue(url, attribute, [0,0,0,1], 4, 'number');
        },

        'enumeration': function (url, attribute) {
            if (attribute.options &&
                attribute.options.enumerations &&
                pc.type(attribute.options.enumerations) === 'array' &&
                attribute.options.enumerations.length) {

                var valueType;
                var enumerations = attribute.options.enumerations;
                // TODO check enumerations max length
                for (var i=0; i<enumerations.length; i++) {
                    if (pc.type(enumerations[i]) !== 'object') {
                        throw attributeErrorMsg(url, attribute, "Each enumeration must be an object with this form: {name: '...', value: ...}");
                    } else {
                        if (pc.type(enumerations[i].name) !== 'string' ||
                            enumerations[i].name.length === 0 ||
                            pc.type(enumerations[i].value) === 'undefined') {

                            throw attributeErrorMsg(url, attribute, "Each enumeration must be an object with this form: {name: '...', value: ...}");
                        } else {
                            if (!valueType) {
                                valueType = pc.type(enumerations[i].value);
                            } else {
                                if (valueType !== pc.type(enumerations[i].value)) {
                                    throw attributeErrorMsg(url, attribute, "All enumerations values must be the same type");
                                }
                            }
                        }
                    }
                }

                validateValue(url, attribute, valueType, enumerations[0].value);

                var isValueInEnumerations = false;
                for (var i = 0; i < enumerations.length; i++) {
                    if (enumerations[i].value === attribute.defaultValue) {
                        isValueInEnumerations = true;
                        break;
                    }
                }

                if (!isValueInEnumerations) {
                    throw attributeErrorMsg(url, attribute, "Value is not one of the possible enumerations");
                }
            } else {
                throw attributeErrorMsg(url, attribute, "Missing enumerations from attribute options");
            }
        },

        'entity': function (url, attribute) {
            validateValue(url, attribute, 'string', null);

            if (attribute.defaultValue && !REGEX_GUID.test(attribute.defaultValue)) {
                throw attributeErrorMsg(url, attribute, "Value is not a valid Entity resource id");
            }
        },

        'curve': function (url, attribute) {
            if (!attribute.options)
                attribute.options = {};

            if (!attribute.options.curves) {
                attribute.options.curves = ['Value'];
            } else {
                if (!attribute.options.curves.length) {
                    throw attributeErrorMsg(url, attribute, "Curves option must be a non-empty string array");
                } else if (attribute.options.curves.length > 4) {
                    throw attributeErrorMsg(url, attribute, "Curves option cannot exceed 4 elements");
                }
            }

            if (attribute.defaultValue !== null && attribute.defaultValue !== undefined) {
                if (typeof attribute.defaultValue !== 'object' || attribute.defaultValue instanceof Array)
                    throw attributeErrorMsg(url, attribute, "Invalid default value for curve attribute");

                var validData = {
                    type: attribute.defaultValue.type,
                    keys: attribute.defaultValue.keys
                };

                attribute.defaultValue = validData;

                if (validData.type !== undefined) {
                    if (validData.type !== 0 && validData.type !== 1 && validData.type !== 2) {
                        throw attributeErrorMsg(url, attribute, "Invalid type. Needs to be one of: 0, 1, 2");
                    }
                }

                if (!(validData.keys instanceof Array)) {
                    throw attributeErrorMsg(url, attribute, "Invalid keys. Needs to be an array");
                }

                if (attribute.options.curves.length > 1) {
                    if (validData.keys.length !== 0 && validData.keys.length !== attribute.options.curves.length) {
                        throw attributeErrorMsg(url, attribute, 'Invalid keys. Needs to be an array of ' + attribute.options.curves.length + ' arrays');
                    } else {
                        for (var i = 0, len = validData.keys.length; i < len; i++) {
                            if (!(validData.keys[i] instanceof Array)) {
                                throw attributeErrorMsg(url, attribute, 'Invalid keys. Needs to be an array of ' + len + ' arrays');
                            } else {
                                var len2 = validData.keys[i].length;
                                if (len2 % 2 !== 0)
                                    throw attributeErrorMsg(url, attribute, 'Invalid keys. Array must hold an even amount of numbers');

                                for (var j = 0; j < len2; j++) {
                                    if (typeof validData.keys[i][j] !== 'number')
                                        throw attributeErrorMsg(url, attribute, 'Invalid keys. Array values must be numbers');
                                }
                            }
                        }
                    }
                } else {
                    if (attribute.options.curves.length === 1) {
                        if (validData.keys.length % 2 !== 0)
                            throw attributeErrorMsg(url, attribute, 'Invalid keys. Array must hold an even amount of numbers');

                        for (var i = 0, len = validData.keys.length; i < len; i++) {
                            if (typeof validData.keys[i] !== 'number')
                                throw attributeErrorMsg(url, attribute, 'Invalid keys. Array values must be numbers');
                        }
                    }
                }
            } else {
                attribute.defaultValue = {
                    type: 1,
                    keys: []
                };

                if (attribute.options.curves.length === 1)
                    attribute.defaultValue.keys = [0, 0];
                else {
                    for (var i = 0; i < attribute.options.curves.length; i++) {
                        attribute.defaultValue.keys.push([0, 0]);
                    }
                }
            }
        },

        'colorcurve': function (url, attribute) {
            if (!attribute.options)
                attribute.options = {};

            if (!attribute.options.type) {
                attribute.options.type = 'rgb';
            } else {
                if (!REGEX_COLOR_CURVE.test(attribute.options.type)) {
                    throw attributeErrorMsg(url, attribute, "Color curve type can be one of 'r', 'g', 'b', 'a', 'rgb', 'rgba'");
                }
            }

            if (attribute.defaultValue !== null && attribute.defaultValue !== undefined) {
                if (typeof attribute.defaultValue !== 'object' || attribute.defaultValue instanceof Array)
                    throw attributeErrorMsg(url, attribute, "Invalid default value for curve attribute");

                var validData = {
                    type: attribute.defaultValue.type,
                    keys: attribute.defaultValue.keys
                };

                attribute.defaultValue = validData;

                if (validData.type !== undefined) {
                    if (validData.type !== 0 && validData.type !== 1 && validData.type !== 2) {
                        throw attributeErrorMsg(url, attribute, "Invalid type. Needs to be one of: 0, 1, 2");
                    }
                }

                if (!(validData.keys instanceof Array)) {
                    throw attributeErrorMsg(url, attribute, "Invalid keys. Needs to be an array");
                }

                if (attribute.options.type.length > 1) {
                    if (validData.keys.length !== 0 && validData.keys.length !== attribute.options.type.length) {
                        throw attributeErrorMsg(url, attribute, 'Invalid keys. Needs to be an array of ' + attribute.options.type.length + ' arrays');
                    } else {
                        for (var i = 0, len = validData.keys.length; i < len; i++) {
                            if (!(validData.keys[i] instanceof Array)) {
                                throw attributeErrorMsg(url, attribute, 'Invalid keys. Needs to be an array of ' + len + ' arrays');
                            } else {
                                var len2 = validData.keys[i].length;
                                if (len2 % 2 !== 0)
                                    throw attributeErrorMsg(url, attribute, 'Invalid keys. Array must hold an even amount of numbers');

                                for (var j = 0; j < len2; j++) {
                                    if (typeof validData.keys[i][j] !== 'number')
                                        throw attributeErrorMsg(url, attribute, 'Invalid keys. Array values must be numbers');
                                }
                            }
                        }
                    }
                } else {
                    if (attribute.options.type.length === 1) {
                        if (validData.keys.length % 2 !== 0)
                            throw attributeErrorMsg(url, attribute, 'Invalid keys. Array must hold an even amount of numbers');

                        for (var i = 0, len = validData.keys.length; i < len; i++) {
                            if (typeof validData.keys[i] !== 'number')
                                throw attributeErrorMsg(url, attribute, 'Invalid keys. Array values must be numbers');
                        }
                    }
                }
            } else {
                attribute.defaultValue = {
                    type: 1,
                    keys: []
                };

                if (attribute.options.type.length === 1)
                    attribute.defaultValue.keys = [0, 0];
                else {
                    for (var i = 0; i < attribute.options.type.length; i++) {
                        attribute.defaultValue.keys.push([0, 0]);
                    }
                }
            }
        }
    };

    var validateValue = function (url, attribute, correctType, valueIfUndefined) {
        var type = pc.type(attribute.defaultValue);
        if (type === 'undefined' || type === 'null') {
            attribute.defaultValue = valueIfUndefined;
        } else if (type !== correctType) {
            throw attributeErrorMsg(url, attribute, 'Value is not of type ' + correctType);
        }
    };

    var validateArrayValue = function (url, attribute, valueIfUndefined, correctLength, typeofElements) {
        validateValue(url, attribute, 'array', valueIfUndefined);

        if (correctLength >= 0 && attribute.defaultValue.length !== correctLength) {
            throw attributeErrorMsg(url, attribute, pc.string.format('Value must be an array with {0} elements of type {1}', correctLength, typeofElements));
        } else {
            for (var i=0; i<attribute.defaultValue.length; i++) {
                if (typeof attribute.defaultValue[i] !== typeofElements) {
                    throw attributeErrorMsg(url, attribute, pc.string.format('Value must be an array with elements of type {0}', typeofElements));
                }
            }
        }
    };

    var attributeErrorMsg = function (url, attribute, error) {
        return pc.string.format("Attribute '{0}' of script {1} is invalid: {2}", attribute.name, url, error);
    };

    var validateScriptAttributes = function (url, data) {
        var hasErrors = false;
        var validated = {
            name: data.name,
            attributes: {},
            attributesOrder: []
        };

        data.values.forEach(function (attr) {
            try {
                // check if name is valid
                if (typeof attr.name !== 'string' || !attr.name) {
                    throw pc.string.format("Validation error in {0}: Missing attribute name", url);
                }

                if (attr.name.length > 128) {
                    throw pc.string.format(pc.string.format("Validation error in {0}: Attribute name exceeds 128 characters", url));
                }

                // check if type is valid
                if (typeof attr.type === 'undefined') {
                    throw attributeErrorMsg(url, attr, "Missing attribute type");
                }

                if (VALID_TYPES.indexOf(attr.type) < 0) {
                    throw attributeErrorMsg(url, attr, pc.string.format("{0} is not a valid attribute type", attr.type));
                }

                if (attr.options) {
                    if (attr.options.displayName) {
                        if (typeof attr.options.displayName !== 'string') {
                            throw attributeErrorMsg(url, attr, "Display name of attribute must be a string");
                        }

                        if (attr.options.displayName.length > 128) {
                            throw attributeErrorMsg(url, attr, "Display name of attribute cannot exceed 128 characters");
                        }
                    }

                    if (attr.options.description) {
                        if (typeof attr.options.description !== 'string') {
                            throw attributeErrorMsg(url, attr, "Description of attribute must be a string");
                        }

                        if (attr.options.description.length > 1024) {
                            throw attributeErrorMsg(url, attr, "Description of attribute cannot exceed 1024 characters");
                        }
                    }
                }

                // type-specific validations
                validators[attr.type](url, attr);

                if (validated.attributes[attr.name]) {
                    throw attributeErrorMsg(url, attr, 'Duplicate attribute');
                }

                validated.attributesOrder.push(attr.name);

                validated.attributes[attr.name] = {
                    name: attr.name,
                    displayName: attr.options && attr.options.displayName ? attr.options.displayName : attr.name,
                    description: attr.options ? attr.options.description : undefined,
                    defaultValue: attr.defaultValue,
                    value: attr.defaultValue,
                    type: attr.type,
                    options: attr.options ? {
                        // Only allowed options
                        max: attr.options.max,
                        min: attr.options.min,
                        step: attr.options.step,
                        type: attr.options.type,
                        decimalPrecision: attr.options.decimalPrecision,
                        enumerations: attr.options.enumerations,
                        curves: attr.options.curves,
                        color: attr.options.color
                    } : {}
                };
            } catch (e) {
                hasErrors = true;
                console.error(e);
            }
        });

        if (hasErrors) {
            editor.call('status:error', 'Error while parsing script attributes. Open browser console for details.');
            validated = null;
        }

        return validated;
    };

    // only allow scrpts from playcanvas, code.playcanvas.com and localhost:51000 to be parsed
    var REGEX_ALLOWED = new RegExp('^((http(s)?:\/\/)((code.playcanvas.com)|(localhost:51000)))|(' + config.url.api + ')');

    /**
     * Starts a web worker which scans the specified URL
     * for script attributes, then validates the result and passes it to
     * the success callback
     */
    editor.method('sourcefiles:scan', function (url, success) {
        if (!REGEX_ALLOWED.test(url)) {
            success({});
            return;
        }

        var worker = new Worker("/editor/scene/js/editor/sourcefiles/sourcefiles-attributes-parser.js");
        worker.postMessage({
            url: url
        });

        worker.onmessage = function (e) {
            if (e.data) {
                if (typeof e.data.error !== 'undefined') {
                    editor.call('status:error', pc.string.format("Could not parse {0} - {1}", url, e.data.error));
                } else {
                    var result = validateScriptAttributes(url, e.data);
                    if (result) {
                        success(result);
                    }
                }
            }
        };
    });
});


/* editor/storage/localstorage.js */
editor.once('load', function () {
    // Get a key from the local storage
    editor.method('localStorage:get', function (key) {
        var value = localStorage.getItem(key);
        if (value) {
            try {
                value = JSON.parse(value);
            } catch (e) {
                console.error(e);
            }
        }

        return value;
    });

    // Set a key-value pair in localStorage
    editor.method('localStorage:set', function (key, value) {
        localStorage.setItem(key, JSON.stringify(value));
    });

    // Returns true if the key exists in the local storage
    editor.method('localStorage:has', function (key) {
        return !!localStorage.getItem(key);
    });
});


/* editor/entities/entities.js */
editor.once('load', function() {
    'use strict';

    var entities = new ObserverList({
        index: 'resource_id'
    });

    var entityRoot = null;

    // on adding
    entities.on('add', function(entity) {
        editor.emit('entities:add', entity);
    });

    // on removing
    entities.on('remove', function(entity) {
        editor.emit('entities:remove', entity);
        entity.destroy();
        entity.entity = null;
    });


    // allow adding entity
    editor.method('entities:add', function(entity) {
        if (! entity.get('parent'))
            entityRoot = entity;

        entities.add(entity);
    });

    // allow remove entity
    editor.method('entities:remove', function(entity) {
        entities.remove(entity);
    });

    // remove all entities
    editor.method('entities:clear', function () {
        entities.clear();
    });

    // get entity
    editor.method('entities:get', function(resourceId) {
        return entities.get(resourceId);
    });


    // list entities
    editor.method('entities:list', function() {
        return entities.array();
    });


    // get root entity
    editor.method('entities:root', function () {
        return entityRoot;
    });

});


/* editor/entities/entities-selection.js */
editor.once('load', function() {
    'use strict';

    // returns all selected entities
    editor.method('entities:selection', function () {
        if (editor.call('selector:type') !== 'entity')
            return [ ];

        return editor.call('selector:items').slice(0);
    });

    // returns first selected entity
    editor.method('entities:selectedFirst', function () {
        var selection = editor.call('entities:selection');
        if (selection.length) {
            return selection[0];
        } else {
            return null;
        }
    });
});


/* editor/entities/entities-edit.js */
editor.once('load', function() {
    'use strict';

    // index
    var childToParent = { };

    var deletedCache = { };

    // add
    editor.on('entities:add', function(entity) {
        var children = entity.get('children');
        for(var i = 0; i < children.length; i++)
            childToParent[children[i]] = entity.get('resource_id');

        entity.on('children:insert', function(value) {
            childToParent[value] = this.get('resource_id');
        });
        entity.on('children:remove', function(value) {
            delete childToParent[value];
        });
    });

    editor.method('entities:childToParent', function(child, parent) {
        childToParent[child.get('resource_id')] = parent.get('resource_id');
    });


    // new entity
    editor.method('entities:new', function (raw) {
        // get root if parent is null
        raw = raw || { };
        var parent = raw.parent || editor.call('entities:root');

        var data = {
            name: raw.name || 'New Entity',
            tags: [ ],
            enabled: true,
            resource_id: pc.guid.create(),
            parent: parent.get('resource_id'),
            children: [ ],
            position: raw.position || [ 0, 0, 0 ],
            rotation: raw.rotation || [ 0, 0, 0 ],
            scale: raw.scale || [ 1, 1, 1 ],
            components: raw.components || { }
        };

        var selectorType, selectorItems;

        if (! raw.noHistory) {
            var selectorType = editor.call('selector:type');
            var selectorItems = editor.call('selector:items');
            if (selectorType === 'entity') {
                for(var i = 0; i < selectorItems.length; i++)
                    selectorItems[i] = selectorItems[i].get('resource_id');
            }
        }

        // create new Entity data
        var entity = new Observer(data);
        childToParent[entity.get('resource_id')] = parent.get('resource_id');
        addEntity(entity, parent, ! raw.noSelect);

        // history
        if (! raw.noHistory) {
            var resourceId = entity.get('resource_id');
            var parentId = parent.get('resource_id');

            editor.call('history:add', {
                name: 'new entity ' + resourceId,
                undo: function() {
                    var entity = editor.call('entities:get', resourceId);
                    if (! entity)
                        return;

                    removeEntity(entity);

                    if (selectorType === 'entity' && selectorItems.length) {
                        var items = [ ];
                        for(var i = 0; i < selectorItems.length; i++) {
                            var item = editor.call('entities:get', selectorItems[i]);
                            if (item)
                                items.push(item);
                        }

                        if (items.length) {
                            editor.call('selector:history', false);
                            editor.call('selector:set', selectorType, items);
                            editor.once('selector:change', function() {
                                editor.call('selector:history', true);
                            });
                        }
                    }
                },
                redo: function() {
                    var parent = editor.call('entities:get', parentId);
                    if (! parent)
                        return;

                    var entity = new Observer(data);
                    childToParent[entity.get('resource_id')] = parent.get('resource_id');
                    addEntity(entity, parent, true);
                }
            });
        }

        return entity;
    });

    var addEntity = function(entity, parent, select, ind) {
        var children = entity.get('children');
        if (children.length)
            entity.set('children', [ ]);

        // call add event
        editor.call('entities:add', entity);

        // sharejs
        editor.call('realtime:scene:op', {
            p: [ 'entities', entity.get('resource_id') ],
            oi: entity.json()
        });

        // this is necessary for the entity to be added to the tree view
        parent.history.enabled = false;
        parent.insert('children', entity.get('resource_id'), ind);
        parent.history.enabled = true;

        if (select) {
            setTimeout(function() {
                editor.call('selector:history', false);
                editor.call('selector:set', 'entity', [ entity ]);
                editor.once('selector:change', function() {
                    editor.call('selector:history', true);
                });
            }, 0);
        }

        // add children too
        children.forEach(function(childId) {
            var data = deletedCache[childId];
            if (! data)
                return;

            var child = new Observer(data);
            childToParent[child.get('resource_id')] = entity.get('resource_id');
            addEntity(child, entity);
        });
    };

    var removeEntity = function(entity) {
        deletedCache[entity.get('resource_id')] = entity.json();

        // remove children
        entity.get('children').forEach(function (child) {
            var entity = editor.call('entities:get', child);
            if (! entity)
                return;

            removeEntity(entity);
        });

        if (editor.call('selector:type') === 'entity' && editor.call('selector:items').indexOf(entity) !== -1) {
            editor.call('selector:history', false);
            editor.call('selector:remove', entity);
            editor.once('selector:change', function() {
                editor.call('selector:history', true);
            });
        }

        // remove from parent
        var parentId = childToParent[entity.get('resource_id')];
        if (parentId) {
            var parent = editor.call('entities:get', parentId);
            if (parent) {
                parent.history.enabled = false;
                parent.removeValue('children', entity.get('resource_id'));
                parent.history.enabled = true;
            }
        }

        // call remove method
        editor.call('entities:remove', entity);

        // sharejs
        editor.call('realtime:scene:op', {
            p: [ 'entities', entity.get('resource_id') ],
            od: { }
        });
    };

    editor.method('entities:addEntity', addEntity);
    editor.method('entities:removeEntity', removeEntity);

    var duplicateEntity = function(entity, parent, ind) {
        var resourceId = entity.get('resource_id');
        var data = entity.json();
        var children = data.children;

        data.children = [ ];
        data.resource_id = pc.guid.create();
        data.parent = parent.get('resource_id');

        entity = new Observer(data);
        childToParent[entity.get('resource_id')] = parent.get('resource_id');

        // call add event
        editor.call('entities:add', entity);

        // sharejs
        editor.call('realtime:scene:op', {
            p: [ 'entities', entity.get('resource_id') ],
            oi: entity.json()
        });

        // this is necessary for the entity to be added to the tree view
        parent.history.enabled = false;
        parent.insert('children', entity.get('resource_id'), ind);
        parent.history.enabled = true;

        // add children too
        children.forEach(function(childId) {
            duplicateEntity(editor.call('entities:get', childId), entity);
        });

        return entity;
    };

    // duplicate entity
    editor.method('entities:duplicate', function (entities) {
        var root = editor.call('entities:root');
        var items = entities.slice(0);
        var entitiesNew = [ ];
        var entitiesNewData = [ ];
        var entitiesNewMeta = { };
        var ids = { };

        // make sure not duplicating root
        if (items.indexOf(root) !== -1)
            return;

        // build entities index
        for(var i = 0; i < items.length; i++) {
            var id = items[i].get('resource_id');

            ids[id] = {
                id: id,
                entity: items[i],
                parentId: childToParent[id],
                ind: editor.call('entities:get', childToParent[id]).get('children').indexOf(id)
            };
        }

        // filter children off
        var i = items.length;
        while(i--) {
            var item = ids[items[i].get('resource_id')];
            var parentId = item.parentId;

            while(parentId && parentId !== root.get('resource_id')) {
                if (ids[parentId]) {
                    items.splice(i, 1);
                    delete ids[item.id];
                    break;
                }
                parentId = childToParent[parentId];
            }
        }

        // sort by order index within parent
        items.sort(function(a, b) {
            return ids[b.get('resource_id')].ind - ids[a.get('resource_id')].ind;
        });

        // remember current selection
        var selectorType = editor.call('selector:type');
        var selectorItems = editor.call('selector:items');
        for(var i = 0; i < selectorItems.length; i++) {
            var item = selectorItems[i];
            if (selectorType === 'entity') {
                selectorItems[i] = {
                    type: 'entity',
                    id: item.get('resource_id')
                };
            } else if (selectorType === 'asset') {
                selectorItems[i] = { };
                if (selectorItems[i].get('type') === 'script') {
                    selectorItems[i].type = 'script';
                    selectorItems[i].id = item.get('filename');
                } else {
                    selectorItems[i].type = 'asset';
                    selectorItems[i].id = item.get('id');
                }
            }
        }

        // duplicate
        for(var i = 0; i < items.length; i++) {
            var entity = items[i];
            var id = entity.get('resource_id');
            var parent = editor.call('entities:get', childToParent[id]);
            var entityNew = duplicateEntity(entity, parent, ids[id].ind + 1);
            entitiesNew.push(entityNew);
            entitiesNewData.push(entityNew.json());
            entitiesNewMeta[entityNew.get('resource_id')] = {
                parentId: childToParent[id],
                ind: ids[id].ind
            };
        }

        // set new selection
        setTimeout(function() {
            editor.call('selector:history', false);
            editor.call('selector:set', 'entity', entitiesNew);
            editor.once('selector:change', function() {
                editor.call('selector:history', true);
            });
        }, 0);

        // add history action
        editor.call('history:add', {
            name: 'duplicate entities',
            undo: function() {
                // remove duplicated entities
                for(var i = 0; i < entitiesNewData.length; i++) {
                    var entity = editor.call('entities:get', entitiesNewData[i].resource_id);
                    if (! entity)
                        continue;

                    removeEntity(entity);
                }

                // restore selection
                if (selectorType) {
                    var items = [ ];
                    for(var i = 0; i < selectorItems.length; i++) {
                        var item;

                        if (selectorItems[i].type === 'entity') {
                            item = editor.call('entities:get', selectorItems[i].id);
                        } else if (selectorItems[i].type === 'asset') {
                            item = editor.call('assets:get', selectorItems[i].id);
                        } else if (selectorItems[i].type === 'script') {
                            item = editor.call('sourcefiles:get', selectorItems[i].id);
                        }

                        if (! item)
                            continue;

                        items.push(item);
                    }

                    if (items.length) {
                        editor.call('selector:history', false);
                        editor.call('selector:set', selectorType, items);
                        editor.once('selector:change', function() {
                            editor.call('selector:history', true);
                        });
                    }
                }
            },
            redo: function() {
                var entities = [ ];

                for(var i = 0; i < entitiesNewData.length; i++) {
                    var id = entitiesNewData[i].resource_id;
                    var meta = entitiesNewMeta[id];
                    if (! meta)
                        continue;

                    var parent = editor.call('entities:get', meta.parentId);
                    if (! parent)
                        continue;

                    var entity = new Observer(entitiesNewData[i]);
                    childToParent[id] = meta.parentId;
                    addEntity(entity, parent, true, meta.ind + 1);

                    entities.push(entity);
                }

                if (entities.length) {
                    setTimeout(function() {
                        editor.call('selector:history', false);
                        editor.call('selector:set', 'entity', entities);
                        editor.once('selector:change', function() {
                            editor.call('selector:history', true);
                        });
                    }, 0);
                }
            }
        });
    });

    // delete entity
    editor.method('entities:delete', function (items) {
        var records = [ ];
        var itemsToDelete = [ ];

        // index items
        var itemsIds = { };
        for(var i = 0; i < items.length; i++) {
            itemsIds[items[i].get('resource_id')] = items[i];
        }

        // find out if item has ancestor
        for(var i = 0; i < items.length; i++) {
            var child = false;
            var parent = childToParent[items[i].get('resource_id')];
            while(! child && parent) {
                if (itemsIds[parent]) {
                    child = true;
                } else {
                    parent = childToParent[parent]
                }
            }

            if (! child)
                itemsToDelete.push(items[i]);
        }

        // delete only non-childed items
        items = itemsToDelete;

        for(var i = 0; i < items.length; i++) {
            var resourceId = items[i].get('resource_id');
            var parentId = childToParent[resourceId];
            var ind;
            if (parentId) {
                var parent = editor.call('entities:get', parentId);
                if (parent)
                    ind = parent.get('children').indexOf(resourceId);
            }

            records.push({
                resourceId: resourceId,
                parentId: parentId,
                ind: ind,
                data: items[i].json()
            });
        }

        for(var i = 0; i < items.length; i++) {
            removeEntity(items[i]);
        }

        // sort records by index
        // so that items are re-added
        // in the correct order in undo
        records.sort(function (a, b) {
            return a.ind - b.ind;
        });

        editor.call('history:add', {
            name: 'delete entities',
            undo: function() {
                var items = [ ];
                for (var i = 0, len = records.length; i < len; i++) {
                    var parent = editor.call('entities:get', records[i].parentId);
                    if (! parent)
                        return;

                    var entity = new Observer(records[i].data);
                    items.push(entity);
                    childToParent[entity.get('resource_id')] = parent.get('resource_id');
                    addEntity(entity, parent, false, records[i].ind);
                }

                setTimeout(function() {
                    editor.call('selector:history', false);
                    editor.call('selector:set', 'entity', items);
                    editor.once('selector:change', function() {
                        editor.call('selector:history', true);
                    });
                }, 0);
            },
            redo: function() {
                for(var i = 0, len = records.length; i < len; i++) {
                    var entity = editor.call('entities:get', records[i].resourceId);
                    if (! entity)
                        return;

                    removeEntity(entity);
                }
            }
        });
    });

    // copy entity to local storage
    editor.method('entities:copy', function (entities) {
        var settings = editor.call('settings:project');

        var data = {
            project: config.project.id,
            legacy_scripts: settings.get('useLegacyScripts'),
            hierarchy: {},
            assets: {}
        };

        // store asset path in data by converting the array of
        // folder ids to an array of folder names
        var storeAssetPath = function (assetId) {
            if (! assetId || data.assets[assetId])
                return;

            var asset = editor.call('assets:get', assetId);
            if (! asset)
                return;

            var parts = [];

            var path = asset.get('path');
            if (path && path.length) {
                for (var i = 0; i < path.length; i++) {
                    var a = editor.call('assets:get', path[i]);
                    if (! a) continue;

                    parts.push(a.get('name'));
                }
            }

            parts.push(asset.get('name'));

            data.assets[assetId] = {
                path: parts,
                type: asset.get('type')
            };
        };

        var componentAssetPaths = editor.call('components:assetPaths');

        var containsStar = /\.\*\./;

        // gather all dependencies of this entity
        var gatherDependencies = function (entity) {
            // store entity json
            var resourceId = entity.get('resource_id');
            if (! data.hierarchy[resourceId]) {
                data.hierarchy[resourceId] = entity.json();
            }

            // gather all asset references from the entity
            // and store their path + name
            for (var i = 0; i < componentAssetPaths.length; i++) {
                var path = componentAssetPaths[i];

                // handle paths that contain a '*' as a wildcard
                if (containsStar.test(path)) {
                    var parts = path.split('.*.');
                    if (! entity.has(parts[0])) continue;

                    var obj = entity.get(parts[0]);
                    if (! obj) continue;

                    for (var key in obj) {
                        var fullKey = parts[0] + '.' + key + '.' + parts[1];
                        if (! entity.has(fullKey))
                            continue;

                        var assets = entity.get(fullKey);
                        if (! assets) continue;
                        if (assets instanceof Array) {
                            assets.forEach(storeAssetPath);
                        } else {
                            storeAssetPath(assets);
                        }
                    }
                } else if (entity.has(path)) {
                    // handle path without '*'
                    var assets = entity.get(path);
                    if (! assets) continue;

                    if (assets instanceof Array) {
                        assets.forEach(storeAssetPath);
                    } else {
                        storeAssetPath(assets);
                    }
                }
            }

            // gather script attributes
            if (entity.has('components.script.scripts')) {
                var scripts = entity.get('components.script.scripts');
                if (scripts) {
                    // legacy scripts
                    if (settings.get('useLegacyScripts')) {
                        for (var i = 0, len = scripts.length; i < len; i++) {
                            var script = scripts[i];
                            if (! script.attributes) continue;
                            for (var name in script.attributes) {
                                var attr = script.attributes[name];
                                if (! attr) continue;
                                if (attr.type === 'asset') {
                                    if (attr.value) {
                                        if (attr.value.length) {
                                            attr.value.forEach(storeAssetPath);
                                        } else {
                                            storeAssetPath(attr.value);
                                        }
                                    }

                                    if (attr.defaultValue) {
                                        if (attr.defaultValue.length) {
                                            attr.defaultValue.forEach(storeAssetPath);
                                        } else {
                                            storeAssetPath(attr.defaultValue);
                                        }
                                    }

                                }
                            }
                        }
                    } else {
                        // scripts 2.0
                        for (var key in scripts) {
                            var scriptData = scripts[key];
                            if (! scriptData || ! scriptData.attributes) continue;

                            var asset = editor.call('assets:scripts:assetByScript', key);
                            if (! asset) continue;

                            // search for asset script attributes in script asset
                            var assetData = asset.get('data.scripts.' + key + '.attributes');
                            if (!assetData) continue;

                            for (var name in assetData) {
                                if (assetData[name].type === 'asset' && scriptData.attributes[name]) {
                                    if (assetData[name].array) {
                                        scriptData.attributes[name].forEach(storeAssetPath);
                                    } else {
                                        storeAssetPath(scriptData.attributes[name]);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            var children = entity.get('children');
            for (var i = 0; i < children.length; i++) {
                gatherDependencies(editor.call('entities:get', children[i]));
            }
        };

        // build index
        var selection = {};
        for (var i = 0, len = entities.length; i < len; i++) {
            selection[entities[i].get('resource_id')] = entities[i];
        }


        // sort entities by their index in their parent's children list
        entities.sort(function (a, b) {
            var pA = a.get('parent');
            if (! pA)
                return -1;

            pA = editor.call('entities:get', pA);
            if (! pA)
                return -1;

            var indA = pA.get('children').indexOf(a.get('resource_id'));

            var pB = b.get('parent');
            if (! pB)
                return 1;

            pB = editor.call('entities:get', pB);
            if (! pB)
                return -1;

            var indB = pB.get('children').indexOf(b.get('resource_id'));

            return indA - indB;
        });

        for (var i = 0, len = entities.length; i < len; i++) {
            var e = entities[i];

            var p = childToParent[e.get('resource_id')];
            var isParentSelected = false;
            while (p) {
                if (selection[p]) {
                    isParentSelected = true;
                    break;
                }

                p = childToParent[p];
            }

            // if parent is also selected then skip child
            // and only add parent to copied entities
            if (isParentSelected) {
                // remove entity from selection
                // since its parent is selected
                delete selection[e.get('resource_id')];
                continue;
            }

            // add entity to clipboard if not already added as a child of
            // a higher level entity
            gatherDependencies(e)
        }

        for (var key in selection) {
            // set parent of each copied entity to null
            if (data.hierarchy[key])
                data.hierarchy[key].parent = null;
        }

        // save to local storage
        editor.call('entities:clipboard:set', data);
    });

    // paste entity in local storage under parent
    editor.method('entities:paste', function (parent) {
        // parse data from local storage
        var data = editor.call('entities:clipboard:get');
        if (! data)
            return;

        // paste on root if no parent specified
        if (! parent)
            parent = editor.call('entities:root');

        var settings = editor.call('settings:project');
        var legacy_scripts = settings.get('useLegacyScripts');

        var componentAssetPaths = editor.call('components:assetPaths');
        var containsStar = /\.\*\./;

        // try to find asset id in this project
        // from path of asset in old project
        var remapAsset = function (assetId) {
            if (! assetId) return null;

            // return the old asset id if not found
            var result = parseInt(assetId, 10);

            var assetData = data.assets[assetId];
            if (! assetData)
                return result;

            var len = assetData.path.length;
            var name = assetData.path[len-1];
            var type = assetData.type;

            var pathToId = [];

            var assets = editor.call('assets:list');
            var assetLen = assets.length;

            // change path names to folder ids
            for (var i = 0; i < len - 1; i++) {
                var folder = null;

                for (var j = 0; j < assetLen; j++) {
                    var asset = assets[j];
                    if (asset.get('name') === assetData.path[i] && asset.get('type') === 'folder') {
                        folder = asset;
                        break;
                    }
                }

                if (!folder)
                    return result;

                pathToId.push(parseInt(folder.get('id'), 10));
            }

            var pathToIdLen = pathToId.length;

            // search for asset of same name, type
            // and path as original
            for (var i = 0; i < assetLen; i++) {
                var asset = assets[i];

                if (asset.get('name') === name &&
                    asset.get('type') === type &&
                    !asset.get('source')) {
                    var path = asset.get('path');
                    var pathLen = path && path.length;
                    if (path && pathLen === pathToIdLen) {
                        var pathsEqual = true;
                        for (var j = 0; j < pathLen; j++) {
                            if (path[j] !== pathToId[j]) {
                                pathsEqual = false;
                                break;
                            }
                        }

                        if (! pathsEqual)
                            continue;
                    }

                    result = parseInt(asset.get('id'), 10);
                    break;
                }
            }

            return result;
        };

        // remap assets
        if (data.assets) {
            for (var key in data.assets) {
                data.assets[key] = remapAsset(key);
            }
        }

        // change resource ids
        var mapping = {};
        for (var resourceId in data.hierarchy) {
            mapping[resourceId] = pc.guid.create();
        }

        var remapResourceIds = function (entity) {
            var resourceId = entity.get('resource_id');

            var newResourceId = mapping[resourceId];
            entity.set('resource_id', newResourceId);

            // set new resource id for parent
            var parentId = entity.get('parent');
            if (parentId) {
                entity.set('parent', mapping[parentId]);
            } else {
                entity.set('parent', parent.get('resource_id'));
            }

            childToParent[newResourceId] = entity.get('parent');

            // set children to empty array because these
            // are going to get added later on
            entity.set('children', []);

            // remap assets and entities
            if (data.project !== config.project.id) {
                for (var i = 0; i < componentAssetPaths.length; i++) {
                    var path = componentAssetPaths[i];
                    if (containsStar.test(path)) {
                        var parts = path.split('.*.');
                        if (! entity.has(parts[0])) continue;

                        var obj = entity.get(parts[0]);
                        if (! obj) continue;

                        for (var key in obj) {
                            var fullKey = parts[0] + '.' + key + '.' + parts[1];
                            if (! entity.has(fullKey)) continue;

                            var assets = entity.get(fullKey);
                            if (! assets) continue;

                            if (assets instanceof Array) {
                                for (var j = 0; j < assets.length; j++) {
                                    assets[j] = data.assets[assets[j]];
                                }
                                entity.set(fullKey, assets);
                            } else {
                                entity.set(fullKey, data.assets[assets]);
                            }
                        }
                    }
                    else if (entity.has(path)) {
                        var assets = entity.get(path);
                        if (! assets) continue;

                        if (assets instanceof Array) {
                            for (var j = 0; j < assets.length; j++) {
                                assets[j] = data.assets[assets[j]];
                            }
                            entity.set(path, assets);
                        } else {
                            entity.set(path, data.assets[assets]);
                        }
                    }
                }
            }

            // remap script asset attributes
            if (entity.has('components.script.scripts')) {
                if (entity.has('components.script')) {
                    // remove script component if legacy scripts flag is different between the two projects
                    if (legacy_scripts !== data.legacy_scripts) {
                        entity.unset('components.script');
                    } else {
                        var scripts = entity.get('components.script.scripts');
                        // legacy scripts
                        if (legacy_scripts) {
                            for (var i = 0, len = scripts.length; i < len; i++) {
                                var script = scripts[i];
                                if (! script.attributes) continue;

                                for (var name in script.attributes) {
                                    var attr = script.attributes[name];
                                    if (! attr) continue;

                                    if (attr.type === 'asset' && data.project !== config.project.id) {
                                        if (attr.value) {
                                            if (attr.value instanceof Array) {
                                                for (var j = 0; j < attr.value.length; j++) {
                                                    entity.set('components.script.scripts.' + i + '.attributes.' + name + '.value.' + j, data.assets[attr.value[j]])
                                                }
                                            } else {
                                                entity.set('components.script.scripts.' + i + '.attributes.' + name + '.value', data.assets[attr.value]);
                                            }
                                        }

                                        if (attr.defaultValue) {
                                            if (attr.defaultValue instanceof Array) {
                                                for (var j = 0; j < attr.defaultValue.length; j++) {
                                                    entity.set('components.script.scripts.' + i + '.attributes.' + name + '.defaultValue.' + j, data.assets[attr.value[j]])
                                                }
                                            } else {
                                                entity.set('components.script.scripts.' + i + '.attributes.' + name + '.defaultValue', data.assets[attr.value]);
                                            }
                                        }
                                    } else if (attr.type === 'entity') {
                                        if (mapping[attr.value])
                                            entity.set('components.script.scripts.' + i + '.attributes.' + name + '.value', mapping[attr.value]);
                                        if (mapping[attr.defaultValue])
                                            entity.set('components.script.scripts.' + i + '.attributes.' + name + '.defaultValue', mapping[attr.defaultValue]);
                                    }
                                }
                            }
                        } else {
                            // scripts 2.0
                            if (scripts) {
                                for(var script in scripts) {
                                    var asset = editor.call('assets:scripts:assetByScript', script);
                                    if (! asset) continue;

                                    var attrs = scripts[script].attributes;
                                    if (! attrs) continue;

                                    for (var key in attrs) {
                                        var attrData = asset.get('data.scripts.' + script + '.attributes.' + key);
                                        if (attrData) {
                                            if (attrData.type === 'asset' && data.project !== config.project.id) {
                                                // remap asset ids
                                                if (attrData.array) {
                                                    for (var j = 0; j < attrs[key].length; j++) {
                                                        entity.set('components.script.scripts.' + script + '.attributes.' + key + '.' + j, data.assets[attrs[key][j]]);
                                                    }
                                                } else {
                                                    entity.set('components.script.scripts.' + script + '.attributes.' + key, data.assets[attrs[key]]);
                                                }
                                            } else if (attrData.type === 'entity') {
                                                // try to remap entities
                                                if (mapping[attrs[key]]) {
                                                    entity.set('components.script.scripts.' + script + '.attributes.' + key, mapping[attrs[key]]);
                                                }
                                            }

                                        }
                                    }
                                }
                            }
                        }
                    }
                }

            }
        };

        // add all entities with different resource ids
        var newEntities = [];
        var selectedEntities = [];

        for (var resourceId in data.hierarchy) {
            // create new entity
            var entity = new Observer(data.hierarchy[resourceId]);

            // select the entity if its parent is not selected
            var select = !data.hierarchy[entity.get('parent')];

            // change resource ids
            remapResourceIds(entity);

            // sharejs
            editor.call('realtime:scene:op', {
                p: [ 'entities', entity.get('resource_id') ],
                oi: entity.json()
            });

            // add it
            editor.call('entities:add', entity);
            newEntities.push(entity);

            if (select)
                selectedEntities.push(entity);
        }

        // reparent children after they're all added
        for (var i = 0; i < newEntities.length; i++) {
            var entity = newEntities[i];
            var parentEntity = editor.call('entities:get', entity.get('parent'));

            // this is necessary for the entity to be added to the tree view
            parentEntity.history.enabled = false;
            parentEntity.insert('children', entity.get('resource_id'));
            parentEntity.history.enabled = true;
        }

        // select pasted entities
        setTimeout(function() {
            editor.call('selector:history', false);
            editor.call('selector:set', 'entity', selectedEntities);
            editor.once('selector:change', function() {
                editor.call('selector:history', true);
            });
        }, 0);

        // add history
        editor.call('history:add', {
            name: 'paste entities',
            undo: function() {
                for (var i = selectedEntities.length - 1; i >= 0; i--) {
                    var entity = editor.call('entities:get', selectedEntities[i].get('resource_id'));
                    if (! entity) continue;

                    removeEntity(entity);
                }

                var selectorType = editor.call('selector:type');
                var selectorItems = editor.call('selector:items');
                if (selectorType === 'entity' && selectorItems.length) {
                    var items = [ ];
                    for(var i = 0; i < selectorItems.length; i++) {
                        var item = editor.call('entities:get', selectorItems[i]);
                        if (item)
                            items.push(item);
                    }

                    if (items.length) {
                        editor.call('selector:history', false);
                        editor.call('selector:set', selectorType, items);
                        editor.once('selector:change', function() {
                            editor.call('selector:history', true);
                        });
                    }
                }
            },
            redo: function() {
                var newParent = editor.call('entities:get', parent.get('resource_id'));
                if (! newParent) return;

                var numChildren = newParent.get('children').length;

                var entities = [];
                // re-add entities
                for (var i = 0; i < selectedEntities.length; i++) {
                    var fromCache = deletedCache[selectedEntities[i].get('resource_id')];
                    if (! fromCache) continue;
                    var e = new Observer(fromCache);
                    addEntity(e, newParent, false, numChildren + i);
                    entities.push(e);
                }

                editor.call('selector:history', false);
                editor.call('selector:set', 'entity', entities);
                editor.once('selector:change', function() {
                    editor.call('selector:history', true);
                });
            }
        });
    });

    editor.method('entities:addComponent', function (entities, component) {
        var componentData = editor.call('components:getDefault', component);
        var records = [ ];

        for(var i = 0; i < entities.length; i++) {
            if (entities[i].has('components.' + component))
                continue;

            records.push({
                get: entities[i].history._getItemFn,
                value: componentData
            });

            entities[i].history.enabled = false;
            entities[i].set('components.' + component, componentData);
            entities[i].history.enabled = true;
        }

        // if it's a collision or rigidbody component then enable physics
        if (component === 'collision' || component === 'rigidbody') {
            var settings = editor.call('settings:project');
            var history = settings.history;
            settings.history = false;
            settings.set('use3dPhysics', true);
            settings.history = history;
        }

        editor.call('history:add', {
            name: 'entities.' + component,
            undo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;
                    item.history.enabled = false;
                    item.unset('components.' + component);
                    item.history.enabled = true;
                }
            },
            redo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;
                    item.history.enabled = false;
                    item.set('components.' + component, records[i].value);
                    item.history.enabled = true;
                }
            }
        });
    });
});


/* editor/entities/entities-panel.js */
editor.once('load', function() {
    'use strict'

    // hierarchy index
    var uiItemIndex = { };
    var awaitingParent = { };

    var panel = editor.call('layout.left');

    // list
    var hierarchy = new ui.Tree();
    hierarchy.allowRenaming = editor.call('permissions:write');
    hierarchy.class.add('hierarchy');
    panel.append(hierarchy);

    editor.on('permissions:writeState', function(state) {
        hierarchy.allowRenaming = state;
    });

    var resizeQueued = false;
    var resizeTree = function() {
        resizeQueued = false;
        hierarchy.element.style.width = '';
        hierarchy.element.style.width = (panel.innerElement.scrollWidth - 5) + 'px';
    };
    var resizeQueue = function() {
        if (resizeQueued) return;
        resizeQueued = true;
        requestAnimationFrame(resizeTree);
    };
    panel.on('resize', resizeQueue);
    hierarchy.on('open', resizeQueue);
    hierarchy.on('close', resizeQueue);
    setInterval(resizeQueue, 1000);


    // return hirarchy
    editor.method('entities:hierarchy', function () {
        return hierarchy;
    });

    // list item selected
    hierarchy.on('select', function(item) {
        // open items till parent
        var parent = item.parent;
        while(parent && parent instanceof ui.TreeItem) {
            parent.open = true;
            parent = parent.parent;
        }
        // focus
        item.elementTitle.focus();
        // add selection
        editor.call('selector:add', 'entity', item.entity);
    });

    // list item deselected
    hierarchy.on('deselect', function(item) {
        editor.call('selector:remove', item.entity);
    });


    // scrolling on drag
    var dragScroll = 0;
    var dragTimer;
    var dragLastEvt;
    var dragEvt = function(evt) {
        if (! hierarchy._dragging) {
            clearInterval(dragTimer);
            window.removeEventListener('mousemove', dragEvt);
            return;
        }
        var rect = panel.innerElement.getBoundingClientRect();

        if ((evt.clientY - rect.top) < 32 && panel.innerElement.scrollTop > 0) {
            dragScroll = -1;
        } else if ((rect.bottom - evt.clientY) < 32 && (panel.innerElement.scrollHeight - (rect.height + panel.innerElement.scrollTop)) > 0) {
            dragScroll = 1;
        } else {
            dragScroll = 0;
        }
    };
    hierarchy.on('dragstart', function() {
        dragTimer = setInterval(function() {
            if (dragScroll === 0)
                return;

            panel.innerElement.scrollTop += dragScroll * 8;
            hierarchy._dragOver = null;
            hierarchy._updateDragHandle();
        }, 1000 / 60);

        dragScroll = 0;
        window.addEventListener('mousemove', dragEvt, false);

        var resourceId = hierarchy._dragItems[0].entity.get('resource_id');
        editor.call('drop:set', 'entity', { resource_id: resourceId });
        editor.call('drop:activate', true);
    });

    hierarchy.on('dragend', function() {
        editor.call('drop:activate', false);
        editor.call('drop:set');
    });


    var target = editor.call('drop:target', {
        ref: panel.innerElement,
        type: 'entity',
        hole: true,
        passThrough: true
    });
    target.element.style.outline = 'none';


    // reparenting
    hierarchy.on('reparent', function(items) {
        var records = [ ];

        var preserveTransform = Tree._ctrl && Tree._ctrl();

        // make records and collect relevant data
        for(var i = 0; i < items.length; i++) {
            if (items[i].item.entity.reparenting)
                continue;

            var record = {
                item: items[i].item,
                parent: items[i].item.parent.entity,
                entity: items[i].item.entity,
                parentOld: items[i].old.entity,
                resourceId: items[i].item.entity.get('resource_id'),
                parentId: items[i].item.parent.entity.get('resource_id'),
                parentIdOld: items[i].old.entity.get('resource_id')
            };

            if (preserveTransform && record.entity) {
                record.position = record.entity.entity.getPosition().clone();
                record.rotation = record.entity.entity.getRotation().clone();
            }

            // relative entity
            record.indOld = record.parentOld.get('children').indexOf(record.resourceId);
            record.indNew = Array.prototype.indexOf.call(record.item.parent.innerElement.childNodes, record.item.element) - 1;

            records.push(record);
        }

        for(var i = 0; i < records.length; i++) {
            var record = records[i];

            record.entity.reparenting = true;

            record.parent.history.enabled = false;
            record.parentOld.history.enabled = false;
            record.entity.history.enabled = false;

            if (record.parent === record.parentOld) {
                // move
                record.parent.removeValue('children', record.resourceId);
                record.parent.insert('children', record.resourceId, record.indNew + ((record.indNew > record.indOld) ? (records.length - 1 - i) : 0));
            } else {
                // reparenting

                // remove from old parent
                record.parentOld.removeValue('children', record.resourceId);

                // add to new parent children
                if (record.indNew !== -1) {
                    // before other item
                    record.parent.insert('children', record.resourceId, record.indNew);
                } else {
                    // at the end
                    record.parent.insert('children', record.resourceId);
                }

                // set parent
                record.entity.set('parent', record.parentId);
            }

            if (preserveTransform && record.position) {
                record.entity.entity.setPosition(record.position);
                record.entity.entity.setRotation(record.rotation);

                var localPosition = record.entity.entity.getLocalPosition();
                var localRotation = record.entity.entity.getLocalEulerAngles();
                record.entity.set('position', [ localPosition.x, localPosition.y, localPosition.z ]);
                record.entity.set('rotation', [ localRotation.x, localRotation.y, localRotation.z ]);
            }

            record.parent.history.enabled = true;
            record.parentOld.history.enabled = true;
            record.entity.history.enabled = true;
            record.entity.reparenting = false;
        }

        editor.call('history:add', {
            name: 'reparent entities',
            undo: function() {
                for(var i = 0; i < records.length; i++) {
                    var entity = editor.call('entities:get', records[i].resourceId);
                    if (! entity) continue;

                    var parent = editor.call('entities:get', entity.get('parent'));
                    var parentOld = editor.call('entities:get', records[i].parentIdOld);
                    if (! parentOld || ! parent) continue;

                    if (parent.get('children').indexOf(records[i].resourceId) === -1 || (parentOld.get('children').indexOf(records[i].resourceId) !== -1 && parentOld !== parent))
                        return;

                    // check if not reparenting to own child
                    var deny = false;
                    var checkParent = editor.call('entities:get', parentOld.get('parent'));
                    while(checkParent) {
                        if (checkParent === entity) {
                            deny = true;
                            checkParent = null;
                            break;
                        } else {
                            checkParent = editor.call('entities:get', checkParent.get('parent'));
                        }
                    }
                    if (deny)
                        continue;

                    parent.history.enabled = false;
                    parent.removeValue('children', records[i].resourceId);
                    parent.history.enabled = true;

                    parentOld.history.enabled = false;
                    var off = parent !== parentOld ? 0 : ((records[i].indNew < records[i].indOld) ? (records.length - 1 - i) : 0);
                    parentOld.insert('children', records[i].resourceId, records[i].indOld === -1 ? undefined : records[i].indOld + off);
                    parentOld.history.enabled = true;

                    entity.history.enabled = false;
                    entity.set('parent', records[i].parentIdOld);

                    if (preserveTransform && records[i].position && entity.entity) {
                        entity.entity.setPosition(records[i].position);
                        entity.entity.setRotation(records[i].rotation);

                        var localPosition = entity.entity.getLocalPosition();
                        var localRotation = entity.entity.getLocalEulerAngles();
                        entity.set('position', [ localPosition.x, localPosition.y, localPosition.z ]);
                        entity.set('rotation', [ localRotation.x, localRotation.y, localRotation.z ]);
                    }

                    entity.history.enabled = true;

                    editor.call('viewport:render');
                }
            },
            redo: function() {
                for(var i = 0; i < records.length; i++) {
                    var entity = editor.call('entities:get', records[i].resourceId);
                    if (! entity) continue;

                    var parent = editor.call('entities:get', records[i].parentId);
                    var parentOld = editor.call('entities:get', entity.get('parent'));
                    if (! parentOld || ! parent) continue;

                    if (parentOld.get('children').indexOf(records[i].resourceId) === -1 || (parent.get('children').indexOf(records[i].resourceId) !== -1 && parent !== parentOld))
                        continue;

                    // check if not reparenting to own child
                    var deny = false;
                    var checkParent = editor.call('entities:get', parent.get('parent'));
                    while(checkParent) {
                        if (checkParent === entity) {
                            deny = true;
                            checkParent = null;
                            break;
                        } else {
                            checkParent = editor.call('entities:get', checkParent.get('parent'));
                        }
                    }
                    if (deny)
                        continue;

                    parentOld.history.enabled = false;
                    parentOld.removeValue('children', records[i].resourceId);
                    parentOld.history.enabled = true;

                    parent.history.enabled = false;
                    var off = parent !== parentOld ? 0 : ((records[i].indNew > records[i].indOld) ? (records.length - 1 - i) : 0);
                    parent.insert('children', records[i].resourceId, records[i].indNew + off);
                    parent.history.enabled = true;

                    entity.history.enabled = false;
                    entity.set('parent', records[i].parentId);

                    if (preserveTransform && records[i].position && entity.entity) {
                        entity.entity.setPosition(records[i].position);
                        entity.entity.setRotation(records[i].rotation);

                        var localPosition = entity.entity.getLocalPosition();
                        var localRotation = entity.entity.getLocalEulerAngles();
                        entity.set('position', [ localPosition.x, localPosition.y, localPosition.z ]);
                        entity.set('rotation', [ localRotation.x, localRotation.y, localRotation.z ]);
                    }

                    entity.history.enabled = true;

                    editor.call('viewport:render');
                }
            }
        });

        resizeQueue();
        editor.call('viewport:render');
    });


    // selector add
    editor.on('selector:add', function(entity, type) {
        if (type !== 'entity')
            return;

        uiItemIndex[entity.get('resource_id')].selected = true;
    });
    // selector remove
    editor.on('selector:remove', function(entity, type) {
        if (type !== 'entity')
            return;

        uiItemIndex[entity.get('resource_id')].selected = false;
    });
    // selector change
    editor.on('selector:change', function(type, items) {
        if (type !== 'entity') {
            hierarchy.clear();
        } else {
            var selected = hierarchy.selected;
            var ids = { };

            // build index of selected items
            for(var i = 0; i < items.length; i++) {
                ids[items[i].get('resource_id')] = true;
            };

            // deselect unselected items
            for(var i = 0; i < selected.length; i++) {
                if (! ids[selected[i].entity.get('resource_id')])
                    selected[i].selected = false;
            }
        }
    });


    // entity removed
    editor.on('entities:remove', function(entity) {
        uiItemIndex[entity.get('resource_id')].destroy();
        resizeQueue();
    });


    var componentList;

    // entity added
    editor.on('entities:add', function(entity) {
        var element = new ui.TreeItem({
            text: entity.get('name')
        });

        element.entity = entity;
        element.enabled = entity.get('enabled');

        if (! componentList)
            componentList = editor.call('components:list');

        // icon
        var components = Object.keys(entity.get('components'));
        for(var i = 0; i < components.length; i++)
            element.class.add('c-' + components[i]);

        var watchComponent = function(component) {
            entity.on('components.' + component + ':set', function() {
                element.class.add('c-' + component);
            });
            entity.on('components.' + component + ':unset', function() {
                element.class.remove('c-' + component);
            });
        };
        for(var i = 0; i < componentList.length; i++) {
            watchComponent(componentList[i]);
        }

        entity.reparenting = false;

        // index
        uiItemIndex[entity.get('resource_id')] = element;

        // name change
        entity.on('name:set', function(value) {
            element.text = value;
            resizeQueue();
        });

        entity.on('enabled:set', function(value) {
            element.enabled = value;
        });

        entity.on('children:move', function(value, ind, indOld) {
            var item = uiItemIndex[value];
            if (! item || item.entity.reparenting)
                return;

            element.remove(item);

            var next = uiItemIndex[entity.get('children.' + (ind + 1))];
            var after = null;
            if (next === item) {
                next = null;

                if (ind > 0)
                    after = uiItemIndex[entity.get('children.' + ind)]
            }

            if (item.parent)
                item.parent.remove(item);

            if (next) {
                element.appendBefore(item, next);
            } else if (after) {
                element.appendAfter(item, after);
            } else {
                element.append(item);
            }
        });

        // remove children
        entity.on('children:remove', function(value) {
            var item = uiItemIndex[value];
            if (! item || item.entity.reparenting)
                return;

            element.remove(item);
        });

        // add children
        entity.on('children:insert', function(value, ind) {
            var item = uiItemIndex[value];

            if (! item || item.entity.reparenting)
                return;

            if (item.parent)
                item.parent.remove(item);

            var next = uiItemIndex[entity.get('children.' + (ind + 1))];
            if (next) {
                element.appendBefore(item, next);
            } else {
                element.append(item);
            }
        });

        // collaborators
        var users = element.users = document.createElement('span');
        users.classList.add('users');
        element.elementTitle.appendChild(users);

        resizeQueue();
    });


    // append all treeItems according to child order
    editor.on('entities:load', function() {
        var entities = editor.call('entities:list');

        for(var i = 0; i < entities.length; i++) {
            var entity = entities[i];
            var element = uiItemIndex[entity.get('resource_id')];

            if (! entity.get('parent')) {
                // root
                hierarchy.append(element);
                element.open = true;
            }

            var children = entity.get('children');
            if (children.length) {
                for(var c = 0; c < children.length; c++) {
                    var child = uiItemIndex[children[c]];
                    element.append(child);
                }
            }
        }
    });


    // deleting entity
    editor.on('entity:delete', function(entity) {
        editor.call('entities:remove', entity);
    });

    // get entity item
    editor.method('entities:panel:get', function (resourceId) {
        return uiItemIndex[resourceId];
    });

    // highlight entity
    editor.method('entities:panel:highlight', function (resourceId, highlight) {
        var item = uiItemIndex[resourceId];
        if (!item) return;

        if (highlight)
            item.class.add('highlight');
        else
            item.class.remove('highlight');
    });
});


/* editor/entities/entities-menu.js */
editor.once('load', function() {
    'use strict';

    var componentsLogos = {
        'animation': '&#57875;',
        'audiolistener': '&#57750;',
        'audiosource': '&#57751;',
        'sound': '&#57751;',
        'camera': '&#57874;',
        'collision': '&#57735;',
        'directional': '&#57746;',
        'point': '&#57745;',
        'spot': '&#57747;',
        'model': '&#57736;',
        'particlesystem': '&#57753;',
        'rigidbody': '&#57737;',
        'script': '&#57910;',
        'zone': '&#57910;',
        'screen': '&#57665;',
        'element': '&#58232;'
    };

    editor.method('menu:entities:new', function (getParentFn) {
        if (! getParentFn)
            getParentFn = function () {return editor.call('entities:selectedFirst');};

        return {
            'add-new-entity': {
                title: 'Entity',
                icon: '&#57632;',
                select: function() {
                    editor.call('entities:new', {parent: getParentFn()});
                }
            },
            'add-new-listener': {
                title: 'Audio Listener',
                icon: componentsLogos.audiolistener,
                select: function() {
                    editor.call('entities:new', {
                        name: 'Audio Listener',
                        parent: getParentFn(),
                        components: {
                            audiolistener: editor.call('components:getDefault', 'audiolistener')
                        }
                    });
                }
            },
            'add-new-audiosource': {
                title: 'Audio Source',
                icon: componentsLogos.audiosource,
                hide: function () {
                    return ! editor.call('settings:project').get('useLegacyAudio');
                },
                select: function() {
                    editor.call('entities:new', {
                        name: 'Audio Source',
                        parent: getParentFn(),
                        components: {
                            audiosource: editor.call('components:getDefault', 'audiosource')
                        }
                    });
                }
            },
            'add-new-sound': {
                title: 'Sound',
                icon: componentsLogos.sound,
                select: function() {
                    editor.call('entities:new', {
                        name: 'Sound',
                        parent: getParentFn(),
                        components: {
                            sound: editor.call('components:getDefault', 'sound')
                        }
                    });
                }
            },
            'add-new-camera': {
                title: 'Camera',
                icon: componentsLogos.camera,
                select: function() {
                    editor.call('entities:new', {
                        name: 'Camera',
                        parent: getParentFn(),
                        components: {
                            camera: editor.call('components:getDefault', 'camera')
                        }
                    });
                }
            },
            'add-new-box': {
                title: 'Box',
                icon: componentsLogos.model,
                select: function() {
                    var component = editor.call('components:getDefault', 'model');
                    component.type = 'box';

                    editor.call('entities:new', {
                        name: 'Box',
                        parent: getParentFn(),
                        components: {
                            model: component
                        }
                    });
                }
            },
            'add-new-capsule': {
                title: 'Capsule',
                icon: componentsLogos.model,
                select: function() {
                    var component = editor.call('components:getDefault', 'model');
                    component.type = 'capsule';

                    editor.call('entities:new', {
                        name: 'Capsule',
                        parent: getParentFn(),
                        components: {
                            model: component
                        }
                    });
                }
            },
            'add-new-cone': {
                title: 'Cone',
                icon: componentsLogos.model,
                select: function() {
                    var component = editor.call('components:getDefault', 'model');
                    component.type = 'cone';

                    editor.call('entities:new', {
                        name: 'Cone',
                        parent: getParentFn(),
                        components: {
                            model: component
                        }
                    });
                }
            },
            'add-new-cylinder': {
                title: 'Cylinder',
                icon: componentsLogos.model,
                select: function() {
                    var component = editor.call('components:getDefault', 'model');
                    component.type = 'cylinder';

                    editor.call('entities:new', {
                        name: 'Cylinder',
                        parent: getParentFn(),
                        components: {
                            model: component
                        }
                    });
                }
            },
            'add-new-model': {
                title: 'Model',
                icon: componentsLogos.model,
                select: function() {
                    var component = editor.call('components:getDefault', 'model');
                    component.type = 'asset';

                    editor.call('entities:new', {
                        name: 'Model',
                        parent: getParentFn(),
                        components: {
                            model: component
                        }
                    });
                }
            },
            'add-new-plane': {
                title: 'Plane',
                icon: componentsLogos.model,
                select: function() {
                    var component = editor.call('components:getDefault', 'model');
                    component.type = 'plane';

                    editor.call('entities:new', {
                        name: 'Plane',
                        parent: getParentFn(),
                        components: {
                            model: component
                        }
                    });
                }
            },
            'add-new-sphere': {
                title: 'Sphere',
                icon: componentsLogos.model,
                select: function() {
                    var component = editor.call('components:getDefault', 'model');
                    component.type = 'sphere';

                    editor.call('entities:new', {
                        name: 'Sphere',
                        parent: getParentFn(),
                        components: {
                            model: component
                        }
                    });
                }
            },
            'add-new-directional': {
                title: 'Directional Light',
                icon: componentsLogos.directional,
                select: function() {
                    var component = editor.call('components:getDefault', 'light');
                    component.type = 'directional';

                    editor.call('entities:new', {
                        name: 'Directional Light',
                        parent: getParentFn(),
                        components: {
                            light: component
                        }
                    });
                }
            },
            'add-new-point': {
                title: 'Point Light',
                icon: componentsLogos.point,
                select: function() {
                    var component = editor.call('components:getDefault', 'light');
                    component.type = 'point';
                    component.shadowResolution = 256;

                    editor.call('entities:new', {
                        name: 'Point Light',
                        parent: getParentFn(),
                        components: {
                            light: component
                        }
                    });
                }
            },
            'add-new-spot': {
                title: 'Spot Light',
                icon: componentsLogos.spot,
                select: function() {
                    var component = editor.call('components:getDefault', 'light');
                    component.type = 'spot';

                    editor.call('entities:new', {
                        name: 'Spot Light',
                        parent: getParentFn(),
                        components: {
                            light: component
                        }
                    });
                }
            },
            'add-new-particles': {
                title: 'Particle System',
                icon: componentsLogos.particlesystem,
                select: function() {
                    editor.call('entities:new', {
                        name: 'Particle System',
                        parent: getParentFn(),
                        components: {
                            particlesystem: editor.call('components:getDefault', 'particlesystem')
                        }
                    });
                }
            },
            'add-new-zone': {
                title: 'Zone',
                icon: componentsLogos.zone,
                select: function() {
                    editor.call('entities:new', {
                        name: 'Zone',
                        parent: getParentFn(),
                        components: {
                            zone: editor.call('components:getDefault', 'zone')
                        }
                    });
                }
            },
            'add-new-2d-screen': {
                title: '2D Screen',
                icon: componentsLogos.screen,
                select: function() {
                    var data = editor.call('components:getDefault', 'screen');
                    data.screenSpace = true;

                    editor.call('entities:new', {
                        name: '2D Screen',
                        parent: getParentFn(),
                        components: {
                            screen: data
                        }
                    });
                }
            },
            'add-new-3d-screen': {
                title: '3D Screen',
                icon: componentsLogos.screen,
                select: function() {
                    var data = editor.call('components:getDefault', 'screen');
                    data.screenSpace = false;

                    editor.call('entities:new', {
                        name: '3D Screen',
                        parent: getParentFn(),
                        scale: [0.01, 0.01, 0.01],
                        components: {
                            screen: data
                        }
                    });
                }
            },
            'add-new-text': {
                title: 'Text Element',
                icon: componentsLogos.element,
                select: function() {
                    var data = editor.call('components:getDefault', 'element');
                    data.type = 'text';
                    data.text = 'Text';
                    data.autoWidth = true;
                    data.autoHeight = true;
                    editor.call('entities:new', {
                        name: 'Text',
                        parent: getParentFn(),
                        components: {
                            element: data
                        }
                    });
                }
            },
            'add-new-image': {
                title: 'Image Element',
                icon: componentsLogos.element,
                select: function() {
                    var data = editor.call('components:getDefault', 'element');
                    data.type = 'image';
                    editor.call('entities:new', {
                        name: 'Image',
                        parent: getParentFn(),
                        components: {
                            element: data
                        }
                    });
                }
            },
            'add-new-group': {
                title: 'Element Group',
                icon: componentsLogos.element,
                select: function() {
                    var data = editor.call('components:getDefault', 'element');
                    data.type = 'group';
                    editor.call('entities:new', {
                        name: 'Group',
                        parent: getParentFn(),
                        components: {
                            element: data
                        }
                    });
                }
            }
        };
    });
});


/* editor/entities/entities-control.js */
editor.once('load', function() {
    'use strict'

    var root = editor.call('layout.root');
    var panel = editor.call('layout.left');

    // controls
    var controls = new ui.Panel();

    controls.hidden = ! editor.call('permissions:write');
    editor.on('permissions:writeState', function(state) {
        controls.hidden = ! state;
    });

    controls.class.add('hierarchy-controls');
    controls.parent = panel;
    panel.headerAppend(controls);


    // controls delete
    var btnDelete = new ui.Button({
        text: '&#57636;'
    });
    btnDelete.class.add('delete');
    btnDelete.style.fontWeight = 200;
    btnDelete.on('click', function() {
        var type = editor.call('selector:type');

        if (type !== 'entity')
            return;

        editor.call('entities:delete', editor.call('selector:items'));
    });
    controls.append(btnDelete);

    var tooltipDelete = Tooltip.attach({
        target: btnDelete.element,
        text: 'Delete Entity',
        align: 'top',
        root: root
    });
    tooltipDelete.class.add('innactive');


    // controls duplicate
    var btnDuplicate = new ui.Button({
        text: '&#57638;'
    });
    btnDuplicate.disabled = true;
    btnDuplicate.class.add('duplicate');
    btnDuplicate.on('click', function() {
        var type = editor.call('selector:type');
        var items = editor.call('selector:items');

        if (type === 'entity' && items.length)
            editor.call('entities:duplicate', items);
    });
    controls.append(btnDuplicate);

    var tooltipDuplicate = Tooltip.attach({
        target: btnDuplicate.element,
        text: 'Duplicate Entity',
        align: 'top',
        root: root
    });
    tooltipDuplicate.class.add('innactive');

    var menuEntities = ui.Menu.fromData(editor.call('menu:entities:new'));
    root.append(menuEntities);

    // controls add
    var btnAdd = new ui.Button({
        text: '&#57632;'
    });
    btnAdd.class.add('add');
    btnAdd.on('click', function() {
        menuEntities.open = true;
        var rect = btnAdd.element.getBoundingClientRect();
        menuEntities.position(rect.left, rect.top);
    });
    controls.append(btnAdd);

    Tooltip.attach({
        target: btnAdd.element,
        text: 'Add Entity',
        align: 'top',
        root: root
    });


    editor.on('attributes:clear', function() {
        btnDuplicate.disabled = true;
        btnDelete.disabled = true;
        tooltipDelete.class.add('innactive');
        tooltipDuplicate.class.add('innactive');
    });

    editor.on('attributes:inspect[*]', function(type, items) {
        var root = editor.call('entities:root');

        if (type === 'entity' && items[0] !== root) {
            btnDelete.enabled = true;
            btnDuplicate.enabled = true;
            tooltipDelete.class.remove('innactive');
            tooltipDuplicate.class.remove('innactive');
        } else {
            btnDelete.enabled = false;
            btnDuplicate.enabled = false;
            tooltipDelete.class.add('innactive');
            tooltipDuplicate.class.add('innactive');
        }
    });
});





/* editor/entities/entities-fuzzy-search.js */
editor.once('load', function() {
    'use strict';


    editor.method('entities:fuzzy-search', function(query, limit) {
        var items = [ ];
        var entities = editor.call('entities:list');

        for(var i = 0; i < entities.length; i++)
            items.push([ entities[i].get('name'), entities[i] ]);

        var result = editor.call('search:items', items, query, {
            limitResults: limit || 16
        });

        return result;
    });
});


/* editor/entities/entities-fuzzy-search-ui.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var panel = editor.call('layout.left');
    var hierarchy = editor.call('entities:hierarchy');
    var changing = false;
    var itemsIndex = { };

    var results = new ui.List();
    results.element.tabIndex = 0;
    results.hidden = true;
    results.class.add('search-results');
    panel.append(results);

    // clear on escape
    results.element.addEventListener('keydown', function(evt) {
        if (evt.keyCode === 27) { // esc
            searchClear.click();

        } else if (evt.keyCode === 13) { // enter
            if (! results.selected) {
                var firstElement = results.element.firstChild;
                if (firstElement && firstElement.ui && firstElement.ui.entity)
                    editor.call('selector:set', 'entity', [ firstElement.ui.entity ]);
            }
            search.value = '';

        } else if (evt.keyCode === 40) { // down
            selectNext();
            evt.stopPropagation();

        } else if (evt.keyCode === 38) { // up
            selectPrev();
            evt.stopPropagation();
        }
    }, false);

    // deselecting
    results.unbind('deselect', results._onDeselect);
    results._onDeselect = function(item) {
        var ind = this._selected.indexOf(item);
        if (ind !== -1) this._selected.splice(ind, 1);

        if (this._changing)
            return;

        if (List._ctrl && List._ctrl()) {

        } else {
            this._changing = true;

            var items = editor.call('selector:type') === 'entity' && editor.call('selector:items') || [ ];
            var inSelected = items.indexOf(item.entity) !== -1;

            if (items.length >= 2 && inSelected) {
                var selected = this.selected;
                for(var i = 0; i < selected.length; i++)
                    selected[i].selected = false;

                item.selected = true;
            }

            this._changing = false;
        }

        this.emit('change');
    };
    results.on('deselect', results._onDeselect);

    // results selection change
    results.on('change', function() {
        if (changing)
            return;

        if (results.selected) {
            editor.call('selector:set', 'entity', results.selected.map(function(item) {
                return item.entity;
            }));
        } else {
            editor.call('selector:clear');
        }
    });

    // selector change
    editor.on('selector:change', function(type, items) {
        if (changing)
            return;

        changing = true;

        if (type === 'entity') {
            results.selected = [ ];

            for(var i = 0; i < items.length; i++) {
                var item = itemsIndex[items[i].get('resource_id')];
                if (! item) continue;
                item.selected = true;
            }
        } else {
            results.selected = [ ];
        }

        changing = false;
    });

    var selectNext = function() {
        var children = results.element.children;

        // could be nothing or only one item to select
        if (! children.length)
            return;

        var toSelect = null;
        var items = results.element.querySelectorAll('.ui-list-item.selected');
        var multi = (ui.List._ctrl && ui.List._ctrl()) || (ui.List._shift && ui.List._shift());

        if (items.length) {
            var last = items[items.length - 1];
            var next = last.nextSibling;
            if (next) {
                // select next
                toSelect = next.ui;
            } else {
                // loop through
                if (! multi) toSelect = children[0].ui;
            }
        } else {
            // select first
            toSelect = children[0].ui;
        }

        if (toSelect) {
            if (! multi) results.selected = [ ];
            toSelect.selected = true;
        }
    };
    var selectPrev = function() {
        var children = results.element.children;

        // could be nothing or only one item to select
        if (! children.length)
            return;

        var toSelect = null;
        var items = results.element.querySelectorAll('.ui-list-item.selected');
        var multi = (ui.List._ctrl && ui.List._ctrl()) || (ui.List._shift && ui.List._shift());

        if (items.length) {
            var first = items[0];
            var prev = first.previousSibling;
            if (prev) {
                // select previous
                toSelect = prev.ui;
            } else {
                // loop through
                if (! multi) toSelect = children[children.length - 1].ui;
            }
        } else {
            // select last
            toSelect = children[children.length - 1].ui;
        }

        if (toSelect) {
            if (! multi) results.selected = [ ];
            toSelect.selected = true;
        }
    };


    var lastSearch = '';
    var search = new ui.TextField({
        placeholder: 'Search'
    });
    search.blurOnEnter = false;
    search.keyChange = true;
    search.class.add('search');
    search.renderChanges = false;
    panel.element.insertBefore(search.element, panel.innerElement);

    search.element.addEventListener('keydown', function(evt) {
        if (evt.keyCode === 27) {
            searchClear.click();

        } else if (evt.keyCode === 13) {
            if (! results.selected.length) {
                var firstElement = results.element.firstChild;
                if (firstElement && firstElement.ui && firstElement.ui.entity)
                    editor.call('selector:set', 'entity', [ firstElement.ui.entity ]);
            }
            search.value = '';

        } else if (evt.keyCode === 40) { // down
            editor.call('hotkey:updateModifierKeys', evt);
            selectNext();
            evt.stopPropagation();
            evt.preventDefault();

        } else if (evt.keyCode === 38) { // up
            editor.call('hotkey:updateModifierKeys', evt);
            selectPrev();
            evt.stopPropagation();
            evt.preventDefault();

        } else if (evt.keyCode === 65 && evt.ctrlKey) { // ctrl + a
            var toSelect = [ ];

            var items = results.element.querySelectorAll('.ui-list-item');
            for(var i = 0; i < items.length; i++)
                toSelect.push(items[i].ui);

            results.selected = toSelect;

            evt.stopPropagation();
            evt.preventDefault();
        }
    }, false);

    var searchClear = document.createElement('div');
    searchClear.innerHTML = '&#57650;';
    searchClear.classList.add('clear');
    search.element.appendChild(searchClear);

    searchClear.addEventListener('click', function() {
        search.value = '';
    }, false);


    // if entity added, check if it maching query
    editor.on('entities:add', function(entity) {
        var query = search.value.trim();
        if (! query)
            return;

        var items = [ [ entity.get('name'), entity ] ];
        var result = editor.call('search:items', items, query);

        if (! result.length)
            return;

        performSearch();
    });


    var addItem = function(entity) {
        var events = [ ];

        var item = new ui.ListItem({
            text: entity.get('name')
        });
        item.disabledClick = true;
        item.entity = entity;

        if (entity.get('children').length)
            item.class.add('container');

        // relate to tree item
        var treeItem = editor.call('entities:panel:get', entity.get('resource_id'));

        item.disabled = treeItem.disabled;

        var onStateChange = function() {
            item.disabled = treeItem.disabled;
        };

        events.push(treeItem.on('enable', onStateChange));
        events.push(treeItem.on('disable', onStateChange));

        var onNameSet = function(name) {
            item.text = name;
        };
        events.push(entity.on('name:set', onNameSet));

        // icon
        var components = Object.keys(entity.get('components'));
        for(var c = 0; c < components.length; c++)
            item.class.add('c-' + components[c]);

        var onContextMenu = function(evt) {
            var openned = editor.call('entities:contextmenu:open', entity, evt.clientX, evt.clientY);

            if (openned) {
                evt.preventDefault();
                evt.stopPropagation();
            }
        };

        var onDblClick = function(evt) {
            search.value = '';
            editor.call('selector:set', 'entity', [ entity ]);

            evt.stopPropagation();
            evt.preventDefault();
        };

        item.element.addEventListener('contextmenu', onContextMenu);
        item.element.addEventListener('dblclick', onDblClick);

        events.push(item.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();
            events = null;

            item.element.removeEventListener('contextmenu', onContextMenu);
            item.element.removeEventListener('dblclick', onDblClick);
        }));

        events.push(treeItem.once('destroy', function() {
            // if entity removed, perform search again
            performSearch();
        }));

        return item;
    };


    var performSearch = function() {
        var query = lastSearch;

        // clear results list
        results.clear();
        itemsIndex = { };

        if (query) {
            var result = editor.call('entities:fuzzy-search', query);

            hierarchy.hidden = true;
            results.hidden = false;

            var selected = [ ];
            if (editor.call('selector:type') === 'entity')
                selected = editor.call('selector:items');

            for(var i = 0; i < result.length; i++) {
                var item = addItem(result[i]);

                itemsIndex[result[i].get('resource_id')] = item;

                if (selected.indexOf(result[i]) !== -1)
                    item.selected = true;

                results.append(item);
            }
        } else {
            results.hidden = true;
            hierarchy.hidden = false;
        }
    };


    search.on('change', function(value) {
        value = value.trim();

        if (lastSearch === value) return;
        lastSearch = value;

        if (value) {
            search.class.add('not-empty');
        } else {
            search.class.remove('not-empty');
        }

        performSearch();
    });
});


/* editor/entities/entities-load.js */
editor.on('load', function() {
    var hierarchyOverlay = new ui.Panel();
    hierarchyOverlay.class.add('overlay');
    editor.call('layout.left').append(hierarchyOverlay);

    var p = new ui.Progress();
    p.on('progress:100', function() {
        hierarchyOverlay.hidden = true;
    });
    hierarchyOverlay.append(p);
    p.hidden = true;

    var loadedEntities = false;

    editor.method('entities:loaded', function() {
        return loadedEntities;
    });

    editor.on('scene:raw', function(data) {
        editor.call('selector:clear');
        editor.call('entities:clear');
        editor.call('attributes:clear');

        var total = Object.keys(data.entities).length;
        var i = 0;

        // list
        for(var key in data.entities) {
            editor.call('entities:add',  new Observer(data.entities[key]));
            p.progress = (++i / total) * 0.8 + 0.1;
        }

        p.progress = 1;

        loadedEntities = true;
        editor.emit('entities:load');
    });

    editor.on('realtime:disconnected', function() {
        editor.call('selector:clear');
        editor.call('entities:clear');
        editor.call('attributes:clear');
    });

    editor.call('attributes:clear');

    editor.on('scene:unload', function () {
        editor.call('entities:clear');
        editor.call('attributes:clear');
    });

    editor.on('scene:beforeload', function () {
        hierarchyOverlay.hidden = false;
        p.hidden = false;
        p.progress = 0.1;
    });
});


/* editor/entities/entities-history.js */
editor.once('load', function() {
    'use strict';

    editor.on('entities:add', function(entity) {
        if (entity.history)
            return;

        var resourceId = entity.get('resource_id');

        entity.history = new ObserverHistory({
            item: entity,
            prefix: 'entity.' + resourceId + '.',
            getItemFn: function () {
                return editor.call('entities:get', resourceId);
            }
        });

        // record history
        entity.history.on('record', function(action, data) {
            editor.call('history:' + action, data);
        });
    });
});


/* editor/entities/entities-sync.js */
editor.once('load', function() {
    'use strict';


    var syncPaths = [
        'name',
        'tags',
        'parent',
        'children',
        'position',
        'rotation',
        'scale',
        'enabled',
        'components'
    ];

    editor.on('entities:add', function(entity) {
        if (entity.sync)
            return;

        entity.sync = new ObserverSync({
            item: entity,
            prefix: [ 'entities', entity.get('resource_id') ],
            paths: syncPaths
        });

        // client > server
        entity.sync.on('op', function(op) {
            editor.call('realtime:scene:op', op);
        });
    });


    // server > client
    editor.on('realtime:scene:op:entities', function(op) {
        var entity = null;
        if (op.p[1])
            entity = editor.call('entities:get', op.p[1]);

        if (op.p.length === 2) {
            if (op.hasOwnProperty('od')) {
                // delete entity
                if (entity) {
                    editor.call('entities:remove', entity);
                } else {
                    console.log('delete operation entity not found', op);
                }
            } else if (op.hasOwnProperty('oi')) {
                // new entity
                editor.call('entities:add', new Observer(op.oi));
            } else {
                console.log('unknown operation', op);
            }
        } else if (entity) {
            // write operation
            entity.sync.write(op);
        } else {
            console.log('unknown operation', op);
        }
    });
});


/* editor/entities/entities-migrations.js */
editor.once('load', function() {
    'use strict'

    editor.on('entities:add', function(entity) {
        setTimeout(function() {
            entity.history.enabled = false;

            // tags
            if (! entity.has('tags'))
                entity.set('tags', [ ]);

            // components

            // camera
            if (entity.has('components.camera')) {
                // frustumCulling
                if (! entity.has('components.camera.frustumCulling'))
                    entity.set('components.camera.frustumCulling', false);
            }

            // light
            if (entity.has('components.light')) {
                // isStatic
                if (! entity.has('components.light.isStatic'))
                    entity.set('components.light.isStatic', false);

                // bake
                if (! entity.has('components.light.bake'))
                    entity.set('components.light.bake', false);

                // bakeDir
                if (! entity.has('components.light.bakeDir'))
                    entity.set('components.light.bakeDir', true);

                // affectDynamic
                if (! entity.has('components.light.affectDynamic'))
                    entity.set('components.light.affectDynamic', true);

                // affectLightmapped
                if (! entity.has('components.light.affectLightmapped'))
                    entity.set('components.light.affectLightmapped', false);

                // shadowUpdateMode
                var shadowUpdateMode = entity.get('components.light.shadowUpdateMode');
                if (shadowUpdateMode === null || isNaN(shadowUpdateMode))
                    entity.set('components.light.shadowUpdateMode', pc.SHADOWUPDATE_REALTIME);

                // shadowType
                if (! entity.has('components.light.shadowType'))
                    entity.set('components.light.shadowType', 0);

                // vsmBlurMode
                if (! entity.has('components.light.vsmBlurMode'))
                    entity.set('components.light.vsmBlurMode', 0);

                // vsmBlurSize
                if (! entity.has('components.light.vsmBlurSize'))
                    entity.set('components.light.vsmBlurSize', 5);

                // vsmBias
                if (! entity.has('components.light.vsmBias'))
                    entity.set('components.light.vsmBias', 0.01 * 0.25);

                // cookieAsset
                if (! entity.has('components.light.cookieAsset'))
                    entity.set('components.light.cookieAsset', null);

                // cookieIntensity
                if (! entity.has('components.light.cookieIntensity'))
                    entity.set('components.light.cookieIntensity', 1.0);

                // cookieFalloff
                if (! entity.has('components.light.cookieFalloff'))
                    entity.set('components.light.cookieFalloff', true);

                // cookieChannel
                if (! entity.has('components.light.cookieChannel'))
                    entity.set('components.light.cookieChannel', 'rgb');

                // cookieAngle
                if (! entity.has('components.light.cookieAngle'))
                    entity.set('components.light.cookieAngle', 0);

                // cookieScale
                if (! entity.has('components.light.cookieScale'))
                    entity.set('components.light.cookieScale', [ 1.0, 1.0 ]);

                // cookieOffset
                if (! entity.has('components.light.cookieOffset'))
                    entity.set('components.light.cookieOffset', [ 0.0, 0.0 ]);
            }

            // model
            if(entity.has('components.model')) {
                // isStatic
                if (! entity.has('components.model.isStatic'))
                    entity.set('components.model.isStatic', false);

                // lightmapped
                if (! entity.has('components.model.lightmapped'))
                    entity.set('components.model.lightmapped', false);

                // castShadowsLightmap
                if (! entity.has('components.model.castShadowsLightmap'))
                    entity.set('components.model.castShadowsLightmap', true);

                // lightmapSizeMultiplier
                if (! entity.has('components.model.lightmapSizeMultiplier'))
                    entity.set('components.model.lightmapSizeMultiplier', 1.0);
            }

            // element
            if (entity.has('components.element')) {
                var color = entity.get('components.element.color');
                var opacity = 1.0;
                if (color.length > 3) {
                    opacity = color[3];
                    entity.set('components.element.color', [color[0], color[1], color[2]]);
                }

                if (! entity.has('components.element.opacity')) {
                    entity.set('components.element.opacity', opacity);
                }

                if (! entity.has('components.element.useInput')) {
                    entity.set('components.element.useInput', false);
                }

                if (! entity.has('components.element.autoWidth')) {
                    entity.set('components.element.autoWidth', entity.get('components.element.type') === 'text');
                }

                if (! entity.has('components.element.autoHeight')) {
                    entity.set('components.element.autoHeight', entity.get('components.element.type') === 'text');
                }

                if (! entity.has('components.element.margin')) {
                    if (entity.entity && entity.entity.element) {
                        var margin = entity.entity.element.margin.data;
                        entity.set('components.element.margin', [margin[0], margin[1], margin[2], margin[3]]);
                    } else {
                        entity.set('components.element.margin', [0, 0, 0, 0]);
                    }
                }

                if (! entity.has('components.element.alignment')) {
                    entity.set('components.element.alignment', [0.5, 0.5]);
                }
            }

            entity.history.enabled = true;
        }, 0);
    });
});


/* editor/entities/entities-scripts.js */
editor.once('load', function() {
    'use strict';

    // index all entities with scripts
    // when primary script set, update attributes on entities component
    // when script attributes change, update attributes on entities component

    var index = { };
    var defaults = {
        boolean: false,
        number: 0,
        string: '',
        json: '{ }',
        asset: null,
        entity: null,
        rgb: [ 1, 1, 1 ],
        rgba: [ 1, 1, 1, 1 ],
        vec2: [ 0, 0 ],
        vec3: [ 0, 0, 0 ],
        vec4: [ 0, 0, 0, 0 ],
        curve: { keys: [ 0, 0 ], type: 2 }
    };
    var types = {
        boolean: 'boolean',
        number: 'number',
        string: 'string',
        json: 'string',
        asset: 'number',
        entity: 'string',
        rgb: 'object',
        rgba: 'object',
        vec2: 'object',
        vec3: 'object',
        vec4: 'object',
        curve: 'object'
    };


    var indexAdd = function(entity, script) {
        if (! index[script])
            index[script] = { };

        if (index[script][entity.get('resource_id')])
            return;

        index[script][entity.get('resource_id')] = {
            entity: entity,
            asset: null,
            events: [ ]
        };

        updateAttributes(entity, script);
    };
    var indexRemove = function(entity, script) {
        if (! index[script])
            return;

        var item = index[script][entity.get('resource_id')];
        if (! item) return;

        for(var i = 0; i < item.events.length; i++)
            item.events[i].unbind();

        delete index[script][entity.get('resource_id')];
        if (Object.keys(index[script]).length === 0)
            delete index[script];
    };
    var attributeValue = function(attribute) {
        var value = null;
        if (attribute.default === undefined || (attribute.default !== null && typeof(attribute.default) !== types[attribute.type])) {
            if (attribute.array) {
                value = [ ];
            } else {
                value = defaults[attribute.type];
                if (value instanceof Array)
                    value = value.slice(0);

                if (attribute.type === 'curve') {
                    value = {
                        keys: [ 0, 0 ],
                        type: 2
                    };
                    if (attribute.color || attribute.curves) {
                        var len = attribute.color ? attribute.color.length : attribute.curves.length;
                        value.keys = [ ];
                        for(var c = 0; c < len; c++)
                            value.keys.push([ 0, 0 ]);
                    }
                }
            }
        } else {
            value = attribute.default;
        }
        return value;
    };
    var attributeDefaultValue = function(value, attribute) {
        var old = attributeValue(attribute);

        if ((old instanceof Array) && (value instanceof Array) && old.equals(value)) {
            // was default array value
            return true;
        } else if ((old instanceof Object) && (value instanceof Object) && old.type === value.type && (old.keys instanceof Array) && (value.keys instanceof Array) && old.keys.length === value.keys.length) {
            if ((old.keys[0] instanceof Array) && (value.keys[0] instanceof Array)) {
                for(var k = 0; k < old.keys.length; k++) {
                    if (! old.keys[k].equals(value.keys[k])) {
                        // was curveset default value
                        return false;
                    }
                }
                return true;
            } else if (old.keys.equals(value.keys)) {
                // was curve default value
                return true;
            }
        } else if (old === value) {
            // was default value
            return true;
        }
        return false;
    };
    var updateAttributes = function(entity, script) {
        var asset = editor.call('assets:scripts:assetByScript', script);
        if (! asset)
            return;

        var item = index[script][entity.get('resource_id')];
        var assetOld = null;
        if (item.asset && item.asset !== asset.get('id')) {
            assetOld = item.asset;

            for(var i = 0; i < item.events.length; i++)
                item.events[i].unbind();

            item.events = [ ];
            item.asset = asset.get('id');
        }

        // unset attributes
        var attributes = entity.get('components.script.scripts.' + script + '.attributes');
        for(var key in attributes) {
            if (! attributes.hasOwnProperty(key))
                continue;

            if (! asset.has('data.scripts.' + script + '.attributes.' + key)) {
                var history = entity.history.enabled;
                entity.history.enabled = false;
                entity.unset('components.script.scripts.' + script + '.attributes.' + key);
                entity.history.enabled = history;
            }
        }

        // set/update attributes
        var attributesOrder = asset.get('data.scripts.' + script + '.attributesOrder');
        for(var i = 0; i < attributesOrder.length; i++) {
            var name = attributesOrder[i];
            var setAttribute = false;
            var attribute = asset.get('data.scripts.' + script + '.attributes.' + name);
            var valueDefault = attributeValue(attribute);

            if (entity.has('components.script.scripts.' + script + '.attributes.' + name)) {
                // update attribute
                var value = entity.get('components.script.scripts.' + script + '.attributes.' + name);
                var attr = null;
                if (assetOld) attr = assetOld.get('data.scripts.' + script + '.attributes.' + name);
                if (! attr) attr = attribute;
                setAttribute = attributeDefaultValue(value, attr);

                // value type
                if (! setAttribute && ((typeof(value) !== typeof(valueDefault) && valueDefault !== null) || attribute.type !== attr.type))
                    setAttribute = true;

                // curve types
                if (! setAttribute && attribute.type === 'curve') {
                    if (attribute.color || attribute.curves) {
                        var len = attribute.color ? attribute.color.length : attribute.curves.length;
                        if (len !== 1 && (! (value.keys[0] instanceof Array) || value.keys.length !== len)) {
                            setAttribute = true;
                        } else if (len === 1 && (value.keys[0] instanceof Array)) {
                            setAttribute = true;
                        }
                    } else if (value.keys[0] instanceof Array) {
                        setAttribute = true;
                    }
                }
            } else {
                // set new attribute
                setAttribute = true;
            }

            if (setAttribute) {
                var history = entity.history.enabled;
                entity.history.enabled = false;
                entity.set('components.script.scripts.' + script + '.attributes.' + name, valueDefault);
                entity.history.enabled = history;
            }
        }

        // subscribe to script asset attribute changes
        // set attribute
        item.events.push(asset.on('*:set', function(path, attribute, old) {
            if (! path.startsWith('data.scripts.' + script + '.attributes.'))
                return;

            var parts = path.split('.');
            if (parts.length !== 5)
                return;

            var name = parts[4];
            var setAttribute = false;

            if (entity.has('components.script.scripts.' + script + '.attributes.' + name)) {
                var value = entity.get('components.script.scripts.' + script + '.attributes.' + name);
                setAttribute = ! old || attributeDefaultValue(value, old);

                // value type
                if (! setAttribute && (typeof(value) !== typeof(valueDefault) || attribute.type !== old.type))
                    setAttribute = true;

                // curve types
                if (! setAttribute && attribute.type === 'curve') {
                    if (attribute.color || attribute.curves) {
                        var len = attribute.color ? attribute.color.length : attribute.curves.length;
                        if (! (value.keys[0] instanceof Array) || value.keys.length !== len)
                            setAttribute = true;
                    } else if (value.keys[0] instanceof Array) {
                        setAttribute = true;
                    }
                }
            } else {
                setAttribute = true;
            }

            if (setAttribute) {
                var history = entity.history.enabled;
                entity.history.enabled = false;
                entity.set('components.script.scripts.' + script + '.attributes.' + name, attributeValue(attribute));
                entity.history.enabled = history;
            }
        }));
        // unset attribute
        item.events.push(asset.on('*:unset', function(path, attribute) {
            if (! path.startsWith('data.scripts.' + script + '.attributes.'))
                return;

            var parts = path.split('.');
            if (parts.length !== 5)
                return;

            var name = parts[4];

            if (! entity.has('components.script.scripts.' + script + '.attributes.' + name))
                return;

            var history = entity.history.enabled;
            entity.history.enabled = false;
            entity.unset('components.script.scripts.' + script + '.attributes.' + name);
            entity.history.enabled = history;
        }));
    };

    editor.on('entities:add', function(entity) {
        var scripts = entity.get('components.script.order');
        if (scripts) {
            for(var i = 0; i < scripts.length; i++)
                indexAdd(entity, scripts[i]);
        }

        entity.on('components.script.order:insert', function(script) {
            indexAdd(this, script);
        });

        entity.on('components.script.order:remove', function(script) {
            indexRemove(this, script);
        });
    });

    editor.on('assets:scripts:primary:set', function(asset, script) {
        if (! index[script])
            return;

        for(var key in index[script]) {
            if (! index[script].hasOwnProperty(key))
                continue;

            updateAttributes(index[script][key].entity, script);
        }
    });

    editor.method('entities:list:byScript', function(script) {
        return index[script];
    });
});


/* editor/entities/entities-hotkeys.js */
editor.once('load', function() {
    'use strict';

    // new
    editor.call('hotkey:register', 'entity:new', {
        key: 'e',
        ctrl: true,
        callback: function() {
            if (! editor.call('permissions:write'))
                return;

            var type = editor.call('selector:type');
            var items = editor.call('selector:items');

            if (type === 'entity') {
                if (items.length !== 1)
                    return;

                editor.call('entities:new', {
                    parent: items[0]
                });
            } else {
                editor.call('entities:new');
            }
        }
    });


    // duplicate
    editor.call('hotkey:register', 'entity:duplicate', {
        key: 'd',
        ctrl: true,
        callback: function() {
            if (! editor.call('permissions:write'))
                return;

            var type = editor.call('selector:type');
            var items = editor.call('selector:items');

            if (! items.length)
                return;

            if (type === 'entity') {
                if (items.indexOf(editor.call('entities:root')) !== -1)
                    return;

                editor.call('entities:duplicate', items);
            } else if (type === 'asset' && items.length === 1) {
                if (items[0].get('type') !== 'material')
                    return;

                editor.call('assets:duplicate', items[0]);
            }
        }
    });

    // delete
    var deleteCallback = function() {
        // if curve editor is open then return
        // because in that case we want to delete a curve key
        if (editor.call('picker:curve:isOpen'))
            return;

        if (! editor.call('permissions:write'))
            return;

        var type = editor.call('selector:type');
        if (type !== 'entity')
            return;

        var root = editor.call('entities:root');
        var items = editor.call('selector:items');

        if (items.indexOf(root) !== -1)
            return;

        editor.call('entities:delete', items);
    };
    // delete
    editor.call('hotkey:register', 'entity:delete', {
        key: 'delete',
        callback: deleteCallback
    });
    // ctrl + backspace
    editor.call('hotkey:register', 'entity:delete', {
        ctrl: true,
        key: 'backspace',
        callback: deleteCallback
    });

    // copy
    editor.call('hotkey:register', 'entity:copy', {
        key: 'c',
        ctrl: true,
        skipPreventDefault: true,
        callback: function () {
            // write permissions only (perhaps we could also allow read permissions)
            if (! editor.call('permissions:write'))
                return;

            var type = editor.call('selector:type');
            if (type !== 'entity')
                return;

            var items = editor.call('selector:items');
            if (!items.length)
                return;

            editor.call('entities:copy', items);
        }
    });

    // paste
    editor.call('hotkey:register', 'entity:paste', {
        key: 'v',
        ctrl: true,
        callback: function () {
            // write permissions only (perhaps we could also allow read permissions)
            if (! editor.call('permissions:write'))
                return;

            var items = editor.call('selector:items');
            if (items.length === 0 || items.length === 1 && editor.call('selector:type') === 'entity')
                editor.call('entities:paste', items[0]);
        }
    });

    // rename
    var onRename = function() {
        if (! editor.call('permissions:write'))
            return;

        var type = editor.call('selector:type');
        if (type !== 'entity')
            return;

        var items = editor.call('selector:items');
        if (! items.length)
            return;

        var root = editor.call('attributes.rootPanel');
        if (! root)
            return;

        var input = root.element.querySelector('.ui-text-field.entity-name');

        if (! input || ! input.ui)
            return;

        input.ui.flash();
        input.ui.elementInput.select();
    };

    editor.method('entities:rename', onRename);

    editor.call('hotkey:register', 'entities:rename', {
        key: 'n',
        callback: onRename
    });

    editor.call('hotkey:register', 'entities:rename:f2', {
        key: 'f2',
        callback: onRename
    });
});


/* editor/entities/entities-context-menu.js */
editor.once('load', function() {
    'use strict';

    var entity = null;
    var items = [ ];
    var customMenuItems = [ ];
    var root = editor.call('layout.root');

    var legacyScripts = editor.call('settings:project').get('useLegacyScripts');

    // create data for entity menu
    var menu;

    var componentsLogos = {
        'animation': '&#57875;',
        'audiolistener': '&#57750;',
        'audiosource': '&#57751;',
        'sound': '&#57751;',
        'camera': '&#57874;',
        'collision': '&#57735;',
        'light': '&#57748;',
        'model': '&#57736;',
        'particlesystem': '&#57753;',
        'rigidbody': '&#57737;',
        'script': '&#57910;',
        'zone': '&#57910;',
        'screen': '&#57665;',
        'element': '&#58232;'
    };


    var getSelection = function() {
        var selection = editor.call('selector:items');

        if (selection.indexOf(entity) !== -1) {
            return selection;
        } else {
            return [ entity ];
        }
    };

    var hasLegacyScript = function (entity, url) {
        var scriptComponent = entity.get('components.script');
        if (scriptComponent) {
            for (var i = 0; i < scriptComponent.scripts.length; i++) {
                if (scriptComponent.scripts[i].url === url) {
                    return true;
                }
            }
        }

        return false;
    };

    var addBultinScript = function (entity, url) {
        if (! legacyScripts)
            return;

        var resourceId = entity.get('resource_id');

        var addedComponent = false;

        var action = {
            name: 'entity.' + resourceId + '.builtinscript',
            combine: false,
            undo: function () {
                var e = editor.call('entities:get', resourceId);
                if (! e) return;

                var history = e.history.enabled;
                e.history.enabled = false;

                if (addedComponent) {
                    e.unset('components.script');
                } else {
                    var scripts = e.get('components.script.scripts');
                    if (scripts) {
                        for (var i = 0; i < scripts.length; i++) {
                            if (scripts[i].url === url) {
                                e.remove('components.script.scripts', i);
                                break;
                            }
                        }
                    }
                }

                e.history.enabled = history;
            },
            redo: function () {
                var e = editor.call('entities:get', resourceId);
                if (! e) return;

                var history = e.history.enabled;
                e.history.enabled = false;

                if (!e.get('components.script')) {
                    editor.call('entities:addComponent', [e], 'script');
                    addedComponent = true;
                }

                // add script
                var script = new Observer({
                    url: url
                });
                e.insert('components.script.scripts', script);

                e.history.enabled = history;

                // scan script
                editor.call('sourcefiles:scan', url, function (data) {
                    e.history.enabled = false;

                    data.url = url;
                    script.patch(data);

                    e.history.enabled = history;
                });
            }
        };

        // perform action
        action.redo();

        // raise history event
        entity.history.emit('record', 'add', action);
    };

    var setField = function(field, value) {
        var records = [ ];

        for(var i = 0; i < items.length; i++) {
            records.push({
                get: items[i].history._getItemFn,
                value: value,
                valueOld: items[i].get(field)
            });

            items[i].history.enabled = false;
            items[i].set(field, value);
            items[i].history.enabled = true;
        }

        editor.call('history:add', {
            name: 'entities.set[' + field + ']',
            undo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set(field, records[i].valueOld);
                    item.history.enabled = true;
                }
            },
            redo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set(field, records[i].value);
                    item.history.enabled = true;
                }
            }
        });
    };

    // wait until all entities are loaded
    // before creating the menu to make sure
    // that the menu data for entities have been created
    editor.once('entities:load', function () {
        var menuData = { };

        menuData['new-entity'] = {
            title: 'New Entity',
            filter: function() {
                return items.length === 1;
            },
            select: function () {
                editor.call('entities:new', {parent: items[0]});
            },
            items: editor.call('menu:entities:new', function () {return items[0];})
        };

        menuData['add-component'] = {
            title: 'Add Component',
            items: { }
        };

        if (legacyScripts) {
            menuData['add-builtin-script'] = {
                title: 'Add Built-In Script',
                filter: function () {
                    return items.length === 1;
                },
                items: {
                    'post-effects': {
                        title: 'Post-Effects',
                        filter: function () {
                            return items.length === 1;
                        },
                        items: { }
                    },
                    'camera-scripts': {
                        title: 'Camera',
                        filter: function () {
                            return items.length === 1;
                        },
                        items: { }
                    }
                }
            };
        } else {
            // TODO scripts2
            // built-in scripts
        }

        menuData['enable'] = {
            title: 'Enable',
            icon: '&#57651;',
            hide: function () {
                if (items.length === 1) {
                    return items[0].get('enabled');
                } else {
                    var enabled = items[0].get('enabled');
                    for(var i = 1; i < items.length; i++) {
                        if (enabled !== items[i].get('enabled'))
                            return false;
                    }
                    return enabled;
                }
            },
            select: function() {
                setField('enabled', true);
            }
        };

        menuData['disable'] = {
            title: 'Disable',
            icon: '&#57650;',
            hide: function () {
                if (items.length === 1) {
                    return ! items[0].get('enabled');
                } else {
                    var disabled = items[0].get('enabled');
                    for(var i = 1; i < items.length; i++) {
                        if (disabled !== items[i].get('enabled'))
                            return false;
                    }
                    return ! disabled;
                }
            },
            select: function() {
                setField('enabled', false);
            }
        };

        menuData['copy'] = {
            title: 'Copy',
            icon: '&#58193;',
            select: function() {
                editor.call('entities:copy', items);
            }
        };

        menuData['paste'] = {
            title: 'Paste',
            icon: '&#58184;',
            filter: function () {
                return items.length <= 1 && ! editor.call('entities:clipboard:empty');
            },
            select: function() {
                editor.call('entities:paste', entity);
            }
        };

        menuData['duplicate'] = {
            title: 'Duplicate',
            icon: '&#57638;',
            filter: function () {
                var items = getSelection();

                if (items.indexOf(editor.call('entities:root')) !== -1)
                    return false;

                return items.length > 0;
            },
            select: function() {
                editor.call('entities:duplicate', getSelection());
            }
        };

        menuData['delete'] = {
            title: 'Delete',
            icon: '&#57636;',
            filter: function () {
                var root = editor.call('entities:root');
                for(var i = 0; i < items.length; i++) {
                    if (items[i] === root)
                        return false;
                }
                return true;
            },
            select: function() {
                editor.call('entities:delete', items);
            }
        };

        var makeMenuComponentItem = function(key) {
            var data = {
                title: components[key].title,
                icon: componentsLogos[key],
                filter: function() {
                    var name = 'components.' + key;
                    for (var i = 0, len = items.length; i < len; i++) {
                        if (!items[i].has(name))
                            return true;
                    }

                    return false;
                },

                select: function() {
                    editor.call('entities:addComponent', items, this._value);
                }
            };

            if (key === 'audiosource') {
                data.hide = function () {
                    return !editor.call('settings:project').get('useLegacyAudio');
                };
            }

            return data;
        };

        var components = editor.call('components:schema');
        var list = editor.call('components:list');
        for(var i = 0; i < list.length; i++) {
            var key = list[i];
            menuData['add-component'].items[key] = makeMenuComponentItem(key);
        }

        if (legacyScripts) {
            var builtInScripts = [{
                group: 'post-effects',
                title: 'Bloom',
                name: 'posteffect-bloom',
                url: 'https://code.playcanvas.com/posteffects/posteffect_bloom.js',
                requires: 'camera'
            }, {
                group: 'post-effects',
                title: 'Bloom',
                name: 'posteffect-bloom',
                url: 'https://code.playcanvas.com/posteffects/posteffect_bloom.js',
                requires: 'camera'
            }, {
                group: 'post-effects',
                title: 'Bloom',
                name: 'posteffect-bloom',
                url: 'https://code.playcanvas.com/posteffects/posteffect_bloom.js',
                requires: 'camera'
            }, {
                group: 'post-effects',
                title: 'Brightness-Contrast',
                name: 'posteffect-brightnesscontrast',
                url: 'https://code.playcanvas.com/posteffects/posteffect_brightnesscontrast.js',
                requires: 'camera'
            }, {
                group: 'post-effects',
                title: 'Hue-Saturation',
                name: 'posteffect-huesaturation',
                url: 'https://code.playcanvas.com/posteffects/posteffect_huesaturation.js',
                requires: 'camera'
            }, {
                group: 'post-effects',
                title: 'FXAA',
                name: 'posteffect-fxaa',
                url: 'https://code.playcanvas.com/posteffects/posteffect_fxaa.js',
                requires: 'camera'
            }, {
                group: 'post-effects',
                title: 'Sepia',
                name: 'posteffect-sepia',
                url: 'https://code.playcanvas.com/posteffects/posteffect_sepia.js',
                requires: 'camera'
            }, {
                group: 'post-effects',
                title: 'Vignette',
                name: 'posteffect-vignette',
                url: 'https://code.playcanvas.com/posteffects/posteffect_vignette.js',
                requires: 'camera'
            }, {
                group: 'camera-scripts',
                title: 'Fly Camera',
                name: 'camera-fly',
                url: 'https://code.playcanvas.com/camera/camera_fly.js',
                requires: 'camera'
            }];

            builtInScripts.forEach(function (data) {
                menuData['add-builtin-script'].items[data.group].items[data.name] = {
                    title: data.title,
                    filter: function () {
                        return items.length === 1 &&
                            editor.call('permissions:write') &&
                            !hasLegacyScript(items[0], data.url) &&
                            (!data.requires || items[0].get('components.' + data.requires));
                    },
                    select: function () {
                        addBultinScript(items[0], data.url);
                    }
                };
            });
        } else {
            // TODO scripts2
            // built-in scripts
        }

        // menu
        menu = ui.Menu.fromData(menuData);
        root.append(menu);

        menu.on('open', function() {
            var selection = getSelection();

            for(var i = 0; i < customMenuItems.length; i++) {
                if (! customMenuItems[i].filter)
                    continue;

                customMenuItems[i].hidden = ! customMenuItems[i].filter(selection);
            }
        });
    });

    editor.method('entities:contextmenu:add', function(data) {
        var item = new ui.MenuItem({
            text: data.text,
            icon: data.icon,
            value: data.value
        });

        item.on('select', function() {
            data.select.call(item, getSelection());
        });

        var parent = data.parent || menu;
        parent.append(item);

        if (data.filter)
            item.filter = data.filter;

        customMenuItems.push(item);

        return item;
    });

    editor.method('entities:contextmenu:open', function(item, x, y, ignoreSelection) {
        if (! menu || ! editor.call('permissions:write')) return;

        entity = item;

        if (ignoreSelection) {
            items = [ ];
        } else {
            items = getSelection();
        }

        menu.open = true;
        menu.position(x + 1, y);

        return true;
    });

    // for each entity added
    editor.on('entities:add', function(item) {
        // get tree item
        var treeItem = editor.call('entities:panel:get', item.get('resource_id'));
        if (! treeItem) return;

        // attach contextmenu event
        treeItem.element.addEventListener('contextmenu', function(evt) {
            var openned = editor.call('entities:contextmenu:open', item, evt.clientX, evt.clientY);

            if (openned) {
                evt.preventDefault();
                evt.stopPropagation();
            }
        });
    });
});


/* editor/entities/entities-pick.js */
editor.once('load', function() {
    'use strict';

    editor.on('viewport:pick:clear', function() {
        if (! editor.call('hotkey:ctrl'))
            editor.call('selector:clear');
    });

    editor.on('viewport:pick:node', function(node, picked) {
        // icon
        if (node._icon || (node.__editor && node._getEntity)) {
            node = node._getEntity();
            if (! node) return;
        }

        // get entity
        var entity = editor.call('entities:get', node.getGuid());
        if (! entity) return;

        // get selector data
        var type = editor.call('selector:type');
        var items = editor.call('selector:items');

        if (type === 'entity' && items.length === 1 && items.indexOf(entity) !== -1 && ! editor.call('hotkey:ctrl')) {
            // if entity already selected
            // try selecting model asset
            // with highlighting mesh instance
            if (node.model && node.model.type === 'asset' && node.model.model) {
                var meshInstances = node.model.model.meshInstances;

                for(var i = 0; i < meshInstances.length; i++) {
                    var instance = meshInstances[i];

                    if (instance !== picked && instance !== picked._staticSource)
                        continue;

                    var index = i;

                    // if the model component has a material mapping then
                    // open the model component otherwise go to the model asset
                    if (node.model.mapping && node.model.mapping[i] !== undefined) {
                        editor.call('selector:set', 'entity', [entity]);
                    } else {
                        // get model asset
                        var asset = editor.call('assets:get', node.model.asset);
                        if (! asset) break;

                        // select model asset
                        editor.call('selector:set', 'asset', [ asset ]);
                    }

                    // highlight selected node
                    setTimeout(function() {
                        var node = editor.call('attributes.rootPanel').element.querySelector('.field-asset.node-' + index);
                        if (node) {
                            node.classList.add('active');
                            var field = node.querySelector('.ui-image-field');
                            field.focus();
                            field.blur();
                        }
                    }, 200);

                    break;
                }
            }
        } else {
            // select entity
            if (type === 'entity' && editor.call('hotkey:ctrl')) {
                // with ctrl
                if (items.indexOf(entity) !== -1) {
                    // deselect
                    editor.call('selector:remove', entity);
                } else {
                    // add to selection
                    editor.call('selector:add', 'entity', entity);
                }
            } else {
                // set selection
                editor.call('selector:set', 'entity', [ entity ]);
            }
        }
    })
});


/* editor/entities/entities-icons.js */
editor.once('load', function() {
    'use strict';

    var app;
    var iconsEntity;
    var textureNames = [ 'animation', 'audiolistener', 'audiosource', 'sound', 'camera', 'collision', 'light-point', 'light-directional', 'light-spot', 'particlesystem', 'rigidbody', 'script', 'unknown' ];
    var components = [ 'camera', 'light', 'audiolistener', 'audiosource', 'sound', 'particlesystem', 'script', 'animation', 'model' ];
    var icons = [ ];
    var pool = [ ];
    var dirtifyKeys = [
        'enabled:set',
        'components.model.type:set',
        'components.model.asset:set'
    ];
    var dirtifyLocalKeys = {
        'light': [
            'components.light.color.0:set',
            'components.light.color.1:set',
            'components.light.color.2:set',
            'components.light.type:set'
        ]
    };
    var material = null;
    var materialBehind = null;
    var iconColor = new pc.Color(1, 1, 1, 1);
    var textures = { };
    var scale = .5;
    var cameraRotation = new pc.Quat();
    var rotateMatrix = new pc.Mat4().setFromAxisAngle(pc.Vec3.LEFT, -90);
    var quadMaterial = new pc.Material();
    var selectedIds = { };


    // icon class
    function Icon() {
        var self = this;

        this.entity = null;
        this.behind = null;
        this.color = new pc.Color();

        this._link = null;
        this.events = [ ];
        this.eventsLocal = [ ];
        this.local = '';
        this.dirty = true;
        this.dirtify = function() {
            self.dirty = true;
        };
    }

    Icon.prototype.entityCreate = function() {
        if (this.entity)
            return;

        if (! app) return; // webgl not available

        var self = this;

        this.entity = new pc.Entity(app);
        this.entity._icon = true;
        this.entity._getEntity = function() {
            return self._link && self._link.entity || null;
        };
        this.entity.addComponent('model', {
            type: 'plane',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        this.entity.model.meshInstances[0].__editor = true;
        this.entity.model.meshInstances[0].mask = 8;

        if (this._link && this._link.entity)
            this.entity.setPosition(this._link.entity.getPosition());

        this.entity.setLocalScale(scale, scale, scale);
        this.entity.setRotation(cameraRotation);
        this.entity.rotateLocal(90, 0, 0);

        this.behind = new pc.Entity(app);
        this.behind._icon = true;
        this.behind._getEntity = this.entity._getEntity;
        this.entity.addChild(this.behind);
        this.behind.addComponent('model', {
            type: 'plane',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        this.behind.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        this.behind.model.model.meshInstances[0].mask = 8;
        this.behind.model.model.meshInstances[0].pick = false;

        iconsEntity.addChild(this.entity);
    };

    Icon.prototype.entityDelete = function() {
        if (! this.entity)
            return;

        this.entity.destroy();

        this.entity = null;
        this.behind = null;
    };

    Icon.prototype.update = function() {
        if (! this._link || ! this._link.entity)
            return;

        // don't render if selected or disabled
        if (! this._link.entity._enabled || ! this._link.entity._enabledInHierarchy || this._link.entity.__noIcon || scale === 0 || selectedIds[this._link.entity._guid]) {
            if (this.entity)
                this.entityDelete();

            this.dirty = true;
            return;
        }

        if (this.entity) {
            // position
            this.entity.setPosition(this._link.entity.getPosition());
            this.entity.setLocalScale(scale, scale, scale);
            this.entity.setRotation(cameraRotation);
            this.entity.rotateLocal(90, 0, 0);
        }

        if (! this.dirty) return;
        this.dirty = false;

        // hide icon if model is set
        if (this._link.has('components.model') && this._link.get('components.model.enabled') && (this._link.get('components.model.type') !== 'asset' || this._link.get('components.model.asset'))) {
            if (this.entity)
                this.entityDelete();
            return;
        }

        var component = '';
        for(var i = 0; i < components.length; i++) {
            if (! this._link.has('components.' + components[i]))
                continue;

            component = components[i];
            break;
        }

        if (component) {
            if (! this.entity)
                this.entityCreate();

            this.entity.enabled = true;
            this.entity.model.material = material;
            this.behind.model.material = materialBehind;

            this.color.copy(iconColor);
            var textureName = components[i];
            if (components[i] === 'light') {
                textureName += '-' + this._link.entity.light.type;
                this.color.copy(this._link.entity.light.color);
            }

            if (! textureName || ! textures[textureName])
                textureName = 'unknown';

            this.entity.model.model.meshInstances[0].setParameter('texture_diffuseMap', textures[textureName]);
            this.entity.model.model.meshInstances[0].setParameter('uColor', this.color.data);

            this.color.a = 0.25;
            this.behind.model.model.meshInstances[0].setParameter('texture_diffuseMap', textures[textureName]);
            this.behind.model.model.meshInstances[0].setParameter('uColor', this.color.data);

            if (this.local !== components[i]) {
                // clear local binds
                for(var n = 0; n < this.eventsLocal.length; n++)
                    this.eventsLocal[n].unbind();
                this.eventsLocal = [ ];

                // add local binds
                if (dirtifyLocalKeys[components[i]]) {
                    for(var n = 0; n < dirtifyLocalKeys[components[i]].length; n++)
                        this.eventsLocal.push(this._link.on(dirtifyLocalKeys[components[i]][n], this.dirtify));
                }
            }
        } else if (this.entity) {
            this.entityDelete();
        }
    };
    Icon.prototype.link = function(obj) {
        this.unlink();

        this._link = obj;
        for(var i = 0; i < dirtifyKeys.length; i++)
            this.events.push(obj.on(dirtifyKeys[i], this.dirtify));

        for(var i = 0; i < components.length; i++) {
            this.events.push(obj.on('components.' + components[i] + ':set', this.dirtify));
            this.events.push(obj.on('components.' + components[i] + ':unset', this.dirtify));
        }

        var self = this;
        this.events.push(obj.once('destroy', function() {
            self.unlink();
        }));

        icons.push(this);

        this.dirty = true;
    };
    Icon.prototype.unlink = function() {
        if (! this._link)
            return;

        for(var i = 0; i < this.events.length; i++)
            this.events[i].unbind();

        if (this.entity)
            this.entityDelete();

        this.events = [ ];
        this._link = null;

        var ind = icons.indexOf(this);
        icons.splice(ind, 1);
        pool.push(this);
    };

    editor.once('viewport:load', function() {
        app = editor.call('viewport:app');
        if (! app) return; // webgl not available

        var shader;

        material = new pc.BasicMaterial();
        material.updateShader = function(device) {
            if (! shader) {
                shader = new pc.Shader(device, {
                    attributes: {
                        vertex_position: 'POSITION'
                    },
                    vshader: ' \
                        attribute vec3 vertex_position;\n \
                        uniform mat4 matrix_model;\n \
                        uniform mat4 matrix_viewProjection;\n \
                        varying vec2 vUv0;\n \
                        void main(void)\n \
                        {\n \
                            mat4 modelMatrix = matrix_model;\n \
                            vec4 positionW = modelMatrix * vec4(vertex_position, 1.0);\n \
                            gl_Position = matrix_viewProjection * positionW;\n \
                            vUv0 = vertex_position.xz + vec2(0.5);\n \
                            vUv0.y = 1.0 - vUv0.y;\n \
                        }\n',
                    fshader: ' \
                        precision ' + device.precision + ' float;\n \
                        uniform vec4 uColor;\n \
                        varying vec2 vUv0;\n \
                        uniform sampler2D texture_diffuseMap;\n \
                        void main(void)\n \
                        {\n \
                            float alpha = texture2D(texture_diffuseMap, vUv0).b;\n \
                            if (alpha < 0.5) discard;\n \
                            gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\n \
                        }\n'
                });
            }

            this.shader = shader;
        };
        material.update();

        materialBehind = new pc.BasicMaterial();
        materialBehind.blend = true;
        materialBehind.blendSrc = pc.BLENDMODE_SRC_ALPHA;
        materialBehind.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        materialBehind.updateShader = material.updateShader;
        materialBehind.update();

        iconsEntity = new pc.Entity(app);
        app.root.addChild(iconsEntity);

        for(var i = 0; i < textureNames.length; i++) {
            textures[textureNames[i]] = new pc.Texture(app.graphicsDevice, {
                width: 64,
                height: 64
            });
            textures[textureNames[i]].anisotropy = 16;
            textures[textureNames[i]].addressU = pc.ADDRESS_CLAMP_TO_EDGE;
            textures[textureNames[i]].addressV = pc.ADDRESS_CLAMP_TO_EDGE;

            var img = new Image();
            img.textureName = textureNames[i];
            img.onload = function() {
                textures[this.textureName].setSource(this);
            };
            img.src = '/editor/scene/img/entity-icons/' + textureNames[i] + '.png';
        }

        editor.on('entities:add', function(obj) {
            var icon = pool.shift();
            if (! icon)
                icon = new Icon();

            icon.link(obj);
        });
    });

    editor.on('selector:change', function(type, items) {
        selectedIds = { };

        if (type !== 'entity')
            return;

        for(var i = 0; i < items.length; i++)
            selectedIds[items[i].get('resource_id')] = true;
    });

    editor.on('viewport:postUpdate', function() {
        if (app) cameraRotation.copy(editor.call('camera:current').getRotation());

        for(var i = 0; i < icons.length; i++)
            icons[i].update();
    });

    editor.method('viewport:icons:size', function(size) {
        if (size === undefined)
            return scale;

        scale = size;
        editor.call('viewport:render');
    });

    var settings = editor.call('settings:user');
    editor.call('viewport:icons:size', settings.get('editor.iconSize'));
    settings.on('editor.iconSize:set', function(size) {
        editor.call('viewport:icons:size', size);
    });
});


/* editor/entities/entities-gizmo-translate.js */
editor.once('load', function() {
    'use strict';

    var events = [ ];
    var items = [ ];
    var quat = new pc.Quat();
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var vecC = new pc.Vec3();
    var startPosition = new pc.Vec3();
    var timeoutUpdatePosition, timeoutUpdateRotation;
    var coordSystem = 'world';
    var app;
    var gizmoMoving = false;
    var gizmoAxis, gizmoPlane;
    var movingStart = new pc.Vec3();
    var linesColorActive = new pc.Color(1, 1, 1, 1);
    var linesColor = new pc.Color(1, 1, 1, .2);
    var linesColorBehind = new pc.Color(1, 1, 1, .05);

    editor.on('gizmo:coordSystem', function(system) {
        if (coordSystem === system)
            return;

        coordSystem = system;

        var pos = getGizmoPosition();
        if (pos)
            editor.call('gizmo:translate:position', pos.x, pos.y, pos.z);

        var rot = getGizmoRotation();
        if (rot)
            editor.call('gizmo:translate:rotation', rot[0], rot[1], rot[2]);

        editor.call('viewport:render');
    });

    // get position of gizmo based on selected entities
    var getGizmoPosition = function() {
        if (! items.length)
            return;

        if (items.length === 1) {
            vecA.copy(items[0].obj.entity.getPosition());
        } else if (coordSystem === 'local') {
            var reference = items[items.length - 1];
            var parent = reference.parent;
            while(parent) {
                reference = parent;
                parent = parent.parent;
            }
            vecA.copy(reference.obj.entity.getPosition());
        } else {
            var selection = editor.call('selection:aabb');
            if (! selection) return;
            vecA.copy(selection.center);
        }

        return vecA;
    };

    var getGizmoRotation = function() {
        if (! items.length)
            return;

        if (coordSystem === 'local') {
            var reference = items[items.length - 1];
            var parent = reference.parent;
            while(parent) {
                reference = parent;
                parent = parent.parent;
            }
            var rot = reference.obj.entity.getEulerAngles()
            return [ rot.x, rot.y, rot.z ];
        } else {
            return [ 0, 0, 0 ];
        }
    };

    // update gizmo position
    var updateGizmoPosition = function() {
        if (! items.length || timeoutUpdatePosition || gizmoMoving)
            return;

        timeoutUpdatePosition = true;

        setTimeout(function() {
            timeoutUpdatePosition = false;

            var vec = getGizmoPosition();
            if (vec)
                editor.call('gizmo:translate:position', vec.x, vec.y, vec.z);
        });
    };

    // update gizmo position
    var updateGizmoRotation = function() {
        if (! items.length || timeoutUpdateRotation)
            return;

        timeoutUpdateRotation = true;

        setTimeout(function() {
            timeoutUpdateRotation = false;

            var vec = getGizmoRotation();
            if (vec)
                editor.call('gizmo:translate:rotation', vec[0], vec[1], vec[2]);
        });
    };

    // start translating
    var onGizmoStart = function(axis, plane) {
        gizmoAxis = axis;
        gizmoPlane = plane;
        gizmoMoving = true;

        movingStart.copy(getGizmoPosition());

        for(var i = 0; i < items.length; i++) {
            var pos = items[i].obj.entity.getPosition();
            items[i].start[0] = pos.x;
            items[i].start[1] = pos.y;
            items[i].start[2] = pos.z;
            items[i].pos = items[i].start.slice(0);

            pos = items[i].obj.get('position');
            items[i].startLocal[0] = pos[0];
            items[i].startLocal[1] = pos[1];
            items[i].startLocal[2] = pos[2];

            items[i].obj.history.enabled = false;
        }
    };

    // end translating
    var onGizmoEnd = function() {
        gizmoMoving = false;
        var records = [ ];

        for(var i = 0; i < items.length; i++) {
            items[i].obj.history.enabled = true;

            var data = {
                get: items[i].obj.history._getItemFn,
                valueOld: items[i].startLocal.slice(0),
                value: items[i].obj.get('position')
            };

            records.push(data);
        }

        editor.call('history:add', {
            name: 'entities.translate',
            undo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set('position', records[i].valueOld);
                    item.history.enabled = true;
                }
            },
            redo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set('position', records[i].value);
                    item.history.enabled = true;
                }
            }
        });
    };

    // translated
    var onGizmoOffset = function(x, y, z) {
        timeoutUpdateRotation = true;

        for(var i = 0; i < items.length; i++) {
            if (items[i].child)
                continue;

            var entity = items[i].obj.entity;

            if (coordSystem === 'local') {
                vecA.set(x, y, z);
                vecB.set(1,1,1);
                if (entity.element && entity.element.screen) {
                    // scale offset by screen scale to ensure correct movement
                    vecB.copy(entity.element.screen.getLocalScale())
                    vecB.x = 1/vecB.x;
                    vecB.y = 1/vecB.y;
                    vecB.z = 1/vecB.z;
                }
                quat.copy(entity.getLocalRotation()).transformVector(vecA, vecA);
                vecA.mul(vecB);
                entity.setLocalPosition(items[i].startLocal[0] + vecA.x, items[i].startLocal[1] + vecA.y, items[i].startLocal[2] + vecA.z);
            } else {
                entity.setPosition(items[i].start[0] + x, items[i].start[1] + y, items[i].start[2] + z);
            }

            // if (entity.collision) {
            //     app.systems.collision.onTransformChanged(entity.collision, entity.getPosition(), entity.getRotation(), entity.getLocalScale());
            // }

            var pos = entity.getLocalPosition();
            items[i].obj.set('position', [ pos.x, pos.y, pos.z ]);
        }

        timeoutUpdateRotation = false;

        var pos = getGizmoPosition();
        editor.call('gizmo:translate:position', pos.x, pos.y, pos.z);
    };

    var onRender = function() {
        if (! app) return; // webgl not available

        if (! gizmoMoving && items.length) {
            var dirty = false;
            for(var i = 0; i < items.length; i++) {
                if (! items[i].obj.entity)
                    continue;

                var pos = items[i].obj.entity.getPosition();
                if (pos.x !== items[i].pos[0] || pos.y !== items[i].pos[1] || pos.z !== items[i].pos[2]) {
                    dirty = true;
                    items[i].pos[0] = pos.x;
                    items[i].pos[1] = pos.y;
                    items[i].pos[2] = pos.z;
                }
            }

            if (dirty) {
                var pos = getGizmoPosition();
                editor.call('gizmo:translate:position', pos.x, pos.y, pos.z);
            }
        }

        if (gizmoMoving && items.length) {
            var camera = editor.call('camera:current');
            var pos;

            var len = coordSystem === 'local' ? items.length : 1;
            for(var i = 0; i < len; i++) {
                if (items[i].child)
                    continue;

                if (coordSystem === 'local') {
                    pos = items[i].obj.entity.getPosition();
                    quat.copy(items[i].obj.entity.getRotation());
                } else {
                    pos = editor.call('gizmo:translate:position');
                    quat.setFromEulerAngles(0, 0, 0);
                }

                // x
                vecB.set(camera.camera.farClip * 2, 0, 0);
                quat.transformVector(vecB, vecB).add(pos);
                vecC.set(camera.camera.farClip * -2, 0, 0);
                quat.transformVector(vecC, vecC).add(pos);
                app.renderLine(vecB, vecC, linesColorBehind, pc.LINEBATCH_GIZMO);
                if ((gizmoAxis === 'x' && ! gizmoPlane) || (gizmoPlane && (gizmoAxis === 'y' || gizmoAxis === 'z'))) {
                    app.renderLine(vecB, vecC, linesColorActive);
                } else {
                    app.renderLine(vecB, vecC, linesColor);
                }

                // y
                vecB.set(0, camera.camera.farClip * 2, 0);
                quat.transformVector(vecB, vecB).add(pos);
                vecC.set(0, camera.camera.farClip * -2, 0);
                quat.transformVector(vecC, vecC).add(pos);
                app.renderLine(vecB, vecC, linesColorBehind, pc.LINEBATCH_GIZMO);
                if ((gizmoAxis === 'y' && ! gizmoPlane) || (gizmoPlane && (gizmoAxis === 'x' || gizmoAxis === 'z'))) {
                    app.renderLine(vecB, vecC, linesColorActive);
                } else {
                    app.renderLine(vecB, vecC, linesColor);
                }

                // z
                vecB.set(0, 0, camera.camera.farClip * 2);
                quat.transformVector(vecB, vecB).add(pos);
                vecC.set(0, 0, camera.camera.farClip * -2);
                quat.transformVector(vecC, vecC).add(pos);
                app.renderLine(vecB, vecC, linesColorBehind, pc.LINEBATCH_GIZMO);
                if ((gizmoAxis === 'z' && ! gizmoPlane) || (gizmoPlane && (gizmoAxis === 'x' || gizmoAxis === 'y'))) {
                    app.renderLine(vecB, vecC, linesColorActive);
                } else {
                    app.renderLine(vecB, vecC, linesColor);
                }
            }
        }
    };

    editor.once('viewport:load', function() {
        app = editor.call('viewport:app');
    });

    var updateChildRelation = function() {
        var itemIds = { };
        for(var i = 0; i < items.length; i++) {
            itemIds[items[i].obj.get('resource_id')] = items[i];
        }

        for(var i = 0; i < items.length; i++) {
            var child = false;
            var parent = items[i].obj.entity._parent;
            var id = '';
            while(! child && parent) {
                id = parent.getGuid();
                if (itemIds[id]) {
                    parent = itemIds[id];
                    child = true;
                    break;
                }
                parent = parent._parent;
            }
            items[i].child = child;
            items[i].parent = child ? parent : null;
        }
    };

    var updateGizmo = function() {
        if (! editor.call('permissions:write'))
            return;

        var objects = editor.call('selector:items');

        for(var i = 0; i < events.length; i++)
            events[i].unbind();
        events = [ ];
        items = [ ];

        if (editor.call('selector:type') === 'entity' && editor.call('gizmo:type') === 'translate') {
            for(var i = 0; i < objects.length; i++) {
                if (! objects[i].entity)
                    continue;

                var pos = objects[i].entity.getPosition();

                items.push({
                    obj: objects[i],
                    pos: [ pos.x, pos.y, pos.z ],
                    start: [ 0, 0, 0 ],
                    startLocal: [ 0, 0, 0 ]
                });

                // position
                events.push(objects[i].on('position:set', updateGizmoPosition));
                // position.*
                for(var n = 0; n < 3; n++)
                    events.push(objects[i].on('position.' + n + ':set', updateGizmoPosition));

                // rotation
                events.push(objects[i].on('rotation:set', updateGizmoRotation));
                // rotation.*
                for(var n = 0; n < 3; n++)
                    events.push(objects[i].on('rotation.' + n + ':set', updateGizmoRotation));

                events.push(objects[i].on('parent:set', updateChildRelation));
            }

            if (! items.length)
                return;

            updateChildRelation();

            var rot = getGizmoRotation();
            editor.call('gizmo:translate:rotation', rot[0], rot[1], rot[2]);

            // gizmo start
            events.push(editor.on('gizmo:translate:start', onGizmoStart));
            // gizmo end
            events.push(editor.on('gizmo:translate:end', onGizmoEnd));
            // gizmo offset
            events.push(editor.on('gizmo:translate:offset', onGizmoOffset));

            // position gizmo
            var pos = getGizmoPosition();
            editor.call('gizmo:translate:position', pos.x, pos.y, pos.z);
            // show gizmo
            editor.call('gizmo:translate:toggle', true);
            // on render
            events.push(editor.on('gizmo:translate:render', onRender));
            // render
            editor.call('viewport:render');
        } else {
            // hide gizmo
            editor.call('gizmo:translate:toggle', false);
            // render
            editor.call('viewport:render');
        }
    };

    editor.on('gizmo:type', updateGizmo);
    editor.on('selector:change', updateGizmo);
});


/* editor/entities/entities-gizmo-scale.js */
editor.once('load', function() {
    'use strict';

    var events = [ ];
    var items = [ ];
    var quat = new pc.Quat();
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var vecC = new pc.Vec3();
    var startPosition = new pc.Vec3();
    var timeoutUpdatePosition, timeoutUpdateRotation;
    var app;
    var gizmoMoving = false;
    var gizmoAxis, gizmoMiddle;
    var linesColorActive = new pc.Color(1, 1, 1, 1);
    var linesColor = new pc.Color(1, 1, 1, .2);
    var linesColorBehind = new pc.Color(1, 1, 1, .05);

    // get position of gizmo based on selected entities
    var getGizmoPosition = function() {
        if (! items.length)
            return;

        var reference = items[items.length - 1];
        var parent = reference.parent;
        while(parent) {
            reference = parent;
            parent = parent.parent;
        }
        vecA.copy(reference.obj.entity.getPosition());

        return vecA;
    };

    var getGizmoRotation = function() {
        if (! items.length)
            return;

        var reference = items[items.length - 1];
        var parent = reference.parent;
        while(parent) {
            reference = parent;
            parent = parent.parent;
        }
        var rot = reference.obj.entity.getEulerAngles();

        return [ rot.x, rot.y, rot.z ];
    };

    // update gizmo position
    var updateGizmoPosition = function() {
        if (! items.length || timeoutUpdatePosition)
            return;

        timeoutUpdatePosition = true;

        setTimeout(function() {
            timeoutUpdatePosition = false;

            var vec = getGizmoPosition();
            if (vec)
                editor.call('gizmo:scale:position', vec.x, vec.y, vec.z);
        });
    };

    // update gizmo position
    var updateGizmoRotation = function() {
        if (! items.length || timeoutUpdateRotation)
            return;

        timeoutUpdateRotation = true;

        setTimeout(function() {
            timeoutUpdateRotation = false;

            var vec = getGizmoRotation();
            if (vec)
                editor.call('gizmo:scale:rotation', vec[0], vec[1], vec[2]);
        });
    };

    // start translating
    var onGizmoStart = function(axis, middle) {
        gizmoAxis = axis;
        gizmoMiddle = middle;
        gizmoMoving = true;

        for(var i = 0; i < items.length; i++) {
            var scale = items[i].obj.get('scale');
            items[i].start[0] = scale[0];
            items[i].start[1] = scale[1];
            items[i].start[2] = scale[2];
            items[i].pos = items[i].start.slice(0);
            items[i].obj.history.enabled = false;
        }
    };

    // end translating
    var onGizmoEnd = function() {
        gizmoMoving = false;
        var records = [ ];

        for(var i = 0; i < items.length; i++) {
            items[i].obj.history.enabled = true;

            records.push({
                get: items[i].obj.history._getItemFn,
                valueOld: items[i].start.slice(0),
                value: items[i].obj.get('scale')
            });
        }

        editor.call('history:add', {
            name: 'entities.scale',
            undo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set('scale', records[i].valueOld);
                    item.history.enabled = true;
                }
            },
            redo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set('scale', records[i].value);
                    item.history.enabled = true;
                }
            }
        });
    };

    // scaled
    var onGizmoOffset = function(x, y, z) {
        for(var i = 0; i < items.length; i++) {
            if (items[i].child)
                continue;

            // skip 2D screens
            if (items[i].obj.get('components.screen.screenSpace'))
                continue;

            items[i].obj.set('scale', [ items[i].start[0] * x, items[i].start[1] * y, items[i].start[2] * z ]);
        }
    };

    var onRender = function() {
        if (! app) return; // webgl not available

        if (gizmoMoving) {
            var camera = editor.call('camera:current');

            for(var i = 0; i < items.length; i++) {
                if (items[i].child)
                    continue;

                vecA.copy(items[i].obj.entity.getPosition());
                quat.copy(items[i].obj.entity.getRotation());

                if (gizmoAxis === 'x' || gizmoMiddle) {
                    vecB.set(camera.camera.farClip * 2, 0, 0);
                    quat.transformVector(vecB, vecB).add(vecA);
                    vecC.set(camera.camera.farClip * -2, 0, 0);
                    quat.transformVector(vecC, vecC).add(vecA);
                    app.renderLine(vecB, vecC, linesColorBehind, pc.LINEBATCH_GIZMO);
                    app.renderLine(vecB, vecC, linesColorActive);
                }
                if (gizmoAxis === 'y' || gizmoMiddle) {
                    vecB.set(0, camera.camera.farClip * 2, 0);
                    quat.transformVector(vecB, vecB).add(vecA);
                    vecC.set(0, camera.camera.farClip * -2, 0);
                    quat.transformVector(vecC, vecC).add(vecA);
                    app.renderLine(vecB, vecC, linesColorBehind, pc.LINEBATCH_GIZMO);
                    app.renderLine(vecB, vecC, linesColorActive);
                }
                if (gizmoAxis === 'z' || gizmoMiddle) {
                    vecB.set(0, 0, camera.camera.farClip * 2);
                    quat.transformVector(vecB, vecB).add(vecA);
                    vecC.set(0, 0, camera.camera.farClip * -2);
                    quat.transformVector(vecC, vecC).add(vecA);
                    app.renderLine(vecB, vecC, linesColorBehind, pc.LINEBATCH_GIZMO);
                    app.renderLine(vecB, vecC, linesColorActive);
                }
            }
        } else {
            var dirty = false;
            for(var i = 0; i < items.length; i++) {
                if (! items[i].obj.entity)
                    continue;

                var pos = items[i].obj.entity.getPosition();
                if (pos.x !== items[i].pos[0] || pos.y !== items[i].pos[1] || pos.z !== items[i].pos[2]) {
                    dirty = true;
                    items[i].pos[0] = pos.x;
                    items[i].pos[1] = pos.y;
                    items[i].pos[2] = pos.z;
                }
            }

            if (dirty) {
                var pos = getGizmoPosition();
                editor.call('gizmo:scale:position', pos.x, pos.y, pos.z);
            }
        }
    };

    editor.once('viewport:load', function() {
        app = editor.call('viewport:app');
    });

    var updateChildRelation = function() {
        var itemIds = { };
        for(var i = 0; i < items.length; i++) {
            itemIds[items[i].obj.get('resource_id')] = items[i];
        }

        for(var i = 0; i < items.length; i++) {
            var child = false;
            var parent = items[i].obj.entity._parent;
            var id = '';
            while(! child && parent) {
                id = parent.getGuid();
                if (itemIds[id]) {
                    parent = itemIds[id];
                    child = true;
                    break;
                }
                parent = parent._parent;
            }
            items[i].child = child;
            items[i].parent = child ? parent : null;
        }
    };

    var updateGizmo = function() {
        if (! editor.call('permissions:write'))
            return;

        var objects = editor.call('selector:items');

        for(var i = 0; i < events.length; i++)
            events[i].unbind();
        events = [ ];
        items = [ ];

        if (editor.call('selector:type') === 'entity' && editor.call('gizmo:type') === 'scale') {
            for(var i = 0; i < objects.length; i++) {
                if (! objects[i].entity)
                    continue;

                var pos = objects[i].entity.getPosition();

                items.push({
                    obj: objects[i],
                    pos: [ pos.x, pos.y, pos.z ],
                    start: [ 1, 1, 1 ]
                });

                // position
                events.push(objects[i].on('position:set', updateGizmoPosition));
                // position.*
                for(var n = 0; n < 3; n++)
                    events.push(objects[i].on('position.' + n + ':set', updateGizmoPosition));

                // rotation
                events.push(objects[i].on('rotation:set', updateGizmoRotation));
                // rotation.*
                for(var n = 0; n < 3; n++)
                    events.push(objects[i].on('rotation.' + n + ':set', updateGizmoRotation));

                events.push(objects[i].on('parent:set', updateChildRelation));
            }

            if (! items.length)
                return;

            updateChildRelation();

            var rot = getGizmoRotation();
            editor.call('gizmo:scale:rotation', rot[0], rot[1], rot[2]);

            // gizmo start
            events.push(editor.on('gizmo:scale:start', onGizmoStart));
            // gizmo end
            events.push(editor.on('gizmo:scale:end', onGizmoEnd));
            // gizmo offset
            events.push(editor.on('gizmo:scale:offset', onGizmoOffset));

            // position gizmo
            var pos = getGizmoPosition();
            editor.call('gizmo:scale:position', pos.x, pos.y, pos.z);
            // show gizmo
            editor.call('gizmo:scale:toggle', true);
            // on render
            events.push(editor.on('gizmo:scale:render', onRender));
            // render
            editor.call('viewport:render');
        } else {
            // hide gizmo
            editor.call('gizmo:scale:toggle', false);
            // render
            editor.call('viewport:render');
        }
    };

    editor.on('gizmo:type', updateGizmo);
    editor.on('selector:change', updateGizmo);
});


/* editor/entities/entities-gizmo-rotate.js */
editor.once('load', function() {
    'use strict';

    var events = [ ];
    var items = [ ];
    var quat = new pc.Quat();
    var quatB = new pc.Quat();
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var vecC = new pc.Vec3();
    var startPosition = new pc.Vec3();
    var timeoutUpdatePosition, timeoutUpdateRotation;
    var coordSystem = 'world';
    var gizmoPos = new pc.Vec3();
    var gizmoMoving = false;
    var gizmoAxis;
    var linesColorActive = new pc.Color(1, 1, 1, 1);
    var linesColor = new pc.Color(1, 1, 1, .2);
    var linesColorBehind = new pc.Color(1, 1, 1, .05);

    editor.on('gizmo:coordSystem', function(system) {
        if (coordSystem === system)
            return;

        coordSystem = system;

        var rot = getGizmoRotation();
        if (rot)
            editor.call('gizmo:rotate:rotation', rot[0], rot[1], rot[2]);

        var vec = getGizmoPosition();
        if (vec)
            editor.call('gizmo:rotate:position', vec.x, vec.y, vec.z);

        editor.call('viewport:render');
    });

    // get position of gizmo based on selected entities
    var getGizmoPosition = function() {
        if (! items.length)
            return;

        if (items.length === 1) {
            vecA.copy(items[0].obj.entity.getPosition());
        } else if (coordSystem === 'local') {
            var reference = items[items.length - 1];
            var parent = reference.parent;
            while(parent) {
                reference = parent;
                parent = parent.parent;
            }
            vecA.copy(reference.obj.entity.getPosition());
        } else {
            var selection = editor.call('selection:aabb');
            if (! selection) return;
            vecA.copy(selection.center);
        }

        return vecA;
    };

    var getGizmoRotation = function() {
        if (! items.length)
            return;

        if (coordSystem === 'local') {
            var reference = items[items.length - 1];
            var parent = reference.parent;
            while(parent) {
                reference = parent;
                parent = parent.parent;
            }
            var rot = reference.obj.entity.getEulerAngles();

            return [ rot.x, rot.y, rot.z ];
        } else {
            return [ 0, 0, 0 ];
        }
    };

    // update gizmo position
    var updateGizmoPosition = function() {
        if (! items.length || timeoutUpdatePosition || gizmoMoving)
            return;

        timeoutUpdatePosition = true;

        setTimeout(function() {
            timeoutUpdatePosition = false;

            var vec = getGizmoPosition();
            if (vec)
                editor.call('gizmo:rotate:position', vec.x, vec.y, vec.z);
        });
    };

    // update gizmo position
    var updateGizmoRotation = function() {
        if (! gizmoMoving)
            updateGizmoPosition();

        if (! items.length || timeoutUpdateRotation)
            return;

        timeoutUpdateRotation = true;

        setTimeout(function() {
            timeoutUpdateRotation = false;

            var vec = getGizmoRotation();
            if (vec)
                editor.call('gizmo:rotate:rotation', vec[0], vec[1], vec[2]);
        });
    };

    // start translating
    var onGizmoStart = function(axis) {
        gizmoAxis = axis;
        gizmoMoving = true;

        gizmoPos.copy(editor.call('gizmo:rotate:position'));

        for(var i = 0; i < items.length; i++) {
            var rot = items[i].obj.entity.getEulerAngles();
            items[i].start[0] = rot.x;
            items[i].start[1] = rot.y;
            items[i].start[2] = rot.z;
            items[i].pos = items[i].start.slice(0);

            var posLocal = items[i].obj.entity.getLocalPosition();

            items[i].startPosLocal[0] = posLocal.x;
            items[i].startPosLocal[1] = posLocal.y;
            items[i].startPosLocal[2] = posLocal.z;

            var pos = items[i].obj.entity.getPosition();

            items[i].offset[0] = pos.x - gizmoPos.x;
            items[i].offset[1] = pos.y - gizmoPos.y;
            items[i].offset[2] = pos.z - gizmoPos.z;

            rot = items[i].obj.get('rotation');
            items[i].startLocal[0] = rot[0];
            items[i].startLocal[1] = rot[1];
            items[i].startLocal[2] = rot[2];

            items[i].startLocalQuat.copy(items[i].obj.entity.getLocalRotation());
            items[i].startQuat.copy(items[i].obj.entity.getRotation());

            items[i].obj.history.enabled = false;
        }
    };

    // end translating
    var onGizmoEnd = function() {
        gizmoMoving = false;
        var records = [ ];

        for(var i = 0; i < items.length; i++) {
            items[i].obj.history.enabled = true;

            records.push({
                get: items[i].obj.history._getItemFn,
                valueRotOld: items[i].startLocal.slice(0),
                valueRot: items[i].obj.get('rotation'),
                valuePosOld: items[i].startPosLocal.slice(0),
                valuePos: items[i].obj.get('position')
            });
        }

        editor.call('history:add', {
            name: 'entities.rotate',
            undo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set('position', records[i].valuePosOld);
                    item.set('rotation', records[i].valueRotOld);
                    item.history.enabled = true;
                }
            },
            redo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set('position', records[i].valuePos);
                    item.set('rotation', records[i].valueRot);
                    item.history.enabled = true;
                }
            }
        });

        var pos = getGizmoPosition();
        editor.call('gizmo:rotate:position', pos.x, pos.y, pos.z);
    };

    // translated
    var onGizmoOffset = function(angle, point) {
        timeoutUpdateRotation = true;

        for(var i = 0; i < items.length; i++) {
            if (items[i].child)
                continue;

            // skip 2D screens
            if (items[i].obj.get('components.screen.screenSpace'))
                continue;

            vecA.set(0, 0, 0);
            vecA[gizmoAxis] = 1;

            quat.setFromAxisAngle(vecA, angle);

            if (coordSystem === 'local') {
                quatB.copy(items[i].startLocalQuat).mul(quat);
                items[i].obj.entity.setLocalRotation(quatB);
            } else if (items.length === 1) {
                quatB.copy(quat).mul(items[i].startQuat);
                items[i].obj.entity.setRotation(quatB);
            } else {
                vecA.set(items[i].offset[0], items[i].offset[1], items[i].offset[2]);
                quat.transformVector(vecA, vecA);
                quatB.copy(quat).mul(items[i].startQuat);
                items[i].obj.entity.setRotation(quatB);
                items[i].obj.entity.setPosition(vecA.add(gizmoPos));

                var pos = items[i].obj.entity.getLocalPosition();
                items[i].obj.set('position', [ pos.x, pos.y, pos.z ]);
            }

            var angles = items[i].obj.entity.getLocalEulerAngles();
            items[i].obj.set('rotation', [ angles.x, angles.y, angles.z ]);
        }

        timeoutUpdateRotation = false;

        if (items.length > 1 || coordSystem === 'local') {
            var rot = getGizmoRotation();
            editor.call('gizmo:rotate:rotation', rot[0], rot[1], rot[2]);
        }
    };

    var onRender = function() {
        if (! gizmoMoving && items.length) {
            var dirty = false;
            for(var i = 0; i < items.length; i++) {
                if (! items[i].obj.entity)
                    continue;

                var pos = items[i].obj.entity.getPosition();
                if (pos.x !== items[i].pos[0] || pos.y !== items[i].pos[1] || pos.z !== items[i].pos[2]) {
                    dirty = true;
                    items[i].pos[0] = pos.x;
                    items[i].pos[1] = pos.y;
                    items[i].pos[2] = pos.z;
                }
            }

            if (dirty) {
                var pos = getGizmoPosition();
                editor.call('gizmo:translate:position', pos.x, pos.y, pos.z);
            }
        }

        if (items.length > 1 && ! coordSystem === 'world') {
            var rot = getGizmoRotation();
            editor.call('gizmo:rotate:rotation', rot[0], rot[1], rot[2]);
        }
    };

    var updateChildRelation = function() {
        var itemIds = { };
        for(var i = 0; i < items.length; i++) {
            itemIds[items[i].obj.get('resource_id')] = items[i];
        }

        for(var i = 0; i < items.length; i++) {
            var child = false;
            var parent = items[i].obj.entity._parent;
            var id = '';
            while(! child && parent) {
                id = parent.getGuid();
                if (itemIds[id]) {
                    parent = itemIds[id];
                    child = true;
                    break;
                }
                parent = parent._parent;
            }
            items[i].child = child;
            items[i].parent = child ? parent : null;
        }

        updateGizmoPosition();
    };

    var updateGizmo = function() {
        if (! editor.call('permissions:write'))
            return;

        var objects = editor.call('selector:items');

        for(var i = 0; i < events.length; i++)
            events[i].unbind();
        events = [ ];
        items = [ ];

        if (editor.call('selector:type') === 'entity' && editor.call('gizmo:type') === 'rotate') {
            for(var i = 0; i < objects.length; i++) {
                if (! objects[i].entity)
                    continue;

                var pos = objects[i].entity.getPosition();

                items.push({
                    obj: objects[i],
                    startLocalQuat: objects[i].entity.getLocalRotation().clone(),
                    startQuat: objects[i].entity.getRotation().clone(),
                    pos: [ pos.x, pos.y, pos.z ],
                    offset: [ 0, 0, 0 ],
                    start: [ 0, 0, 0 ],
                    startLocal: [ 0, 0, 0 ],
                    startPosLocal: [ 0, 0, 0 ]
                });

                // position
                events.push(objects[i].on('position:set', updateGizmoPosition));
                // position.*
                for(var n = 0; n < 3; n++)
                    events.push(objects[i].on('position.' + n + ':set', updateGizmoPosition));

                // rotation
                events.push(objects[i].on('rotation:set', updateGizmoRotation));
                // rotation.*
                for(var n = 0; n < 3; n++)
                    events.push(objects[i].on('rotation.' + n + ':set', updateGizmoRotation));

                events.push(objects[i].on('parent:set', updateChildRelation));
            }

            if (! items.length)
                return;

            updateChildRelation();

            // gizmo start
            events.push(editor.on('gizmo:rotate:start', onGizmoStart));
            // gizmo end
            events.push(editor.on('gizmo:rotate:end', onGizmoEnd));
            // gizmo offset
            events.push(editor.on('gizmo:rotate:offset', onGizmoOffset));

            // rotation gizmo
            var rot = getGizmoRotation();
            editor.call('gizmo:rotate:rotation', rot[0], rot[1], rot[2]);
            // position gizmo
            var pos = getGizmoPosition();
            editor.call('gizmo:rotate:position', pos.x, pos.y, pos.z);
            // show gizmo
            editor.call('gizmo:rotate:toggle', true);
            // on render
            events.push(editor.on('gizmo:rotate:render', onRender));
            // render
            editor.call('viewport:render');
        } else {
            // hide gizmo
            editor.call('gizmo:rotate:toggle', false);
            // render
            editor.call('viewport:render');
        }
    };

    editor.on('gizmo:type', updateGizmo);
    editor.on('selector:change', updateGizmo);
});


/* editor/entities/entities-clipboard.js */
editor.once('load', function () {
    var CLIPBOARD_NAME = 'playcanvas_editor_clipboard';
    var CLIPBOARD_META = CLIPBOARD_NAME + '_meta';

    // get current clipboard value
    editor.method('entities:clipboard:get', function () {
        return editor.call('localStorage:get', CLIPBOARD_NAME);
    });

    // set current clipboard value
    editor.method('entities:clipboard:set', function (data) {
        editor.call('localStorage:set', CLIPBOARD_META, {project: config.project.id});
        editor.call('localStorage:set', CLIPBOARD_NAME, data);
    });

    // return true if there is no data in the clipboard
    editor.method('entities:clipboard:empty', function () {
        return !editor.call('localStorage:get', CLIPBOARD_META);
    });
});

/* editor/entities/entities-user-color.js */
editor.once('load', function() {
    'use strict';

    var colors = { };
    var items = { };
    var pool = { };

    editor.on('selector:sync', function(user, data) {
        // deselect
        if (items[user] && items[user].length) {
            for(var i = 0; i < items[user].length; i++) {
                var element = items[user][i];
                element.parentNode.removeChild(element);
                pool[user].push(element);
            }

            items[user] = [ ];
        }

        if (data.type === 'entity') {
            // select
            if (! items[user]) {
                items[user] = [ ];
                pool[user] = [ ];
            }

            if (! colors[user])
                colors[user] = editor.call('whoisonline:color', user, 'hex');

            for(var i = 0; i < data.ids.length; i++) {
                var element = editor.call('entities:panel:get', data.ids[i]);
                if (! element)
                    continue;

                var point;

                if (pool[user].length) {
                    point = pool[user].pop();
                } else {
                    point = document.createElement('span');
                    point.style.backgroundColor = colors[user];
                }

                element.users.appendChild(point);
                items[user].push(point);
            }
        }
    });

    editor.on('whoisonline:remove', function(id) {
        if (! items[id])
            return;

        for(var i = 0; i < items[id].length; i++)
            items[id][i].parentNode.removeChild(items[id][i]);

        delete items[id];
        delete pool[id];
        delete colors[id];
    });
});


/* editor/components/components-schema.js */
editor.once('load', function() {
    'use strict';

    var projectSettings = editor.call('settings:project');

    var schema = {
        animation: {
            title: 'Animation',
            default: {
                enabled: true,
                assets: [ ],
                speed: 1,
                loop: true,
                activate: true
            }
        },

        light: {
            title: 'Light',
            default: {
                enabled: true,
                type: 'directional',
                isStatic: false,
                bake: false,
                affectDynamic: true,
                affectLightMapped: false,
                color: [ 1, 1, 1 ],
                intensity: 1,
                castShadows: false,
                shadowType: 0,
                shadowDistance: 16,
                shadowResolution: 1024,
                shadowBias: 0.2,
                normalOffsetBias: 0.05,
                vsmBlurMode: 1,
                vsmBlurSize: 11,
                vsmBias: 0.01,
                range: 8,
                falloffMode: 0,
                innerConeAngle: 40,
                outerConeAngle: 45,
                cookieAsset: null,
                cookieIntensity: 1.0,
                cookieFalloff: true,
                cookieChannel: 'rgb',
                cookieAngle: 0.0,
                cookieOffset: [ 0.0, 0.0 ],
                cookieScale: [ 1.0, 1.0 ]
            },
            types: {
                color: 'rgb',
                cookieOffset: 'vec2',
                cookieScale: 'vec2'
            }
        },

        audiolistener: {
            title: 'Audio Listener',
            default: {
                enabled: true
            }
        },

        audiosource: {
            title: 'Audio Source',
            default: {
                enabled: true,
                assets: [],
                volume: 1,
                pitch: 1,
                loop: false,
                activate: true,
                '3d': true,
                minDistance: 1,
                maxDistance: 10000,
                rollOffFactor: 1
            }
        },

        sound: {
            title: 'Sound',
            default: {
                enabled: true,
                volume: 1,
                pitch: 1,
                positional: true,
                refDistance: 1,
                maxDistance: 10000,
                rollOffFactor: 1,
                distanceModel: 'linear',
                slots: {
                    '1': {
                        name: 'Slot 1',
                        loop: false,
                        autoPlay: false,
                        overlap: false,
                        asset: null,
                        startTime: 0,
                        duration: null,
                        volume: 1,
                        pitch: 1
                    }
                }
            }
        },

        camera: {
            title: 'Camera',
            default: {
                enabled: true,
                clearColorBuffer: true,
                clearColor: [0.118, 0.118, 0.118, 1],
                clearDepthBuffer: true,
                projection: 0,
                fov: 45,
                frustumCulling: true,
                orthoHeight: 4,
                nearClip: 0.1,
                farClip: 1000,
                priority: 0,
                rect: [0, 0, 1, 1]
            },
            types: {
                clearColor: 'rgb',
                rect: 'vec4'
            }
        },

        collision: {
            title: 'Collision',
            default: {
                enabled: true,
                type: 'box',
                halfExtents: [0.5,  0.5, 0.5],
                radius: 0.5,
                axis: 1,
                height: 2,
                asset: null
            },
            types: {
                halfExtents: 'vec3'
            }
        },

        model: {
            title: 'Model',
            default: {
                enabled: true,
                isStatic: false,
                type: 'asset',
                asset: null,
                materialAsset: null,
                castShadows: true,
                castShadowsLightmap: true,
                receiveShadows: true,
                lightMapped: false,
                lightMapSizeMultiplier: 1.0
            }
        },

        particlesystem: {
            title: 'Particle System',
            default: {
                enabled: true,
                autoPlay: true,
                numParticles: 30,
                lifetime: 5,
                rate: 0.1,
                rate2: 0.1,
                startAngle: 0,
                startAngle2: 0,
                loop: true,
                preWarm: false,
                lighting: false,
                halfLambert: false,
                intensity: 1,
                depthWrite: false,
                depthSoftening: 0,
                sort: 0,
                blendType: 2,
                stretch: 0,
                alignToMotion: false,
                emitterShape: 0,
                emitterExtents: [0, 0, 0],
                emitterRadius: 0,
                initialVelocity: 0,
                animTilesX: 1,
                animTilesY: 1,
                animNumFrames: 1,
                animSpeed: 1,
                animLoop: true,
                wrap: false,
                wrapBounds: [0,0,0],
                colorMapAsset: null,
                normalMapAsset: null,
                mesh: null,
                localVelocityGraph: {
                    type: 1,
                    keys: [[0, 0], [0, 0], [0, 0]],
                    betweenCurves: false
                },
                localVelocityGraph2: {
                    type: 1,
                    keys: [[0, 0], [0, 0], [0, 0]]
                },
                velocityGraph: {
                    type: 1,
                    keys: [[0, -1], [0, -1], [0, -1]],
                    betweenCurves: true
                },
                velocityGraph2: {
                    type: 1,
                    keys: [[0, 1], [0, 1], [0, 1]]
                },
                rotationSpeedGraph: {
                    type: 1,
                    keys: [0, 0],
                    betweenCurves: false
                },
                rotationSpeedGraph2: {
                    type: 1,
                    keys: [0, 0]
                },
                scaleGraph: {
                    type: 1,
                    keys: [0, 0.1],
                    betweenCurves: false
                },
                scaleGraph2: {
                    type: 1,
                    keys: [0, 0.1]
                },
                colorGraph: {
                    type: 1,
                    keys: [[0, 1], [0, 1], [0, 1]],
                    betweenCurves: false
                },
                alphaGraph: {
                    type: 1,
                    keys: [0, 1],
                    betweenCurves: false
                },
                alphaGraph2: {
                    type: 1,
                    keys: [0, 1]
                }
            },
            types: {
                emitterExtents: 'vec3',
                localVelocityGraph: 'curveset',
                localVelocityGraph2: 'curveset',
                velocityGraph: 'curveset',
                velocityGraph2: 'curveset',
                rotationSpeedGraph: 'curve',
                rotationSpeedGraph2: 'curve',
                scaleGraph: 'curve',
                scaleGraph2: 'curve',
                colorGraph: 'curveset',
                alphaGraph: 'curve',
                alphaGraph2: 'curve'
            }
        },

        rigidbody: {
            title: 'Rigid Body',
            default: {
                enabled: true,
                type: 'static',
                mass: 1,
                linearDamping: 0,
                angularDamping: 0,
                linearFactor: [1, 1, 1],
                angularFactor: [1, 1, 1],
                friction: 0.5,
                restitution: 0.5
            },
            types: {
                linearFactor: 'vec3',
                angularFactor: 'vec3'
            }
        },

        script: {
            title: 'Script',
            default: {
                enabled: true,
                order: [ ],
                scripts: null
            }
        },

        zone: {
            title: 'Zone',
            default: {
                enabled: true,
                size: [ 1, 1, 1 ]
            }
        },

        screen: {
            title: 'Screen',
            default: {
                enabled: true,
                resolution: [640, 320],
                referenceResolution: [640, 320],
                screenSpace: true,
                scaleMode: 'blend',
                scaleBlend: 0.5
            },
            types: {
                resolution: 'vec2',
                referenceResolution: 'vec2'
            }
        },

        element: {
            title: 'Element',
            default: {
                enabled: true,
                useInput: false,
                type: 'text',
                anchor: [0.5, 0.5, 0.5, 0.5],
                pivot: [0.5, 0.5],
                text: '',
                fontAsset: null,
                fontSize: 32,
                lineHeight: 32,
                spacing: 1,
                color: [1, 1, 1],
                opacity: 1,
                textureAsset: null,
                width: 32,
                height: 32,
                margin: [-16,-16,-16,-16],
                alignment: [0.5, 0.5],
                rect: [0, 0, 1, 1],
                autoWidth: false,
                autoHeight: false,
                materialAsset: null
            },
            types: {
                anchor: 'vec4',
                pivot: 'vec2',
                color: 'rgb',
                rect: 'vec4',
                margin: 'vec4',
                alignment: 'vec2'
            }
        }
    };

    // Paths in components that represent
    // assets. Used when copy pasting. Does not include
    // asset script attributes
    var assetPaths = [
        'components.animation.assets',
        'components.light.cookieAsset',
        'components.model.asset',
        'components.model.materialAsset',
        'components.audiosource.assets',
        'components.sound.slots.*.asset',
        'components.collision.asset',
        'components.particlesystem.colorMapAsset',
        'components.particlesystem.normalMapAsset',
        'components.particlesystem.mesh',
        'components.element.fontAsset',
        'components.element.textureAsset',
        'components.element.materialAsset'
    ];

    editor.method('components:assetPaths', function () {
        return assetPaths;
    });

    if (editor.call('settings:project').get('useLegacyScripts')) {
        schema.script.default.scripts = [ ];
        delete schema.script.default.order;
    } else {
        schema.script.default.scripts = { };
    }

    var list = Object.keys(schema).sort(function(a, b) {
        if (a > b) {
            return 1;
        } else if (a < b) {
            return -1;
        } else {
            return 0;
        }
    });

    editor.method('components:convertValue', function (component, property, value) {
        var result = value;

        if (value) {
            var data = schema[component];
            if (data && data.types) {
                var type = data.types[property];
                switch (type) {
                    case 'rgb':
                        result = new pc.Color(value[0], value[1], value[2]);
                        break;
                    case 'rgba':
                        result = new pc.Color(value[0], value[1], value[2], value[3]);
                        break;
                    case 'vec2':
                        result = new pc.Vec2(value[0], value[1]);
                        break;
                    case 'vec3':
                        result = new pc.Vec3(value[0], value[1], value[2]);
                        break;
                    case 'vec4':
                        result = new pc.Vec4(value[0], value[1], value[2], value[3]);
                        break;
                    case 'curveset':
                        result = new pc.CurveSet(value.keys);
                        result.type = value.type;
                        break;
                    case 'curve':
                        result = new pc.Curve(value.keys);
                        result.type = value.type;
                        break;
                }
            }
        }

        return result;
    });

    editor.method('components:list', function () {
        return list.slice(0);
    });

    editor.method('components:schema', function () {
        return schema;
    });

    editor.method('components:getDefault', function (component) {
        var result = utils.deepCopy(schema[component].default);

        // default resolution to project resolution for screen components
        if (component === 'screen') {
            result.resolution[0] = projectSettings.get('width');
            result.resolution[1] = projectSettings.get('height');

            result.referenceResolution[0] = result.resolution[0];
            result.referenceResolution[1] = result.resolution[1];
        }

        return result;
    });

});


/* editor/gizmo/gizmo.js */
editor.once('load', function() {
    'use strict';

    var gizmoType = 'translate';
    var coordSystem = 'world';
    var snap = false;
    var snapToggle = false;
    var snapShift = false;
    var snapIncrement = 1;

    editor.method('gizmo:type', function(type) {
        if (type === undefined)
            return gizmoType;

        if (gizmoType === type)
            return;

        gizmoType = type;

        editor.emit('gizmo:type', type);
    });

    editor.method('gizmo:coordSystem', function(system) {
        if (system === undefined)
            return coordSystem;

        if (coordSystem === system)
            return;

        coordSystem = system;

        editor.emit('gizmo:coordSystem', system);
    });

    var checkSnap = function() {
        var state = (snapToggle || snapShift) && (snapToggle !== snapShift);
        if (snap === state)
            return;

        snap = state;
        editor.emit('gizmo:snap', snap, snapIncrement);
    };

    editor.method('gizmo:snap', function(state) {
        if (snapToggle === state)
            return;

        snapToggle = state;
        checkSnap();
    });

    var editorSettings = editor.call('settings:projectUser');
    editorSettings.on('editor.snapIncrement:set', function(value) {
        if (snapIncrement === (value || 1))
            return;

        snapIncrement = value || 1;
        editor.emit('gizmo:snap', snap, snapIncrement);
    });
    snapIncrement = editorSettings.get('editor.snapIncrement') || 1;

    editor.on('hotkey:shift', function(state) {
        if (snapShift === state)
            return;

        snapShift = state;
        checkSnap();
    });

    editor.once('viewport:load', function() {
        var app = editor.call('viewport:app');
        if (! app) return; // webgl not available

        // clear depth buffer before gizmo layer
        app.scene.drawCalls.push(new pc.scene.Command(pc.LAYER_GIZMO, pc.BLEND_NONE, function() {
            app.graphicsDevice.clear({
                flags: pc.CLEARFLAG_DEPTH
            });
        }));
    });
});


/* editor/gizmo/gizmo-point.js */
editor.once('viewport:load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var pool = [ ];
    var points = [ ];
    var gizmoSize = 0.1;
    var hoverPoint = null;
    var dragPoint = null;
    var mouseTap;
    var evtTapStart;
    var pickStart = new pc.Vec3();
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var vecC = new pc.Vec3();
    var vecD = new pc.Vec3();
    var vecE = new pc.Vec3();
    var quatA = new pc.Quat();

    var color = new pc.Color(1, 1, 1, 1);
    var colorBehind = new pc.Color(1, 1, 1, 0.25);

    var container = new pc.Entity();
    container.name = 'gizmo-points';
    container.__editor = true;
    app.root.addChild(container);

    var material = new pc.BasicMaterial();
    material.color = new pc.Color(1.0, 1.0, 1.0);
    material.cull = pc.CULLFACE_NONE;
    material.update();

    function Gizmo(axis, dir) {
        Events.call(this);
        this.entity = null;
        this.axis = axis || 'y';
        this.dir = dir === undefined ? 1 : dir;
        this.rotation = new pc.Quat();
        this.position = new pc.Vec3();
        this.scale = new pc.Vec3(1, 1, 1);
    }
    Gizmo.prototype = Object.create(Events.prototype);

    Gizmo.prototype.update = function() {
        if (! this.entity)
            return;

        var camera = editor.call('camera:current');
        var posCamera = camera.getPosition();
        var pos = this.entity.getLocalPosition();
        var scale = 1;

        // scale to screen space
        if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
            var dot = vecA.copy(pos).sub(posCamera).dot(camera.forward);
            var denom = 1280 / (2 * Math.tan(camera.camera.fov * pc.math.DEG_TO_RAD / 2));
            scale = Math.max(0.0001, (dot / denom) * 150) * gizmoSize;
        } else {
            scale = camera.camera.orthoHeight / 3 * gizmoSize;
        }
        vecA.copy(this.scale).scale(scale);
        this.entity.setLocalScale(vecA);
    };

    Object.defineProperty(Gizmo.prototype, 'enabled', {
        set: function(value) {
            if (!! value === !! this.entity)
                return;

            if (value) {
                this.entity = new pc.Entity();
                this.entity.addComponent('model', {
                    type: 'box',
                    receiveShadows: false,
                    castShadowsLightmap: false,
                    castShadows: false,
                });
                this.entity.__editor = true;
                this.entity.point = this;
                this.entity.model.meshInstances[0].layer = pc.LAYER_GIZMO;
                this.entity.model.meshInstances[0].mask = 8;
                this.entity.model.meshInstances[0].material = material;
                container.addChild(this.entity);
            } else {
                this.entity.destroy();
                this.entity = null;
            }
        },
        get: function() {
            return !! this.entity;
        }
    });

    editor.method('gizmo:point:create', function(axis, position, dir) {
        var item = pool.shift();
        if (! item)
            item = new Gizmo();

        item.axis = axis || 'y';
        item.dir = dir === undefined ? 1 : dir;
        if (position) axis.position.copy(position);
        item.enabled = true;
        points.push(item.entity);

        return item;
    });

    editor.method('gizmo:point:recycle', function(point) {
        point.scale.set(1, 1, 1);
        point.enabled = false;
        pool.push(point);

        var ind = points.indexOf(point.entity);
        if (ind !== -1)
            points.splice(ind, 1);
    });

    editor.call('gizmo:point:hovered', function() {
        return hoverPoint;
    });

    // on picker hover
    editor.on('viewport:pick:hover', function(node, picked) {
        var match = false;
        if (node && node.__editor && node.point)
            match = points.indexOf(node) !== -1;

        if ((! hoverPoint || hoverPoint !== node) && match && node.point) {
            if (hoverPoint)
                hoverPoint.emit('blur');

            hoverPoint = node.point;
            hoverPoint.emit('focus');

            if (! evtTapStart)
                evtTapStart = editor.on('viewport:tap:start', onTapStart);
        } else if (hoverPoint && ! match) {
            if (hoverPoint)
                hoverPoint.emit('blur');
            hoverPoint = null;

            if (evtTapStart) {
                evtTapStart.unbind();
                evtTapStart = null;
            }
        }
    });

    var pickPlane = function(x, y) {
        var camera = editor.call('camera:current');
        var scale = 1;
        var mouseWPos = camera.camera.screenToWorld(x, y, 1);
        var posGizmo = vecE.copy(dragPoint.position);
        var rayOrigin = vecA.copy(camera.getPosition());
        var rayDirection = vecB.set(0, 0, 0);
        var planeNormal = vecC.set(0, 0, 0);
        planeNormal[dragPoint.axis] = 1;

        if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
            rayDirection.copy(mouseWPos).sub(rayOrigin).normalize();
        } else {
            rayOrigin.add(mouseWPos);
            camera.getWorldTransform().transformVector(vecD.set(0, 0, -1), rayDirection);
        }

        quatA.copy(dragPoint.rotation);

        // rotate vector by gizmo rotation
        quatA.transformVector(planeNormal, planeNormal);

        vecD.copy(rayOrigin).sub(posGizmo).normalize();
        planeNormal.copy(vecD.sub(planeNormal.scale(planeNormal.dot(vecD))).normalize());

        var rayPlaneDot = planeNormal.dot(rayDirection);
        var planeDist = posGizmo.dot(planeNormal);
        var pointPlaneDist = (planeNormal.dot(rayOrigin) - planeDist) / rayPlaneDot;
        var pickedPos = rayDirection.scale(-pointPlaneDist).add(rayOrigin);

        // single axis
        planeNormal.set(0, 0, 0);
        planeNormal[dragPoint.axis] = 1;
        quatA.transformVector(planeNormal, planeNormal);
        pickedPos.copy(planeNormal.scale(planeNormal.dot(pickedPos)));

        quatA.invert().transformVector(pickedPos, pickedPos);

        var v = pickedPos[dragPoint.axis];
        pickedPos.set(0, 0, 0);
        pickedPos[dragPoint.axis] = v;

        return pickedPos;
    };

    var onTapStart = function(tap) {
        if (tap.button !== 0 || ! hoverPoint)
            return;

        editor.emit('camera:toggle', false);

        mouseTap = tap;
        dragPoint = hoverPoint;

        pickStart.copy(pickPlane(mouseTap.x, mouseTap.y));
        dragPoint.entity.enabled = false;

        editor.emit('gizmo:point:start', dragPoint);
        dragPoint.emit('dragStart');
        editor.call('viewport:pick:state', false);
    };

    var onTapMove = function(tap) {
        if (! dragPoint)
            return;

        mouseTap = tap;
    };

    var onTapEnd = function(tap) {
        if (tap.button !== 0)
            return;

        editor.emit('camera:toggle:true', true);

        if (! dragPoint)
            return;

        mouseTap = tap;

        dragPoint.entity.enabled = true;
        editor.emit('gizmo:point:end', dragPoint);
        dragPoint.emit('dragEnd');
        dragPoint = null;

        editor.call('viewport:pick:state', true);
    };

    editor.on('viewport:mouse:move', onTapMove);
    editor.on('viewport:tap:end', onTapEnd);

    editor.on('viewport:postUpdate', function(dt) {
        if (! dragPoint)
            return;

        var point = pickPlane(mouseTap.x, mouseTap.y);
        if (point) {
            vecA.copy(point).sub(pickStart);

            var length = vecA.length();
            if ((vecA[dragPoint.axis] < 0 && dragPoint.dir === 1) || (vecA[dragPoint.axis] > 0 && dragPoint.dir === -1))
                length *= -1;

            dragPoint.emit('dragMove', length);
        }

        editor.call('viewport:render');
    });
});


/* editor/gizmo/gizmo-translate.js */
editor.once('load', function() {
    'use strict';

    var gizmo = null;
    var visible = true;
    var moving = false;
    var mouseTap = null;
    var mouseTapMoved = false;
    var posCameraLast = new pc.Vec3();
    var visible = true;
    var enabled = false;
    var hover = false;
    var hoverAxis = '';
    var hoverPlane = false;
    var hoverEntity = null;
    var gizmoSize = .4;
    var arrowRadius = .4;
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var vecC = new pc.Vec3();
    var vecD = new pc.Vec3();
    var vecE = new pc.Vec3();
    var quat = new pc.Quat();
    var matA = new pc.Mat4();
    var matB = new pc.Mat4();
    var evtTapStart;
    var pickStart = new pc.Vec3();

    var snap = false;
    var snapIncrement = 1;
    editor.on('gizmo:snap', function(state, increment) {
        snap = state;
        snapIncrement = increment;
    });

    // enable/disable gizmo
    editor.method('gizmo:translate:toggle', function(state) {
        if (! gizmo)
            return;

        gizmo.root.enabled = state && editor.call('permissions:write');
        enabled = state;

        visible = true;
    });

    editor.on('permissions:writeState', function(state) {
        if (! gizmo)
            return;

        gizmo.root.enabled = enabled && state;
        editor.call('viewport:render');
    });

    // show/hide gizmo
    editor.method('gizmo:translate:visible', function(state) {
        if (! gizmo)
            return;

        visible = state;

        for(var i = 0; i < gizmo.hoverable.length; i++) {
            if (! gizmo.hoverable[i].model)
                continue;

            gizmo.hoverable[i].model.enabled = state;
        }

        editor.call('viewport:render');
    });

    // position gizmo
    editor.method('gizmo:translate:position', function(x, y, z) {
        if (x === undefined)
            return gizmo.root.getPosition();

        gizmo.root.setPosition(x, y, z);

        if (gizmo.root.enabled)
            editor.call('viewport:render');
    });

    // rotate gizmo
    editor.method('gizmo:translate:rotation', function(pitch, yaw, roll) {
        gizmo.root.setEulerAngles(pitch, yaw, roll);

        if (gizmo.root.enabled)
            editor.call('viewport:render');
    });

    // initialize gizmo
    editor.once('viewport:load', function() {
        var app = editor.call('viewport:app');
        if (! app) return; // webgl not available

        gizmo = createEntity();
        gizmo.root.enabled = false;
        app.root.addChild(gizmo.root);

        // on picker hover
        editor.on('viewport:pick:hover', function(node, picked) {
            var match = gizmo.hoverable.indexOf(node) !== -1;
            if (! hover && match) {
                // hover
                hover = true;
            } else if (hover && ! match) {
                // unhover
                hover = false;
            }

            if (hover) {
                hoverEntity = node;

                if (node.axis && (hoverAxis !== node.axis || hoverPlane !== node.plane)) {
                    // set normal material
                    if (hoverAxis) {
                        if (hoverPlane) {
                            gizmo.plane[hoverAxis].model.material = gizmo.plane[hoverAxis].mat;
                        } else {
                            gizmo.arrow[hoverAxis].model.material = gizmo.arrow[hoverAxis].mat;
                        }
                    }

                    if (! hoverAxis && ! evtTapStart)
                        evtTapStart = editor.on('viewport:tap:start', onTapStart);

                    hoverAxis = node.axis;
                    hoverPlane = node.plane;

                    // set active material
                    if (hoverPlane) {
                        gizmo.plane[hoverAxis].model.material = gizmo.matActiveTransparent;
                    } else {
                        gizmo.arrow[hoverAxis].model.material = gizmo.matActive;
                    }
                }
            } else {
                if (hoverAxis) {
                    if (hoverPlane) {
                        gizmo.plane[hoverAxis].model.material = gizmo.plane[hoverAxis].mat;
                    } else {
                        gizmo.arrow[hoverAxis].model.material = gizmo.arrow[hoverAxis].mat;
                    }
                }

                hoverAxis = '';

                if (evtTapStart) {
                    evtTapStart.unbind();
                    evtTapStart = null;
                }
            }
        });

        // update gizmo
        editor.on('viewport:postUpdate', function(dt) {
            if (gizmo.root.enabled) {
                var camera = editor.call('camera:current');
                var posCamera = camera.getPosition();

                quat.copy(gizmo.root.getRotation()).invert();

                if (moving && (vecA.copy(posCameraLast).sub(posCamera).length() > 0.01 || mouseTapMoved)) {
                    var point = pickPlane(mouseTap.x, mouseTap.y);
                    if (point) {
                        point.sub(pickStart);
                        if (snap) {
                            point.scale(1 / snapIncrement);
                            point.x = Math.round(point.x);
                            point.y = Math.round(point.y);
                            point.z = Math.round(point.z);
                            point.scale(snapIncrement);
                        }
                        editor.emit('gizmo:translate:offset', point.x, point.y, point.z);
                    }

                    editor.call('viewport:render');
                }

                editor.emit('gizmo:translate:render', dt);

                posCameraLast.copy(posCamera);

                var posGizmo = gizmo.root.getPosition();
                var scale = 1;

                // scale to screen space
                if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
                    var dot = vecA.copy(posGizmo).sub(posCamera).dot(camera.forward);
                    var denom = 1280 / (2 * Math.tan(camera.camera.fov * pc.math.DEG_TO_RAD / 2));
                    scale = Math.max(0.0001, (dot / denom) * 150) * gizmoSize;
                } else {
                    scale = camera.camera.orthoHeight / 3 * gizmoSize;
                }
                gizmo.root.setLocalScale(scale, scale, scale);

                // calculate viewing angle
                vecA
                    .copy(posCamera)
                    .sub(posGizmo)
                    .normalize();

                // rotate vector by gizmo rotation
                quat.transformVector(vecA, vecA);

                // swap sides to face camera
                // x
                gizmo.plane.x.setLocalPosition(0, (vecA.y > 0) ? .4 : -.4, (vecA.z > 0) ? .4 : -.4);
                gizmo.line.x.setLocalPosition((vecA.x > 0) ? 1.5 : 1.1, 0, 0);
                gizmo.line.x.setLocalScale(arrowRadius, (vecA.x > 0) ? 1 : 1.8, arrowRadius);
                // y
                gizmo.plane.y.setLocalPosition((vecA.x > 0) ? .4 : -.4, 0, (vecA.z > 0) ? .4 : -.4);
                gizmo.line.y.setLocalPosition(0, (vecA.y > 0) ? 1.5 : 1.1, 0);
                gizmo.line.y.setLocalScale(arrowRadius, (vecA.y > 0) ? 1 : 1.8, arrowRadius);
                // z
                gizmo.plane.z.setLocalPosition((vecA.x > 0) ? .4 : -.4, (vecA.y > 0) ? .4 : -.4, 0);
                gizmo.line.z.setLocalPosition(0, 0, (vecA.z > 0) ? 1.5 : 1.1);
                gizmo.line.z.setLocalScale(arrowRadius, (vecA.z > 0) ? 1 : 1.8, arrowRadius);

                // hide plane if viewed from very angle
                gizmo.plane.x.model.enabled = Math.abs(vecA.x) > 0.15 && visible;
                gizmo.plane.y.model.enabled = Math.abs(vecA.y) > 0.15 && visible;
                gizmo.plane.z.model.enabled = Math.abs(vecA.z) > 0.15 && visible;

                quat.invert();

                // plane x lines
                if (gizmo.plane.x.model.enabled) {
                    vecB.set(0, 0, (vecA.z > 0) ? scale * .8 : -scale * .8);
                    vecC.set(0, (vecA.y > 0) ? scale * .8 : -scale * .8, (vecA.z > 0) ? scale * .8 : -scale * .8);
                    vecD.set(0, (vecA.y > 0) ? scale * .8 : -scale * .8, 0);
                    quat.transformVector(vecB, vecB).add(gizmo.root.getPosition());
                    quat.transformVector(vecC, vecC).add(gizmo.root.getPosition());
                    quat.transformVector(vecD, vecD).add(gizmo.root.getPosition());
                    var clr = (hoverAxis === 'x' && hoverPlane) ? gizmo.matActive.color : gizmo.arrow.x.mat.color;
                    app.renderLines([ vecB, vecC, vecC, vecD ], clr, pc.LINEBATCH_GIZMO);
                }
                // plane y lines
                if (gizmo.plane.y.model.enabled) {
                    vecB.set((vecA.x > 0) ? scale * .8 : -scale * .8, 0, 0);
                    vecC.set((vecA.x > 0) ? scale * .8 : -scale * .8, 0, (vecA.z > 0) ? scale * .8 : -scale * .8);
                    vecD.set(0, 0, (vecA.z > 0) ? scale * .8 : -scale * .8);
                    quat.transformVector(vecB, vecB).add(gizmo.root.getPosition());
                    quat.transformVector(vecC, vecC).add(gizmo.root.getPosition());
                    quat.transformVector(vecD, vecD).add(gizmo.root.getPosition());
                    var clr = (hoverAxis === 'y' && hoverPlane) ? gizmo.matActive.color : gizmo.arrow.y.mat.color;
                    app.renderLines([ vecB, vecC, vecC, vecD ], clr, pc.LINEBATCH_GIZMO);
                }
                // plane z lines
                if (gizmo.plane.z.model.enabled) {
                    vecB.set((vecA.x > 0) ? scale * .8 : -scale * .8, 0, 0);
                    vecC.set((vecA.x > 0) ? scale * .8 : -scale * .8, (vecA.y > 0) ? scale * .8 : -scale * .8, 0);
                    vecD.set(0, (vecA.y > 0) ? scale * .8 : -scale * .8, 0);
                    quat.transformVector(vecB, vecB).add(gizmo.root.getPosition());
                    quat.transformVector(vecC, vecC).add(gizmo.root.getPosition());
                    quat.transformVector(vecD, vecD).add(gizmo.root.getPosition());
                    var clr = (hoverAxis === 'z' && hoverPlane) ? gizmo.matActive.color : gizmo.arrow.z.mat.color;
                    app.renderLines([ vecB, vecC, vecC, vecD ], clr, pc.LINEBATCH_GIZMO);
                }

                // hide lines and arrows if viewed from very angle
                gizmo.line.x.model.enabled = gizmo.arrow.x.model.enabled = ! (Math.abs(vecA.z) <= 0.15 && Math.abs(vecA.y) <= 0.15) && visible;
                gizmo.line.y.model.enabled = gizmo.arrow.y.model.enabled = ! (Math.abs(vecA.x) <= 0.15 && Math.abs(vecA.z) <= 0.15) && visible;
                gizmo.line.z.model.enabled = gizmo.arrow.z.model.enabled = ! (Math.abs(vecA.x) <= 0.15 && Math.abs(vecA.y) <= 0.15) && visible;

                // draw axes lines
                // line x
                if (gizmo.line.x.model.enabled) {
                    vecB.set(((vecA.x > 0) ? scale * 1 : scale * .2), 0, 0);
                    quat.transformVector(vecB, vecB).add(gizmo.root.getPosition());
                    vecC.set(scale * 2, 0, 0);
                    quat.transformVector(vecC, vecC).add(gizmo.root.getPosition());
                    app.renderLine(vecB, vecC, gizmo.arrow.x.model.material.color, pc.LINEBATCH_GIZMO);
                }
                // line y
                if (gizmo.line.y.model.enabled) {
                    vecB.set(0, ((vecA.y > 0) ? scale * 1 : scale * .2), 0);
                    quat.transformVector(vecB, vecB).add(gizmo.root.getPosition());
                    vecC.set(0, scale * 2, 0);
                    quat.transformVector(vecC, vecC).add(gizmo.root.getPosition());
                    app.renderLine(vecB, vecC, gizmo.arrow.y.model.material.color, pc.LINEBATCH_GIZMO);
                }
                // line z
                if (gizmo.line.z.model.enabled) {
                    vecB.set(0, 0, ((vecA.z > 0) ? scale * 1 : scale * .2));
                    quat.transformVector(vecB, vecB).add(gizmo.root.getPosition());
                    vecC.set(0, 0, scale * 2);
                    quat.transformVector(vecC, vecC).add(gizmo.root.getPosition());
                    app.renderLine(vecB, vecC, gizmo.arrow.z.model.material.color, pc.LINEBATCH_GIZMO);
                }
            }

            mouseTapMoved = false
        });

        var pickPlane = function(x, y) {
            var camera = editor.call('camera:current');

            var mouseWPos = camera.camera.screenToWorld(x, y, 1);
            var posGizmo = gizmo.root.getPosition();
            var rayOrigin = vecA.copy(camera.getPosition());
            var rayDirection = vecB.set(0, 0, 0);
            var planeNormal = vecC.set(0, 0, 0);
            planeNormal[hoverAxis] = 1;

            if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
                rayDirection.copy(mouseWPos).sub(rayOrigin).normalize();
            } else {
                rayOrigin.add(mouseWPos);
                camera.getWorldTransform().transformVector(vecD.set(0, 0, -1), rayDirection);
            }

            // rotate vector by gizmo rotation
            quat.copy(gizmo.root.getRotation()).transformVector(planeNormal, planeNormal);

            // single axis
            if (! hoverPlane) {
                vecD.copy(rayOrigin).sub(posGizmo).normalize();
                planeNormal.copy(vecD.sub(planeNormal.scale(planeNormal.dot(vecD))).normalize());
            }

            var rayPlaneDot = planeNormal.dot(rayDirection);
            var planeDist = posGizmo.dot(planeNormal);
            var pointPlaneDist = (planeNormal.dot(rayOrigin) - planeDist) / rayPlaneDot;
            var pickedPos = rayDirection.scale(-pointPlaneDist).add(rayOrigin);

            if (! hoverPlane) {
                // single axis
                planeNormal.set(0, 0, 0);
                planeNormal[hoverAxis] = 1;
                quat.transformVector(planeNormal, planeNormal);
                pickedPos.copy(planeNormal.scale(planeNormal.dot(pickedPos)));
            }

            quat.invert().transformVector(pickedPos, pickedPos);

            if (! hoverPlane) {
                var v = pickedPos[hoverAxis];
                pickedPos.set(0, 0, 0);
                pickedPos[hoverAxis] = v;
            }

            return pickedPos;
        };

        var onTapStart = function(tap) {
            if (moving || tap.button !== 0)
                return;

            editor.emit('camera:toggle', false);
            editor.call('viewport:pick:state', false);

            moving = true;
            mouseTap = tap;

            if (gizmo.root.enabled)
                pickStart.copy(pickPlane(tap.x, tap.y));

            editor.emit('gizmo:translate:start', hoverAxis, hoverPlane);
            editor.call('gizmo:translate:visible', false);
        };

        var onTapMove = function(tap) {
            if (! moving)
                return;

            mouseTap = tap;
            mouseTapMoved = true;
        };

        var onTapEnd = function(tap) {
            if (tap.button !== 0)
                return;

            editor.emit('camera:toggle', true);

            if (! moving)
                return;

            moving = false;
            mouseTap = tap;

            editor.emit('gizmo:translate:end');
            editor.call('gizmo:translate:visible', true);
            editor.call('viewport:pick:state', true);
        };

        editor.on('viewport:tap:move', onTapMove);
        editor.on('viewport:tap:end', onTapEnd);
    });

    var createMaterial = function(color) {
        var mat = new pc.BasicMaterial();
        mat.color = color;
        if (color.a !== 1) {
            mat.blend = true;
            mat.blendSrc = pc.BLENDMODE_SRC_ALPHA;
            mat.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        }
        mat.update();
        return mat;
    };

    var createEntity = function() {
        var obj = {
            root: null,
            plane: {
                x: null,
                y: null,
                z: null
            },
            line: {
                x: null,
                y: null,
                z: null
            },
            arrow: {
                x: null,
                y: null,
                z: null
            },
            hoverable: [ ],
            matActive: null,
            matActiveTransparent: null
        };

        // active mat
        obj.matActive = createMaterial(new pc.Color(1, 1, 1, 1));
        obj.matActiveTransparent = createMaterial(new pc.Color(1, 1, 1, .25));
        obj.matActiveTransparent.cull = pc.CULLFACE_NONE;

        // root entity
        var entity = obj.root = new pc.Entity();

        // plane x
        var planeX = obj.plane.x = new pc.Entity();
        obj.hoverable.push(planeX);
        planeX.axis = 'x';
        planeX.plane = true;
        planeX.addComponent('model', {
            type: 'plane',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        planeX.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        planeX.model.model.meshInstances[0].mask = 8;
        entity.addChild(planeX);
        planeX.setLocalEulerAngles(90, -90, 0);
        planeX.setLocalScale(.8, .8, .8);
        planeX.setLocalPosition(0, .4, .4);
        planeX.mat = planeX.model.material = createMaterial(new pc.Color(1, 0, 0, .25));
        planeX.mat.cull = pc.CULLFACE_NONE;

        // plane y
        var planeY = obj.plane.y = new pc.Entity();
        obj.hoverable.push(planeY);
        planeY.axis = 'y';
        planeY.plane = true;
        planeY.addComponent('model', {
            type: 'plane',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        planeY.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        planeY.model.model.meshInstances[0].mask = 8;
        entity.addChild(planeY);
        planeY.setLocalEulerAngles(0, 0, 0);
        planeY.setLocalScale(.8, .8, .8);
        planeY.setLocalPosition(-.4, 0, .4);
        planeY.mat = planeY.model.material = createMaterial(new pc.Color(0, 1, 0, .25));
        planeY.mat.cull = pc.CULLFACE_NONE;

        // plane z
        var planeZ = obj.plane.z = new pc.Entity();
        obj.hoverable.push(planeZ);
        planeZ.axis = 'z';
        planeZ.plane = true;
        planeZ.addComponent('model', {
            type: 'plane',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        planeZ.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        planeZ.model.model.meshInstances[0].mask = 8;
        entity.addChild(planeZ);
        planeZ.setLocalEulerAngles(90, 0, 0);
        planeZ.setLocalScale(.8, .8, .8);
        planeZ.setLocalPosition(-.4, .4, 0);
        planeZ.mat = planeZ.model.material = createMaterial(new pc.Color(0, 0, 1, .25));
        planeZ.mat.cull = pc.CULLFACE_NONE;

        // line x
        var lineX = obj.line.x = new pc.Entity();
        obj.hoverable.push(lineX);
        lineX.axis = 'x';
        lineX.addComponent('model', {
            type: 'cylinder',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        lineX.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        lineX.model.model.meshInstances[0].mask = 8;
        entity.addChild(lineX);
        lineX.setLocalEulerAngles(90, 90, 0);
        lineX.setLocalPosition(1.6, 0, 0);
        lineX.setLocalScale(arrowRadius, .8, arrowRadius);
        lineX.mat = lineX.model.material = createMaterial(new pc.Color(1, 0, 0, 0));

        // line y
        var lineY = obj.line.y = new pc.Entity();
        obj.hoverable.push(lineY);
        lineY.axis = 'y';
        lineY.addComponent('model', {
            type: 'cylinder',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        lineY.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        lineY.model.model.meshInstances[0].mask = 8;
        entity.addChild(lineY);
        lineY.setLocalEulerAngles(0, 0, 0);
        lineY.setLocalPosition(0, 1.6, 0);
        lineY.setLocalScale(arrowRadius, .8, arrowRadius);
        lineY.mat = lineY.model.material = createMaterial(new pc.Color(0, 1, 0, 0));

        // line z
        var lineZ = obj.line.z = new pc.Entity();
        obj.hoverable.push(lineZ);
        lineZ.axis = 'z';
        lineZ.addComponent('model', {
            type: 'cylinder',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        lineZ.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        lineZ.model.model.meshInstances[0].mask = 8;
        entity.addChild(lineZ);
        lineZ.setLocalEulerAngles(90, 0, 0);
        lineZ.setLocalPosition(0, 0, 1.6);
        lineZ.setLocalScale(arrowRadius, .8, arrowRadius);
        lineZ.mat = lineZ.model.material = createMaterial(new pc.Color(0, 0, 1, 0));

        // arrow x
        var arrowX = obj.arrow.x = new pc.Entity();
        obj.hoverable.push(arrowX);
        arrowX.axis = 'x';
        arrowX.addComponent('model', {
            type: 'cone',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        arrowX.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        arrowX.model.model.meshInstances[0].mask = 8;
        entity.addChild(arrowX);
        arrowX.setLocalEulerAngles(90, 90, 0);
        arrowX.setLocalPosition(2.3, 0, 0);
        arrowX.setLocalScale(arrowRadius, .6, arrowRadius);
        arrowX.mat = arrowX.model.material = createMaterial(new pc.Color(1, 0, 0, 1));

        // arrow y
        var arrowY = obj.arrow.y = new pc.Entity();
        obj.hoverable.push(arrowY);
        arrowY.axis = 'y';
        arrowY.addComponent('model', {
            type: 'cone',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        arrowY.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        arrowY.model.model.meshInstances[0].mask = 8;
        entity.addChild(arrowY);
        arrowY.setLocalEulerAngles(0, 0, 0);
        arrowY.setLocalPosition(0, 2.3, 0);
        arrowY.setLocalScale(arrowRadius, .6, arrowRadius);
        arrowY.mat = arrowY.model.material = createMaterial(new pc.Color(0, 1, 0, 1));

        // arrow z
        var arrowZ = obj.arrow.z = new pc.Entity();
        obj.hoverable.push(arrowZ);
        arrowZ.axis = 'z';
        arrowZ.addComponent('model', {
            type: 'cone',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        arrowZ.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        arrowZ.model.model.meshInstances[0].mask = 8;
        entity.addChild(arrowZ);
        arrowZ.setLocalEulerAngles(90, 0, 0);
        arrowZ.setLocalPosition(0, 0, 2.3);
        arrowZ.setLocalScale(arrowRadius, .6, arrowRadius);
        arrowZ.mat = arrowZ.model.material = createMaterial(new pc.Color(0, 0, 1, 1));

        return obj;
    };
});


/* editor/gizmo/gizmo-scale.js */
editor.once('load', function() {
    'use strict';

    var gizmo = null;
    var visible = true;
    var moving = false;
    var mouseTap = null;
    var visible = true;
    var enabled = false;
    var hover = false;
    var hoverAxis = '';
    var hoverMiddle = false;
    var hoverEntity = null;
    var gizmoSize = .4;
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var vecC = new pc.Vec3();
    var vecD = new pc.Vec3();
    var vecE = new pc.Vec3();
    var quat = new pc.Quat();
    var evtTapStart;
    var pickStart = new pc.Vec3();

    var snap = false;
    var snapIncrement = 1;
    editor.on('gizmo:snap', function(state, increment) {
        snap = state;
        snapIncrement = increment;
    });

    // enable/disable gizmo
    editor.method('gizmo:scale:toggle', function(state) {
        if (! gizmo)
            return;

        gizmo.root.enabled = state && editor.call('permissions:write');
        enabled = state;

        visible = true;
    });

    editor.on('permissions:writeState', function(state) {
        if (! gizmo)
            return;

        gizmo.root.enabled = enabled && state;
        editor.call('viewport:render');
    });

    // show/hide gizmo
    editor.method('gizmo:scale:visible', function(state) {
        if (! gizmo)
            return;

        visible = state;

        for(var i = 0; i < gizmo.hoverable.length; i++) {
            if (! gizmo.hoverable[i].model)
                continue;

            gizmo.hoverable[i].model.enabled = state;
        }

        editor.call('viewport:render');
    });

    // position gizmo
    editor.method('gizmo:scale:position', function(x, y, z) {
        gizmo.root.setPosition(x, y, z);

        if (gizmo.root.enabled)
            editor.call('viewport:render');
    });

    // rotate gizmo
    editor.method('gizmo:scale:rotation', function(pitch, yaw, roll) {
        gizmo.root.setEulerAngles(pitch, yaw, roll);

        if (gizmo.root.enabled)
            editor.call('viewport:render');
    });

    // initialize gizmo
    editor.once('viewport:load', function() {
        var app = editor.call('viewport:app');
        if (! app) return; // webgl not available

        gizmo = createEntity();
        gizmo.root.enabled = false;
        app.root.addChild(gizmo.root);

        // on picker hover
        editor.on('viewport:pick:hover', function(node, picked) {
            var match = gizmo.hoverable.indexOf(node) !== -1;
            if (! hover && match) {
                // hover
                hover = true;
            } else if (hover && ! match) {
                // unhover
                hover = false;
            }

            if (hover) {
                hoverEntity = node;

                if (node.axis && hoverAxis !== node.axis) {
                    // set normal material
                    if (hoverAxis) {
                        if (hoverMiddle) {
                            gizmo.box['x'].model.material = gizmo.box['x'].mat;
                            gizmo.box['y'].model.material = gizmo.box['y'].mat;
                            gizmo.box['z'].model.material = gizmo.box['z'].mat;
                        } else {
                            gizmo.box[hoverAxis].model.material = gizmo.box[hoverAxis].mat;
                        }
                    }

                    if (! hoverAxis && ! evtTapStart)
                        evtTapStart = editor.on('viewport:tap:start', onTapStart);

                    hoverAxis = node.axis;
                    hoverMiddle = node.middle;

                    // set active material
                    if (hoverMiddle) {
                        gizmo.box['x'].model.material = gizmo.matActive;
                        gizmo.box['y'].model.material = gizmo.matActive;
                        gizmo.box['z'].model.material = gizmo.matActive;
                    } else {
                        gizmo.box[hoverAxis].model.material = gizmo.matActive;
                    }
                }
            } else {
                if (hoverAxis) {
                    if (hoverMiddle) {
                        gizmo.box['x'].model.material = gizmo.box['x'].mat;
                        gizmo.box['y'].model.material = gizmo.box['y'].mat;
                        gizmo.box['z'].model.material = gizmo.box['z'].mat;
                    } else {
                        gizmo.box[hoverAxis].model.material = gizmo.box[hoverAxis].mat;
                    }
                }

                hoverAxis = '';

                if (evtTapStart) {
                    evtTapStart.unbind();
                    evtTapStart = null;
                }
            }
        });

        // update gizmo
        editor.on('viewport:postUpdate', function(dt) {
            if (gizmo.root.enabled) {
                editor.emit('gizmo:scale:render', dt);

                if (moving) {
                    var point = pickPlane(mouseTap.x, mouseTap.y);
                    if (point) {
                        point.sub(pickStart);
                        if (snap) {
                            point.scale(1 / snapIncrement);
                            point.x = Math.round(point.x);
                            point.y = Math.round(point.y);
                            point.z = Math.round(point.z);
                            point.scale(snapIncrement);
                        }
                        editor.emit('gizmo:scale:offset', point.x, point.y, point.z);
                    }

                    editor.call('viewport:render');
                }

                var camera = editor.call('camera:current');

                var posCamera = camera.getPosition();
                var posGizmo = gizmo.root.getPosition();
                var scale = 1;

                // scale to screen space
                if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
                    var dot = vecA.copy(posGizmo).sub(posCamera).dot(camera.forward);
                    var denom = 1280 / (2 * Math.tan(camera.camera.fov * pc.math.DEG_TO_RAD / 2));
                    scale = Math.max(0.0001, (dot / denom) * 150) * gizmoSize;
                } else {
                    scale = camera.camera.orthoHeight / 3 * gizmoSize;
                }
                gizmo.root.setLocalScale(scale, scale, scale);

                // calculate viewing angle
                vecA
                    .copy(posCamera)
                    .sub(posGizmo)
                    .normalize();

                // rotate vector by gizmo rotation
                quat
                    .copy(gizmo.root.getRotation())
                    .invert()
                    .transformVector(vecA, vecA);

                quat.invert();

                // hide lines and boxes if viewed from very angle
                gizmo.line.x.model.enabled = gizmo.box.x.model.enabled = ! (Math.abs(vecA.z) <= 0.15 && Math.abs(vecA.y) <= 0.15) && visible;
                gizmo.line.y.model.enabled = gizmo.box.y.model.enabled = ! (Math.abs(vecA.x) <= 0.15 && Math.abs(vecA.z) <= 0.15) && visible;
                gizmo.line.z.model.enabled = gizmo.box.z.model.enabled = ! (Math.abs(vecA.x) <= 0.15 && Math.abs(vecA.y) <= 0.15) && visible;

                // draw axes lines
                // line x
                if (gizmo.line.x.model.enabled) {
                    vecB.set(scale * .5, 0, 0);
                    quat.transformVector(vecB, vecB).add(posGizmo);
                    vecC.set(scale * 2, 0, 0);
                    quat.transformVector(vecC, vecC).add(posGizmo);
                    app.renderLine(vecB, vecC, gizmo.box.x.model.material === gizmo.matActive ? gizmo.matActive.color : gizmo.box.x.color, pc.LINEBATCH_GIZMO);
                }
                // line y
                if (gizmo.line.y.model.enabled) {
                    vecB.set(0, scale * .5, 0);
                    quat.transformVector(vecB, vecB).add(posGizmo);
                    vecC.set(0, scale * 2, 0);
                    quat.transformVector(vecC, vecC).add(posGizmo);
                    app.renderLine(vecB, vecC, gizmo.box.y.model.material === gizmo.matActive ? gizmo.matActive.color : gizmo.box.y.color, pc.LINEBATCH_GIZMO);
                }
                // line z
                if (gizmo.line.z.model.enabled) {
                    vecB.set(0, 0, scale * .5);
                    quat.transformVector(vecB, vecB).add(posGizmo);
                    vecC.set(0, 0, scale * 2);
                    quat.transformVector(vecC, vecC).add(posGizmo);
                    app.renderLine(vecB, vecC, gizmo.box.z.model.material === gizmo.matActive ? gizmo.matActive.color : gizmo.box.z.color, pc.LINEBATCH_GIZMO);
                }
            }
        });

        var pickPlane = function(x, y) {
            var camera = editor.call('camera:current');
            var scale = 1;
            var mouseWPos = camera.camera.screenToWorld(x, y, 1);
            var posGizmo = gizmo.root.getPosition();
            var rayOrigin = vecA.copy(camera.getPosition());
            var rayDirection = vecB;
            var planeNormal = vecC;

            if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
                rayDirection.copy(mouseWPos).sub(rayOrigin).normalize();
                var dot = vecC.copy(posGizmo).sub(rayOrigin).dot(camera.forward);
                var denom = 1280 * Math.tan(camera.camera.fov * pc.math.DEG_TO_RAD);
                scale = Math.max(0.0001, (dot / denom) * 150) * gizmoSize;
            } else {
                rayOrigin.add(mouseWPos);
                camera.getWorldTransform().transformVector(vecD.set(0, 0, -1), rayDirection);
                scale = camera.camera.orthoHeight / 3 * gizmoSize;
            }

            quat.copy(gizmo.root.getRotation());

            // single axis
            if (! hoverMiddle) {
                // vector based on selected axis
                planeNormal.set(0, 0, 0);
                planeNormal[hoverAxis] = 1;
                // rotate vector by gizmo rotation
                quat.transformVector(planeNormal, planeNormal);

                vecE.copy(rayOrigin).sub(posGizmo).normalize();
                planeNormal.copy(vecE.sub(planeNormal.scale(planeNormal.dot(vecE))).normalize());
            } else {
                planeNormal.copy(rayOrigin).sub(posGizmo).normalize();
            }

            var rayPlaneDot = planeNormal.dot(rayDirection);
            var planeDist = posGizmo.dot(planeNormal);
            var pointPlaneDist = (planeNormal.dot(rayOrigin) - planeDist) / rayPlaneDot;
            var pickedPos = rayDirection.scale(-pointPlaneDist).add(rayOrigin);

            if (! hoverMiddle) {
                // single axis
                planeNormal.set(0, 0, 0);
                planeNormal[hoverAxis] = 1;
                quat.transformVector(planeNormal, planeNormal);
                pickedPos.copy(planeNormal.scale(planeNormal.dot(pickedPos)));
                quat.invert().transformVector(pickedPos, pickedPos);

                // calculate viewing angle
                vecE.copy(rayOrigin).sub(posGizmo).normalize();
                quat.transformVector(vecE, vecE);

                var v = pickedPos[hoverAxis];
                pickedPos.set(0, 0, 0);
                pickedPos[hoverAxis] = v / scale;
            } else {
                vecE.copy(pickedPos).sub(posGizmo).normalize();
                vecD.copy(camera.up).add(camera.right).normalize();

                var v = (pickedPos.sub(posGizmo).length() / scale / 2)  * vecE.dot(vecD);
                pickedPos.set(v, v, v);
            }

            return pickedPos;
        };

        var onTapStart = function(tap) {
            if (tap.button !== 0)
                return;

            editor.emit('camera:toggle', false);

            moving = true;
            mouseTap = tap;

            if (gizmo.root.enabled) {
                pickStart.copy(pickPlane(tap.x, tap.y));
                pickStart.x -= 1;
                pickStart.y -= 1;
                pickStart.z -= 1;
            }

            editor.emit('gizmo:scale:start', hoverAxis, hoverMiddle);
            editor.call('gizmo:scale:visible', false);
            editor.call('viewport:pick:state', false);
        };

        var onTapMove = function(tap) {
            if (! moving)
                return;

            mouseTap = tap;
        };

        var onTapEnd = function(tap) {
            if (tap.button !== 0)
                return;

            editor.emit('camera:toggle', true);

            if (! moving)
                return;

            moving = false;
            mouseTap = tap;

            editor.emit('gizmo:scale:end');
            editor.call('gizmo:scale:visible', true);
            editor.call('viewport:pick:state', true);
        };

        editor.on('viewport:mouse:move', onTapMove);
        editor.on('viewport:tap:end', onTapEnd);
    });

    var createMaterial = function(color) {
        var mat = new pc.BasicMaterial();
        mat.color = color;
        if (color.a !== 1) {
            mat.blend = true;
            mat.blendSrc = pc.BLENDMODE_SRC_ALPHA;
            mat.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        }
        mat.cull = pc.CULLFACE_NONE;
        mat.update();
        return mat;
    };

    var createEntity = function() {
        var boxSize = .4;

        var obj = {
            root: null,
            middle: null,
            line: {
                x: null,
                y: null,
                z: null
            },
            box: {
                x: null,
                y: null,
                z: null
            },
            hoverable: [ ],
            matActive: null,
            matActiveTransparent: null
        };

        // active mat
        obj.matActive = createMaterial(new pc.Color(1, 1, 1, 1));
        obj.matActiveTransparent = createMaterial(new pc.Color(1, 1, 1, .25));
        obj.colorLineBehind = new pc.Color(1, 1, 1, 0.05);
        obj.colorLine = new pc.Color(1, 1, 1, .2);
        obj.colorLineActive = new pc.Color(1, 1, 1, 1);

        // root entity
        var entity = obj.root = new pc.Entity();

        // middle
        var middle = obj.middle = new pc.Entity();
        obj.hoverable.push(middle);
        middle.axis = 'xyz';
        middle.middle = true;
        middle.addComponent('model', {
            type: 'box',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        middle.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        middle.model.model.meshInstances[0].mask = 8;
        middle.model.material.id = 0xFFFFFFFF;
        entity.addChild(middle);
        middle.setLocalScale(boxSize * 1.5, boxSize * 1.5, boxSize * 1.5);
        middle.mat = middle.model.material = createMaterial(new pc.Color(1, 1, 1, 0.2));
        middle.mat.depthTest = false;

        // line x
        var lineX = obj.line.x = new pc.Entity();
        obj.hoverable.push(lineX);
        lineX.axis = 'x';
        lineX.addComponent('model', {
            type: 'cylinder',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        lineX.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        lineX.model.model.meshInstances[0].mask = 8;
        entity.addChild(lineX);
        lineX.setLocalEulerAngles(90, 90, 0);
        lineX.setLocalPosition(1.25, 0, 0);
        lineX.setLocalScale(boxSize, 1.5, boxSize);
        lineX.mat = lineX.model.material = createMaterial(new pc.Color(1, 0, 0, 0));

        // line y
        var lineY = obj.line.y = new pc.Entity();
        obj.hoverable.push(lineY);
        lineY.axis = 'y';
        lineY.addComponent('model', {
            type: 'cylinder',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        lineY.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        lineY.model.model.meshInstances[0].mask = 8;
        entity.addChild(lineY);
        lineY.setLocalEulerAngles(0, 0, 0);
        lineY.setLocalPosition(0, 1.25, 0);
        lineY.setLocalScale(boxSize, 1.5, boxSize);
        lineY.mat = lineY.model.material = createMaterial(new pc.Color(0, 1, 0, 0));

        // line z
        var lineZ = obj.line.z = new pc.Entity();
        obj.hoverable.push(lineZ);
        lineZ.axis = 'z';
        lineZ.addComponent('model', {
            type: 'cylinder',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        lineZ.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        lineZ.model.model.meshInstances[0].mask = 8;
        entity.addChild(lineZ);
        lineZ.setLocalEulerAngles(90, 0, 0);
        lineZ.setLocalPosition(0, 0, 1.25);
        lineZ.setLocalScale(boxSize, 1.5, boxSize);
        lineZ.mat = lineZ.model.material = createMaterial(new pc.Color(0, 0, 1, 0));

        // box x
        var boxX = obj.box.x = new pc.Entity();
        obj.hoverable.push(boxX);
        boxX.axis = 'x';
        boxX.addComponent('model', {
            type: 'box',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        boxX.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        boxX.model.model.meshInstances[0].mask = 8;
        entity.addChild(boxX);
        boxX.setLocalPosition(2.2, 0, 0);
        boxX.setLocalScale(boxSize, boxSize, boxSize);
        boxX.mat = boxX.model.material = createMaterial(new pc.Color(1, 0, 0, 1.1));
        boxX.color = new pc.Color(1, 0, 0, 1);

        // box y
        var boxY = obj.box.y = new pc.Entity();
        obj.hoverable.push(boxY);
        boxY.axis = 'y';
        boxY.addComponent('model', {
            type: 'box',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        boxY.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        boxY.model.model.meshInstances[0].mask = 8;
        entity.addChild(boxY);
        boxY.setLocalPosition(0, 2.2, 0);
        boxY.setLocalScale(boxSize, boxSize, boxSize);
        boxY.mat = boxY.model.material = createMaterial(new pc.Color(0, 1, 0, 1.1));
        boxY.color = new pc.Color(0, 1, 0, 1);

        // box z
        var boxZ = obj.box.z = new pc.Entity();
        obj.hoverable.push(boxZ);
        boxZ.axis = 'z';
        boxZ.addComponent('model', {
            type: 'box',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        boxZ.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        boxZ.model.model.meshInstances[0].mask = 8;
        entity.addChild(boxZ);
        boxZ.setLocalPosition(0, 0, 2.2);
        boxZ.setLocalScale(boxSize, boxSize, boxSize);
        boxZ.mat = boxZ.model.material = createMaterial(new pc.Color(0, 0, 1, 1.1));
        boxZ.color = new pc.Color(0, 0, 1, 1);

        return obj;
    };
});


/* editor/gizmo/gizmo-rotate.js */
editor.once('load', function() {
    'use strict';

    var gizmo = null;
    var visible = true;
    var moving = false;
    var mouseTap = null;
    var mouseTapMoved = false;
    var posCameraLast = new pc.Vec3();
    var visible = true;
    var enabled = false;
    var hover = false;
    var hoverAxis = '';
    var hoverEntity = null;
    var gizmoSize = .4;
    var arrowRadius = .4;
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var vecC = new pc.Vec3();
    var vecD = new pc.Vec3();
    var quat = new pc.Quat();
    var evtTapStart;
    var angleStart = 0;
    var startRotation = new pc.Quat();

    var snap = false;
    var snapIncrement = 5;
    editor.on('gizmo:snap', function(state, increment) {
        snap = state;
        snapIncrement = increment * 5;
    });

    // enable/disable gizmo
    editor.method('gizmo:rotate:toggle', function(state) {
        if (! gizmo)
            return;

        gizmo.root.enabled = state && editor.call('permissions:write');
        enabled = state;

        visible = true;

        editor.call('viewport:render');
    });

    editor.on('permissions:writeState', function(state) {
        if (! gizmo)
            return;

        gizmo.root.enabled = enabled && state;
        editor.call('viewport:render');
    });

    // show/hide gizmo
    editor.method('gizmo:rotate:visible', function(state) {
        if (! gizmo)
            return;

        visible = state;

        for(var i = 0; i < gizmo.hoverable.length; i++) {
            if (! gizmo.hoverable[i].model)
                continue;

            gizmo.hoverable[i].model.enabled = state;
        }

        editor.call('viewport:render');
    });

    // position gizmo
    editor.method('gizmo:rotate:position', function(x, y, z) {
        if (x === undefined)
            return gizmo.root.getPosition();

        gizmo.root.setPosition(x, y, z);

        if (gizmo.root.enabled)
            editor.call('viewport:render');
    });

    // rotate gizmo
    editor.method('gizmo:rotate:rotation', function(pitch, yaw, roll) {
        gizmo.root.setEulerAngles(pitch, yaw, roll);

        if (gizmo.root.enabled)
            editor.call('viewport:render');
    });

    // initialize gizmo
    editor.once('viewport:load', function() {
        var app = editor.call('viewport:app');
        if (! app) return; // webgl not available

        gizmo = createEntity(app);
        gizmo.root.enabled = false;
        app.root.addChild(gizmo.root);

        // on picker hover
        editor.on('viewport:pick:hover', function(node, picked) {
            var match = gizmo.hoverable.indexOf(node) !== -1;
            if (! hover && match) {
                // hover
                hover = true;
            } else if (hover && ! match) {
                // unhover
                hover = false;
            }

            if (hover) {
                hoverEntity = node;

                if (node.axis && hoverAxis !== node.axis) {
                    // set normal material
                    if (hoverAxis)
                        gizmo.line[hoverAxis].material = gizmo.line[hoverAxis].mat;

                    if (! hoverAxis && ! evtTapStart)
                        evtTapStart = editor.on('viewport:tap:start', onTapStart);

                    hoverAxis = node.axis;

                    // set active material
                    gizmo.line[hoverAxis].material = gizmo.matActive;
                }
            } else {
                if (hoverAxis) {
                    gizmo.line[hoverAxis].material = gizmo.line[hoverAxis].mat;
                }

                hoverAxis = '';

                if (evtTapStart) {
                    evtTapStart.unbind();
                    evtTapStart = null;
                }
            }
        });

        var lastPoint = new pc.Vec3();

        // update gizmo
        editor.on('viewport:postUpdate', function(dt) {
            if (gizmo.root.enabled) {
                var camera = editor.call('camera:current');
                var posCamera = camera.getPosition();

                if (moving && (vecA.copy(posCameraLast).sub(posCamera).length() > 0.01 || mouseTapMoved)) {
                    var data = pickPlane(mouseTap.x, mouseTap.y);
                    lastPoint.copy(data.point);

                    if (snap) {
                        data.angle = Math.round((data.angle - angleStart) / snapIncrement) * snapIncrement;
                    } else {
                        data.angle -= angleStart;
                    }

                    editor.emit('gizmo:rotate:offset', data.angle, data.point);

                    editor.call('viewport:render');
                }

                var posGizmo = gizmo.root.getPosition();
                var scale = 1;

                // scale to screen space
                if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
                    var dot = vecA.copy(posGizmo).sub(posCamera).dot(camera.forward);
                    var denom = 1280 / (2 * Math.tan(camera.camera.fov * pc.math.DEG_TO_RAD / 2));
                    scale = Math.max(0.0001, (dot / denom) * 150) * gizmoSize;
                } else {
                    scale = camera.camera.orthoHeight / 3 * gizmoSize;
                }
                gizmo.root.setLocalScale(scale, scale, scale);

                if (moving && lastPoint) {
                    vecC.copy(lastPoint).normalize().scale(2 * scale);
                    quat.copy(startRotation).transformVector(vecC, vecC);
                    // quat.invert().transformVector(vecC, vecC);
                    vecC.add(posGizmo);

                    app.renderLine(posGizmo, vecC, gizmo.colorActive, pc.LINEBATCH_GIZMO);
                }

                editor.emit('gizmo:rotate:render', dt);

                posCameraLast.copy(posCamera);

                // posGizmo = gizmo.root.getPosition();

                // calculate viewing angle
                vecA
                    .copy(posCamera)
                    .sub(posGizmo)
                    .normalize();

                // rotate vector by gizmo rotation
                quat
                    .copy(gizmo.root.getRotation())
                    .invert()
                    .transformVector(vecA, vecA);

                // hide plane if viewed from very angle
                gizmo.plane.x.model.enabled = Math.abs(vecA.x) > 0.1 && visible;
                gizmo.plane.y.model.enabled = Math.abs(vecA.y) > 0.1 && visible;
                gizmo.plane.z.model.enabled = Math.abs(vecA.z) > 0.1 && visible;

                var worldTransform = gizmo.root.getWorldTransform();

                // render lines
                // x
                if (moving && hoverAxis === 'x') {
                    // behind line
                    app.renderMesh(gizmo.line.x.mesh, gizmo.matBehindActive, worldTransform);
                } else {
                    // behind line
                    app.renderMesh(gizmo.line.x.mesh, gizmo.matBehindHover.x, worldTransform);
                    // front line
                    if (! moving && gizmo.plane.x.model.enabled) {
                        gizmo.line.x.node.worldTransform = worldTransform;
                        app.renderMeshInstance(gizmo.line.x);
                    }
                }

                // y
                if (moving && hoverAxis === 'y') {
                    // behind line
                    app.renderMesh(gizmo.line.y.mesh, gizmo.matBehindActive, worldTransform);
                } else {
                    // behind line
                    app.renderMesh(gizmo.line.y.mesh, gizmo.matBehindHover.y, worldTransform);
                    // front line
                    if (! moving && gizmo.plane.y.model.enabled) {
                        gizmo.line.y.node.worldTransform = worldTransform;
                        app.renderMeshInstance(gizmo.line.y);
                    }
                }
                // z
                if (moving && hoverAxis === 'z') {
                    // behind line
                    app.renderMesh(gizmo.line.z.mesh, gizmo.matBehindActive, worldTransform);
                } else {
                    // behind line
                    app.renderMesh(gizmo.line.z.mesh, gizmo.matBehindHover.z, worldTransform);
                    // front line
                    if (! moving && gizmo.plane.z.model.enabled) {
                        gizmo.line.z.node.worldTransform = worldTransform;
                        app.renderMeshInstance(gizmo.line.z);
                    }
                }

                // cull
                gizmo.line.cull.node.worldTransform = worldTransform;
                app.renderMeshInstance(gizmo.line.cull);
            }

            mouseTapMoved = false
        });

        var pickPlane = function(x, y) {
            var camera = editor.call('camera:current');

            var mouseWPos = camera.camera.screenToWorld(x, y, 1);
            var posGizmo = gizmo.root.getPosition();
            var rayOrigin = vecA.copy(camera.getPosition());
            var rayDirection = vecB;
            var planeNormal = vecC.set(0, 0, 0);
            planeNormal[hoverAxis] = 1;

            // rotate plane to local space
            quat.copy(startRotation).transformVector(planeNormal, planeNormal);

            // ray from camera
            if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
                rayDirection.copy(mouseWPos).sub(rayOrigin).normalize();
            } else {
                rayOrigin.copy(mouseWPos);
                camera.getWorldTransform().transformVector(vecD.set(0, 0, -1), rayDirection);
            }

            // pick the plane
            var rayPlaneDot = planeNormal.dot(rayDirection);
            var planeDist = posGizmo.dot(planeNormal);
            var pointPlaneDist = (planeNormal.dot(rayOrigin) - planeDist) / rayPlaneDot;
            var pickedPos = rayDirection.scale(-pointPlaneDist).add(rayOrigin).sub(posGizmo);

            // rotate vector to world space
            quat.invert().transformVector(pickedPos, pickedPos);

            var angle = 0;
            if (hoverAxis === 'x') {
                angle = Math.atan2(pickedPos.z, pickedPos.y) / (Math.PI / 180);
            } else if (hoverAxis === 'y') {
                angle = Math.atan2(pickedPos.x, pickedPos.z) / (Math.PI / 180);
            } else if (hoverAxis === 'z') {
                angle = Math.atan2(pickedPos.y, pickedPos.x) / (Math.PI / 180);
            }

            return {
                angle: angle,
                point: pickedPos
            };
        };

        var onTapStart = function(tap) {
            if (moving || tap.button !== 0)
                return;

            editor.emit('camera:toggle', false);

            moving = true;
            mouseTap = tap;
            mouseTapMoved = true;

            if (gizmo.root.enabled) {
                startRotation.copy(gizmo.root.getRotation());
                var data = pickPlane(tap.x, tap.y);
                angleStart = data.angle;
            }

            editor.emit('gizmo:rotate:start', hoverAxis);
            editor.call('viewport:pick:state', false);
        };

        var onTapMove = function(tap) {
            if (! moving)
                return;

            mouseTap = tap;
            mouseTapMoved = true;
        };

        var onTapEnd = function(tap) {
            if (tap.button !== 0)
                return;

            editor.emit('camera:toggle', true);

            if (! moving)
                return;

            moving = false;
            mouseTap = tap;

            editor.emit('gizmo:rotate:end');
            editor.call('viewport:pick:state', true);
        };

        editor.on('viewport:mouse:move', onTapMove);
        editor.on('viewport:tap:end', onTapEnd);
    });

    var createMaterial = function(color) {
        var mat = new pc.BasicMaterial();
        mat.color = color;
        if (color.a !== 1) {
            mat.blend = true;
            mat.blendSrc = pc.BLENDMODE_SRC_ALPHA;
            mat.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        }
        mat.update();
        return mat;
    };

    var createEntity = function(app) {
        var obj = {
            root: null,
            sphere: null,
            plane: {
                x: null,
                y: null,
                z: null
            },
            line: {
                x: null,
                y: null,
                z: null,
                cull: null
            },
            hoverable: [ ],
            matActive: null,
            matBehind: null,
            matBehindHover: { },
            matBehindActive: null
        };

        // materials
        obj.matBehind = createMaterial(new pc.Color(1, 1, 1, .1));
        obj.matBehind.depthTest = false;
        obj.matBehindHover.x = createMaterial(new pc.Color(1, 0, 0, .2));
        obj.matBehindHover.y = createMaterial(new pc.Color(0, 1, 0, .2));
        obj.matBehindHover.z = createMaterial(new pc.Color(0, 0, 1, .2));
        obj.matBehindHover.x.depthTest = false;
        obj.matBehindHover.y.depthTest = false;
        obj.matBehindHover.z.depthTest = false;
        obj.matBehindActive = createMaterial(new pc.Color(1, 1, 1, 1.1));
        obj.matBehindActive.depthTest = false;
        obj.colorActive = new pc.Color(1, 1, 1, 1);

        // root entity
        var entity = obj.root = new pc.Entity();

        // plane x
        var planeX = obj.plane.x = new pc.Entity();
        obj.hoverable.push(planeX);
        planeX.axis = 'x';
        planeX.plane = true;
        planeX.addComponent('model', {
            type: 'cylinder',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        planeX.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(planeX);
        planeX.setLocalEulerAngles(90, -90, 0);
        planeX.setLocalScale(4.1, 0.3, 4.1);
        planeX.mat = planeX.model.material = createMaterial(new pc.Color(1, 0, 0, 0));

        // plane y
        var planeY = obj.plane.y = new pc.Entity();
        obj.hoverable.push(planeY);
        planeY.axis = 'y';
        planeY.plane = true;
        planeY.addComponent('model', {
            type: 'cylinder',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        planeY.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(planeY);
        planeY.setLocalEulerAngles(0, 0, 0);
        planeY.setLocalScale(4.2, 0.3, 4.2);
        planeY.mat = planeY.model.material = createMaterial(new pc.Color(0, 1, 0, 0));

        // plane z
        var planeZ = obj.plane.z = new pc.Entity();
        obj.hoverable.push(planeZ);
        planeZ.axis = 'z';
        planeZ.plane = true;
        planeZ.addComponent('model', {
            type: 'cylinder',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        planeZ.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(planeZ);
        planeZ.setLocalEulerAngles(90, 0, 0);
        planeZ.setLocalScale(4, 0.3, 4);
        planeZ.mat = planeZ.model.material = createMaterial(new pc.Color(0, 0, 1, 0));

        // sphere
        var sphere = obj.sphere = new pc.Entity();
        sphere.addComponent('model', {
            type: 'sphere',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        sphere.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(sphere);
        sphere.setLocalScale(3, 3, 3);
        sphere.mat = sphere.model.material = createMaterial(new pc.Color(1, 1, 1, 0));

        obj.matActive = createMaterial(new pc.Color(1, 1, 1, 1.1));

        var lines = createLinesModel(app);
        obj.line.x = lines[0];
        obj.line.y = lines[1];
        obj.line.z = lines[2];
        obj.line.cull = lines[3];

        return obj;
    };

    var createMeshInstance = function (node, mesh, material) {
        var result = new pc.MeshInstance(node, mesh, material);
        result.layer = pc.LAYER_GIZMO;
        result.updateKey();
        return result;
    };

    var createLinesModel = function(app) {
        // Create the rotate gizmo geometry
        var device = app.graphicsDevice;
        var axisSegments = 50;
        var numVerts = (axisSegments + 1);
        var angle = 0.0;
        var iterator;
        var sinAngle, cosAngle;
        var scale = 2;

        var vertexFormat = new pc.gfx.VertexFormat(app.graphicsDevice, [
            { semantic: pc.gfx.SEMANTIC_POSITION, components: 3, type: pc.gfx.ELEMENTTYPE_FLOAT32 }
        ]);

        var vertexBuffers = [];
        for (var axis = 0; axis < 3; axis++) {
            // Create a vertex buffer
            vertexBuffers.push(new pc.gfx.VertexBuffer(device, vertexFormat, numVerts));

            // Fill the vertex buffer
            iterator = new pc.gfx.VertexIterator(vertexBuffers[axis]);
            for (var seg = 0; seg <= axisSegments; seg++) {
                angle = 2 * Math.PI * (seg / axisSegments);
                sinAngle = Math.sin(angle);
                cosAngle = Math.cos(angle);
                if (axis === 0) {
                    iterator.element[pc.SEMANTIC_POSITION].set(0, sinAngle * scale, cosAngle * scale);
                } else if (axis === 1) {
                    iterator.element[pc.SEMANTIC_POSITION].set(sinAngle * scale, 0, cosAngle * scale);
                } else if (axis === 2) {
                    iterator.element[pc.SEMANTIC_POSITION].set(sinAngle * scale, cosAngle * scale, 0);
                }
                iterator.next();
            }
            iterator.end();
        }

        var node = new pc.GraphNode();
        var mesh, meshInstance;

        var meshInstances = [ ];
        var materials = [
            createMaterial(new pc.Color(1, 0, 0, 1.1)),
            createMaterial(new pc.Color(0, 1, 0, 1.1)),
            createMaterial(new pc.Color(0, 0, 1, 1.1))
        ];

        for (var i = 0; i < 3; i++) {
            mesh = new pc.Mesh();
            mesh.vertexBuffer = vertexBuffers[i];
            mesh.indexBuffer[0] = null;
            mesh.primitive[0].type = pc.PRIMITIVE_LINESTRIP;
            mesh.primitive[0].base = 0;
            mesh.primitive[0].count = vertexBuffers[i].getNumVertices();
            mesh.primitive[0].indexed = false;

            meshInstance = createMeshInstance(node, mesh, materials[i]);
            meshInstance.mat = materials[i];
            meshInstances.push(meshInstance);
        }

        mesh = pc.createSphere(device, {
            segments: 75,
            radius: 1.95
        });
        var material = createMaterial(new pc.Color(1, 1, 1, 0));
        material.update();
        meshInstance = createMeshInstance(node, mesh, material);
        meshInstances.push(meshInstance);

        return meshInstances;
    };
});


/* editor/gizmo/gizmo-camera.js */
editor.once('load', function () {
    'use strict';

    var app;
    // selected entity gizmos
    var entities = { };
    // pool of gizmos
    var pool = [ ];
    // colors
    var colorBehind = new pc.Color(1, 1, 1, .15);
    var colorPrimary = new pc.Color(1, 1, 1);

    // gizmo class
    function Gizmo() {
        this._link = null;
        this.lines = [ ];
        this.events = [ ];
        this.visible = false;

        for(var i = 0; i < 24; i++)
            this.lines.push(new pc.Vec3());
    }
    // update lines
    Gizmo.prototype.update = function() {
        if (! app) return; // webgl not available

        if (! this._link || ! this._link.entity || editor.call('camera:current') === this._link.entity) {
            this.visible = false;
            return;
        }

        var camera = this._link.entity.camera;

        this.visible = this._link.entity.enabled && camera && camera.enabled && editor.call('camera:current') !== this._link.entity;
        if (! this.visible)
            return;

        var nearClip = camera.nearClip || 0.0001;
        var farClip = camera.farClip;
        var fov = camera.fov * Math.PI / 180.0;
        var projection = camera.projection;

        var device = app.graphicsDevice;
        var rect = camera.rect;
        var aspectRatio = (device.width * rect.z) / (device.height * rect.w);

        var nx, ny, fx, fy;
        if (projection === pc.PROJECTION_PERSPECTIVE) {
            ny = Math.tan(fov / 2.0) * nearClip;
            fy = Math.tan(fov / 2.0) * farClip;
            nx = ny * aspectRatio;
            fx = fy * aspectRatio;
        } else {
            ny = camera.camera._orthoHeight;
            fy = ny;
            nx = ny * aspectRatio;
            fx = nx;
        }

        // near plane
        this.lines[0].set(nx, -ny, -nearClip);
        this.lines[1].set(nx, ny, -nearClip);
        this.lines[2].set(nx, ny, -nearClip);
        this.lines[3].set(-nx, ny, -nearClip);
        this.lines[4].set(-nx, ny, -nearClip);
        this.lines[5].set(-nx, -ny, -nearClip);
        this.lines[6].set(-nx, -ny, -nearClip);
        this.lines[7].set(nx, -ny, -nearClip);
        // far plane
        this.lines[8].set(fx, -fy, -farClip);
        this.lines[9].set(fx, fy, -farClip);
        this.lines[10].set(fx, fy, -farClip);
        this.lines[11].set(-fx, fy, -farClip);
        this.lines[12].set(-fx, fy, -farClip);
        this.lines[13].set(-fx, -fy, -farClip);
        this.lines[14].set(-fx, -fy, -farClip);
        this.lines[15].set(fx, -fy, -farClip);
        // parallel lines
        this.lines[16].set(nx, -ny, -nearClip);
        this.lines[17].set(fx, -fy, -farClip);
        this.lines[18].set(nx, ny, -nearClip);
        this.lines[19].set(fx, fy, -farClip);
        this.lines[20].set(-nx, ny, -nearClip);
        this.lines[21].set(-fx, fy, -farClip);
        this.lines[22].set(-nx, -ny, -nearClip);
        this.lines[23].set(-fx, -fy, -farClip);

        // transform lines according to camera transform
        var wtm = new pc.Mat4().setTRS(this._link.entity.getPosition(), this._link.entity.getRotation(), pc.Vec3.ONE);
        for(var i = 0; i < this.lines.length; i++)
            wtm.transformPoint(this.lines[i], this.lines[i]);

        this.visible = true;
    };
    // render lines
    Gizmo.prototype.render = function() {
        if (! app) return; // webgl not available

        if (! this.visible)
            return;

        app.renderLines(this.lines, colorBehind, pc.LINEBATCH_GIZMO);
        app.renderLines(this.lines, colorPrimary, pc.LINEBATCH_WORLD);
    };
    // link to entity
    Gizmo.prototype.link = function(obj) {
        this.unlink();
        this._link = obj;

        var self = this;

        this.events.push(this._link.once('destroy', function() {
            self.unlink();
        }));
    };
    // unlink
    Gizmo.prototype.unlink = function() {
        if (! this._link)
            return;

        for(var i = 0; i < this.events.length; i++)
            this.events[i].unbind();

        this.events = [ ];
        this._link = null;
        this.visible = false;
    };

    editor.on('selector:change', function(type, items) {
        // clear gizmos
        if (type !== 'entity') {
            for(var key in entities) {
                entities[key].unlink();
                pool.push(entities[key]);
            }
            entities = { };
            return;
        }

        // index selection
        var ids = { };
        for(var i = 0; i < items.length; i++)
            ids[items[i].get('resource_id')] = items[i];

        var render = false;

        // remove
        for(var key in entities) {
            if (ids[key])
                continue;

            pool.push(entities[key]);
            entities[key].unlink();
            delete entities[key];
            render = true;
        }

        // add
        for(var key in ids) {
            if (entities[key])
                continue;

            var gizmo = pool.shift();
            if (! gizmo)
                gizmo = new Gizmo();

            gizmo.link(ids[key]);
            entities[key] = gizmo;
            render = true;
        }

        if (render)
            editor.call('viewport:render');
    });

    editor.once('viewport:load', function() {
        app = editor.call('viewport:app');
    });

    editor.on('viewport:gizmoUpdate', function(dt) {
        for(var key in entities) {
            entities[key].update();
            entities[key].render();
        }
    });
});


/* editor/gizmo/gizmo-light.js */
editor.once('load', function () {
    'use strict';

    var app;
    // selected entity gizmos
    var entities = { };
    // pool of gizmos
    var pool = [ ];
    // colors
    var colorBehind = new pc.Color(1, 1, 1, .15);
    var colorPrimary = new pc.Color(1, 1, 1);
    var container;
    var vec = new pc.Vec3();
    var materialBehind = new pc.BasicMaterial();
    materialBehind.color = colorBehind;
    materialBehind.blend = true;
    materialBehind.blendSrc = pc.BLENDMODE_SRC_ALPHA;
    materialBehind.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
    materialBehind.depthTest = false;
    materialBehind.update();
    var materialSpot, materialSpotBehind;
    var models = { };
    var poolModels = { 'directional': [ ], 'point': [ ], 'point-close': [ ], 'spot': [ ] };

    // gizmo class
    function Gizmo() {
        this._link = null;
        this.lines = [ ];
        this.events = [ ];
        this.type = '';
        this.entity = null;
    }
    // update lines
    Gizmo.prototype.update = function() {
        if (! app) return; // webgl not available

        if (! this._link || ! this._link.entity)
            return;

        var light = this._link.entity.light;
        this.entity.enabled = this._link.entity.enabled && light && light.enabled;
        if (! this.entity.enabled)
            return;

        this.entity.setPosition(this._link.entity.getPosition());

        var type = light.type;

        // close point light, switch to triple circle
        if (type === 'point' && vec.copy(this.entity.getPosition()).sub(editor.call('camera:current').getPosition()).length() < light.range)
            type += '-close';

        if (this.type !== type) {
            this.type = type;

            // set new model based on type
            if (models[this.type]) {
                // get current model
                var model = this.entity.model.model;
                if (model) {
                    // put back in pool
                    app.scene.removeModel(model);
                    this.entity.removeChild(model.getGraph());
                    poolModels[model._type].push(model);
                }
                // get from pool
                model = poolModels[this.type].shift();
                if (! model) {
                    // no in pool
                    model = models[this.type].clone();
                    model._type = this.type;
                }
                // set to model
                this.entity.model.model = model;
                model.meshInstances[0].mask = 8;
                this.entity.setLocalScale(1, 1, 1);
                this.entity.setEulerAngles(0, 0, 0);
            } else {
                this.entity.model.model = null;
                this.entity.enabled = false;
                return;
            }
        }

        var material = materialBehind;

        switch(this.type) {
            case 'directional':
                this.entity.setRotation(this._link.entity.getRotation());
                break;
            case 'point':
                this.entity.setLocalScale(light.range, light.range, light.range);
                this.entity.lookAt(editor.call('camera:current').getPosition());
                break;
            case 'point-close':
                this.entity.setLocalScale(light.range, light.range, light.range);
                break;
            case 'spot':
                this.entity.setRotation(this._link.entity.getRotation());
                this.entity.model.model.meshInstances[0].setParameter('range', light.range);
                this.entity.model.model.meshInstances[0].setParameter('innerAngle', light.innerConeAngle);
                this.entity.model.model.meshInstances[0].setParameter('outerAngle', light.outerConeAngle);
                material = materialSpotBehind;
                break;
        }

        // render behind model
        if (this.entity.enabled && this.entity.model.model) {
            var instance = new pc.MeshInstance(this.entity, this.entity.model.model.meshInstances[0].mesh, material);
            instance.mask = 8;
            instance.pick = false;
            if (this.type === 'spot') {
                instance.layer = pc.LAYER_GIZMO;
                instance.setParameter('range', light.range);
                instance.setParameter('innerAngle', light.innerConeAngle);
                instance.setParameter('outerAngle', light.outerConeAngle);
            }
            app.scene.immediateDrawCalls.push(instance);
        }
    };
    // link to entity
    Gizmo.prototype.link = function(obj) {
        if (! app) return; // webgl not available

        this.unlink();
        this._link = obj;

        var self = this;

        this.events.push(this._link.once('destroy', function() {
            self.unlink();
        }));

        this.entity = new pc.Entity();
        this.entity.addComponent('model', {
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });

        container.addChild(this.entity);
    };
    // unlink
    Gizmo.prototype.unlink = function() {
        if (! app) return; // webgl not available

        if (! this._link)
            return;

        for(var i = 0; i < this.events.length; i++)
            this.events[i].unbind();

        this.events = [ ];
        this._link = null;
        this.type = '';

        var model = this.entity.model.model;
        if (model) {
            // put back in pool
            app.scene.removeModel(model);
            this.entity.removeChild(model.getGraph());
            poolModels[model._type].push(model);
        }

        this.entity.destroy();
    };

    editor.on('selector:change', function(type, items) {
        // clear gizmos
        if (type !== 'entity') {
            for(var key in entities) {
                entities[key].unlink();
                pool.push(entities[key]);
            }
            entities = { };
            return;
        }

        // index selection
        var ids = { };
        for(var i = 0; i < items.length; i++)
            ids[items[i].get('resource_id')] = items[i];

        var render = false;

        // remove
        for(var key in entities) {
            if (ids[key])
                continue;

            pool.push(entities[key]);
            entities[key].unlink();
            delete entities[key];
            render = true;
        }

        // add
        for(var key in ids) {
            if (entities[key])
                continue;

            var gizmo = pool.shift();
            if (! gizmo)
                gizmo = new Gizmo();

            gizmo.link(ids[key]);
            entities[key] = gizmo;

            render = true;
        }

        if (render)
            editor.call('viewport:render');
    });

    editor.once('viewport:load', function() {
        app = editor.call('viewport:app');
        if (! app) return; // webgl not available

        container = new pc.Entity(app);
        app.root.addChild(container);

        // material
        var material = new pc.BasicMaterial();
        material.color = colorPrimary;
        material.update();

        var shaderSpot;

        materialSpot = new pc.BasicMaterial();
        materialSpot.updateShader = function(device) {
            if (! shaderSpot) {
                shaderSpot = new pc.Shader(device, {
                    attributes: {
                        vertex_position: 'POSITION',
                        outer: 'ATTR0'
                    },
                    vshader: ' \
                        attribute vec3 vertex_position;\n \
                        attribute float outer;\n \
                        uniform mat4 matrix_model;\n \
                        uniform mat4 matrix_viewProjection;\n \
                        uniform float range;\n \
                        uniform float innerAngle;\n \
                        uniform float outerAngle;\n \
                        void main(void)\n \
                        {\n \
                            mat4 modelMatrix = matrix_model;\n \
                            vec4 positionW = vec4(vertex_position, 1.0);\n \
                            float radius = (outer * (sin(radians(outerAngle)) * range)) + ((1.0 - outer) * (sin(radians(innerAngle)) * range));\n \
                            positionW.xz *= radius;\n \
                            positionW.y *= range * ((outer * cos(radians(outerAngle))) + ((1.0 - outer) * cos(radians(innerAngle))));\n \
                            positionW = modelMatrix * positionW;\n \
                            gl_Position = matrix_viewProjection * positionW;\n \
                        }\n',
                    fshader: ' \
                        precision ' + device.precision + ' float;\n \
                        uniform vec4 uColor;\n \
                        void main(void)\n \
                        {\n \
                            gl_FragColor = uColor;\n \
                            gl_FragColor = clamp(gl_FragColor, 0.0, 1.0);\n \
                        }\n',
                });
            }
            this.shader = shaderSpot;
        };
        materialSpot.color = colorPrimary;
        materialSpot.update();

        materialSpotBehind = new pc.BasicMaterial();
        materialSpotBehind.updateShader = materialSpot.updateShader;
        materialSpotBehind.color = colorBehind;
        materialSpotBehind.blend = true;
        materialSpotBehind.blendSrc = pc.BLENDMODE_SRC_ALPHA;
        materialSpotBehind.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        materialSpotBehind.depthTest = false;
        materialSpotBehind.update();

        var buffer, iterator, size, length, node, mesh, material, meshInstance, model;
        var vertexFormat = new pc.gfx.VertexFormat(app.graphicsDevice, [
            { semantic: pc.gfx.SEMANTIC_POSITION, components: 3, type: pc.gfx.ELEMENTTYPE_FLOAT32 }
        ]);
        var vertexFormatSpot = new pc.gfx.VertexFormat(app.graphicsDevice, [
            { semantic: pc.gfx.SEMANTIC_POSITION, components: 3, type: pc.gfx.ELEMENTTYPE_FLOAT32 },
            { semantic: pc.gfx.SEMANTIC_ATTR0, components: 1, type: pc.gfx.ELEMENTTYPE_FLOAT32 }
        ]);
        var rad = Math.PI / 180;

        // ================
        // directional light
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, 14);
        iterator = new pc.gfx.VertexIterator(buffer);
        size = .2;
        length = -(2 - size * 2);
        // line
        iterator.element[pc.SEMANTIC_POSITION].set(0, 0, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(0, length, 0);
        iterator.next();
        // triangle
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(0 * rad) * size, length, Math.cos(0 * rad) * size);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(120 * rad) * size, length, Math.cos(120 * rad) * size);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(120 * rad) * size, length, Math.cos(120 * rad) * size);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(240 * rad) * size, length, Math.cos(240 * rad) * size);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(240 * rad) * size, length, Math.cos(240 * rad) * size);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(0 * rad) * size, length, Math.cos(0 * rad) * size);
        iterator.next();
        // triangle corners
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(0 * rad) * size, length, Math.cos(0 * rad) * size);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(0, length - (size * 2), 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(120 * rad) * size, length, Math.cos(120 * rad) * size);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(0, length - (size * 2), 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(240 * rad) * size, length, Math.cos(240 * rad) * size);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(0, length - (size * 2), 0);
        iterator.next();
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, material);
        meshInstance.mask = 8;
        meshInstance.pick = false;
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['directional'] = model;

        // ================
        // point light
        var segments = 72;
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, segments * 2);
        iterator = new pc.gfx.VertexIterator(buffer);
        // xz axis
        for(var i = 0; i < segments; i++) {
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), Math.cos(360 / segments * i * rad), 0);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), Math.cos(360 / segments * (i + 1) * rad), 0);
            iterator.next();
        }
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, material);
        meshInstance.mask = 8;
        meshInstance.pick = false;
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['point'] = model;


        // ================
        // point light close
        var segments = 72;
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, segments * 2 * 3);
        iterator = new pc.gfx.VertexIterator(buffer);
        // circles
        for(var i = 0; i < segments; i++) {
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), 0, Math.cos(360 / segments * i * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), 0, Math.cos(360 / segments * (i + 1) * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), Math.cos(360 / segments * i * rad), 0);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), Math.cos(360 / segments * (i + 1) * rad), 0);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(0, Math.cos(360 / segments * i * rad), Math.sin(360 / segments * i * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(0, Math.cos(360 / segments * (i + 1) * rad), Math.sin(360 / segments * (i + 1) * rad));
            iterator.next();
        }
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, material);
        meshInstance.mask = 8;
        meshInstance.pick = false;
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['point-close'] = model;


        // ================
        // spot light
        var segments = 72;
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormatSpot, segments * 2 * 2 + 8);
        iterator = new pc.gfx.VertexIterator(buffer);
        // lines
        //      left
        iterator.element[pc.SEMANTIC_POSITION].set(0, 0, 0);
        iterator.element[pc.SEMANTIC_ATTR0].set(1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(0 * rad), -1, Math.cos(0 * rad));
        iterator.element[pc.SEMANTIC_ATTR0].set(1);
        iterator.next();
        //      right
        iterator.element[pc.SEMANTIC_POSITION].set(0, 0, 0);
        iterator.element[pc.SEMANTIC_ATTR0].set(1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(180 * rad), -1, Math.cos(180 * rad));
        iterator.element[pc.SEMANTIC_ATTR0].set(1);
        iterator.next();
        // circles
        for(var i = 0; i < segments; i++) {
            // inner
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), -1, Math.cos(360 / segments * i * rad));
            iterator.element[pc.SEMANTIC_ATTR0].set(0);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), -1, Math.cos(360 / segments * (i + 1) * rad));
            iterator.element[pc.SEMANTIC_ATTR0].set(0);
            iterator.next();
            // outer
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), -1, Math.cos(360 / segments * i * rad));
            iterator.element[pc.SEMANTIC_ATTR0].set(1);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), -1, Math.cos(360 / segments * (i + 1) * rad));
            iterator.element[pc.SEMANTIC_ATTR0].set(1);
            iterator.next();
        }
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, materialSpot);
        meshInstance.mask = 8;
        meshInstance.pick = false;
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['spot'] = model;
    });

    editor.on('viewport:gizmoUpdate', function(dt) {
        for(var key in entities)
            entities[key].update();
    });
});


/* editor/gizmo/gizmo-collision.js */
editor.once('load', function () {
    'use strict';

    var app;
    // selected entity gizmos
    var entities = { };
    var selected = { };
    // pool of gizmos
    var pool = [ ];
    var poolVec3 = [ ];
    // colors
    var alphaFront = 0.6;
    var alphaBehind = 0.2;
    var colorBehind = new pc.Color(1, 1, 1, .05);
    var colorPrimary = new pc.Color(1, 1, 1);
    var colorOccluder = new pc.Color(1, 1, 1, 1);
    var colorDefault = [ 1, 1, 1 ];
    var container;
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();

    var materialDefault = new pc.BasicMaterial();
    materialDefault.color = colorPrimary;
    materialDefault.blend = true;
    materialDefault.blendSrc = pc.BLENDMODE_SRC_ALPHA;
    materialDefault.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
    materialDefault.update();

    var materialBehind = new pc.BasicMaterial();
    materialBehind.color = colorBehind;
    materialBehind.blend = true;
    materialBehind.blendSrc = pc.BLENDMODE_SRC_ALPHA;
    materialBehind.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
    materialBehind.depthWrite = false;
    materialBehind.depthTest = true;
    materialBehind.update();

    var materialOccluder = new pc.BasicMaterial();
    materialOccluder.color = colorOccluder;
    materialOccluder.redWrite = false;
    materialOccluder.greenWrite = false;
    materialOccluder.blueWrite = false;
    materialOccluder.alphaWrite = false;
    materialOccluder.depthWrite = true;
    materialOccluder.depthTest = true;
    materialOccluder.update();

    var models = { };
    var materials = { };
    var poolModels = { 'box': [ ], 'sphere': [ ], 'capsule-x': [ ], 'capsule-y': [ ], 'capsule-z': [ ], 'cylinder-x': [ ], 'cylinder-y': [ ], 'cylinder-z': [ ] };
    var axesNames = { 0: 'x', 1: 'y', 2: 'z' };
    var shaderCapsule = { };

    var filterPicker = function(drawCall) {
        if (drawCall.command)
            return true;

        return (drawCall.__editor && drawCall.__collision) || drawCall.layer === pc.LAYER_GIZMO;
    };

    var visible = false;
    editor.method('gizmo:collision:visible', function(state) {
        if (state === undefined)
            return visible;

        if (visible === !! state)
            return;

        visible = !! state;

        if (visible) {
            editor.call('gizmo:zone:visible', false);
            editor.call('viewport:pick:filter', filterPicker);
        } else {
            editor.call('viewport:pick:filter', null);
        }

        editor.emit('gizmo:collision:visible', visible);
        editor.call('viewport:render');
    });

    // gizmo class
    function Gizmo() {
        this._link = null;
        this.lines = [ ];
        this.events = [ ];
        this.type = '';
        this.asset = 0;
        this.entity = null;
        this.color;
    }
    // update lines
    Gizmo.prototype.update = function() {
        if (! app) return; // webgl not available

        if (! this._link || ! this._link.entity)
            return;

        var select = selected[this._link.get('resource_id')];
        var collision = this._link.entity.collision;
        this.entity.enabled = this._link.entity.enabled && collision && collision.enabled && (select || visible);
        if (! this.entity.enabled) {
            this._link.entity.__noIcon = false;
            return;
        }

        this._link.entity.__noIcon = true;
        this.entity.setPosition(this._link.entity.getPosition());
        this.entity.setRotation(this._link.entity.getRotation());

        var type = collision.type;

        if (type === 'cylinder' || type === 'capsule')
            type += '-' + axesNames[collision.axis];

        if (this.type !== type) {
            this.type = type;

            if (! this.color) {
                var hash = 0;
                var string = this._link.entity._guid;
                for(var i = 0; i < string.length; i++)
                    hash += string.charCodeAt(i);

                this.color = editor.call('color:hsl2rgb', (hash % 128) / 128, 0.5, 0.5);
            }

            this.wireframeMesh = null;

            // set new model based on type
            if (models[this.type]) {
                // get current model
                var model = this.entity.model.model;
                if (model) {
                    // put back in pool
                    app.scene.removeModel(model);
                    this.entity.removeChild(model.getGraph());
                    if (poolModels[model._type])
                        poolModels[model._type].push(model);
                }
                // get from pool
                model = null;
                if (poolModels[this.type])
                    model = poolModels[this.type].shift();

                if (! model) {
                    // no in pool
                    model = models[this.type].clone();
                    model._type = this.type;

                    var color = this.color || colorDefault;

                    var old = model.meshInstances[0].material;
                    model.meshInstances[0].setParameter('offset', 0);
                    model.meshInstances[0].layer = 12;
                    model.meshInstances[0].updateKey();
                    model.meshInstances[0].__editor = true;
                    model.meshInstances[0].__collision = true;
                    model.meshInstances[0].material = old.clone();
                    model.meshInstances[0].material.updateShader = old.updateShader;
                    model.meshInstances[0].material.color.set(color[0], color[1], color[2], alphaFront);
                    model.meshInstances[0].material.update();

                    var old = model.meshInstances[1].material;
                    model.meshInstances[1].setParameter('offset', 0.001);
                    model.meshInstances[1].layer = 2;
                    model.meshInstances[1].pick = false;
                    model.meshInstances[1].updateKey();
                    model.meshInstances[1].__editor = true;
                    model.meshInstances[1].material = old.clone();
                    model.meshInstances[1].material.updateShader = old.updateShader;
                    model.meshInstances[1].material.color.set(color[0], color[1], color[2], alphaBehind);
                    model.meshInstances[1].material.update();

                    model.meshInstances[2].setParameter('offset', 0);
                    model.meshInstances[2].layer = 9;
                    model.meshInstances[2].pick = false;
                    model.meshInstances[2].updateKey();
                    model.meshInstances[2].__editor = true;

                    switch(this.type) {
                        case 'capsule-x':
                        case 'capsule-y':
                        case 'capsule-z':
                            model.meshInstances[0]._shader[pc.SHADER_PICK] = shaderCapsule['pick-' + axesNames[collision.axis]];

                            for(var i = 0; i < model.meshInstances.length; i++) {
                                model.meshInstances[i].setParameter('radius', collision.radius || 0.5);
                                model.meshInstances[i].setParameter('height', collision.height || 2);
                            }
                            break;
                    }
                }
                // set to model
                this.entity.model.model = model;
                this.entity.setLocalScale(1, 1, 1);
            } else if (this.type === 'mesh') {
                this.asset = collision.asset;
                this.entity.setLocalScale(this._link.entity.getWorldTransform().getScale());
                this.createWireframe(collision.asset);
                if (! this.asset) {
                    this.entity.enabled = false;
                    this.entity.model.model = null;
                    return;
                }
            } else {
                this.entity.enabled = false;
                this.entity.model.model = null;
                return;
            }
        }

        var mat = materialBehind;
        var radius = collision.radius || .00001;
        var height = collision.height || .00001;

        if (this.entity.model.model && this.entity.model.meshInstances[1])
            mat = null;

        switch(this.type) {
            case 'sphere':
                this.entity.setLocalScale(radius, radius, radius);
                break;
            case 'box':
                this.entity.setLocalScale(collision.halfExtents.x || .00001, collision.halfExtents.y || .00001, collision.halfExtents.z || .00001);
                break;
            case 'cylinder-x':
                this.entity.setLocalScale(height, radius, radius);
                break;
            case 'cylinder-y':
                this.entity.setLocalScale(radius, height, radius);
                break;
            case 'cylinder-z':
                this.entity.setLocalScale(radius, radius, height);
                break;
            case 'capsule-x':
            case 'capsule-y':
            case 'capsule-z':
                for(var i = 0; i < this.entity.model.meshInstances.length; i++) {
                    this.entity.model.meshInstances[i].setParameter('radius', collision.radius || 0.5);
                    this.entity.model.meshInstances[i].setParameter('height', collision.height || 2);
                }
                break;
            case 'mesh':
                this.entity.setLocalScale(this._link.entity.getWorldTransform().getScale());

                if (collision.asset !== this.asset) {
                    this.asset = collision.asset;
                    this.createWireframe(collision.asset);
                    if (! this.asset) {
                        this.entity.enabled = false;
                        this.entity.model.model = null;
                        return;
                    }
                }

                if (this.entity.model.model) {
                    var picking = ! visible && this._link.entity.model && this._link.entity.model.enabled && this._link.entity.model.type === 'asset' && this._link.entity.model.asset === collision.asset;
                    if (picking !== this.entity.model.model.__picking) {
                        this.entity.model.model.__picking = picking;

                        var meshes = this.entity.model.meshInstances;
                        for(var i = 0; i < meshes.length; i++) {
                            if (! meshes[i].__collision)
                                continue;

                            meshes[i].pick = ! picking;
                        }
                    }
                }
                break;
        }
    };
    // link to entity
    Gizmo.prototype.link = function(obj) {
        if (! app) return; // webgl not available

        this.unlink();
        this._link = obj;

        var self = this;

        this.events.push(this._link.once('destroy', function() {
            self.unlink();
        }));

        this.color = null;

        this.entity = new pc.Entity();
        this.entity.__editor = true;
        this.entity.addComponent('model', {
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        this.entity._getEntity = function() {
            return self._link.entity;
        };

        container.addChild(this.entity);
    };
    // unlink
    Gizmo.prototype.unlink = function() {
        if (! app) return; // webgl not available

        if (! this._link)
            return;

        for(var i = 0; i < this.events.length; i++) {
            if (this.events[i] && this.events[i].unbind)
                this.events[i].unbind();
        }

        this.events = [ ];
        this._link = null;
        this.color = null;
        this.type = '';
        this.asset = 0;

        var model = this.entity.model.model;
        if (model) {
            // put back in pool
            app.scene.removeModel(model);
            this.entity.removeChild(model.getGraph());
            if (model._type)
                poolModels[model._type].push(model);
        }

        this.entity.destroy();
    };
    // create wireframe
    Gizmo.prototype.createWireframe = function(asset) {
        if (! app) return; // webgl not available

        asset = app.assets.get(asset);
        if (! asset)
            return null;

        if (asset.resource) {
            this.entity.model.model = createModelCopy(asset.resource, this.color);
        } else {
            var self = this;

            this.events.push(asset.once('load', function(asset) {
                if (self.asset !== asset.id)
                    return;

                self.entity.model.model = createModelCopy(asset.resource, this.color);
            }));
        }
    };

    editor.on('entities:add', function(entity) {
        var key = entity.get('resource_id');

        var addGizmo = function() {
            if (entities[key])
                return;

            var gizmo = pool.shift();
            if (! gizmo)
                gizmo = new Gizmo();

            gizmo.link(entity);
            entities[key] = gizmo;

            editor.call('viewport:render');
        };

        var removeGizmo = function() {
            if (! entities[key])
                return;

            pool.push(entities[key]);
            entities[key].unlink();
            delete entities[key];

            editor.call('viewport:render');
        };

        if (entity.has('components.collision'))
            addGizmo();

        entity.on('components.collision:set', addGizmo);
        entity.on('components.collision:unset', removeGizmo);
        entity.on('destroy', removeGizmo);
    });

    editor.on('selector:change', function(type, items) {
        selected = { };

        if (type === 'entity' && items && items.length) {
            for(var i = 0; i < items.length; i++)
                selected[items[i].get('resource_id')] = true;
        }
    });

    editor.once('viewport:load', function() {
        app = editor.call('viewport:app');
        if (! app) return; // webgl not available

        app.scene.drawCalls.push(new pc.Command(10, pc.BLEND_NONE, function() {
            app.graphicsDevice.clear({
                depth: 1.0,
                flags: pc.CLEARFLAG_DEPTH
            });
        }));

        app.scene.drawCalls.push(new pc.Command(13, pc.BLEND_NONE, function() {
            var gl = app.graphicsDevice.gl;
            gl.enable(gl.POLYGON_OFFSET_FILL);
            gl.polygonOffset(0, -8);
        }));

        app.scene.drawCalls.push(new pc.Command(11, pc.BLEND_NONE, function() {
            var gl = app.graphicsDevice.gl;
            gl.disable(gl.POLYGON_OFFSET_FILL);
        }));

        container = new pc.Entity(app);
        app.root.addChild(container);

        // material
        var defaultVShader = ' \
            attribute vec3 aPosition;\n \
            attribute vec3 aNormal;\n \
            varying vec3 vNormal;\n \
            varying vec3 vPosition;\n \
            uniform float offset;\n \
            uniform mat4 matrix_model;\n \
            uniform mat3 matrix_normal;\n \
            uniform mat4 matrix_view;\n \
            uniform mat4 matrix_viewProjection;\n \
            void main(void)\n \
            {\n \
                vec4 posW = matrix_model * vec4(aPosition, 1.0);\n \
                vNormal = normalize(matrix_normal * aNormal);\n \
                posW += vec4(vNormal * offset, 0.0);\n \
                gl_Position = matrix_viewProjection * posW;\n \
                vPosition = posW.xyz;\n \
            }\n';
        var defaultFShader = ' \
            precision ' + app.graphicsDevice.precision + ' float;\n \
            varying vec3 vNormal;\n \
            varying vec3 vPosition;\n \
            uniform vec4 uColor;\n \
            uniform vec3 view_position;\n \
            void main(void)\n \
            {\n \
                vec3 viewNormal = normalize(view_position - vPosition);\n \
                float light = dot(vNormal, viewNormal);\n \
                gl_FragColor = vec4(uColor.rgb * light * 2.0, uColor.a);\n \
            }\n';

        var shaderDefault;

        materialDefault.updateShader = function(device) {
            if (! shaderDefault) {
                shaderDefault = new pc.Shader(device, {
                    attributes: {
                        aPosition: pc.SEMANTIC_POSITION,
                        aNormal: pc.SEMANTIC_NORMAL
                    },
                    vshader: defaultVShader,
                    fshader: defaultFShader,
                });
            }

            this.shader = shaderDefault;
        };
        materialDefault.update();

        materialBehind.updateShader = materialDefault.updateShader;
        materialOccluder.updateShader = materialDefault.updateShader;

        var capsuleVShader = ' \
            attribute vec3 aPosition;\n \
            attribute vec3 aNormal;\n \
            attribute float aSide;\n \
            varying vec3 vNormal;\n \
            varying vec3 vPosition;\n \
            uniform float offset;\n \
            uniform mat4 matrix_model;\n \
            uniform mat3 matrix_normal;\n \
            uniform mat4 matrix_viewProjection;\n \
            uniform float radius;\n \
            uniform float height;\n \
            void main(void) {\n \
                vec3 pos = aPosition * radius;\n \
                pos.{axis} += aSide * max(height / 2.0 - radius, 0.0);\n \
                vec4 posW = matrix_model * vec4(pos, 1.0);\n \
                vNormal = normalize(matrix_normal * aNormal);\n \
                posW += vec4(vNormal * offset, 0.0);\n \
                gl_Position = matrix_viewProjection * posW;\n \
                vPosition = posW.xyz;\n \
            }\n';
        var capsuleFShader = ' \
            precision ' + app.graphicsDevice.precision + ' float;\n \
            varying vec3 vNormal;\n \
            varying vec3 vPosition;\n \
            uniform vec4 uColor;\n \
            uniform vec3 view_position;\n \
            void main(void) {\n \
                vec3 viewNormal = normalize(view_position - vPosition);\n \
                float light = dot(vNormal, viewNormal);\n \
                gl_FragColor = vec4(uColor.rgb * light * 2.0, uColor.a);\n \
            }\n';

        var capsuleVShaderPick = ' \
            attribute vec3 aPosition;\n \
            attribute vec3 aNormal;\n \
            attribute float aSide;\n \
            uniform mat4 matrix_model;\n \
            uniform mat4 matrix_viewProjection;\n \
            uniform float radius;\n \
            uniform float height;\n \
            void main(void) {\n \
                vec3 pos = aPosition * radius;\n \
                pos.{axis} += aSide * max(height / 2.0 - radius, 0.0);\n \
                vec4 posW = matrix_model * vec4(pos, 1.0);\n \
                gl_Position = matrix_viewProjection * posW;\n \
            }\n';

        var capsuleFShaderPick = ' \
            precision ' + app.graphicsDevice.precision + ' float;\n \
            uniform vec4 uColor;\n \
            void main(void) {\n \
                gl_FragColor = uColor;\n \
            }\n';


        var makeMaterial = function(a) {
            var matDefault = materials['capsule-' + a] = materialDefault.clone();
            matDefault.updateShader = function(device) {
                if (! shaderCapsule[a]) {
                    shaderCapsule[a] = new pc.Shader(device, {
                        attributes: {
                            aPosition: pc.SEMANTIC_POSITION,
                            aNormal: pc.SEMANTIC_NORMAL,
                            aSide: pc.SEMANTIC_ATTR0
                        },
                        vshader: capsuleVShader.replace('{axis}', a),
                        fshader: capsuleFShader,
                    });
                }
                this.shader = shaderCapsule[a];
            };
            matDefault.update();

            var matBehind = materials['capsuleBehind-' + a] = materialBehind.clone();
            matBehind.updateShader = matDefault.updateShader;
            matBehind.update();

            var matOccluder = materials['capsuleOcclude-' + a] = materialOccluder.clone();
            matOccluder.updateShader = matDefault.updateShader;
            matOccluder.update();

            if (! shaderCapsule['pick-' + a]) {
                shaderCapsule['pick-' + a] = new pc.Shader(app.graphicsDevice, {
                    attributes: {
                        aPosition: pc.SEMANTIC_POSITION,
                        aNormal: pc.SEMANTIC_NORMAL,
                        aSide: pc.SEMANTIC_ATTR0
                    },
                    vshader: capsuleVShaderPick.replace('{axis}', a),
                    fshader: capsuleFShaderPick
                });
            }
        }

        for(var key in axesNames)
            makeMaterial(axesNames[key]);

        var buffer, iterator, size, length, node, mesh, meshInstance, model, indexBuffer, indices;
        var vertexFormat = new pc.VertexFormat(app.graphicsDevice, [
            { semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.ELEMENTTYPE_FLOAT32 }
        ]);
        var vertexFormatAttr0 = new pc.VertexFormat(app.graphicsDevice, [
            { semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.ELEMENTTYPE_FLOAT32 },
            { semantic: pc.SEMANTIC_NORMAL, components: 3, type: pc.ELEMENTTYPE_FLOAT32 },
            { semantic: pc.SEMANTIC_ATTR0, components: 1, type: pc.ELEMENTTYPE_FLOAT32 }
        ]);
        var rad = Math.PI / 180;

        var createModel = function(args) {
            var mesh;

            if (args.vertices) {
                // mesh
                mesh = new pc.Mesh();
                mesh.vertexBuffer = args.vertices;
                mesh.indexBuffer[0] = args.indices;
                mesh.primitive[0].type = pc.PRIMITIVE_TRIANGLES;
                mesh.primitive[0].base = 0;
                mesh.primitive[0].count = args.count;
                mesh.primitive[0].indexed = true;
            } else {
                mesh = pc.createMesh(app.graphicsDevice, args.positions, {
                    normals: args.normals,
                    indices: args.indices
                });
            }

            // node
            var node = new pc.GraphNode();
            // meshInstance
            var meshInstance = new pc.MeshInstance(node, mesh, args.matDefault);
            meshInstance.__editor = true;
            meshInstance.__collision = true;
            meshInstance.layer = 12;
            meshInstance.castShadow = false;
            meshInstance.castLightmapShadow = false;
            meshInstance.receiveShadow = false;
            meshInstance.updateKey();
            // meshInstanceBehind
            var meshInstanceBehind = new pc.MeshInstance(node, mesh, args.matBehind);
            meshInstanceBehind.__editor = true;
            meshInstanceBehind.pick = false;
            meshInstanceBehind.layer = 2;
            meshInstanceBehind.drawToDepth = false;
            meshInstanceBehind.castShadow = false;
            meshInstanceBehind.castLightmapShadow = false;
            meshInstanceBehind.receiveShadow = false;
            meshInstanceBehind.updateKey();
            // meshInstanceOccluder
            var meshInstanceOccluder = new pc.MeshInstance(node, mesh, args.matOccluder);
            meshInstanceOccluder.__editor = true;
            meshInstanceOccluder.pick = false;
            meshInstanceOccluder.layer = 9;
            meshInstanceOccluder.castShadow = false;
            meshInstanceOccluder.castLightmapShadow = false;
            meshInstanceOccluder.receiveShadow = false;
            meshInstanceOccluder.updateKey();
            // model
            var model = new pc.Model();
            model.graph = node;
            model.meshInstances = [ meshInstance, meshInstanceBehind, meshInstanceOccluder ];

            return model;
        };


        // ================
        // box
        var positions = [
            1, 1, 1,   1, 1, -1,   -1, 1, -1,   -1, 1, 1, // top
            1, 1, 1,   -1, 1, 1,   -1, -1, 1,   1, -1, 1, // front
            1, 1, 1,   1, -1, 1,   1, -1, -1,   1, 1, -1, // right
            1, 1, -1,   1, -1, -1,   -1, -1, -1,   -1, 1, -1, // back
            -1, 1, 1,   -1, 1, -1,   -1, -1, -1,   -1, -1, 1, // left
            1, -1, 1,   -1, -1, 1,   -1, -1, -1,   1, -1, -1 // bottom
        ];
        var normals = [
            0, 1, 0,   0, 1, 0,   0, 1, 0,   0, 1, 0,
            0, 0, 1,   0, 0, 1,   0, 0, 1,   0, 0, 1,
            1, 0, 0,   1, 0, 0,   1, 0, 0,   1, 0, 0,
            0, 0, -1,   0, 0, -1,   0, 0, -1,   0, 0, -1,
            -1, 0, 0,   -1, 0, 0,   -1, 0, 0,   -1, 0, 0,
            0, -1, 0,   0, -1, 0,   0, -1, 0,   0, -1, 0
        ];
        var indices = [
            0, 1, 2, 2, 3, 0,
            4, 5, 6, 6, 7, 4,
            8, 9, 10, 10, 11, 8,
            12, 13, 14, 14, 15, 12,
            16, 17, 18, 18, 19, 16,
            20, 21, 22, 22, 23, 20
        ];
        models['box'] = createModel({
            positions: positions,
            normals: normals,
            indices: indices,
            matDefault: materialDefault,
            matBehind: materialBehind,
            matOccluder: materialOccluder
        });


        // ================
        // sphere
        var segments = 64;
        positions = [ ];
        normals = [ ];
        indices = [ ];

        for(var y = 1; y < segments / 2; y++) {
            for(var i = 0; i < segments; i++) {
                var l = Math.sin((y * (180 / (segments / 2)) + 90) * rad);
                var c = Math.cos((y * (180 / (segments / 2)) + 90) * rad);
                vecA.set(Math.sin(360 / segments * i * rad) * Math.abs(c), l, Math.cos(360 / segments * i * rad) * Math.abs(c));
                positions.push(vecA.x, vecA.y, vecA.z);
                vecA.normalize();
                normals.push(vecA.x, vecA.y, vecA.z);
            }
        }

        positions.push(0, 1, 0);
        normals.push(0, 1, 0);
        positions.push(0, -1, 0);
        normals.push(0, -1, 0);

        for(var y = 0; y < segments / 2 - 2; y++) {
            for(var i = 0; i < segments; i++) {
                indices.push(y * segments + i, (y + 1) * segments + i, y * segments + (i + 1) % segments);
                indices.push((y + 1) * segments + i, (y + 1) * segments + (i + 1) % segments, y * segments + (i + 1) % segments);
            }
        }

        for(var i = 0; i < segments; i++) {
            indices.push(i, (i + 1) % segments, (segments / 2 - 1) * segments);
            indices.push((segments / 2 - 2) * segments + i, (segments / 2 - 1) * segments + 1, (segments / 2 - 2) * segments + (i + 1) % segments);
        }

        models['sphere'] = createModel({
            positions: positions,
            normals: normals,
            indices: indices,
            matDefault: materialDefault,
            matBehind: materialBehind,
            matOccluder: materialOccluder
        });


        // ================
        // cylinders
        var axes = {
            'x': [ 'z', 'y', 'x' ],
            'y': [ 'x', 'z', 'y' ],
            'z': [ 'y', 'x', 'z' ]
        };
        for(var a in axes) {
            positions = [ ];
            indices = [ ];
            normals = [ ];
            var segments = 72;

            // side
            for(var v = 1; v >= -1; v -= 2) {
                for(var i = 0; i < segments; i++) {
                    vecA[axes[a][0]] = Math.sin(360 / segments * i * rad);
                    vecA[axes[a][1]] = Math.cos(360 / segments * i * rad);
                    vecA[axes[a][2]] = v * 0.5;

                    vecB.copy(vecA);
                    vecB[axes[a][2]] = 0;
                    positions.push(vecA.x, vecA.y, vecA.z);
                    normals.push(vecB.x, vecB.y, vecB.z);
                }
            }

            // top/bottom
            for(var v = 1; v >= -1; v -= 2) {
                vecA.set(0, 0, 0);
                vecA[axes[a][2]] = v;
                positions.push(vecA.x * 0.5, vecA.y * 0.5, vecA.z * 0.5);
                normals.push(vecA.x, vecA.y, vecA.z);

                for(var i = 0; i < segments; i++) {
                    vecA[axes[a][0]] = Math.sin(360 / segments * i * rad);
                    vecA[axes[a][1]] = Math.cos(360 / segments * i * rad);
                    vecA[axes[a][2]] = v * 0.5;

                    vecB.set(0, 0, 0);
                    vecB[axes[a][2]] = v;

                    positions.push(vecA.x, vecA.y, vecA.z);
                    normals.push(vecB.x, vecB.y, vecB.z);
                }
            }

            for(var i = 0; i < segments; i++) {
                // sides
                indices.push(i, i + segments, (i + 1) % segments);
                indices.push(i + segments, (i + 1) % segments + segments, (i + 1) % segments);

                // lids
                indices.push(segments * 2, segments * 2 + i + 1, segments * 2 + (i + 1) % segments + 1);
                indices.push(segments * 3 + 1, segments * 3 + (i + 1) % segments + 2, segments * 3 + i + 2);
            }
            models['cylinder-' + a] = createModel({
                positions: positions,
                normals: normals,
                indices: indices,
                matDefault: materialDefault,
                matBehind: materialBehind,
                matOccluder: materialOccluder
            });
        }


        // ================
        // capsules
        for(var a in axes) {
            positions = [ ];
            indices = [ ];
            var segments = 32;

            for(var y = 1; y < segments / 2 + 1; y++) {
                for(var i = 0; i < segments; i++) {
                    var k = y;
                    if (y === Math.floor(segments / 4) || y === Math.floor(segments / 4) + 1)
                        k = Math.floor(segments / 4);
                    var l = Math.sin((k * (180 / (segments / 2)) + 90) * rad);
                    var c = Math.cos((k * (180 / (segments / 2)) + 90) * rad);
                    vecA[axes[a][0]] = Math.sin(360 / segments * i * rad) * Math.abs(c);
                    vecA[axes[a][1]] = Math.cos(360 / segments * i * rad) * Math.abs(c);
                    vecA[axes[a][2]] = l;
                    positions.push(vecA.x, vecA.y, vecA.z);
                    vecA.normalize();
                    positions.push(vecA.x, vecA.y, vecA.z);
                    positions.push(y < segments / 4 ? 1 : -1);
                }
            }

            vecA.set(0, 0, 0);
            vecA[axes[a][2]] = 1;
            // top
            positions.push(vecA.x, vecA.y, vecA.z);
            positions.push(vecA.x, vecA.y, vecA.z);
            positions.push(1);
            // bottom
            vecA.scale(-1);
            positions.push(vecA.x, vecA.y, vecA.z);
            positions.push(vecA.x, vecA.y, vecA.z);
            positions.push(-1);

            // sides
            for(var y = 0; y < segments / 2 - 1; y++) {
                for(var i = 0; i < segments; i++) {
                    indices.push(y * segments + i, (y + 1) * segments + i, y * segments + (i + 1) % segments);
                    indices.push((y + 1) * segments + i, (y + 1) * segments + (i + 1) % segments, y * segments + (i + 1) % segments);
                }
            }

            // lids
            for(var i = 0; i < segments; i++) {
                indices.push(i, (i + 1) % segments, (segments / 2) * segments);
                indices.push((segments / 2 - 1) * segments + i, (segments / 2) * segments + 1, (segments / 2 - 1) * segments + (i + 1) % segments);
            }

            var bufferVertex = new pc.VertexBuffer(app.graphicsDevice, vertexFormatAttr0, positions.length / 7);
            var dst = new Float32Array(bufferVertex.lock());
            dst.set(positions);
            bufferVertex.unlock();

            var bufferIndex = new pc.IndexBuffer(app.graphicsDevice, pc.INDEXFORMAT_UINT16, indices.length);
            var dst = new Uint16Array(bufferIndex.lock());
            dst.set(indices);
            bufferIndex.unlock();

            models['capsule-' + a] = createModel({
                vertices: bufferVertex,
                indices: bufferIndex,
                count: indices.length,
                matDefault: materials['capsule-' + a],
                matBehind: materials['capsuleBehind-' + a],
                matOccluder: materials['capsuleOcclude-' + a]
            });

            var meshInstance = models['capsule-' + a].meshInstances[0];
            // TODO
        }
    });

    var createModelCopy = function(resource, color) {
        var model = resource.clone();

        var meshesExtra = [ ];

        for(var i = 0; i < model.meshInstances.length; i++) {
            model.meshInstances[i].material = materialDefault.clone();
            model.meshInstances[i].material.updateShader = materialDefault.updateShader;
            model.meshInstances[i].material.color.set(color[0], color[1], color[2], alphaFront);
            model.meshInstances[i].material.update();
            model.meshInstances[i].layer = 12;
            model.meshInstances[i].__editor = true;
            model.meshInstances[i].__collision = true;
            model.meshInstances[i].castShadow = false;
            model.meshInstances[i].castLightmapShadow = false;
            model.meshInstances[i].receiveShadow = false;
            model.meshInstances[i].setParameter('offset', 0);
            model.meshInstances[i].updateKey();

            var node = model.meshInstances[i].node;
            var mesh = model.meshInstances[i].mesh;

            var meshInstanceBehind = new pc.MeshInstance(node, mesh, materialBehind.clone());
            meshInstanceBehind.material.updateShader = materialBehind.updateShader;
            meshInstanceBehind.material.color.set(color[0], color[1], color[2], alphaBehind);
            meshInstanceBehind.material.update();
            meshInstanceBehind.setParameter('offset', 0);
            meshInstanceBehind.__editor = true;
            meshInstanceBehind.pick = false;
            meshInstanceBehind.layer = 2;
            meshInstanceBehind.drawToDepth = false;
            meshInstanceBehind.castShadow = false;
            meshInstanceBehind.castLightmapShadow = false;
            meshInstanceBehind.receiveShadow = false;
            meshInstanceBehind.updateKey();

            // meshInstanceOccluder
            var meshInstanceOccluder = new pc.MeshInstance(node, mesh, materialOccluder);
            meshInstanceOccluder.setParameter('offset', 0);
            meshInstanceOccluder.__editor = true;
            meshInstanceOccluder.pick = false;
            meshInstanceOccluder.layer = 9;
            meshInstanceOccluder.castShadow = false;
            meshInstanceOccluder.castLightmapShadow = false;
            meshInstanceOccluder.receiveShadow = false;
            meshInstanceOccluder.updateKey();

            meshesExtra.push(meshInstanceBehind, meshInstanceOccluder);
        }

        model.meshInstances = model.meshInstances.concat(meshesExtra);

        return model;
    };

    editor.on('viewport:gizmoUpdate', function(dt) {
        for(var key in entities)
            entities[key].update();
    });
});


/* editor/gizmo/gizmo-particles.js */
editor.once('load', function () {
    'use strict';

    var app;
    // selected entity gizmos
    var entities = { };
    // pool of gizmos
    var pool = [ ];
    // colors
    var colorBehind = new pc.Color(1, 1, 1, .15);
    var colorPrimary = new pc.Color(1, 1, 1);
    var container;
    var materialDefault;
    var materialBehind = new pc.BasicMaterial();
    materialBehind.color = colorBehind;
    materialBehind.blend = true;
    materialBehind.blendSrc = pc.BLENDMODE_SRC_ALPHA;
    materialBehind.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
    materialBehind.depthTest = false;
    materialBehind.update();
    var models = { };
    var poolModels = { 'box': [ ], 'sphere': [ ] };
    var shapes = { 0: 'box', 1: 'sphere' };

    // gizmo class
    function Gizmo() {
        this._link = null;
        this.events = [ ];
        this.type = '';
        this.entity = null;
    }
    // update lines
    Gizmo.prototype.update = function() {
        if (! app) return; // webgl not available

        if (! this._link || ! this._link.entity)
            return;

        var particles = this._link.entity.particlesystem;
        this.entity.enabled = this._link.entity.enabled && particles && particles.enabled;
        if (! this.entity.enabled)
            return;

        this.entity.setPosition(this._link.entity.getPosition());
        this.entity.setRotation(this._link.entity.getRotation());

        var type = shapes[particles.emitterShape];

        if (this.type !== type) {
            this.type = type;

            // set new model based on type
            if (models[this.type]) {
                // get current model
                var model = this.entity.model.model;
                if (model) {
                    // put back in pool
                    app.scene.removeModel(model);
                    this.entity.removeChild(model.getGraph());
                    if (poolModels[model._type])
                        poolModels[model._type].push(model);
                }
                // get from pool
                model = null;
                if (poolModels[this.type])
                    model = poolModels[this.type].shift();

                if (! model) {
                    // no in pool
                    model = models[this.type].clone();
                    model._type = this.type;
                }
                // set to model
                this.entity.model.model = model;
                this.entity.setLocalScale(1, 1, 1);
            } else {
                this.entity.enabled = false;
                this.entity.model.model = null;
                return;
            }
        }

        var mat = materialBehind;

        switch(this.type) {
            case 'sphere':
                this.entity.setLocalScale(particles.emitterRadius || .000001, particles.emitterRadius || .000001, particles.emitterRadius || .000001);
                break;
            case 'box':
                this.entity.setLocalScale(particles.emitterExtents.x / 2 || .00001, particles.emitterExtents.y / 2 || .00001, particles.emitterExtents.z / 2 || .00001);
                break;
        }

        // render behind model
        if (this.entity.enabled && this.entity.model.model) {
            var instance = new pc.MeshInstance(this.entity.model.model.meshInstances[0].node, this.entity.model.model.meshInstances[0].mesh, mat);
            app.scene.immediateDrawCalls.push(instance);
        }
    };
    // link to entity
    Gizmo.prototype.link = function(obj) {
        if (! app) return; // webgl not available

        this.unlink();
        this._link = obj;

        var self = this;

        this.events.push(this._link.once('destroy', function() {
            self.unlink();
        }));

        this.entity = new pc.Entity();
        this.entity.addComponent('model', {
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });

        container.addChild(this.entity);
    };
    // unlink
    Gizmo.prototype.unlink = function() {
        if (! app) return; // webgl not available

        if (! this._link)
            return;

        for(var i = 0; i < this.events.length; i++) {
            if (this.events[i] && this.events[i].unbind)
                this.events[i].unbind();
        }

        this.events = [ ];
        this._link = null;
        this.type = '';

        var model = this.entity.model.model;
        if (model) {
            // put back in pool
            app.scene.removeModel(model);
            this.entity.removeChild(model.getGraph());
            if (model._type)
                poolModels[model._type].push(model);
        }

        this.entity.destroy();
    };

    editor.on('selector:change', function(type, items) {
        // clear gizmos
        if (type !== 'entity') {
            for(var key in entities) {
                entities[key].unlink();
                pool.push(entities[key]);
            }
            entities = { };
            return;
        }

        // index selection
        var ids = { };
        for(var i = 0; i < items.length; i++)
            ids[items[i].get('resource_id')] = items[i];

        var render = false;

        // remove
        for(var key in entities) {
            if (ids[key])
                continue;

            pool.push(entities[key]);
            entities[key].unlink();
            delete entities[key];
            render = true;
        }

        // add
        for(var key in ids) {
            if (entities[key])
                continue;

            var gizmo = pool.shift();
            if (! gizmo)
                gizmo = new Gizmo();

            gizmo.link(ids[key]);
            entities[key] = gizmo;
            render = true;
        }

        if (render)
            editor.call('viewport:render');
    });

    editor.once('viewport:load', function() {
        app = editor.call('viewport:app');
        if (! app) return; // webgl not available

        container = new pc.Entity(app);
        app.root.addChild(container);

        // material
        materialDefault = new pc.BasicMaterial();
        materialDefault.color = colorPrimary;
        materialDefault.update();

        var buffer, iterator, size, length, node, mesh, meshInstance, model;
        var vertexFormat = new pc.gfx.VertexFormat(app.graphicsDevice, [
            { semantic: pc.gfx.SEMANTIC_POSITION, components: 3, type: pc.gfx.ELEMENTTYPE_FLOAT32 }
        ]);
        var vertexFormatAttr0 = new pc.gfx.VertexFormat(app.graphicsDevice, [
            { semantic: pc.gfx.SEMANTIC_POSITION, components: 3, type: pc.gfx.ELEMENTTYPE_FLOAT32 },
            { semantic: pc.gfx.SEMANTIC_ATTR0, components: 1, type: pc.gfx.ELEMENTTYPE_FLOAT32 }
        ]);
        var rad = Math.PI / 180;


        // ================
        // box
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, 12 * 2);
        iterator = new pc.gfx.VertexIterator(buffer);
        // top
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, 1);
        iterator.next();
        // bottom
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, 1);
        iterator.next();
        // sides
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, 1);
        iterator.next();
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, materialDefault);
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['box'] = model;


        // ================
        // sphere
        var segments = 72;
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, segments * 2 * 3);
        iterator = new pc.gfx.VertexIterator(buffer);
        // circles
        for(var i = 0; i < segments; i++) {
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), 0, Math.cos(360 / segments * i * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), 0, Math.cos(360 / segments * (i + 1) * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), Math.cos(360 / segments * i * rad), 0);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), Math.cos(360 / segments * (i + 1) * rad), 0);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(0, Math.cos(360 / segments * i * rad), Math.sin(360 / segments * i * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(0, Math.cos(360 / segments * (i + 1) * rad), Math.sin(360 / segments * (i + 1) * rad));
            iterator.next();
        }
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, materialDefault);
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['sphere'] = model;
    });

    editor.on('viewport:gizmoUpdate', function(dt) {
        for(var key in entities)
            entities[key].update();
    });
});


/* editor/gizmo/gizmo-bounding-box.js */
editor.once('load', function () {
    'use strict';
    var app = null;
    var entities = [ ];

    var firstBB = true;
    var bbA = new pc.BoundingBox();
    var bbB = new pc.BoundingBox();
    var bbC = new pc.BoundingBox();
    var bbD = new pc.BoundingBox();
    var bbE = new pc.BoundingBox();
    var bbF = new pc.BoundingBox();

    var matA = new pc.Mat4();
    var matB = new pc.Mat4();
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var minExtends = new pc.Vec3(0.01, 0.01, 0.01);

    var color = new pc.Color(1, 1, 1);
    var colorBehind = new pc.Color(1, 1, 1, .2);

    var colorNew = new pc.Color(1, .5, 0);


    var points = [ ];
    for(var c = 0; c < 32; c++)
        points[c] = new pc.Vec3();

    editor.on('selector:change', function(type, items) {
        if (type === 'entity') {
            entities = items.map(function(item) {
                return item.entity;
            });
        } else {
            entities = [ ];
        }
    });

    editor.method('viewport:render:aabb', function(aabb) {
        if (! app) return; // webgl not available

        var ind = 0;
        for(var x = -1; x <= 1; x += 2) {
            for(var y = -1; y <= 1; y += 2) {
                for(var z = -1; z <= 1; z += 2) {
                    points[ind * 4].copy(aabb.halfExtents);
                    points[ind * 4].x *= x;
                    points[ind * 4].y *= y;
                    points[ind * 4].z *= z;
                    points[ind * 4].add(aabb.center);

                    points[ind * 4 + 1].copy(points[ind * 4]);
                    points[ind * 4 + 1].x -= aabb.halfExtents.x * .3 * x;

                    points[ind * 4 + 2].copy(points[ind * 4]);
                    points[ind * 4 + 2].y -= aabb.halfExtents.y * .3 * y;

                    points[ind * 4 + 3].copy(points[ind * 4]);
                    points[ind * 4 + 3].z -= aabb.halfExtents.z * .3 * z;

                    app.renderLine(points[ind * 4], points[ind * 4 + 1], colorBehind, pc.LINEBATCH_OVERLAY);
                    app.renderLine(points[ind * 4], points[ind * 4 + 2], colorBehind, pc.LINEBATCH_OVERLAY);
                    app.renderLine(points[ind * 4], points[ind * 4 + 3], colorBehind, pc.LINEBATCH_OVERLAY);

                    app.renderLine(points[ind * 4], points[ind * 4 + 1], color, pc.LINEBATCH_WORLD);
                    app.renderLine(points[ind * 4], points[ind * 4 + 2], color, pc.LINEBATCH_WORLD);
                    app.renderLine(points[ind * 4], points[ind * 4 + 3], color, pc.LINEBATCH_WORLD);

                    ind++;
                }
            }
        }
    });

    editor.method('entities:boundingbox', function(entity) {
        var bb = editor.call('entities:boundingbox:entity', entity);

        if (bb) {
            if (firstBB) {
                firstBB = false;
                bbA.copy(bb);
            } else {
                bbA.add(bb);
            }
        }


        var children = entity.getChildren();
        for(var i = 0; i < children.length; i++) {
            if (children[i].__editor || ! (children[i] instanceof pc.Entity))
                continue;

            editor.call('entities:boundingbox', children[i]);
        }
    });

    editor.method('entities:boundingbox:entity', function(entity) {
        var first = true;

        entity.getWorldTransform();
        bbD.center.set(0, 0, 0);

        if (entity.model && entity.model.model && entity.model.meshInstances.length) {
            var meshes = entity.model.meshInstances;

            for(var i = 0; i < meshes.length; i++) {
                if (meshes[i]._hidden)
                    continue;

                meshes[i].node.getWorldTransform();

                if (first) {
                    first = false;
                    bbC.copy(meshes[i].aabb);
                } else {
                    bbC.add(meshes[i].aabb);
                }
            }
        }

        if (first && entity.collision) {
            switch(entity.collision.type) {
                case 'box':
                    first = false;
                    bbD.halfExtents.copy(entity.collision.halfExtents);
                    bbE.setFromTransformedAabb(bbD, entity.getWorldTransform());
                    bbC.copy(bbE);
                    break;
                case 'sphere':
                    first = false;
                    bbD.center.copy(entity.getPosition());
                    bbD.halfExtents.set(entity.collision.radius, entity.collision.radius, entity.collision.radius);
                    bbC.copy(bbD);
                    break;
                case 'capsule':
                case 'cylinder':
                    first = false;
                    bbD.halfExtents.set(entity.collision.radius, entity.collision.radius, entity.collision.radius);
                    bbD.halfExtents.data[entity.collision.axis] = entity.collision.height / 2;
                    bbE.setFromTransformedAabb(bbD, entity.getWorldTransform());
                    bbC.copy(bbE);
                    break;
            }
        }

        if (first && entity.element) {
            first = false;

            if (entity.element.type === 'image') {
                if (entity.element._image._meshInstance) {
                    bbC.copy(entity.element._image._meshInstance.aabb);
                }
            } else if (entity.element.type === 'text') {
                if (entity.element._text._meshInstance) {
                    bbC.copy(entity.element._text._meshInstance.aabb);
                }
            }
        }

        if (first && entity.particlesystem) {
            if (entity.particlesystem.emitter) {
                first = false;
                bbD.copy(entity.particlesystem.emitter.localBounds);
                bbE.setFromTransformedAabb(bbD, entity.getWorldTransform());
                bbC.copy(bbE);
            } else if (entity.particlesystem.emitterShape === pc.EMITTERSHAPE_BOX) {
                first = false;
                bbD.halfExtents.copy(entity.particlesystem.emitterExtents).scale(0.5);
                bbE.setFromTransformedAabb(bbD, entity.getWorldTransform());
                bbC.copy(bbE);
            } else if (entity.particlesystem.emitterShape === pc.EMITTERSHAPE_SPHERE) {
                first = false;
                bbD.center.copy(entity.getPosition());
                bbD.halfExtents.set(entity.particlesystem.emitterRadius, entity.particlesystem.emitterRadius, entity.particlesystem.emitterRadius);
                bbC.copy(bbD);
            }
        }

        if (first && entity.zone) {
            first = false;
            bbD.halfExtents.copy(entity.zone.size).scale(0.5);
            var position = entity.getPosition();
            var rotation = entity.getRotation();
            matA.setTRS(position, rotation, pc.Vec3.ONE);
            bbE.setFromTransformedAabb(bbD, matA);
            bbC.copy(bbE);
        }

        if (first) {
            bbC.center.copy(entity.getPosition());
            bbC.halfExtents.copy(minExtends);
        }

        return bbC;
    });

    editor.once('viewport:load', function() {
        app = editor.call('viewport:app');

        editor.on('viewport:postUpdate', function() {
            if (! entities.length)
                return;

            firstBB = true;
            var noEntities = true;

            for(var i = 0; i < entities.length; i++) {
                if (! entities[i])
                    continue;

                noEntities = false;
                editor.call('entities:boundingbox', entities[i]);
            }

            if (! noEntities) {
                bbA.halfExtents.add(minExtends);
                editor.call('viewport:render:aabb', bbA);
            }
        });
    });
});


/* editor/gizmo/gizmo-zone.js */
editor.once('load', function() {
    'use strict';

    var app;
    var visible = false;

    var filterPicker = function(drawCall) {
        if (drawCall.command)
            return true;

        return (drawCall.__editor && drawCall.__zone) || drawCall.layer === pc.LAYER_GIZMO;
    };

    editor.method('gizmo:zone:visible', function(state) {
        if (state === undefined)
            return visible;

        if (visible === !! state)
            return;

        visible = state;

        if (visible) {
            editor.call('gizmo:collision:visible', false);
            editor.call('viewport:pick:filter', filterPicker);
        } else {
            editor.call('viewport:pick:filter', null);
        }

        editor.emit('gizmo:zone:visible', visible);
        editor.call('viewport:render');
    });

    editor.once('viewport:load', function () {
        app = editor.call('viewport:app');
        if (! app) return; // webgl not available

        var container = new pc.Entity();
        container.name = 'zones';
        container.__editor = true;
        app.root.addChild(container);

        // entity gizmos
        var entities = { };
        var selected = { };

        // pool of gizmos
        var pool = [ ];
        var models = { };
        var poolModels = {
            'box': [ ]
        };
        var zones = 0;
        var lastZone = null;
        var historyPositon = new pc.Vec3();
        var historySize = new pc.Vec3();
        var points = [ ];
        var hoverPoint = null;
        var dragPoint = null;
        var dragLength = 0;
        var dragPos = new pc.Vec3();
        var dragGizmoType = '';
        var events = [ ];

        var vecA = new pc.Vec3();
        var vecB = new pc.Vec3();
        var vecC = new pc.Vec3();
        var vecD = new pc.Vec3();
        var quatA = new pc.Quat();
        var quatB = new pc.Quat();
        var quatC = new pc.Quat();

        var axesInd = { 'x': 0, 'y': 1, 'z': 2 };
        var axes = [ 'z', 'x', 'z', 'x', 'y', 'y' ];
        var direction = [ -1, 1, 1, -1, 1, -1 ];
        var eulers = [
            [ -90, 0, 0 ], // front
            [ 90, 90, 0 ], // right
            [ 90, 0, 0 ], // back
            [ 90, -90, 0 ], // left
            [ 0, 0, 0 ], // top
            [ 180, 0, 0 ]  // bottom
        ];
        var scales = [
            [ 'x', 'y', ], // front
            [ 'z', 'y', ], // right
            [ 'x', 'y', ], // back
            [ 'z', 'y', ], // left
            [ 'x', 'z', ], // top
            [ 'x', 'z', ]  // bottom
        ];
        var materials = [
            new pc.Color(0, 0, 1),
            new pc.Color(1, 0, 0),
            new pc.Color(0, 0, 1),
            new pc.Color(1, 0, 0),
            new pc.Color(0, 1, 0),
            new pc.Color(0, 1, 0)
        ];
        for(var i = 0; i < materials.length; i++) {
            var color = materials[i];
            materials[i] = new pc.BasicMaterial();
            materials[i].color = color;
            materials[i].update();
        }

        var alphaFront = 0.6;
        var alphaBehind = 0.1;
        var colorDefault = [ 1, 1, 1 ];
        var colorPrimary = new pc.Color(1, 1, 1, alphaFront);
        var colorBehind = new pc.Color(1, 1, 1, alphaBehind);
        var colorOccluder = new pc.Color(1, 1, 1, 1);

        // material
        var defaultVShader = ' \
            attribute vec3 aPosition;\n \
            attribute vec3 aNormal;\n \
            varying vec3 vNormal;\n \
            varying vec3 vPosition;\n \
            uniform float offset;\n \
            uniform mat4 matrix_model;\n \
            uniform mat3 matrix_normal;\n \
            uniform mat4 matrix_view;\n \
            uniform mat4 matrix_viewProjection;\n \
            void main(void)\n \
            {\n \
                vec4 posW = matrix_model * vec4(aPosition, 1.0);\n \
                vNormal = normalize(matrix_normal * aNormal);\n \
                posW += vec4(vNormal * offset, 0.0);\n \
                gl_Position = matrix_viewProjection * posW;\n \
                vPosition = posW.xyz;\n \
            }\n';
        var defaultFShader = ' \
            precision ' + app.graphicsDevice.precision + ' float;\n \
            varying vec3 vNormal;\n \
            varying vec3 vPosition;\n \
            uniform vec4 uColor;\n \
            uniform vec3 view_position;\n \
            void main(void)\n \
            {\n \
                vec3 viewNormal = normalize(view_position - vPosition);\n \
                float light = abs(dot(vNormal, viewNormal));\n \
                gl_FragColor = vec4(uColor.rgb * light * 2.0, uColor.a);\n \
            }\n';

        var shaderDefault;
        var materialDefault = new pc.BasicMaterial();
        materialDefault.updateShader = function(device) {
            if (! shaderDefault) {
                shaderDefault = new pc.Shader(device, {
                    attributes: {
                        aPosition: pc.SEMANTIC_POSITION,
                        aNormal: pc.SEMANTIC_NORMAL
                    },
                    vshader: defaultVShader,
                    fshader: defaultFShader
                });
            }

            this.shader = shaderDefault;
        };
        materialDefault.cull = pc.CULLFACE_NONE;
        materialDefault.color = colorPrimary;
        materialDefault.blend = true;
        materialDefault.blendSrc = pc.BLENDMODE_SRC_ALPHA;
        materialDefault.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        materialDefault.update();

        var materialBehind = new pc.BasicMaterial();
        materialBehind.updateShader = materialDefault.updateShader;
        materialBehind.color = colorBehind;
        materialBehind.blend = true;
        materialBehind.blendSrc = pc.BLENDMODE_SRC_ALPHA;
        materialBehind.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        materialBehind.depthWrite = false;
        materialBehind.depthTest = true;
        materialBehind.cull = pc.CULLFACE_NONE;
        materialBehind.update();

        var materialOccluder = new pc.BasicMaterial();
        materialOccluder.color = colorOccluder;
        materialOccluder.redWrite = false;
        materialOccluder.greenWrite = false;
        materialOccluder.blueWrite = false;
        materialOccluder.alphaWrite = false;
        materialOccluder.depthWrite = true;
        materialOccluder.depthTest = true;
        materialOccluder.cull = pc.CULLFACE_NONE;
        materialOccluder.update();

        var materialWireframe = new pc.BasicMaterial();
        materialWireframe.color = new pc.Color(1, 1, 1, 0.4);
        materialWireframe.depthWrite = false;
        materialWireframe.depthTest = false;
        materialWireframe.update();

        var materialPlaneBehind = new pc.BasicMaterial();
        materialPlaneBehind.color = new pc.Color(1, 1, 1, 0.4);
        materialPlaneBehind.blend = true;
        materialPlaneBehind.blendSrc = pc.BLENDMODE_SRC_ALPHA;
        materialPlaneBehind.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        materialPlaneBehind.cull = pc.CULLFACE_NONE;
        materialPlaneBehind.update();

        var materialPlane = new pc.BasicMaterial();
        materialPlane.color = new pc.Color(1, 1, 1, 0.1);
        materialPlane.blend = true;
        materialPlane.blendSrc = pc.BLENDMODE_SRC_ALPHA;
        materialPlane.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        materialPlane.depthTest = false;
        materialPlane.cull = pc.CULLFACE_NONE;
        materialPlane.update();

        var plane = new pc.Entity();
        plane.enabled = false;
        plane.__editor = true;
        plane.addComponent('model', {
            type: 'plane',
            receiveShadows: false,
            castShadowsLightmap: false,
            castShadows: false
        });
        var instance = plane.model.meshInstances[0];
        instance.material = materialPlane;
        var instanceBehind = new pc.MeshInstance(instance.node, instance.mesh, materialPlaneBehind);
        plane.model.meshInstances.push(instanceBehind);

        // gizmo class
        function Gizmo() {
            this._link = null;
            this.events = [ ];
            this.entity = null;
            this.type = '';
            this.color;
        }

        // update lines
        Gizmo.prototype.update = function() {
            if (! this._link || ! this._link.entity)
                return;

            var zone = this._link.entity.zone;
            var select = selected[this._link.get('resource_id')] === this._link;

            this.entity.enabled = this._link.entity.enabled && zone && zone.enabled && (select || visible);
            if (! this.entity.enabled)
                return;

            if (this.type !== 'box') {
                this.type = 'box';

                if (! this.color && this._link.entity) {
                    var hash = 0;
                    var string = this._link.entity._guid;
                    for(var i = 0; i < string.length; i++)
                        hash += string.charCodeAt(i);

                    this.color = editor.call('color:hsl2rgb', (hash % 128) / 128, 0.5, 0.5);
                }

                if (models[this.type]) {
                    var model = this.entity.model.model;
                    if (model) {
                        app.scene.removeModel(model);
                        this.entity.removeChild(model.getGraph());
                        poolModels[model._type].push(model);
                    }

                    model = poolModels[this.type].shift();
                    if (! model) {
                        model = models[this.type].clone();
                        model._type = this.type;

                        var color = this.color || colorDefault;

                        var old = model.meshInstances[0].material;
                        model.meshInstances[0].setParameter('offset', 0);
                        model.meshInstances[0].layer = 12;
                        model.meshInstances[0].updateKey();
                        model.meshInstances[0].__editor = true;
                        model.meshInstances[0].__zone = true;
                        model.meshInstances[0].material = old.clone();
                        model.meshInstances[0].material.updateShader = old.updateShader;
                        model.meshInstances[0].material.color.set(color[0], color[1], color[2], alphaFront);
                        model.meshInstances[0].material.update();

                        var old = model.meshInstances[1].material;
                        model.meshInstances[1].setParameter('offset', 0.001);
                        model.meshInstances[1].layer = 2;
                        model.meshInstances[1].pick = false;
                        model.meshInstances[1].updateKey();
                        model.meshInstances[1].__editor = true;
                        model.meshInstances[1].material = old.clone();
                        model.meshInstances[1].material.updateShader = old.updateShader;
                        model.meshInstances[1].material.color.set(color[0], color[1], color[2], alphaBehind);
                        model.meshInstances[1].material.update();

                        model.meshInstances[2].setParameter('offset', 0);
                        model.meshInstances[2].layer = 9;
                        model.meshInstances[2].pick = false;
                        model.meshInstances[2].updateKey();
                        model.meshInstances[2].__editor = true;
                    }

                    this.entity.model.model = model;
                    this.entity.enabled = true;
                } else {
                    this.entity.model.model = null;
                    this.entity.enabled = false;
                }
            }

            if (this.entity && this.entity.enabled) {
                this.entity.setLocalPosition(this._link.entity.getPosition());
                this.entity.setLocalRotation(this._link.entity.getRotation());
                this.entity.setLocalScale(this._link.entity.zone.size);
            }

            if (select) {
                zones++;
                lastZone = this;
            }
        };

        // link to entity
        Gizmo.prototype.link = function(obj) {
            this.unlink();
            this._link = obj;

            var self = this;

            this.events.push(this._link.once('destroy', function() {
                self.unlink();
            }));

            this.entity = new pc.Entity();
            this.entity.addComponent('model', {
                castShadows: false,
                receiveShadows: false,
                castShadowsLightmap: false
            });
            this.entity._getEntity = function() {
                return self._link.entity;
            };
            this.entity.setLocalScale(1, 1, 1);
            this.entity.__editor = true;

            container.addChild(this.entity);
        };

        // unlink
        Gizmo.prototype.unlink = function() {
            if (! this._link)
                return;

            for(var i = 0; i < this.events.length; i++)
                this.events[i].unbind();

            this.events = [ ];
            this._link = null;

            var model = this.entity.model.model;
            if (model) {
                // put back in pool
                app.scene.removeModel(model);
                this.entity.removeChild(model.getGraph());
                this.entity.model.model = null;
                poolModels[model._type].push(model);
            }

            container.removeChild(this.entity);
            this.entity = null;
            this.type = '';
        };

        var onPointFocus = function() {
            if (hoverPoint)
                hoverPoint.entity.model.meshInstances[0].material = materials[hoverPoint.ind];

            hoverPoint = this;
            hoverPoint.entity.model.meshInstances[0].material = materialDefault;
            plane.enabled = true;
        };

        var onPointBlur = function() {
            if (hoverPoint === this) {
                hoverPoint.entity.model.meshInstances[0].material = materials[hoverPoint.ind];
                hoverPoint = null;
                plane.enabled = false;
            }
        };

        var onPointDragStart = function() {
            if (! editor.call('permissions:write'))
                return;

            dragPoint = hoverPoint;
            dragLength = lastZone._link.entity.zone.size[dragPoint.axis];
            dragPos.copy(lastZone._link.entity.getLocalPosition());
            dragGizmoType = editor.call('gizmo:type');
            editor.call('gizmo:' + dragGizmoType + ':toggle', false);

            for(var i = 0; i < points.length; i++)
                points[i].entity.enabled = false;

            lastZone.entity.model.meshInstances[1].visible = false;
            editor.call('viewport:render');

            lastZone._link.history.enabled = false;

            var position = lastZone._link.get('position');
            var size = lastZone._link.get('components.zone.size');
            historyPositon.set(position[0], position[1], position[2]);
            historySize.set(size[0], size[1], size[2]);
        };

        var onPointDragEnd = function() {
            dragPoint = null;
            editor.call('gizmo:' + dragGizmoType + ':toggle', true);

            for(var i = 0; i < points.length; i++)
                points[i].entity.enabled = true;

            lastZone.entity.model.meshInstances[1].visible = true;
            editor.call('viewport:render');

            lastZone._link.history.enabled = true;

            var getItem = lastZone._link.history._getItemFn;

            var newPosition = lastZone._link.get('position');
            var newSize = lastZone._link.get('components.zone.size');

            var prevPosition = [ historyPositon.x, historyPositon.y, historyPositon.z ];
            var prevSize = [ historySize.x, historySize.y, historySize.z ];

            editor.call('history:add', {
                name: 'entity.zone',
                undo: function() {
                    var item = getItem();
                    if (! item) return;

                    item.history.enabled = false;
                    item.set('position', prevPosition);
                    item.set('components.zone.size', prevSize);
                    item.history.enabled = true;
                },
                redo: function() {
                    var item = getItem();
                    if (! item) return;

                    item.history.enabled = false;
                    item.set('position', newPosition);
                    item.set('components.zone.size', newSize);
                    item.history.enabled = true;
                }
            });
        };

        var onPointDragMove = function(length) {
            var size = Math.max(0.000000001, dragLength + length);
            lastZone._link.set('components.zone.size.' + axesInd[dragPoint.axis], size);

            quatA.copy(lastZone._link.entity.getRotation());
            vecA.set(0, 0, 0);
            vecA[dragPoint.axis] = (Math.max(0.000000001, dragLength + length * 0.5) - dragLength) * dragPoint.dir;
            quatA.transformVector(vecA, vecA);
            vecB.copy(dragPos).add(vecA);

            lastZone._link.set('position', [ vecB.x, vecB.y, vecB.z ]);

            pointsUpdate();
            editor.call('viewport:render');
        };

        var pointsCreate = function() {
            for(var i = 0; i < 6; i++) {
                var point = editor.call('gizmo:point:create', axes[i], null, direction[i]);
                point.ind = i;
                point.entity.model.meshInstances[0].material = materials[i];
                point.scale[scales[i][0]] = 2;
                point.scale[scales[i][1]] = 2;

                point.entity.enabled = editor.call('permissions:write');

                events.push(point.on('focus', onPointFocus));
                events.push(point.on('blur', onPointBlur));
                events.push(point.on('dragStart', onPointDragStart));
                events.push(point.on('dragEnd', onPointDragEnd));
                events.push(point.on('dragMove', onPointDragMove));
                points.push(point);
            }

            container.addChild(plane);
            editor.call('viewport:render');
        };

        editor.on('permissions:writeState', function(state) {
            if (! points || ! points.length)
                return;

            for(var i = 0; i < points.length; i++)
                points[i].entity.enabled = state;
        });

        var pointsDestroy = function() {
            for(var i = 0; i < points.length; i++)
                editor.call('gizmo:point:recycle', points[i]);

            for(var i = 0; i < events.length; i++)
                events[i].unbind();

            events = [ ];
            points = [ ];
            container.removeChild(plane);
        };

        var pointsUpdate = function() {
            var transform = lastZone.entity.getWorldTransform();
            var position = transform.getTranslation();
            var rotation = quatA.setFromMat4(transform);
            var scale = vecB.copy(lastZone._link.entity.zone.size.clone());

            // front
            vecA.set(0, 0, -0.5);
            transform.transformPoint(vecA, vecA);
            points[0].entity.setLocalPosition(vecA);
            points[0].entity.setLocalRotation(rotation);
            points[0].update();

            // right
            vecA.set(0.5, 0, 0);
            transform.transformPoint(vecA, vecA);
            points[1].entity.setLocalPosition(vecA);
            points[1].entity.setLocalRotation(rotation);
            points[1].update();

            // back
            vecA.set(0, 0, 0.5);
            transform.transformPoint(vecA, vecA);
            points[2].entity.setLocalPosition(vecA);
            points[2].entity.setLocalRotation(rotation);
            points[2].update();

            // left
            vecA.set(-0.5, 0, 0);
            transform.transformPoint(vecA, vecA);
            points[3].entity.setLocalPosition(vecA);
            points[3].entity.setLocalRotation(rotation);
            points[3].update();

            // top
            vecA.set(0, 0.5, 0);
            transform.transformPoint(vecA, vecA);
            points[4].entity.setLocalPosition(vecA);
            points[4].entity.setLocalRotation(rotation);
            points[4].update();

            // bottom
            vecA.set(0, -0.5, 0);
            transform.transformPoint(vecA, vecA);
            points[5].entity.setLocalPosition(vecA);
            points[5].entity.setLocalRotation(rotation);
            points[5].update();

            if (hoverPoint) {
                hoverPoint.rotation.copy(rotation);
                hoverPoint.position.copy(position);

                plane.setLocalPosition(hoverPoint.entity.getPosition());

                var angles = eulers[hoverPoint.ind];
                quatB.setFromEulerAngles(angles[0], angles[1], angles[2]);
                quatC.copy(rotation).mul(quatB);
                plane.setLocalRotation(quatC);

                var axes = scales[hoverPoint.ind];
                plane.setLocalScale(scale[axes[0]], 1, scale[axes[1]]);
            }
        };

        editor.on('entities:add', function(entity) {
            var key = entity.get('resource_id');

            var addGizmo = function() {
                if (entities[key])
                    return;

                var gizmo = pool.shift();
                if (! gizmo)
                    gizmo = new Gizmo();

                gizmo.link(entity);
                entities[key] = gizmo;

                editor.call('viewport:render');
            };

            var removeGizmo = function() {
                if (! entities[key])
                    return;

                pool.push(entities[key]);
                entities[key].unlink();
                delete entities[key];

                editor.call('viewport:render');
            };

            if (entity.has('components.zone'))
                addGizmo();

            entity.on('components.zone:set', addGizmo);
            entity.on('components.zone:unset', removeGizmo);

            entity.once('destroy', function() {
                removeGizmo();
            });
        });

        editor.on('selector:change', function(type, items) {
            selected = { };
            if (items) {
                for(var i = 0; i < items.length; i++)
                    selected[items[i].get('resource_id')] = items[i];
            }

            editor.call('viewport:render');
        });

        editor.on('viewport:gizmoUpdate', function(dt) {
            zones = 0;

            for(var key in entities)
                entities[key].update();

            if (zones === 1) {
                if (! points.length)
                    pointsCreate();

                pointsUpdate();
            } else if (points.length) {
                pointsDestroy();
            }

            if (dragPoint) {
                var camera = editor.call('camera:current');
                var transform = lastZone._link.entity.getWorldTransform();
                var rotation = lastZone.entity.getRotation();
                var position = dragPoint.entity.getLocalPosition();
                var scale = lastZone._link.entity.zone.size;

                var a = scales[dragPoint.ind];

                for(var i = 0; i < a.length; i++) {
                    for(var l = 0; l <= 2; l++) {
                        vecA.set(0, 0, 0);
                        vecA[a[i]] = scale[a[i]] * 0.5;
                        rotation.transformVector(vecA, vecA);

                        vecD.set(0, 0, 0);
                        vecD[a[i ? 0 : 1]] = scale[a[i ? 0 : 1]] * (l - 1) * 0.5;
                        rotation.transformVector(vecD, vecD);

                        vecB.copy(position).add(vecD).add(vecA);
                        vecC.copy(position).add(vecD).sub(vecA);

                        app.renderLine(vecB, vecC, colorBehind, pc.LINEBATCH_GIZMO);
                        app.renderLine(vecB, vecC, colorPrimary, pc.LINEBATCH_WORLD);
                    }
                }
            }
        });


        var createModels = function() {
            // ================
            // box
            var positions = [
                0.5, 0.5, 0.5,   0.5, 0.5, -0.5,   -0.5, 0.5, -0.5,   -0.5, 0.5, 0.5, // top
                0.5, 0.5, 0.5,   -0.5, 0.5, 0.5,   -0.5, -0.5, 0.5,   0.5, -0.5, 0.5, // front
                0.5, 0.5, 0.5,   0.5, -0.5, 0.5,   0.5, -0.5, -0.5,   0.5, 0.5, -0.5, // right
                0.5, 0.5, -0.5,   0.5, -0.5, -0.5,   -0.5, -0.5, -0.5,   -0.5, 0.5, -0.5, // back
                -0.5, 0.5, 0.5,   -0.5, 0.5, -0.5,   -0.5, -0.5, -0.5,   -0.5, -0.5, 0.5, // left
                0.5, -0.5, 0.5,   -0.5, -0.5, 0.5,   -0.5, -0.5, -0.5,   0.5, -0.5, -0.5 // bottom
            ];
            var normals = [
                0, 1, 0,   0, 1, 0,   0, 1, 0,   0, 1, 0,
                0, 0, 1,   0, 0, 1,   0, 0, 1,   0, 0, 1,
                1, 0, 0,   1, 0, 0,   1, 0, 0,   1, 0, 0,
                0, 0, -1,   0, 0, -1,   0, 0, -1,   0, 0, -1,
                -1, 0, 0,   -1, 0, 0,   -1, 0, 0,   -1, 0, 0,
                0, -1, 0,   0, -1, 0,   0, -1, 0,   0, -1, 0
            ];
            var indices = [
                0, 1, 2, 2, 3, 0,
                4, 5, 6, 6, 7, 4,
                8, 9, 10, 10, 11, 8,
                12, 13, 14, 14, 15, 12,
                16, 17, 18, 18, 19, 16,
                20, 21, 22, 22, 23, 20
            ];

            var mesh = pc.createMesh(app.graphicsDevice, positions, {
                normals: normals,
                indices: indices
            });

            var wireframePositions = [
                0.5, 0.5, 0.5,    0.5, 0.5, -0.5,   -0.5, 0.5, -0.5,   -0.5, 0.5, 0.5, // top
                0.5, 0.5, 0.5,   -0.5, 0.5, 0.5,    -0.5, -0.5, 0.5,    0.5, -0.5, 0.5, // front
                0.5, 0.5, 0.5,    0.5, -0.5, 0.5,    0.5, -0.5, -0.5,   0.5, 0.5, -0.5, // right
                0.5, 0.5, -0.5,  -0.5, 0.5, -0.5,   -0.5, -0.5, -0.5,   0.5, -0.5, -0.5, // back
                -0.5, 0.5, 0.5,   -0.5, -0.5, 0.5,   -0.5, -0.5, -0.5,  -0.5, 0.5, -0.5, // right
                0.5, -0.5, 0.5,   0.5, -0.5, -0.5,  -0.5, -0.5, -0.5,  -0.5, -0.5, 0.5 // bottom
            ];
            var meshWireframe = pc.createMesh(app.graphicsDevice, wireframePositions);
            meshWireframe.primitive[0].type = pc.PRIMITIVE_LINES;

            // node
            var node = new pc.GraphNode();
            // meshInstance
            var meshInstance = new pc.MeshInstance(node, mesh, materialDefault);
            meshInstance.layer = 12;
            meshInstance.__editor = true;
            meshInstance.castShadow = false;
            meshInstance.castLightmapShadow = false;
            meshInstance.receiveShadow = false;
            meshInstance.setParameter('offset', 0);
            meshInstance.updateKey();

            var meshInstanceBehind = new pc.MeshInstance(node, mesh, materialBehind);
            meshInstanceBehind.layer = 2;
            meshInstanceBehind.__editor = true;
            meshInstanceBehind.pick = false;
            meshInstanceBehind.drawToDepth = false;
            meshInstanceBehind.castShadow = false;
            meshInstanceBehind.castLightmapShadow = false;
            meshInstanceBehind.receiveShadow = false;
            meshInstanceBehind.setParameter('offset', 0);
            meshInstanceBehind.updateKey();

            var meshInstanceOccluder = new pc.MeshInstance(node, mesh, materialOccluder);
            meshInstanceOccluder.layer = 9;
            meshInstanceOccluder.__editor = true;
            meshInstanceOccluder.pick = false;
            meshInstanceOccluder.castShadow = false;
            meshInstanceOccluder.castLightmapShadow = false;
            meshInstanceOccluder.receiveShadow = false;
            meshInstanceOccluder.setParameter('offset', 0);
            meshInstanceOccluder.updateKey();

            var meshInstanceWireframe = new pc.MeshInstance(node, meshWireframe, materialWireframe);
            meshInstanceWireframe.layer = pc.LAYER_GIZMO;
            meshInstanceWireframe.__editor = true;
            meshInstanceWireframe.updateKey();
            // model
            var model = new pc.Model();
            model.graph = node;
            model.meshInstances = [ meshInstance, meshInstanceBehind, meshInstanceOccluder, meshInstanceWireframe ];

            models['box'] = model;
        };
        createModels();
    });
});


/* editor/gizmo/gizmo-screen.js */
editor.once('load', function() {
    'use strict';

    var left = new pc.Vec3();
    var right = new pc.Vec3();
    var top = new pc.Vec3();
    var bottom = new pc.Vec3();

    var corners = [];
    var cornerColors = [];

    var vecA = new pc.Vec2();

    var projectSettings = editor.call('settings:project');

    for (var i = 0; i < 8; i++) {
        corners.push(new pc.Vec3());
        cornerColors.push(new pc.Color(1, 1, 1));
    }

    editor.once('viewport:load', function (app) {
        var entities = {};

        // remember selected entities
        var selectedEntities = {};

        editor.on('selector:add', function (item, type) {
            if (type === 'entity') {
                selectedEntities[item.get('resource_id')] = true;
            }
        });

        editor.on('selector:remove', function (item, type) {
            if (type === 'entity') {
                delete selectedEntities[item.get('resource_id')];
            }
        });

        // Returns true if a child of the entity is selected
        var isChildSelected = function (entity) {
            var children = entity.get('children');
            for (var i = 0, len = children.length; i < len; i++) {
                if (selectedEntities[children[i]])
                    return true;
            }

            for (var i = 0, len = children.length; i < len; i++) {
                var child = editor.call('entities:get', children[i]);
                if (child && isChildSelected(child)) {
                    return true;
                }
            }

            return false;
        };

        editor.on('entities:add', function(entity) {
            var key = entity.get('resource_id');

            var addGizmo = function() {
                if (entities[key])
                    return;

                entities[key] = {
                    entity: entity
                };

                editor.call('viewport:render');
            };

            var removeGizmo = function() {
                if (! entities[key])
                    return;

                var e = app.root.findByGuid(key);
                if (e) {
                    // reset scale
                    var scale = entity.get('scale');
                    e.setLocalScale(scale[0], scale[1], scale[2]);

                    // reset rotation
                    var rotation = entity.get('rotation');
                    e.setLocalEulerAngles(rotation[0], rotation[1], rotation[2]);
                }

                delete entities[key];

                editor.call('viewport:render');
            };

            if (entity.has('components.screen'))
                addGizmo();

            entity.on('components.screen:set', addGizmo);
            entity.on('components.screen:unset', removeGizmo);

            entity.once('destroy', function() {
                removeGizmo();
            });
        });

        editor.on('viewport:gizmoUpdate', function (dt) {
            for (var key in entities) {
                var entity = app.root.findByGuid(key);
                if (! entity)
                    continue;

                var isScreenSpace = entities[key].entity.get('components.screen.screenSpace');

                // always render screens as 3d screens in the viewport
                if (isScreenSpace) {
                    entity.setLocalScale(0.01, 0.01, 0.01);
                    entity.setLocalEulerAngles(0, 0, 0);

                    if (entity.screen.screenSpace)
                        entity.screen.screenSpace = false;


                    var res = entity.screen.resolution;
                    var w = projectSettings.get('width');
                    var h = projectSettings.get('height');
                    vecA.set(w, h);

                    // reset resolution
                    if (res.x !== w || res.y !== h) {
                        entity.screen.resolution = vecA;
                    }

                    // reset scale mode
                    var scaleMode = entities[key].entity.get('components.screen.scaleMode');
                    if (entity.screen.scaleMode !== scaleMode) {
                        entity.screen._scaleMode = scaleMode;
                        entity.screen.resolution = vecA; // force update
                    }


                } else {
                    // reset scale that might have been
                    // changed if the screen used to be screen space
                    var scale = entities[key].entity.get('scale');
                    entity.setLocalScale(scale[0], scale[1], scale[2]);

                    var rotation = entities[key].entity.get('rotation');
                    entity.setLocalEulerAngles(rotation[0], rotation[1], rotation[2]);

                    // reset resolution
                    var res = entities[key].entity.get('components.screen.resolution');
                    var currentRes = entity.screen.resolution;
                    vecA.set(res[0], res[1]);
                    if (currentRes.x !== res[0] || currentRes.y !== res[1]) {
                        entity.screen.resolution = vecA;
                    }

                    // reset scale mode
                    if (entity.screen.scaleMode !== 'none') {
                        entity.screen.scaleMode = 'none';
                    }
                }

                // only render screen gizmo if it's selected
                // or a child is selected
                if (!selectedEntities[key] && !isChildSelected(entities[key].entity)) {
                    continue;
                }

                // calculate corners
                var position = entity.getPosition();
                var r = entity.right;
                var u = entity.up;
                var scale = entity.getLocalScale();
                var refResolution = entities[key].entity.get('components.screen.referenceResolution');

                vecA.set(refResolution[0], refResolution[1]);
                var screenScale = entity.screen.scaleMode === 'blend' ? entity.screen._calcScale(entity.screen.resolution, vecA) || Number.MIN_VALUE : 1;

                left
                    .copy(r)
                    .scale(-0.5 * entity.screen.resolution.x * scale.x / screenScale);

                right
                    .copy(r)
                    .scale(0.5 * entity.screen.resolution.x * scale.x / screenScale);

                top
                    .copy(u)
                    .scale(0.5 * entity.screen.resolution.y * scale.y / screenScale);

                bottom
                    .copy(u)
                    .scale(-0.5 * entity.screen.resolution.y * scale.y / screenScale);

                corners[0].copy(position).add(left).add(top);
                corners[1].copy(position).add(left).add(bottom);
                corners[2].copy(position).add(left).add(bottom);
                corners[3].copy(position).add(right).add(bottom);
                corners[4].copy(position).add(right).add(bottom);
                corners[5].copy(position).add(right).add(top);
                corners[6].copy(position).add(right).add(top);
                corners[7].copy(position).add(left).add(top);

                // render rectangle for screen
                app.renderLines(corners, cornerColors, pc.LINEBATCH_GIZMO);
            }
        });
    });
});


/* editor/gizmo/gizmo-element.js */
editor.once('load', function() {
    'use strict';

    var corners = [];
    var cornerColor = new pc.Color(1,1,1,0.9);

    for (var i = 0; i < 8; i++) {
        corners.push(new pc.Vec3());
    }

    editor.once('viewport:load', function (app) {
        editor.on('viewport:gizmoUpdate', function (dt) {
            var selected = editor.call('selector:itemsRaw');
            for (var i = 0, len = selected.length; i < len; i++) {
                var item = selected[i];

                var entity = item.entity;
                if (! entity || ! entity.element)
                    continue;

                var worldCorners = entity.element.worldCorners;

                corners[0].copy(worldCorners[0]);
                corners[1].copy(worldCorners[1]);
                corners[2].copy(worldCorners[1]);
                corners[3].copy(worldCorners[2]);
                corners[4].copy(worldCorners[2]);
                corners[5].copy(worldCorners[3]);
                corners[6].copy(worldCorners[3]);
                corners[7].copy(worldCorners[0]);

                app.renderLines(corners, cornerColor, pc.LINEBATCH_GIZMO);
            }
        });

    });
});


/* editor/gizmo/gizmo-element-anchor.js */
editor.once('load', function() {
    'use strict';

    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var vecC = new pc.Vec3();
    var vecD = new pc.Vec3();
    var quat = new pc.Quat();

    var gizmoAnchor = null;
    var evtTapStart = null;
    var moving = false;
    var mouseTap = null;
    var mouseTapMoved = false;
    var pickStart = new pc.Vec3();
    var posCameraLast = new pc.Vec3();
    var selectedEntity = null;
    var anchorDirty = false;
    var anchorStart = [];
    var anchorCurrent = [];
    var localPosition = [];
    var offset = new pc.Vec3();

    var createAnchorGizmo = function () {
        var obj = {
            root: null,
            handles: {
                tl: null,
                tr: null,
                bl: null,
                br: null
                // center: null
            },
            matActive: null,
            matInactive: null,
            handle: null
        };

        obj.root = new pc.Entity();
        obj.root.enabled = false;

        var c = 0.8;
        obj.matInactive = createMaterial(new pc.Color(c, c, c, 0.5));
        obj.matActive = createMaterial(new pc.Color(c, c, c, 1));

        var createCone = function (angle) {
            var result = new pc.Entity();
            result.setLocalEulerAngles(0, 0, angle);
            obj.root.addChild(result);

            var cone = new pc.Entity();
            cone.addComponent('model', {type: 'cone'});
            cone.model.castShadows = false;
            cone.model.receiveShadows = false;
            cone.model.meshInstances[0].material = obj.matInactive;
            cone.model.meshInstances[0].layer = pc.LAYER_GIZMO;
            cone.setLocalPosition(0, -0.5, 0);
            cone.setLocalScale(1, 1, 0.01);
            cone.handle = result;
            result.addChild(cone);

            result.handleModel = cone;

            return result;
        };

        obj.handles.tl = createCone(230);
        obj.handles.tr = createCone(130);
        obj.handles.bl = createCone(130+180);
        obj.handles.br = createCone(230+180);

        // obj.handles.center = new pc.Entity();
        // var sphere = new pc.Entity();
        // obj.handles.center.addChild(sphere);
        // sphere.addComponent('model', {type: 'sphere'});
        // sphere.model.castShadows = false;
        // sphere.model.receiveShadows = false;
        // sphere.model.meshInstances[0].material = obj.matInactive;
        // sphere.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        // sphere.setLocalPosition(0,0,0.1);
        // sphere.setLocalScale(0.5, 0.5, 0.5);
        // sphere.handle = obj.handles.center;
        // obj.handles.center.handleModel = sphere;
        // obj.root.addChild(obj.handles.center);

        return obj;
    };

    var createMaterial = function(color) {
        var mat = new pc.BasicMaterial();
        mat.color = color;
        if (color.a !== 1) {
            mat.blend = true;
            mat.blendSrc = pc.BLENDMODE_SRC_ALPHA;
            mat.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        }
        mat.update();
        return mat;
    };

    var setModelMaterial = function (entity, material) {
        if (entity.model.meshInstances[0].material !== material)
            entity.model.meshInstances[0].material = material;
    };

    editor.once('viewport:load', function (app) {
        var gizmoAnchor = createAnchorGizmo();
        app.root.addChild(gizmoAnchor.root);

        editor.on('selector:add', function (item, type) {
            if (type !== 'entity') return;

            if (! selectedEntity) {
                selectedEntity = item;
            }
        });

        editor.on('selector:remove', function (item, type) {
            if (selectedEntity === item) {
                selectedEntity = null;
            }
        });

        var isAnchorSplit = function (anchor) {
            return Math.abs(anchor[0] - anchor[2] > 0.001 || Math.abs(anchor[1] - anchor[3]) > 0.001);
        };

        var clamp = function (value, min, max) {
            return Math.min(Math.max(value, min), max);
        };

        var offsetAnchor = function (value, offset, min, max, snap) {
            value += offset;
            // value = Math.round(value / snap)  * snap;
            if (value < min + snap)
                value = min;
            else if (value > max - snap)
                value = max;
            return value;
        };

        var gizmoEnabled = function () {
            if (editor.call('selector:itemsRaw').length > 1)
                return false;

            return selectedEntity &&
                selectedEntity.has('components.element') &&
                editor.call('permissions:write') &&
                selectedEntity.entity &&
                selectedEntity.entity.element.screen;
        };

        editor.on('viewport:gizmoUpdate', function (dt) {
            gizmoAnchor.root.enabled = gizmoEnabled();
            if (! gizmoAnchor.root.enabled)
                return;

            var entity = selectedEntity.entity;
            var parent = entity.parent && entity.parent.element ? entity.parent : entity.element.screen;


            var camera = editor.call('camera:current');
            var posCamera = camera.getPosition();

            gizmoAnchor.root.setPosition(parent.getPosition());
            gizmoAnchor.root.setRotation(parent.getRotation());

            // scale to screen space
            var scale = 1;
            var gizmoSize = 0.2;
            if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
                var center = vecA;
                center.lerp(gizmoAnchor.handles.bl.getPosition(), gizmoAnchor.handles.tr.getPosition(), 0.5);
                var dot = center.sub(posCamera).dot(camera.forward);
                var denom = 1280 / (2 * Math.tan(camera.camera.fov * pc.math.DEG_TO_RAD / 2));
                scale = Math.max(0.0001, (dot / denom) * 150) * gizmoSize;
            } else {
                scale = camera.camera.orthoHeight / 3 * gizmoSize;
            }

            gizmoAnchor.handles.tr.setLocalScale(scale, scale, scale);
            gizmoAnchor.handles.tl.setLocalScale(scale, scale, scale);
            gizmoAnchor.handles.br.setLocalScale(scale, scale, scale);
            gizmoAnchor.handles.bl.setLocalScale(scale, scale, scale);
            // gizmoAnchor.handles.center.setLocalScale(scale, scale, scale);

            // scale snap by gizmo scale
            var snapIncrement = 0.05 * scale;

            var resX, resY;
            if (parent === entity.element.screen) {
                resX = parent.screen.resolution.x;
                resY = parent.screen.resolution.y;

                if (parent.screen.scaleMode === 'blend') {
                    var resScale = parent.screen._calcScale(parent.screen.resolution, parent.screen.referenceResolution) || Number.MIN_VALUE;
                    resX /= resScale;
                    resY /= resScale;
                }
            } else {
                resX = parent.element.width;
                resY = parent.element.height;
            }

            var screenScale = entity.element.screen ? entity.element.screen.getLocalScale() : parent.getLocalScale();
            resX *= screenScale.x;
            resY *= screenScale.y;

            offset.set(0, 0, 0);
            if (moving && (vecA.copy(posCameraLast).sub(posCamera).length() > 0.01 || mouseTapMoved)) {
                offset = pickPlane(mouseTap.x, mouseTap.y);
                if (offset) {
                    offset.sub(pickStart);
                    anchorDirty = true;

                    for (var i = 0; i < 4; i++)
                        anchorCurrent[i] = anchorStart[i];

                    if (gizmoAnchor.handle === gizmoAnchor.handles.tr || gizmoAnchor.handle === gizmoAnchor.handles.tl) {
                        anchorCurrent[3] = offsetAnchor(anchorCurrent[3], offset.y / resY, anchorCurrent[1], 1, snapIncrement);
                        if (gizmoAnchor.handle === gizmoAnchor.handles.tr) {
                            anchorCurrent[2] = offsetAnchor(anchorCurrent[2], offset.x / resX, anchorCurrent[0], 1, snapIncrement);
                        } else {
                            anchorCurrent[0] = offsetAnchor(anchorCurrent[0], offset.x / resX, 0, anchorCurrent[2], snapIncrement);
                        }
                    } else if (gizmoAnchor.handle === gizmoAnchor.handles.br || gizmoAnchor.handle === gizmoAnchor.handles.bl) {
                        anchorCurrent[1] = offsetAnchor(anchorCurrent[1], offset.y / resY, 0, anchorCurrent[3], snapIncrement);
                        if (gizmoAnchor.handle === gizmoAnchor.handles.br) {
                            anchorCurrent[2] = offsetAnchor(anchorCurrent[2], offset.x / resX, anchorCurrent[0], 1, snapIncrement);
                        } else {
                            anchorCurrent[0] = offsetAnchor(anchorCurrent[0], offset.x / resX, 0, anchorCurrent[2], snapIncrement);
                        }
                    }
                    // else if (gizmoAnchor.handle === gizmoAnchor.handles.center) {
                    //     var dx = anchorCurrent[2] - anchorCurrent[0];
                    //     var dy = anchorCurrent[3] - anchorCurrent[1];

                    //     anchorCurrent[0] = clamp(anchorCurrent[0] + offset.x / resX, 0, 1 - dx);
                    //     anchorCurrent[2] = clamp(anchorCurrent[2] + offset.x / resX, dx, 1);
                    //     anchorCurrent[1] = clamp(anchorCurrent[1] + offset.y / resY, 0, 1 - dy);
                    //     anchorCurrent[3] = clamp(anchorCurrent[3] + offset.y / resY, dy, 1);
                    // }

                    selectedEntity.set('components.element.anchor', anchorCurrent);
                }

                editor.call('viewport:render');
            }

            posCameraLast.copy(posCamera);
            mouseTapMoved = false;

            var anchor = entity.element.anchor;

            gizmoAnchor.handles.tl.setLocalPosition(resX * (anchor.x - 0.5), resY * (anchor.w - 0.5), 0);
            gizmoAnchor.handles.tr.setLocalPosition(resX * (anchor.z - 0.5), resY * (anchor.w - 0.5), 0);
            gizmoAnchor.handles.bl.setLocalPosition(resX * (anchor.x - 0.5), resY * (anchor.y - 0.5), 0);
            gizmoAnchor.handles.br.setLocalPosition(resX * (anchor.z - 0.5), resY * (anchor.y - 0.5), 0);

            // gizmoAnchor.handles.center.setLocalPosition(resX * (pc.math.lerp(anchor.x,anchor.z,0.5) - 0.5), resY * (pc.math.lerp(anchor.y,anchor.w,0.5) - 0.5), 0, 0.1);
        });

        editor.on('viewport:pick:hover', function(node, picked) {
            if (! node || ! node.handle) {
                if (gizmoAnchor.handle) {
                    gizmoAnchor.handle = null;

                    for (var key in gizmoAnchor.handles) {
                        setModelMaterial(gizmoAnchor.handles[key].handleModel, gizmoAnchor.matInactive);
                    }

                    if (evtTapStart) {
                        evtTapStart.unbind();
                        evtTapStart = null;
                    }
                }
            } else {
                if (! gizmoAnchor.handle || gizmoAnchor.handle !== node.handle) {
                    gizmoAnchor.handle = node.handle;

                    for (var key in gizmoAnchor.handles) {
                        setModelMaterial(gizmoAnchor.handles[key].handleModel, gizmoAnchor.handles[key] === gizmoAnchor.handle ? gizmoAnchor.matActive : gizmoAnchor.matInactive);
                    }

                    if (! evtTapStart) {
                        evtTapStart = editor.on('viewport:tap:start', onTapStart);
                    }
                }
            }
        });

        var onTapStart = function (tap) {
            if (moving || tap.button !== 0)
                return;

            editor.emit('camera:toggle', false);
            editor.call('viewport:pick:state', false);

            moving = true;
            mouseTap = tap;
            anchorDirty = false;

            if (gizmoAnchor.root.enabled) {
                pickStart.copy(pickPlane(tap.x, tap.y));
            }

            if (selectedEntity) {
                selectedEntity.history.enabled = false;

                anchorStart = selectedEntity.get('components.element.anchor').slice(0);
            }

            editor.call('gizmo:translate:visible', false);
            editor.call('gizmo:rotate:visible', false);
            editor.call('gizmo:scale:visible', false);
        };

        var onTapMove = function(tap) {
            if (! moving)
                return;

            mouseTap = tap;
            mouseTapMoved = true;
        };

        var onTapEnd = function(tap) {
            if (tap.button !== 0)
                return;

            editor.emit('camera:toggle', true);

            if (! moving)
                return;

            moving = false;
            mouseTap = tap;

            editor.call('gizmo:translate:visible', true);
            editor.call('gizmo:rotate:visible', true);
            editor.call('gizmo:scale:visible', true);
            editor.call('viewport:pick:state', true);

            // update entity anchor
            if (selectedEntity) {
                if (anchorDirty) {
                    var resourceId = selectedEntity.get('resource_id');
                    var previousAnchor = anchorStart.slice(0);
                    var newAnchor = anchorCurrent.slice(0);

                    editor.call('history:add', {
                        name: 'entity.element.anchor',
                        undo: function() {
                            var item = editor.call('entities:get', resourceId);
                            if (! item)
                                return;

                            var history = item.history.enabled;
                            item.history.enabled = false;
                            item.set('components.element.anchor', previousAnchor);
                            item.history.enabled = history;
                        },
                        redo: function() {
                            var item = editor.call('entities:get', resourceId);
                            if (! item)
                                return;

                            var history = item.history.enabled;
                            item.history.enabled = false;
                            item.set('components.element.anchor', newAnchor);
                            item.history.enabled = history;
                        }
                    });
                }

                selectedEntity.history.enabled = true;
            }
        };

        var pickPlane = function(x, y) {
            var camera = editor.call('camera:current');

            var mouseWPos = camera.camera.screenToWorld(x, y, camera.camera.farClip);
            var posGizmo = gizmoAnchor.root.getPosition();
            var rayOrigin = vecA.copy(camera.getPosition());
            var rayDirection = vecB.set(0, 0, 0);

            vecC.copy(gizmoAnchor.root.forward);
            var planeNormal = vecC.scale(-1);

            if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
                rayDirection.copy(mouseWPos).sub(rayOrigin).normalize();
            } else {
                rayOrigin.add(mouseWPos);
                camera.getWorldTransform().transformVector(vecD.set(0, 0, -1), rayDirection);
            }

            var rayPlaneDot = planeNormal.dot(rayDirection);
            var planeDist = posGizmo.dot(planeNormal);
            var pointPlaneDist = (planeNormal.dot(rayOrigin) - planeDist) / rayPlaneDot;
            var pickedPos = rayDirection.scale(-pointPlaneDist).add(rayOrigin);

            // convert pickedPos to local position relative to the gizmo
            quat.copy(gizmoAnchor.root.getRotation()).invert().transformVector(pickedPos, pickedPos);

            return pickedPos;
        };

        editor.on('viewport:tap:move', onTapMove);
        editor.on('viewport:tap:end', onTapEnd);

    });
});


/* editor/gizmo/gizmo-element-size.js */
editor.once('load', function() {
    'use strict';

    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var vecC = new pc.Vec3();
    var vecD = new pc.Vec3();

    var selectedEntity = null;

    var evtTapStart = null;
    var moving = false;
    var mouseTap = null;
    var mouseTapMoved = false;
    var pickStart = new pc.Vec3();
    var posCameraLast = new pc.Vec3();

    var posStart = [];
    var posCurrent = [];
    var sizeStart = [0,0];
    var sizeCurrent = [0,0];
    var startWorldCorners = [new pc.Vec3(), new pc.Vec3(), new pc.Vec3(), new pc.Vec3()];
    var worldToEntitySpace = new pc.Mat4();
    var entitySpaceToParentSpace = new pc.Mat4();
    var dirty = false;

    var offset = new pc.Vec3();
    var localOffset = new pc.Vec3();
    var offsetWithPivot = new pc.Vec3();

    var createGizmo = function () {
        var obj = {
            root: null,
            handles: [null, null, null, null],
            matActive: null,
            matInactive: null,
            handle: null
        };

        obj.root = new pc.Entity();
        obj.root.enabled = false;

        obj.matInactive = createMaterial(new pc.Color(1, 1, 0, 0.5));
        obj.matActive = createMaterial(new pc.Color(1, 1, 0, 1));

        var createHandle = function () {
            var sphere = new pc.Entity();
            sphere.addComponent('model', {type: 'sphere'});
            sphere.model.castShadows = false;
            sphere.model.receiveShadows = false;
            sphere.model.meshInstances[0].material = obj.matInactive;
            sphere.model.meshInstances[0].layer = pc.LAYER_GIZMO;
            sphere.setLocalScale(0.5, 0.5, 0.5);
            obj.root.addChild(sphere);
            return sphere;
        };

        for (var i = 0; i < 4; i++)
            obj.handles[i] = createHandle();

        return obj;
    };

    var createMaterial = function(color) {
        var mat = new pc.BasicMaterial();
        mat.color = color;
        if (color.a !== 1) {
            mat.blend = true;
            mat.blendSrc = pc.BLENDMODE_SRC_ALPHA;
            mat.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        }
        mat.update();
        return mat;
    };

    var gizmoEnabled = function () {
        if (editor.call('gizmo:type') === 'resize' && editor.call('permissions:write') && editor.call('selector:itemsRaw').length === 1) {
            return (selectedEntity && selectedEntity.has('components.element') && selectedEntity.entity);
        }

        return false;
    };

    editor.once('viewport:load', function (app) {
        var gizmo = createGizmo();
        app.root.addChild(gizmo.root);

        editor.on('selector:add', function (item, type) {
            if (type !== 'entity') return;

            if (! selectedEntity) {
                selectedEntity = item;
            }
        });

        editor.on('selector:remove', function (item, type) {
            if (selectedEntity === item) {
                selectedEntity = null;
            }
        });

        editor.on('viewport:gizmoUpdate', function (dt) {
            gizmo.root.enabled = gizmoEnabled();
            if (! gizmo.root.enabled)
                return;

            var entity = selectedEntity.entity;

            // scale to screen space
            var scale = 1;
            var gizmoSize = 0.2;
            var camera = editor.call('camera:current');
            var posCamera = camera.getPosition();
            var worldCorners = entity.element.worldCorners;

            var parent = entity.parent && entity.parent.element ? entity.parent : entity.element.screen;

            for (var i = 0; i < 4; i++) {
                if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
                    var dot = vecA.copy(worldCorners[i]).sub(posCamera).dot(camera.forward);
                    var denom = 1280 / (2 * Math.tan(camera.camera.fov * pc.math.DEG_TO_RAD / 2));
                    scale = Math.max(0.0001, (dot / denom) * 150) * gizmoSize;
                } else {
                    scale = camera.camera.orthoHeight / 3 * gizmoSize;
                }

                gizmo.handles[i].setPosition(worldCorners[i]);
                gizmo.handles[i].setLocalScale(scale, scale, scale);
            }

            if (moving && (vecA.copy(posCameraLast).sub(posCamera).length() > 0.01 || mouseTapMoved)) {
                offset = pickPlane(mouseTap.x, mouseTap.y);
                // app.renderLines([pickStart, offset], new pc.Color(1, 0, 0));
                if (offset) {
                    dirty = true;

                    posCurrent[0] = posStart[0];
                    posCurrent[1] = posStart[1];
                    posCurrent[2] = posStart[2];
                    sizeCurrent[0] = sizeStart[0];
                    sizeCurrent[1] = sizeStart[1];

                    var pivot = entity.element.pivot;
                    var px, py, sx, sy;

                    // bottom left
                    if (gizmo.handle === gizmo.handles[0]) {
                        px = 1 - pivot.x;
                        py = 1 - pivot.y;
                        sx = -1;
                        sy = -1;
                    }
                    // bottom right
                    else if (gizmo.handle === gizmo.handles[1]) {
                        px = pivot.x;
                        py = 1 - pivot.y;
                        sx = 1;
                        sy = -1;
                    }
                    // top right
                    else if (gizmo.handle === gizmo.handles[2]) {
                        px = pivot.x;
                        py = pivot.y;
                        sx = 1;
                        sy = 1;
                    }
                    // top left
                    else if (gizmo.handle === gizmo.handles[3]) {
                        px = 1 - pivot.x;
                        py = pivot.y;
                        sx = -1;
                        sy = 1;
                    }

                    // world space offset
                    offset.sub(pickStart);
                    // offset in element space
                    worldToEntitySpace.transformVector(offset, localOffset);

                    // position changes based on the pivot - calculate the
                    // offset in element space after applying pivot
                    offsetWithPivot.set(px * localOffset.x, py * localOffset.y, 0);
                    // transform result to world space and then to element parent space
                    entitySpaceToParentSpace.transformVector(offsetWithPivot, offsetWithPivot);

                    // apply offset
                    posCurrent[0] += offsetWithPivot.x;
                    posCurrent[1] += offsetWithPivot.y;
                    posCurrent[2] += offsetWithPivot.z;

                    // apply size change
                    sizeCurrent[0] += sx * localOffset.x;
                    sizeCurrent[1] += sy * localOffset.y;

                    selectedEntity.set('position', posCurrent);
                    selectedEntity.set('components.element.width', sizeCurrent[0]);
                    selectedEntity.set('components.element.height', sizeCurrent[1]);
                }

                editor.call('viewport:render');
            }

            posCameraLast.copy(posCamera);
            mouseTapMoved = false;

        });

        editor.on('viewport:pick:hover', function(node, picked) {
            if (! node || gizmo.handles.indexOf(node) === -1) {
                if (gizmo.handle) {
                    gizmo.handle = null;

                    for (var i = 0; i < 4; i++) {
                        gizmo.handles[i].model.meshInstances[0].material = gizmo.matInactive;
                    }

                    if (evtTapStart) {
                        evtTapStart.unbind();
                        evtTapStart = null;
                    }
                }
            } else if (! gizmo.handle || gizmo.handle !== node) {

                gizmo.handle = node;

                for (var i = 0; i < 4; i++) {
                    gizmo.handles[i].model.meshInstances[0].material = (gizmo.handles[i] === node ? gizmo.matActive : gizmo.matInactive);
                }

                if (! evtTapStart) {
                    evtTapStart = editor.on('viewport:tap:start', onTapStart);
                }
            }
        });


        var onTapStart = function (tap) {
            if (moving || tap.button !== 0)
                return;

            editor.emit('camera:toggle', false);
            editor.call('viewport:pick:state', false);

            moving = true;
            mouseTap = tap;
            dirty = false;

            if (selectedEntity) {
                selectedEntity.history.enabled = false;

                posStart = selectedEntity.get('position').slice(0);
                sizeStart[0] = selectedEntity.get('components.element.width');
                sizeStart[1] = selectedEntity.get('components.element.height');
                worldToEntitySpace.copy(selectedEntity.entity.getWorldTransform()).invert();
                entitySpaceToParentSpace.copy(selectedEntity.entity.parent.getWorldTransform()).invert().mul(selectedEntity.entity.getWorldTransform());

                for (var i = 0; i < 4; i++)
                    startWorldCorners[i].copy(selectedEntity.entity.element.worldCorners[i]);

            }

            if (gizmo.root.enabled) {
                pickStart.copy(pickPlane(tap.x, tap.y));
            }

            editor.call('gizmo:translate:visible', false);
            editor.call('gizmo:rotate:visible', false);
            editor.call('gizmo:scale:visible', false);
        };

        var onTapMove = function(tap) {
            if (! moving)
                return;

            mouseTap = tap;
            mouseTapMoved = true;
        };

        var onTapEnd = function(tap) {
            if (tap.button !== 0)
                return;

            editor.emit('camera:toggle', true);

            if (! moving)
                return;

            moving = false;
            mouseTap = tap;

            editor.call('gizmo:translate:visible', true);
            editor.call('gizmo:rotate:visible', true);
            editor.call('gizmo:scale:visible', true);
            editor.call('viewport:pick:state', true);

            if (selectedEntity) {
                if (dirty) {
                    var resourceId = selectedEntity.get('resource_id');
                    var previousPos = posStart.slice(0);
                    var newPos = posCurrent.slice(0);
                    var previousSize = sizeStart.slice(0);
                    var newSize = sizeCurrent.slice(0);

                    editor.call('history:add', {
                        name: 'entity.element.size',
                        undo: function() {
                            var item = editor.call('entities:get', resourceId);
                            if (! item)
                                return;

                            var history = item.history.enabled;
                            item.history.enabled = false;
                            item.set('position', previousPos);
                            item.set('components.element.width', previousSize[0]);
                            item.set('components.element.height', previousSize[1]);
                            item.history.enabled = history;
                        },
                        redo: function() {
                            var item = editor.call('entities:get', resourceId);
                            if (! item)
                                return;

                            var history = item.history.enabled;
                            item.history.enabled = false;
                            item.set('position', newPos);
                            item.set('components.element.width', newSize[0]);
                            item.set('components.element.height', newSize[1]);
                            item.history.enabled = history;
                        }
                    });
                }

                selectedEntity.history.enabled = true;
            }
        };

        var pickPlane = function(x, y) {
            var camera = editor.call('camera:current');
            var entity = selectedEntity.entity;

            var posEntity = startWorldCorners[gizmo.handles.indexOf(gizmo.handle)];
            var posMouse = camera.camera.screenToWorld(x, y, 1);
            var rayOrigin = vecA.copy(camera.getPosition());
            var rayDirection = vecB.set(0, 0, 0);

            vecC.copy(entity.forward);
            var planeNormal = vecC.scale(-1);

            if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
                rayDirection.copy(posMouse).sub(rayOrigin).normalize();
            } else {
                rayOrigin.add(posMouse);
                camera.getWorldTransform().transformVector(vecD.set(0, 0, -1), rayDirection);
            }

            var rayPlaneDot = planeNormal.dot(rayDirection);
            var planeDist = posEntity.dot(planeNormal);
            var pointPlaneDist = (planeNormal.dot(rayOrigin) - planeDist) / rayPlaneDot;
            var pickedPos = rayDirection.scale(-pointPlaneDist).add(rayOrigin);

            return pickedPos;
        };

        editor.on('viewport:tap:move', onTapMove);
        editor.on('viewport:tap:end', onTapEnd);

    });
});


/* editor/users/users.js */
editor.once('load', function() {
    'use strict';

    var users = { };
    var userRequests = { };

    // Loads a user from the server
    editor.method('users:loadOne', function (id, callback) {
        if (users[id])
            return callback(users[id]);

        if (userRequests[id])
            return userRequests[id].push(callback);

        userRequests[id] = [ callback ];

        Ajax({
            url: '{{url.api}}/users/' + id,
            auth: true
        })
            .on('load', function (status, data) {
                users[id] = data;

                for(var i = 0; i < userRequests[id].length; i++)
                    userRequests[id][i](data);

                delete userRequests[id];
            });
    });

    editor.method('users:get', function(id) {
        return users[id] || null;
    });
});


/* editor/users/users-usage.js */
editor.once('load', function () {
    'use strict';

    editor.on('messenger:user.usage', function (data) {
        if (data.user !== config.owner.id) return;

        config.owner.size += data.usage.total;

        editor.emit('user:' + config.owner.id + ':usage', config.owner.size);
    });
});


/* editor/users/users-flags.js */
editor.once("load", function () {
    'use strict';

    editor.method('users:isBetaTester', function (flag) {
        return (config.self && (config.self.betaTester || config.self.superUser));
    });

    editor.method('users:isSuperUser', function (flag) {
        return (config.self && config.self.superUser);
    });
});


/* editor/settings/project-facebook-settings-attributes.js */
editor.once('load', function() {
    'use strict';

    if (!config.self.superUser && !config.self.publishFacebook)
        return;

    var foldStates = {
        'facebook': true
    };

    var settings = editor.call('settings:projectPrivate');

    var originalTokenHelp;
    var originalAppIdHelp;

    editor.on('attributes:inspect[editorSettings]', function() {

        var panel = editor.call('attributes:addPanel', {
            name: 'Facebook'
        });
        panel.foldable = true;
        panel.folded = foldStates['facebook'];
        panel.on('fold', function() { foldStates['facebook'] = true; });
        panel.on('unfold', function() { foldStates['facebook'] = false; });
        panel.hidden = !editor.call('permissions:write');
        panel.class.add('component', 'facebook');

        // reference
        editor.call('attributes:reference:attach', 'settings:facebook', panel, panel.headerElement);

        var fieldFbAppId = editor.call('attributes:addField', {
            parent: panel,
            name: 'App ID',
            type: 'string',
            link: settings,
            path: 'facebook.appId'
        });
        var tooltip = editor.call('attributes:reference:attach', 'settings:facebook:app-id', fieldFbAppId.parent.innerElement.firstChild.ui);
        var appIdParagraph = tooltip.innerElement.querySelector('p')
        if (! originalAppIdHelp)
            originalAppIdHelp = appIdParagraph.innerHTML;

        appIdParagraph.innerHTML = originalAppIdHelp + ' Click <a href="https://developers.facebook.com/apps/" target="_blank">here</a> to see all your Facebook applications.';

        var fieldFbUploadToken = editor.call('attributes:addField', {
            parent: panel,
            name: 'Upload Token',
            type: 'string',
            link: settings,
            path: 'facebook.uploadToken'
        });
        tooltip = editor.call('attributes:reference:attach', 'settings:facebook:upload-token', fieldFbUploadToken.parent.innerElement.firstChild.ui);

        var fieldSdk = editor.call('attributes:addField', {
            parent: panel,
            name: 'SDK Version',
            type: 'string'
        });

        fieldSdk.value = settings.get('facebook.sdkVersion');
        fieldSdk.class.add('facebook-version');
        fieldSdk.renderChanges = false;

        // ref
        editor.call('attributes:reference:attach', 'settings:facebook:sdk-version', fieldSdk.parent.innerElement.firstChild.ui);

        // version should be in this form: 1.0 or 1.0.4 etc.
        var versionRegex = /^[0-9]+(\.[0-9]+)+$/;

        var changingVersion = false;

        // check if version exists and if so set it
        var setVersion = function (version) {
            if (versions.indexOf(version) === -1) {
                (new AjaxRequest({
                    method: 'GET',
                    url: '/editor/facebook/version/' + version,
                    notJson: true
                }))
                    .on('load', function () {
                        settings.set('facebook.sdkVersion', version);
                    })
                    .on('error', function () {
                        fieldSdk.class.add('error');
                    });
            } else {
                settings.set('facebook.sdkVersion', version);
            }
        };

        fieldSdk.on('change', function (value) {
            if (! value) {
                fieldSdk.value = settings.get('facebook.sdkVersion') || config.facebook.version;
            } else if (! versionRegex.test(value)) {
                fieldSdk.class.add('error');
            } else {
                fieldSdk.class.remove('error');

                if (! changingVersion) {
                    setVersion(value);
                }
            }

            if (! changingVersion)
                list.hidden = true;
        });

        settings.on('facebook.sdkVersion:set', function (value) {
            changingVersion = true;
            fieldSdk.value = value;
            changingVersion = false;

            fieldSdk.class.remove('error');
        });

        fieldSdk.elementInput.addEventListener('click', function () {
            list.hidden = false;
        });

        fieldSdk.elementInput.addEventListener('keydown', function (e) {
            // up arrow
            if (e.keyCode === 38) {
                e.preventDefault();
                e.stopPropagation();

                listItems[focused].class.remove('focused');

                focused--;
                if (focused < 0)
                    focused = listItems.length - 1;

                listItems[focused].class.add('focused');

                changingVersion = true;
                fieldSdk.value = versions[focused];
                changingVersion = false;
            }
            // down arrow
            else if (e.keyCode === 40) {
                e.preventDefault();
                e.stopPropagation();

                listItems[focused].class.remove('focused');

                focused++;
                if (focused >= listItems.length)
                    focused = 0;

                listItems[focused].class.add('focused');

                changingVersion = true;
                fieldSdk.value = versions[focused];
                changingVersion = false;
            }
            // enter
            else if (e.keyCode === 13) {
                var val = fieldSdk.value;
                var focusedVal = versions[focused];
                // if we have the same value as the field
                // then call setVersion otherwise it will be handled
                // by the 'change' event of the field
                if (val === focusedVal) {
                    setVersion(focusedVal);
                    list.hidden = true;
                }
            }
            // esc
            else if (e.keyCode === 27) {
                fieldSdk.value = settings.get('facebook.sdkVersion');
                list.hidden = true;
            }
        });

        var list = new ui.List();
        list.class.add('facebook-versions');
        list.hidden = true;
        fieldSdk.element.appendChild(list.element);

        var versions = ['1.0', '2.0', '2.1'];
        var listItems = [];
        var focused = 0;

        var hideList = function (e) {
            var el = e.target;
            var found = false;
            while (el) {
                if (el === fieldSdk.element) {
                    found = true;
                    break;
                }

                el = el.parentElement;
            }

            if (! found) {
                list.hidden = true;
                fieldSdk.value = settings.get('facebook.sdkVersion');
            }
        };

        list.on('show', function () {
            window.addEventListener('mousedown', hideList);

            listItems.forEach(function (item, index) {
                if (versions[index] === fieldSdk.value) {
                    focused = index;
                    item.class.add('focused');
                } else {
                    item.class.remove('focused');
                }
            });
        });
        list.on('hide', function () {
            window.removeEventListener('mousedown', hideList);
        });

        var createListItem = function (version) {
            var item = new ui.ListItem({
                text: version
            });
            list.append(item);

            item.on('click', function () {
                fieldSdk.value = version;
                list.hidden = true;
            });

            listItems.push(item);
        };

        versions.forEach(createListItem);

        var tokenParagraph = tooltip.innerElement.querySelector('p');
        if (! originalTokenHelp)
            originalTokenHelp = tokenParagraph.innerHTML;

        var getTokenText = function () {
            return originalTokenHelp + ' You can find this under the ' + (settings.get('facebook.appId') ? '<a href="https://developers.facebook.com/apps/' + settings.get('facebook.appId') + '/hosting/" target="_blank">Canvas Hosting Page</a>' : 'Canvas Hosting page') + ' at the dashboard of your Facebook application.';
        };

        tokenParagraph.innerHTML = getTokenText();

        var evtAppId = settings.on('facebook.appId:set', function (value) {
            tokenParagraph.innerHTML = getTokenText();
        });

        var evtPermissions = editor.on('permissions:set:' + config.self.id, function (accesslevel) {
            panel.hidden = !editor.call('permissions:write');
        });

        panel.on('destroy', function () {
            evtPermissions.unbind();
            evtAppId.unbind();
        });
    });
});


/* editor/assets/assets.js */
/*

NAMESPACE
    asset

METHODS
    add
    remove
    get
    find
    findOne

EVENTS
    add
    remove

*/

editor.once('load', function() {
    'use strict';

    var assets = new ObserverList({
        index: 'id',
        sorted: function(a, b) {
            var f = (b._data['type'] === 'folder') - (a._data['type'] === 'folder');

            if (f !== 0)
                return f;

            if (a._data['name'].toLowerCase() > b._data['name'].toLowerCase()) {
                return 1;
            } else if (a._data['name'].toLowerCase() < b._data['name'].toLowerCase()) {
                return -1;
            } else {
                return 0;
            }
        }
    });


    // return assets ObserverList
    editor.method('assets:raw', function() {
        return assets;
    });

    // allow adding assets
    editor.method('assets:add', function(asset) {
        var pos = assets.add(asset);

        if (pos === null)
            return;

        asset.on('name:set', function(name, nameOld) {
            name = name.toLowerCase();
            nameOld = nameOld.toLowerCase();

            var ind = assets.data.indexOf(this);
            var pos = assets.positionNextClosest(this, function(a, b) {
                var f = (b._data['type'] === 'folder') - (a._data['type'] === 'folder');

                if (f !== 0)
                    return f;

                if ((a === b ? nameOld : a._data['name'].toLowerCase()) > name) {
                    return 1;
                } else if ((a === b ? nameOld : a._data['name'].toLowerCase()) < name) {
                    return -1;
                } else {
                    return 0;
                }
            });

            if (pos === -1 && (ind + 1) == assets.data.length)
                return;

            if (ind !== -1 && (ind + 1 === pos) || (ind === pos))
                return;

            if (ind < pos)
                pos--;

            assets.move(this, pos);
            editor.emit('assets:move', asset, pos);
        });

        // publish added asset
        editor.emit('assets:add[' + asset.get('id') + ']', asset, pos);
        editor.emit('assets:add', asset, pos);
    });

    // allow removing assets
    editor.method('assets:remove', function(asset) {
        assets.remove(asset);
        asset.destroy();
    });

    // remove all assets
    editor.method('assets:clear', function () {
        assets.clear();
        editor.emit('assets:clear');
    });

    // get asset by id
    editor.method('assets:get', function(id) {
        return assets.get(id);
    });

    // find assets by function
    editor.method('assets:find', function(fn) {
        return assets.find(fn);
    });

    // find one asset by function
    editor.method('assets:findOne', function(fn) {
        return assets.findOne(fn);
    });

    editor.method('assets:map', function (fn) {
        assets.map(fn);
    });

    editor.method('assets:list', function () {
        return assets.array();
    });

    // publish remove asset
    assets.on('remove', function(asset) {
        editor.emit('assets:remove', asset);
    });
});


/* editor/assets/assets-registry.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:registry:bind', function (assetRegistry, assetTypes) {
        // add assets to asset registry
        editor.on('assets:add', function (asset) {
            // do only for target assets
            if (asset.get('source'))
                return;

            if (assetTypes && assetTypes.indexOf(asset.get('type')) === -1)
                return;

            // raw json data
            var assetJson = asset.json();

            // engine material data
            var data = {
                id: parseInt(assetJson.id, 10),
                name: assetJson.name,
                file: assetJson.file ? {
                    filename: assetJson.file.filename,
                    url: assetJson.file.url,
                    hash: assetJson.file.hash,
                    size: assetJson.file.size,
                    variants: assetJson.file.variants || null
                } : null,
                data: assetJson.data,
                type: assetJson.type
            };

            // add to registry
            // assetRegistry.createAndAddAsset(assetJson.id, data);

            var newAsset = new pc.Asset(data.name, data.type, data.file, data.data);
            newAsset.id = parseInt(assetJson.id, 10);
            assetRegistry.add(newAsset);

            var timeout;
            var updatedFields = { };

            var onUpdate = function(path, value) {
                var parts = path.split('.');

                if (parts[0] !== 'data' && parts[0] !== 'file')
                    return;

                if (timeout)
                    clearTimeout(timeout);

                updatedFields[parts[0]] = true;

                // do this in a timeout to avoid multiple sets of the same
                // fields
                timeout = setTimeout(function () {
                    var realtimeAsset = assetRegistry.get(asset.get('id'));

                    for (var key in updatedFields) {
                        var data = asset.get(key);

                        // this will trigger the 'update' event on the asset in the engine
                        // handling all resource loading automatically
                        realtimeAsset[key] = data;

                        delete updatedFields[key];
                    }

                    timeout = null;
                });
            };

            asset.on('*:set', onUpdate);
            asset.on('*:unset', onUpdate);
        });

        // remove assets from asset registry
        editor.on('assets:remove', function (asset) {
            var item = assetRegistry.get(asset.get('id'));
            if (item) {
                item.unload();
                assetRegistry.remove(item);
            }
        });
    });
});


/* editor/assets/assets-sync.js */
editor.once('load', function() {
    'use strict';

    var legacyScripts = editor.call('settings:project').get('useLegacyScripts');
    var syncPaths = [
        'name',
        'preload',
        'scope',
        'data',
        'meta',
        'file'
    ];
    var docs = {};

    editor.method('loadAsset', function (id, callback) {
        var connection = editor.call('realtime:connection');

        var doc = connection.get('assets', '' + id);

        docs[id] = doc;

        // error
        doc.on('error', function (err) {
            if (connection.state === 'connected') {
                console.log(err);
                return;
            }

            editor.emit('realtime:assets:error', err);
        });

        // ready to sync
        doc.on('ready', function () {
            var assetData = doc.getSnapshot();
            if (! assetData) {
                console.error('Could not load asset: ' + id);
                editor.call('status:error', 'Could not load asset: ' + id);
                doc.destroy();
                return callback && callback();
            }

            // notify of operations
            doc.on('after op', function (ops, local) {
                if (local) return;

                for (var i = 0; i < ops.length; i++) {
                    editor.emit('realtime:op:assets', ops[i], id);
                }
            });

            // notify of asset load
            assetData.id = id;

            if (assetData.file) {
                assetData.file.url = getFileUrl(assetData.id, assetData.revision, assetData.file.filename);

                if (assetData.file.variants) {
                    for(var key in assetData.file.variants) {
                        assetData.file.variants[key].url = getFileUrl(assetData.id, assetData.revision, assetData.file.variants[key].filename);
                    }
                }
            }

            var asset = new Observer(assetData);
            editor.call('assets:add', asset);

            if (callback)
                callback(asset);
        });

        // subscribe for realtime events
        doc.subscribe();
    });

    editor.method('assets:fs:paths:patch', function(data) {
        var connection = editor.call('realtime:connection');
        var assets = connection.collections.assets;

        for(var i = 0; i < data.length; i++) {
            if (! assets.hasOwnProperty(data[i].id))
                continue;

            // force snapshot path data
            assets[data[i].id].snapshot.path = data[i].path;

            // sync observer
            editor.emit('realtime:op:assets', {
                p: [ 'path' ],
                oi: data[i].path,
                od: null
            }, data[i].id);
        }
    });

    var onLoad = function(data) {
        editor.call('assets:progress', .5);

        var count = 0;

        var load = function (id) {
            editor.call('loadAsset', id, function () {
                count++;
                editor.call('assets:progress', (count / data.length) * .5 + .5);
                if (count >= data.length) {
                    editor.call('assets:progress', 1);
                    editor.emit('assets:load');
                }
            });
        };

        if (data.length) {
            var connection = editor.call('realtime:connection');

            // do bulk subsribe in batches of 'batchSize' assets
            var batchSize = 256;
            var startBatch = 0;
            var total = data.length;

            while (startBatch < total) {
                // start bulk subscribe
                connection.bsStart();
                for(var i = startBatch; i < startBatch + batchSize && i < total; i++) {
                    load(data[i].id);
                }
                // end bulk subscribe and send message to server
                connection.bsEnd();

                startBatch += batchSize;
            }

        } else {
            editor.call('assets:progress', 1);
            editor.emit('assets:load');
        }
    };

    // load all assets
    editor.on('realtime:authenticated', function() {
        editor.call('assets:clear');

        Ajax({
            url: '{{url.api}}/projects/{{project.id}}/assets?view=designer',
            auth: true
        })
            .on('load', function(status, data) {
                onLoad(data);
            })
            .on('progress', function(progress) {
                editor.call('assets:progress', .1 + progress * .4);
            })
            .on('error', function(status, evt) {
                console.log(status, evt);
            });
    });

    editor.call('assets:progress', 0.1);

    var onAssetSelect = function(asset) {
        editor.call('selector:set', 'asset', [ asset ]);

        // navigate to folder too
        var path = asset.get('path');
        if (path.length) {
            editor.call('assets:panel:currentFolder', editor.call('assets:get', path[path.length - 1]));
        } else {
            editor.call('assets:panel:currentFolder', null);
        }
    };

    // create asset
    editor.method('assets:create', function (data, fn, noSelect) {
        var evtAssetAdd;

        if (! noSelect) {
            editor.once('selector:change', function() {
                if (evtAssetAdd) {
                    evtAssetAdd.unbind();
                    evtAssetAdd = null;
                }
            });
        }

        editor.call('assets:uploadFile', data, function(err, res) {
            if (err) {
                editor.call('status:error', err);

                // TODO
                // disk allowance error

                if (fn) fn(err);

                return;
            }

            if (! noSelect) {
                var asset = editor.call('assets:get', res.asset.id);
                if (asset) {
                    onAssetSelect(asset);
                } else {
                    evtAssetAdd = editor.once('assets:add[' + res.asset.id + ']', onAssetSelect);
                }
            }

            if (fn) fn(err, res.asset.id);
        });
    });

    // delete asset
    editor.method('assets:delete', function(list) {
        if (! (list instanceof Array))
            list = [ list ];

        var assets = [ ];

        for(var i = 0; i < list.length; i++) {
            if (legacyScripts && list[i].get('type') === 'script') {
                editor.emit('sourcefiles:remove', list[i]);
                Ajax({
                    url: '{{url.api}}/projects/' + config.project.id + '/repositories/directory/sourcefiles/' + list[i].get('filename'),
                    auth: true,
                    method: 'DELETE'
                })
            } else {
                assets.push(list[i]);
            }
        }

        if (assets.length)
            editor.call('assets:fs:delete', assets);
    });

    editor.on('assets:remove', function (asset) {
        var id = asset.get('id');
        if (docs[id]) {
            docs[id].destroy();
            delete docs[id];
        }
    });

    var getFileUrl = function (id, revision, filename) {
        return '/api/assets/' + id + '/file/' + encodeURIComponent(filename);
    };

    var assetSetThumbnailPaths = function(asset) {
        if (asset.get('type') !== 'texture')
            return;

        if (asset.get('has_thumbnail')) {
            asset.set('thumbnails', {
                's': '/api/assets/' + asset.get('id') + '/thumbnail/small',
                'm': '/api/assets/' + asset.get('id') + '/thumbnail/medium',
                'l': '/api/assets/' + asset.get('id') + '/thumbnail/large',
                'xl': '/api/assets/' + asset.get('id') + '/thumbnail/xlarge'
            });
        } else {
            asset.unset('thumbnails');
        }
    };

    // hook sync to new assets
    editor.on('assets:add', function(asset) {
        if (asset.sync)
            return;

        // convert material data to flat
        if (asset.get('type') === 'material') {
            // store missing tilings / offset before we set default values
            editor.call('material:rememberMissingFields', asset);

            var assetData = asset.get('data');
            if (assetData)
                asset.set('data', editor.call('material:default', assetData));
        }

        asset.sync = new ObserverSync({
            item: asset,
            paths: syncPaths
        });

        // client > server
        asset.sync.on('op', function(op) {
            editor.call('realtime:assets:op', op, asset.get('id'));
        });

        // set thumbnails
        assetSetThumbnailPaths(asset);

        var setting = false;

        asset.on('*:set', function (path, value) {
            if (setting || ! path.startsWith('file') || path.endsWith('.url') || ! asset.get('file'))
                return;

            setting = true;

            var parts = path.split('.');

            if ((parts.length === 1 || parts.length === 2) && parts[1] !== 'variants') {
                // reset file url
                asset.set('file.url', getFileUrl(asset.get('id'), asset.get('revision'), asset.get('file.filename')));
                // set thumbnails
                assetSetThumbnailPaths(asset);
            } else if (parts.length >= 3 && parts[1] === 'variants') {
                var format = parts[2];
                asset.set('file.variants.' + format + '.url', getFileUrl(asset.get('id'), asset.get('revision'), asset.get('file.variants.' + format + '.filename')));
            }

            setting = false;
        });

        asset.on('has_thumbnail:set', function(value) {
            assetSetThumbnailPaths(asset);
        });
    });

    // write asset operations
    editor.method('realtime:assets:op', function(op, id) {
        if (! editor.call('permissions:write') || !docs[id])
            return;

        // console.trace();
        // console.log('out: [ ' + Object.keys(op).filter(function(i) { return i !== 'p' }).join(', ') + ' ]', op.p.join('.'));
        // console.log(op);

        docs[id].submitOp([ op ]);
    });


    // server > client
    editor.on('realtime:op:assets', function(op, id) {
        var asset = editor.call('assets:get', id);
        if (asset) {
            // console.log('in: ' + id + ' [ ' + Object.keys(op).filter(function(i) { return i !== 'p' }).join(', ') + ' ]', op.p.join('.'));
            // console.log(op);
            asset.sync.write(op);
        } else {
            console.error('realtime operation on missing asset: ' + op.p[1]);
        }
    });

    // handle disconnection
    editor.on('realtime:disconnected', function () {
        var app = editor.call('viewport:app');
        if (app) {
            // clear ALL asset registry events
            app.assets._callbacks = { };
        }

        editor.call('assets:clear');
    });
});


/* editor/assets/assets-fs.js */
editor.once('load', function() {
    'use strict';

    var getIds = function(assets) {
        if (! (assets instanceof Array))
            assets = [ assets ];

        var ids = [ ];
        for(var i = 0; i < assets.length; i++)
            ids.push(parseInt(assets[i].get('id'), 10));

        return ids;
    };

    editor.method('assets:fs:delete', function(assets) {
        editor.call('realtime:send', 'fs', {
            op: 'delete',
            ids: getIds(assets)
        });
    });

    editor.method('assets:fs:move', function(assets, assetTo) {
        editor.call('realtime:send', 'fs', {
            op: 'move',
            ids: getIds(assets),
            to: assetTo ? parseInt(assetTo.get('id'), 10) : null
        });
    });

    editor.method('assets:fs:duplicate', function(assets) {
        editor.call('realtime:send', 'fs', {
            op: 'duplicate',
            ids: getIds(assets)
        });
    });
});


/* editor/assets/assets-panel.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var assetsPanel = editor.call('layout.assets');
    var legacyScripts = editor.call('settings:project').get('useLegacyScripts');

    var dragging = false;
    var draggingType = '';
    var draggingData = { };
    var selector = {
        type: '',
        items: [ ],
        prev: {
            type: '',
            items: [ ]
        }
    };
    var searching = false;

    var overlay = new ui.Panel();
    overlay.class.add('overlay');
    assetsPanel.append(overlay);

    var loading = new ui.Progress();
    loading.on('progress:100', function() {
        overlay.hidden = true;
    });
    overlay.append(loading);

    editor.method('assets:progress', function(progress) {
        loading.progress = progress;
    });

    // folders panel
    var folders = new ui.Panel();
    folders.class.add('folders');
    folders.flexShrink = false;
    folders.style.width = '200px';
    folders.innerElement.style.width = '200px';
    folders.foldable = false;
    folders.horizontal = true;
    folders.scroll = true;
    folders.resizable = 'right';
    folders.resizeMin = 100;
    folders.resizeMax = 300;
    assetsPanel.append(folders);

    editor.method('assets:panel:folders', function() {
        return folders;
    });

    var currentFolder = null;
    editor.method('assets:panel:currentFolder', function(asset) {
        if (asset === undefined)
            return currentFolder;

        if (asset === currentFolder)
            return;

        // current folder style remove
        if (currentFolder && typeof(currentFolder) !== 'string' && assetsIndex[currentFolder.get('id')]) {
            assetsIndex[currentFolder.get('id')].tree.class.remove('current');
        } else {
            if (currentFolder === null) {
                treeRoot.class.remove('current');
            } else if (treeScripts && currentFolder === 'scripts') {
                treeScripts.class.remove('current');
            }
        }

        currentFolder = asset;

        // current folder style add
        if (currentFolder && typeof(currentFolder) !== 'string') {
            assetsIndex[currentFolder.get('id')].tree.class.add('current');

            // open tree up
            var path = currentFolder.get('path');
            for(var i = 0; i < path.length; i++) {
                if (! assetsIndex[path[i]] || ! assetsIndex[path[i]].tree)
                    continue;

                assetsIndex[path[i]].tree.open = true;
            }
        } else if (currentFolder === null) {
            treeRoot.class.add('current');
        } else if (treeScripts && currentFolder === 'scripts') {
            treeScripts.class.add('current');
            editor.call('assets:filter:type', 'all');
        }

        if (legacyScripts)
            gridScripts.hidden = currentFolder !== null;

        editor.emit('assets:panel:currentFolder', currentFolder);
    });

    editor.call('hotkey:register', 'assets:fs:up', {
        key: 'backspace',
        callback: function() {
            if (! currentFolder || editor.call('selector:type') !== 'asset')
                return;

            var path = typeof(currentFolder) === 'string' ? [ ] : currentFolder.get('path');
            if (path.length === 0) {
                editor.call('assets:panel:currentFolder', null);
            } else {
                editor.call('assets:panel:currentFolder', editor.call('assets:get', path[path.length - 1]));
            }
        }
    });

    editor.on('drop:active', function(state, type, data) {
        dragging = state;

        if (! dragging) {
            grid.dragOver = undefined;
            gridDropBorder.classList.remove('active');
            treeDropBorder.classList.remove('active');
        }
    });

    editor.on('drop:set', function(type, data) {
        draggingType = type;
        draggingData = data;
    });

    // tree
    var tree = new ui.Tree();
    tree.enabled = false;
    tree.draggable = false;
    tree.class.add('assets');
    folders.append(tree);

    var dropRef = editor.call('drop:target', {
        ref: folders.element,
        hole: true,
        passThrough: true,
        filter: function(type, data) {
            return type.startsWith('asset');
        },
        drop: function(type, data) {
            if (! type || grid.dragOver === undefined || ! type.startsWith('asset'))
                return;

            var items = editor.call('selector:items');
            var assets = [ ];

            var addAsset = function(id) {
                var asset = editor.call('assets:get', id);

                // deselect moved asset
                if (items.indexOf(asset) !== -1)
                    editor.call('selector:remove', asset);

                assets.push(asset);
            };

            if (data.ids) {
                for(var i = 0; i < data.ids.length; i++)
                    addAsset(data.ids[i]);
            } else {
                addAsset(data.id);
            }
            editor.call('assets:fs:move', assets, grid.dragOver);
        }
    });
    dropRef.element.classList.add('assets-drop-area');

    var treeAppendQueue = { };

    // tree root
    var treeRoot = new ui.TreeItem({
        text: '/'
    });
    tree.append(treeRoot);
    treeRoot.open = true;
    treeRoot.class.add('current');
    treeRoot.on('select', function() {
        this.selected = false;
    });

    // scripts folder
    var gridScripts;
    var treeScripts;

    treeRoot.elementTitle.addEventListener('mouseover', function() {
        if (! dragging || grid.dragOver === null || (! draggingData.id && ! draggingData.ids))
            return;

        // already in that folder
        var dragAsset = editor.call('assets:get', draggingData.id || draggingData.ids[0]);
        if (! dragAsset.get('path').length)
            return;

        gridDropBorder.classList.remove('active');

        var rect = treeRoot.elementTitle.getBoundingClientRect();
        treeDropBorder.classList.add('active');
        treeDropBorder.style.left = rect.left + 'px';
        treeDropBorder.style.top = rect.top + 'px';
        treeDropBorder.style.right = (window.innerWidth - rect.right) + 'px';
        treeDropBorder.style.bottom = (window.innerHeight - rect.bottom) + 'px';

        grid.dragOver = null;
    }, false);

    treeRoot.elementTitle.addEventListener('mouseout', function() {
        if (! dragging || grid.dragOver === undefined)
            return;

        gridDropBorder.classList.remove('active');
        treeDropBorder.classList.remove('active');

        grid.dragOver = undefined;
    }, false);

    // tree width resizing
    var resizeQueued = false;
    var resizeTree = function() {
        resizeQueued = false;
        tree.element.style.width = '';
        tree.element.style.width = (folders.innerElement.scrollWidth - 5) + 'px';
    };
    var resizeQueue = function() {
        if (resizeQueued) return;
        resizeQueued = true;
        requestAnimationFrame(resizeTree);
    };
    folders.on('resize', resizeQueue);
    tree.on('open', resizeQueue);
    tree.on('close', resizeQueue);
    setInterval(resizeQueue, 1000);

    var files = new ui.Panel();
    files.class.add('files');
    files.flexGrow = true;
    files.foldable = false;
    files.horizontal = true;
    files.scroll = true;
    assetsPanel.append(files);

    editor.method('assets:panel:files', function() {
        return files;
    });

    // grid
    var grid = new ui.Grid();
    grid.enabled = false;
    grid.class.add('assets');
    files.append(grid);


    var dropRef = editor.call('drop:target', {
        ref: files.element,
        hole: true,
        passThrough: true,
        filter: function(type, data) {
            return type.startsWith('asset');
        },
        drop: function(type, data) {
            if (! type || grid.dragOver === undefined || ! type.startsWith('asset'))
                return;

            var assets = [ ];
            var items = editor.call('selector:items');

            var addAsset = function(id) {
                var asset = editor.call('assets:get', id);

                // deselect moved asset
                if (items.indexOf(asset) !== -1)
                    editor.call('selector:remove', asset);

                assets.push(asset);
            };

            if (data.ids) {
                for(var i = 0; i < data.ids.length; i++)
                    addAsset(data.ids[i]);
            } else {
                addAsset(data.id);
            }

            editor.call('assets:fs:move', assets, grid.dragOver);
        }
    });
    dropRef.element.classList.add('assets-drop-area');

    editor.on('permissions:writeState', function(state) {
        tree.enabled = state;
        grid.enabled = state;
    });

    var labelNoAssets = new ui.Label();
    labelNoAssets.renderChanges = false;
    labelNoAssets.class.add('no-assets');
    labelNoAssets.hidden = true;
    files.append(labelNoAssets);

    editor.method('assets:panel:message', function (msg) {
        labelNoAssets.text = msg;
        labelNoAssets.hidden = !msg;
    });

    var scriptsIndex = { };
    var assetsIndex = { };
    var assetsChanged = false;
    grid.assetsIndex = assetsIndex;

    var gridDropBorder = document.createElement('div');
    gridDropBorder.classList.add('assets-drop-border');
    root.append(gridDropBorder);

    var treeDropBorder = document.createElement('div');
    treeDropBorder.classList.add('assets-drop-border');
    root.append(treeDropBorder);

    var tooltipAsset = new ui.Tooltip({
        text: 'Asset',
        align: 'top',
        hoverable: false
    });
    root.append(tooltipAsset);

    var tooltipTarget = null;
    var tooltipTimeout = null;

    var tooltipShow = function() {
        if (! tooltipTarget)
            return;

        while(tooltipTarget && tooltipTarget.nodeName !== 'LI' && ! tooltipTarget.classList.contains('ui-grid-item'))
            tooltipTarget = tooltipTarget.parentNode;

        if (! tooltipTarget || ! tooltipTarget.ui)
            return;

        var rect = tooltipTarget.getBoundingClientRect();
        var off = 16;

        if (rect.width < 64) off = rect.width / 2;
        tooltipAsset.flip = rect.left + off > window.innerWidth / 2;
        if (tooltipAsset.flip) {
            tooltipAsset.position(rect.right - off, rect.bottom);
        } else {
            tooltipAsset.position(rect.left + off, rect.bottom);
        }

        tooltipAsset.text = tooltipTarget.ui.asset.get('name');
        tooltipAsset.hidden = false;
    };

    var onAssetItemHover = function(evt) {
        if (tooltipTimeout) {
            clearTimeout(tooltipTimeout);
            tooltipTimeout = null;
        }

        tooltipTarget = evt.target;
        tooltipTimeout = setTimeout(tooltipShow, 300);
    };
    var onAssetItemBlur = function() {
        tooltipAsset.hidden = true;

        if (tooltipTimeout) {
            clearTimeout(tooltipTimeout);
            tooltipTimeout = null;
        }
    };
    var onAssetItemRemove = function() {
        if (! tooltipTarget || ! tooltipTarget.ui || tooltipTarget.ui.asset !== this)
            return;

        onAssetItemBlur();
    };

    grid.innerElement.addEventListener('mousewheel', function() {
        tooltipAsset.hidden = true;

        if (tooltipTimeout) {
            clearTimeout(tooltipTimeout);
            tooltipTimeout = null;
        }
    }, false);

    tree.on('select', function(item) {
        if (assetsChanged)
            return;

        if (item.asset) {
            if (! Tree._ctrl || ! Tree._ctrl()) {
                if (currentFolder !== item.asset) {
                    item.selected = false;
                } else {
                    editor.call('selector:set', 'asset', [ item.asset ]);
                }
            } else {
                editor.call('selector:add', 'asset', item.asset);
            }
        }

        if (! item.asset) {
            if (item === treeRoot) {
                editor.call('assets:filter:search', '');
                editor.call('assets:panel:currentFolder', null);
            } else if (item === treeScripts) {
                editor.call('assets:filter:search', '');
                editor.call('assets:panel:currentFolder', 'scripts');
            }
            return;
        }

        if (! Tree._ctrl || ! Tree._ctrl()) {
            editor.call('assets:filter:search', '');
            editor.call('assets:panel:currentFolder', item.asset);
        }
    });

    tree.on('deselect', function(item) {
        if (assetsChanged)
            return;

        if (item.asset)
            editor.call('selector:remove', item.asset);
    });

    grid.on('select', function(item) {
        if (assetsChanged)
            return;

        if (item.asset) {
            editor.call('selector:add', 'asset', item.asset);
        } else if (item.script) {
            editor.call('selector:add', 'asset', item.script);
        }
    });

    grid.on('deselect', function(item) {
        if (assetsChanged)
            return;

        if (item.asset) {
            editor.call('selector:remove', item.asset);
        } else if (item.script) {
            editor.call('selector:remove', item.script);
        }
    });

    editor.on('selector:change', function(type, items) {
        assetsChanged = true;

        selector.prev.type = selector.type;
        selector.prev.items = selector.items;

        selector.type = editor.call('selector:type');
        selector.items = editor.call('selector:items');

        if (type === 'asset') {
            tree.clear();
            items = items.slice(0);
            var assets = items.slice(0);

            for(var i = 0; i < items.length; i++) {
                if (legacyScripts && items[i].get('type') === 'script') {
                    assets[i] = scriptsIndex[items[i].get('filename')];
                } else {
                    assets[i] = assetsIndex[items[i].get('id')];
                    if (assets[i].tree) {
                        assets[i].tree.selected = true;

                        // open tree up
                        var path = items[i].get('path');
                        for(var n = 0; n < path.length; n++) {
                            if (! assetsIndex[path[n]] || ! assetsIndex[path[n]].tree)
                                continue;

                            assetsIndex[path[n]].tree.open = true;
                        }
                    }
                }
            }

            grid.selected = assets;
        } else {
            if ((legacyScripts && ! (gridScripts.selected && grid.selected.length === 1)) || selector.type !== 'asset')
                grid.selected = [ ];

            tree.clear();
        }

        assetsChanged = false;
    });

    // return grid
    editor.method('assets:grid', function() {
        return grid;
    });

    var searchingInProgress = false;
    var searchingElement = null;
    var searchingFunction = null;
    var searchingBatchLimit = 512;

    var searchNextBatch = function() {
        var done = 0;

        while(searchingElement && (searchingBatchLimit === 0 || done < searchingBatchLimit)) {
            var item = searchingElement.ui;

            if (item) {
                if (item.asset) {
                    item.hidden = ! searchingFunction('asset', item.asset);
                } else if (item.script) {
                    item.hidden = ! searchingFunction('script', item.script);
                }
                done++;
            }

            searchingElement = searchingElement.nextSibling;
        }

        if (! searchingElement) {
            searchingInProgress = false;
        } else {
            requestAnimationFrame(searchNextBatch);
        }
    };

    // filter assets in grid
    editor.method('assets:panel:filter', function(fn, immediate) {
        if (! fn)
            fn = editor.call('assets:panel:filter:default');

        labelNoAssets.hidden = true;

        searchingElement = grid._element.firstChild;
        searchingFunction = fn;

        var type = editor.call('assets:filter:type');
        var search = editor.call('assets:filter:search');

        if (! search || immediate) {
            searchingBatchLimit = 0;
        } else {
            searchingBatchLimit = 512;
        }

        if (! searchingInProgress) {
            searchingInProgress = true;
            requestAnimationFrame(searchNextBatch);
        }

        // navigate to selected assets folder
        if (searching && ! search) {
            searching = false;

            if (selector.type === 'asset') {
                var script = legacyScripts && selector.items[0].get('type') === 'script';
                var path = script ? [ ] : selector.items[0].get('path');
                var multiPath = false;
                for(var i = 1; i < selector.items.length; i++) {
                    var item = selector.items[i];
                    if (script !== (item.get('type') === 'script') || (! script && ! path.equals(item.get('path')))) {
                        multiPath = true;
                        break;
                    }
                }

                if (! multiPath) {
                    if (path.length) {
                        editor.call('assets:panel:currentFolder', editor.call('assets:get', path[path.length - 1]));
                        assetsIndex[selector.items[0].get('id')].element.focus();
                    } else if (script) {
                        editor.call('assets:panel:currentFolder', 'scripts');
                    } else {
                        editor.call('assets:panel:currentFolder', null);
                    }
                }
            }
        }

        if (search)
            searching = true;

        if (legacyScripts)
            gridScripts.hidden = ! fn('scripts', 'scripts');
    });


    // get grid item by id
    editor.method('assets:panel:get', function(id) {
        return assetsIndex[id] || scriptsIndex[id];
    });


    editor.on('messenger:asset.thumbnail', function(data) {
        var gridItem = assetsIndex[parseInt(data.asset.id, 10)];

        if (! gridItem || gridItem.asset.get('source'))
            return;

        var url = '/api/assets/' + data.asset.id + '/thumbnail/medium?t=' + (gridItem.asset.get('file.hash') || data.asset.hash || '')
        gridItem.thumbnail.style.backgroundImage = 'url(' + url + ')';
        gridItem.thumbnail.classList.remove('placeholder');
    });


    var appendChildFolders = function(item) {
        var queue = treeAppendQueue[item.asset.get('id')];
        if (! queue || ! queue.length)
            return;

        for(var i = 0; i < queue.length; i++) {
            var closest = treeFindClosest(item.tree, queue[i].tree);
            if (closest === -1) {
                item.tree.append(queue[i].tree);
            } else {
                item.tree.appendBefore(queue[i].tree, item.tree.child(closest).ui);
            }
            appendChildFolders(queue[i]);
        }

        delete treeAppendQueue[item.asset.get('id')];
    };

    var treeFindClosest = function(item, b, nameOld) {
        var l = Array.prototype.slice.call(item.element.childNodes, 1);
        if (item === treeRoot && legacyScripts)
            l = l.slice(1);

        var min = 0;
        var max = l.length - 1;
        var cur;
        var a, i;
        var aN, bN;

        if (l.length === 0)
            return -1;

        if (((a === b) ? nameOld.toLowerCase() : l[0].ui.text.toLowerCase()) === bN)
            return 0;

        while (min <= max) {
            cur = Math.floor((min + max) / 2);
            a = l[cur];

            aN = (a === b) ? nameOld.toLowerCase() : a.ui.text.toLowerCase();
            bN = b.text.toLowerCase();

            if (aN > bN) {
                max = cur - 1;
            } else if (aN < bN) {
                min = cur + 1;
            } else {
                return cur;
            }
        }

        if (aN > bN)
            return cur;

        if ((cur + 1) === l.length)
            return -1;

        return cur + 1;
    };

    var createLegacyScriptFolder = function() {
        gridScripts = new ui.GridItem();
        gridScripts.class.add('type-folder', 'scripts');
        grid.append(gridScripts);

        gridScripts.tree = treeScripts = new ui.TreeItem({
            text: 'scripts'
        });
        gridScripts.tree.class.add('scripts');
        gridScripts.tree.on('select', function() {
            this.selected = false;
        });
        treeRoot.append(gridScripts.tree);

        gridScripts.on('select', function() {
            editor.call('selector:clear');

            if (! selector.type) {
                selector.prev.type = null;
                selector.prev.items = [ ];
            }
        });

        // folder open
        gridScripts.element.addEventListener('dblclick', function() {
            tree.clear();
            editor.call('assets:filter:search', '');
            editor.call('assets:panel:currentFolder', 'scripts');
            // change back selection

            if (selector.prev.type)
                editor.call('selector:set', selector.prev.type, selector.prev.items);
        }, false);

        var thumbnail = gridScripts.thumbnail = document.createElement('div');
        thumbnail.classList.add('thumbnail', 'placeholder');
        gridScripts.element.appendChild(thumbnail);

        var icon = document.createElement('div');
        icon.classList.add('icon');
        gridScripts.element.appendChild(icon);

        var label = gridScripts.labelElement = document.createElement('div');
        label.classList.add('label');
        label.textContent = 'scripts';
        gridScripts.element.appendChild(label);

        // context menu
        var menu = new ui.Menu();
        root.append(menu);

        // script
        var menuScript = new ui.MenuItem({
            text: 'New Script',
            value: 'script',
            icon: '&#57864;'
        });
        menuScript.on('select', function () {
            editor.call('sourcefiles:new');
        });
        menu.append(menuScript);

        editor.on('repositories:load', function (repositories) {
            if (repositories.get('current') !== 'directory')
                menuScript.disabled = true;
        });
        var onContextMenu = function(evt) {
            evt.stopPropagation();
            evt.preventDefault();

            if (! editor.call('permissions:write'))
                return;

            menu.position(evt.clientX + 1, evt.clientY);
            menu.open = true;
        };
        gridScripts.element.addEventListener('contextmenu', onContextMenu, false);
        treeScripts.elementTitle.addEventListener('contextmenu', onContextMenu, false);

        resizeQueue();
    };
    if (legacyScripts)
        createLegacyScriptFolder();

    // select all hotkey
    // ctrl + a
    editor.call('hotkey:register', 'asset:select-all', {
        ctrl: true,
        key: 'a',
        callback: function() {
            var assets = [ ];

            for(var key in assetsIndex) {
                if (! assetsIndex[key].hidden)
                    assets.push(assetsIndex[key].asset);
            }

            for(var key in scriptsIndex) {
                if (! scriptsIndex[key].hidden)
                    assets.push(scriptsIndex[key].script);
            }

            if (assets.length) {
                editor.call('selector:set', 'asset', assets);
            } else {
                editor.call('selector:clear');
            }
        }
    });

    var renderQueue = [ ];
    var renderQueueIndex = { };

    var renderQueueUpdate = function() {
        requestAnimationFrame(renderQueueUpdate);

        if (! renderQueue.length)
            return;

        var items = 0;
        while(items < 4 && renderQueue.length) {
            items++;
            var id = renderQueue.shift();
            delete renderQueueIndex[id];

            if (! assetsIndex[id] || ! assetsIndex[id].thumbnail || ! assetsIndex[id].thumbnail.render)
                continue;

            assetsIndex[id].thumbnail.render();
        }
    };
    requestAnimationFrame(renderQueueUpdate);

    var renderQueueAdd = function(asset) {
        var id = asset.get('id');
        if (renderQueueIndex[id])
            return;

        if (! assetsIndex[id] || ! assetsIndex[id].thumbnail || ! assetsIndex[id].thumbnail.render)
            return;

        renderQueueIndex[id] = true;
        renderQueue.push(id);
    };

    var renderQueueRemove = function(asset) {
        var id = parseInt(asset.get('id'), 10);
        if (! renderQueueIndex[id])
            return;

        var ind = renderQueue.indexOf(id);
        if (ind !== -1)
            renderQueue.splice(ind, 1);

        delete renderQueueIndex[id];
    };

    editor.on('assets:add', function(asset, pos) {
        asset._type = 'asset';

        var events = [ ];
        var item = new ui.GridItem();
        item.asset = asset;
        item.class.add('type-' + asset.get('type'));

        item.element.addEventListener('mouseover', onAssetItemHover, false);
        item.element.addEventListener('mouseout', onAssetItemBlur, false);

        asset.once('destroy', onAssetItemRemove);

        var onMouseDown = function(evt) {
            evt.stopPropagation();
        };

        var onDragStart = function(evt) {
            evt.preventDefault();
            evt.stopPropagation();

            if (! editor.call('permissions:write'))
                return;

            var type = 'asset.' + asset.get('type');
            var data = {
                id: asset.get('id')
            };

            var selectorType = editor.call('selector:type');
            var selectorItems = editor.call('selector:items');

            if (selectorType === 'asset' && selectorItems.length > 1) {
                var path = selectorItems[0].get('path');

                if (selectorItems.indexOf(asset) !== -1) {
                    var ids = [ ];
                    for(var i = 0; i < selectorItems.length; i++) {
                        // don't allow multi-path dragging
                        if (path.length !== selectorItems[i].get('path').length || path[path.length - 1] !== selectorItems[i].get('path')[path.length - 1])
                            return;

                        ids.push(parseInt(selectorItems[i].get('id'), 10));
                    }

                    type = 'assets';
                    data = {
                        ids: ids
                    };
                }
            }

            editor.call('drop:set', type, data);
            editor.call('drop:activate', true);
        };

        if (asset.get('type') === 'folder') {
            item.tree = new ui.TreeItem({
                text: asset.get('name')
            });
            item.tree.asset = asset;

            var appended = false;
            var path = asset.get('path');
            var parent;
            if (path.length) {
                var parentFolderId = path[path.length - 1];
                if (assetsIndex[parentFolderId]) {
                    appended = true;
                    parent = assetsIndex[parentFolderId].tree;
                } else {
                    if (! treeAppendQueue[parentFolderId])
                        treeAppendQueue[parentFolderId] = [ ];

                    treeAppendQueue[parentFolderId].push(item);
                }
            } else {
                appended = true;
                parent = treeRoot;
            }

            if (parent) {
                var closest = treeFindClosest(parent, item.tree);
                if (closest === -1) {
                    parent.append(item.tree);
                } else {
                    parent.appendBefore(item.tree, parent.child(closest).ui);
                }

                appendChildFolders(item);
            }

            // draggable
            item.tree.elementTitle.draggable = true;
            item.tree.elementTitle.addEventListener('mousedown', onMouseDown, false);
            item.tree.elementTitle.addEventListener('dragstart', onDragStart, false);

            var onMouseOver = function() {
                if (! dragging || grid.dragOver === asset)
                    return;

                // don't allow to drag on it self
                if (draggingData.ids) {
                    // multi-drag
                    if (draggingData.ids.indexOf(parseInt(asset.get('id'), 10)) !== -1)
                        return;
                } else if (draggingData.id) {
                    // single-drag
                    if (parseInt(asset.get('id'), 10) === parseInt(draggingData.id, 10))
                        return;
                } else {
                    // script file drag
                    return;
                }


                // already in that folder
                var dragAsset = editor.call('assets:get', draggingData.id || draggingData.ids[0]);
                var path = dragAsset.get('path');
                if (path.length && path[path.length - 1] === parseInt(asset.get('id')))
                    return;

                // don't allow dragging into own child
                if (draggingData.ids) {
                    // multi-drag
                    var assetPath = asset.get('path');
                    for(var i = 0; i < draggingData.ids.length; i++) {
                        if (assetPath.indexOf(draggingData.ids[i]) !== -1)
                            return;
                    }
                } else {
                    // single-drag
                    if (asset.get('path').indexOf(parseInt(dragAsset.get('id'), 10)) !== -1)
                        return;
                }

                var clip = files.element.getBoundingClientRect();
                var rect = item.element.getBoundingClientRect();
                var top = Math.max(rect.top, clip.top);
                var bottom = Math.min(rect.bottom, clip.bottom);

                if ((bottom - top) > 8) {
                    gridDropBorder.classList.add('active');
                    gridDropBorder.style.left = rect.left + 'px';
                    gridDropBorder.style.top = top + 'px';
                    gridDropBorder.style.right = (window.innerWidth - rect.right) + 'px';
                    gridDropBorder.style.bottom = (window.innerHeight - bottom) + 'px';
                }

                var rect = item.tree.elementTitle.getBoundingClientRect();
                top = Math.max(rect.top, clip.top);
                bottom = Math.min(rect.bottom, clip.bottom);
                if (rect.height && (bottom - top) > 4) {
                    treeDropBorder.classList.add('active');
                    treeDropBorder.style.left = rect.left + 'px';
                    treeDropBorder.style.top = top + 'px';
                    treeDropBorder.style.right = (window.innerWidth - rect.right) + 'px';
                    treeDropBorder.style.bottom = (window.innerHeight - bottom) + 'px';
                }

                grid.dragOver = asset;
            };

            var onMouseOut = function() {
                if (! dragging || grid.dragOver !== asset)
                    return;

                gridDropBorder.classList.remove('active');
                treeDropBorder.classList.remove('active');
                grid.dragOver = undefined;
            };

            item.element.addEventListener('mouseout', onMouseOut, false);
            item.tree.elementTitle.addEventListener('mouseout', onMouseOut, false);

            item.element.addEventListener('mouseover', onMouseOver, false);
            item.tree.elementTitle.addEventListener('mouseover', onMouseOver, false);
        } else if (asset.get('type') === 'script') {
            events.push(editor.on('assets[' + asset.get('id') + ']:scripts:collide', function(script) {
                item.class.add('scripts-collide');
            }));
            events.push(editor.on('assets[' + asset.get('id') + ']:scripts:resolve', function(script) {
                item.class.remove('scripts-collide');
            }));
        }

        var updateTask = function() {
            var status = asset.get('task');
            item.class.remove('task', 'failed', 'running');
            if (status && typeof(status) === 'string' && status[0] !== '{') {
                item.class.add('task', status);
            }
        };

        // add task status
        updateTask();
        asset.on('task:set', updateTask);

        item.element.draggable = true;
        item.element.addEventListener('mousedown', onMouseDown, false);
        item.element.addEventListener('dragstart', onDragStart, false);

        assetsIndex[asset.get('id')] = item;

        // source
        if (asset.get('source'))
            item.class.add('source');

        if (! editor.call('assets:panel:filter:default')('asset', asset))
            item.hidden = true;

        var fileSize = asset.get('file.size');

        if (! asset.get('source')) {
            // update thumbnails change
            asset.on('thumbnails.m:set', function(value) {
                if (value.startsWith('/api'))
                    value += '?t=' + asset.get('file.hash');

                thumbnail.style.backgroundImage = 'url(' + value + ')';
                thumbnail.classList.remove('placeholder');
            });

            asset.on('thumbnails.m:unset', function() {
                thumbnail.style.backgroundImage = 'none';
                thumbnail.classList.add('placeholder');
            });
        }

        // folder open
        if (asset.get('type') === 'folder') {
            item.element.addEventListener('dblclick', function() {
                tree.clear();
                item.tree.open = true;
                editor.call('assets:filter:search', '');
                editor.call('assets:panel:currentFolder', item.asset);

                // change back selection
                if (selector.type)
                    editor.call('selector:set', selector.prev.type, selector.prev.items);
            }, false);
        }

        var thumbnail;
        var evtSceneSettings, evtAssetChanged;

        if (asset.get('type') === 'material' || asset.get('type') === 'model' || (asset.get('type') === 'font') && !asset.get('source')) {
            var queuedRender = false;

            thumbnail = document.createElement('canvas');
            thumbnail.classList.add('flipY');
            thumbnail.changed = true;
            thumbnail.width = 64;
            thumbnail.height = 64;

            var watching = null;

            var onRender = thumbnail.render = function() {
                queuedRender = false;

                if (item.hidden)
                    return;

                thumbnail.changed = false;

                var ctx = thumbnail.ctx;
                if (! ctx) ctx = thumbnail.ctx = thumbnail.getContext('2d');

                var imageData = editor.call('preview:render', asset, 64);
                if (imageData) ctx.putImageData(imageData, 0, 0);
            };
            var queueRender = function() {
                if (item.hidden) {
                    thumbnail.changed = true;
                    renderQueueRemove(asset);
                } else {
                    renderQueueAdd(asset);
                }
            };
            item.on('show', function() {
                if (thumbnail.changed)
                    queueRender();

                if (! watching) {
                    watching = editor.call('assets:' + asset.get('type') + ':watch', {
                        asset: asset,
                        autoLoad: true,
                        callback: queueRender
                    });
                }
            });
            var onUnwatch = function() {
                if (! watching)
                    return;

                editor.call('assets:' + asset.get('type') + ':unwatch', asset, watching);
                watching = null;

                renderQueueRemove(asset);
            };
            item.on('hide', onUnwatch);
            item.once('destroy', onUnwatch);
            if (! item.hidden) {
                requestAnimationFrame(queueRender);

                if (! watching) {
                    watching = editor.call('assets:' + asset.get('type') + ':watch', {
                        asset: asset,
                        autoLoad: true,
                        callback: queueRender
                    });
                }
            }

            evtSceneSettings = editor.on('preview:scene:changed', queueRender);
        } else if (asset.get('type') === 'cubemap') {
            thumbnail = document.createElement('canvas');
            thumbnail.changed = true;
            thumbnail.width = 64;
            thumbnail.height = 64;

            var watching = null;

            var positions = [ [ 32, 24 ], [ 0, 24 ], [ 16, 8 ], [ 16, 40 ], [ 16, 24 ], [ 48, 24 ] ];
            var images = [ null, null, null, null, null, null ];

            var onRender = thumbnail.render = function() {
                queuedRender = false;

                if (item.hidden)
                    return;

                thumbnail.changed = false;

                var ctx = thumbnail.ctx;
                if (! ctx) ctx = thumbnail.ctx = thumbnail.getContext('2d');

                ctx.clearRect(0, 0, 64, 64);

                // left
                for(var i = 0; i < 6; i++) {
                    var id = asset.get('data.textures.' + i);
                    var image = null;

                    if (id) {
                        var texture = editor.call('assets:get', id);
                        if (texture) {
                            var hash = texture.get('file.hash');
                            if (images[i] && images[i].hash === hash) {
                                image = images[i];
                            } else {
                                var url = texture.get('thumbnails.s');

                                if (images[i])
                                    images[i].onload = null;

                                images[i] = null;

                                if (url) {
                                    image = images[i] = new Image();
                                    image.hash = hash;
                                    image.onload = queueRender;
                                    image.src = url + '?t=' + hash;
                                }
                            }
                        } else if (images[i]) {
                            images[i].onload = null;
                            images[i] = null;
                        }
                    } else if (images[i]) {
                        images[i].onload = null;
                        images[i] = null;
                    }

                    if (image) {
                        ctx.drawImage(image, positions[i][0], positions[i][1], 16, 16);
                    } else {
                        ctx.beginPath();
                        ctx.rect(positions[i][0], positions[i][1], 16, 16);
                        ctx.fillStyle = '#000';
                        ctx.fill();
                    }
                }
            };
            var queueRender = function() {
                if (item.hidden) {
                    thumbnail.changed = true;
                    renderQueueRemove(asset);
                } else {
                    renderQueueAdd(asset);
                }
            };

            item.on('show', function() {
                if (thumbnail.changed)
                    queueRender();

                if (! watching) {
                    watching = editor.call('assets:cubemap:watch', {
                        asset: asset,
                        autoLoad: true,
                        callback: queueRender
                    });
                }
            });

            var onUnwatch = function() {
                if (! watching)
                    return;

                editor.call('assets:cubemap:unwatch', asset, watching);
                watching = null;

                renderQueueRemove(asset);
            };
            item.on('hide', onUnwatch);
            item.once('destroy', onUnwatch);

            if (! item.hidden) {
                requestAnimationFrame(queueRender);

                if (! watching) {
                    watching = editor.call('assets:cubemap:watch', {
                        asset: asset,
                        autoLoad: true,
                        callback: queueRender
                    });
                }
            }

            evtAssetChanged = asset.on('*:set', function(path) {
                if (queuedRender || ! path.startsWith('data.textures'))
                    return;

                queueRender();
            });
        } else {
            thumbnail = document.createElement('div');
        }

        item.thumbnail = thumbnail;
        thumbnail.classList.add('thumbnail');
        item.element.appendChild(thumbnail);

        if (asset.has('thumbnails') && ! asset.get('source')) {
            thumbnail.style.backgroundImage = 'url("' + config.url.home + asset.get('thumbnails.m') + '")';
        } else {
            thumbnail.classList.add('placeholder');
        }

        var icon = document.createElement('div');
        icon.classList.add('icon');
        item.element.appendChild(icon);

        var label = item.labelElement = document.createElement('div');
        label.classList.add('label');
        label.textContent = asset.get('name');
        item.element.appendChild(label);

        var users = item.users = document.createElement('div');
        users.classList.add('users');
        item.element.appendChild(users);

        // update name/filename change
        events.push(asset.on('name:set', function(name, nameOld) {
            // grid
            label.textContent = this.get('name');
            // tree
            if (item.tree) {
                item.tree.text = this.get('name');

                // resort element (move match alphabetical order)
                var parent = item.tree.parent;
                item.tree.parent.element.removeChild(item.tree.element);
                var closest = treeFindClosest(parent, item.tree, nameOld);
                if (closest === -1) {
                    parent.element.appendChild(item.tree.element);
                } else {
                    parent.element.insertBefore(item.tree.element, parent.child(closest));
                }

                resizeQueue();
            }

            keepLegacyScriptsAtTop();
        }));

        events.push(asset.on('path:set', function(path, pathOld) {
            // show or hide based on filters
            item.hidden = ! editor.call('assets:panel:filter:default')('asset', this);

            if (item.tree) {
                if (! pathOld.length || ! path.length || path[path.length - 1] !== pathOld[pathOld.length - 1]) {
                    item.tree.parent.remove(item.tree);
                    var parent;

                    if (path.length) {
                        parent = assetsIndex[path[path.length - 1]].tree;
                    } else {
                        parent = treeRoot;
                    }

                    var closest = treeFindClosest(parent, item.tree);
                    if (closest === -1) {
                        parent.append(item.tree);
                    } else {
                        parent.appendBefore(item.tree, parent.child(closest).ui);
                    }
                }

                if (currentFolder === asset)
                    editor.emit('assets:panel:currentFolder', currentFolder);
            }

            keepLegacyScriptsAtTop();
        }));

        if (! asset.get('source')) {
            // used event
            var evtUnused = editor.on('assets:used:' + asset.get('id'), function(state) {
                if (state) {
                    item.class.remove('unused');
                } else {
                    item.class.add('unused');
                }
            });
            // used state
            if (! editor.call('assets:used:get', asset.get('id')))
                item.class.add('unused');

            // clean events
            item.once('destroy', function() {
                evtUnused.unbind();
            });
        }

        // clean events
        item.once('destroy', function() {
            editor.call('selector:remove', asset);

            for(var i = 0; i < events.length; i++)
                events[i].unbind();
            events = null;

            delete assetsIndex[asset.get('id')];

            if (evtSceneSettings)
                evtSceneSettings.unbind();

            if (evtAssetChanged)
                evtAssetChanged.unbind();
        });

        // append to grid
        var assets = editor.call('assets:raw');
        if (pos === -1 || ! assets.data[pos + 1]) {
            grid.append(item);
        } else {
            grid.appendBefore(item, assetsIndex[assets.data[pos + 1].get('id')]);
        }

        resizeQueue();

        keepLegacyScriptsAtTop();
    });

    var keepLegacyScriptsAtTop = function() {
        if (! legacyScripts)
            return;

        // resort scripts folder in grid
        gridScripts.element.parentNode.removeChild(gridScripts.element);
        var first = grid.element.firstChild;
        if (first) {
            grid.element.insertBefore(gridScripts.element, first);
        } else {
            grid.element.appendChild(gridScripts.element);
        }

        // resort scripts folder in tree
        treeScripts.element.parentNode.removeChild(treeScripts.element);
        var next = treeRoot.elementTitle.nextSibling;
        if (next) {
            treeRoot.element.insertBefore(treeScripts.element, next);
        } else {
            treeRoot.element.appendChild(treeScripts.element);
        }
    };

    editor.on('assets:move', function(asset, pos) {
        var item = assetsIndex[asset.get('id')];
        // remove
        grid.element.removeChild(item.element);
        // append
        if (pos === -1) {
            // to end
            grid.append(item);
        } else {
            // before another element
            grid.appendBefore(item, assetsIndex[editor.call('assets:raw').data[pos + 1].get('id')]);
        }
    });

    editor.on('assets:remove', function(asset) {
        var treeItem = assetsIndex[asset.get('id')].tree;
        if (treeItem) {
            if (treeItem.parent)
                treeItem.parent.remove(treeItem);
            treeItem.destroy();
        }

        assetsIndex[asset.get('id')].destroy();

        resizeQueue();

        // reselect current directory, if selected was removed
        if (currentFolder && typeof(currentFolder) !== 'string') {
            var id = parseInt(currentFolder.get('id'), 10);
            var path = asset.get('path');
            var ind = path.indexOf(id);
            if (id === parseInt(asset.get('id'), 10) || ind !== -1) {
                if (ind === -1)
                    ind = path.length - 1;

                var found = false;
                i = ind + 1;
                while(i--) {
                    if (assetsIndex[path[i]]) {
                        found = true;
                        editor.call('assets:panel:currentFolder', assetsIndex[path[i]].asset);
                        break;
                    }
                }

                if (! found)
                    editor.call('assets:panel:currentFolder', null);
            }
        }
    });

    var addSourceFile = function(file) {
        file.set('type', 'script');

        var item = new ui.GridItem();
        item.script = file;
        item.class.add('type-script');
        grid.append(item);

        if (! editor.call('assets:panel:filter:default')('script', file))
            item.hidden = true;

        scriptsIndex[file.get('filename')] = item;

        var thumbnail = document.createElement('div');
        thumbnail.classList.add('thumbnail', 'placeholder');
        item.element.appendChild(thumbnail);

        var icon = document.createElement('div');
        icon.classList.add('icon');
        item.element.appendChild(icon);

        var label = item.labelElement = document.createElement('div');
        label.classList.add('label');
        label.textContent = file.get('filename');
        item.element.appendChild(label);

        var users = item.users = document.createElement('div');
        users.classList.add('users');
        item.element.appendChild(users);

        // update name/filename change
        var evtNameSet = file.on('filename:set', function(value, valueOld) {
            label.textContent = value;
            scriptsIndex[value] = item;
            delete scriptsIndex[valueOld];
        });
        item.on('destroy', function() {
            editor.call('selector:remove', file);
            evtNameSet.unbind();
            delete scriptsIndex[file.get('filename')];
        });
        file.on('destroy', function() {
            item.destroy();
        });

        editor.call('drop:item', {
            element: item.element,
            type: 'asset.script',
            data: {
                filename: file.get('filename')
            }
        });
    };
    var removeSourceFile = function(file) {
        file.destroy();
    };

    editor.on('sourcefiles:add', addSourceFile);
    editor.on('sourcefiles:remove', removeSourceFile);
});


/* editor/assets/assets-panel-control.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var assetsPanel = editor.call('layout.assets');

    // context menu
    var menu = new ui.Menu();
    root.append(menu);

    var assets = {
        'upload': {
            title: 'Upload',
            icon: '&#57909;'
        },
        'folder': {
            title: 'Folder',
            icon: '&#57657;'
        },
        'css': {
            title: 'CSS',
            icon: '&#57864;'
        },
        'cubemap': {
            title: 'CubeMap',
            icon: '&#57879;'
        },
        'html': {
            title: 'HTML',
            icon: '&#57864;'
        },
        'json': {
            title: 'JSON',
            icon: '&#57864;'
        },
        'material': {
            title: 'Material',
            icon: '&#57749;'
        },
        'script': {
            title: 'Script',
            icon: '&#57864;'
        },
        'shader': {
            title: 'Shader',
            icon: '&#57864;'
        },
        'text': {
            title: 'Text',
            icon: '&#57864;'
        }
    };

    var addNewMenuItem = function(key, data) {
        // new folder
        var item = new ui.MenuItem({
            text: data.title,
            icon: data.icon || '',
            value: key
        });
        item.on('select', function() {
            var args = {
                parent: editor.call('assets:panel:currentFolder')
            };

            if (key === 'upload') {
                editor.call('assets:upload:picker', args);
            } else if (key === 'script') {
                if (editor.call('settings:project').get('useLegacyScripts')) {
                    editor.call('sourcefiles:new');
                } else {
                    editor.call('picker:script-create', function(filename) {
                        editor.call('assets:create:script', {
                            filename: filename,
                            boilerplate: true
                        });
                    });
                }
            } else {
                editor.call('assets:create:' + key, args)
            }
        });
        menu.append(item);

        if (key === 'script') {
            editor.on('repositories:load', function (repositories) {
                if (repositories.get('current') !== 'directory')
                    item.disabled = true;
            });
        }
    };

    var keys = Object.keys(assets);
    for(var i = 0; i < keys.length; i++) {
        if (! assets.hasOwnProperty(keys[i]))
            continue;

        addNewMenuItem(keys[i], assets[keys[i]]);
    }

    // controls
    var controls = new ui.Panel();
    controls.enabled = false;
    controls.class.add('assets-controls');
    controls.parent = assetsPanel;
    assetsPanel.headerElement.insertBefore(controls.element, assetsPanel.headerElementTitle.nextSibling);
    editor.on('permissions:writeState', function(state) {
        controls.enabled = state;
    });


    // add
    var btnNew = new ui.Button();
    btnNew.hidden = ! editor.call('permissions:write');
    btnNew.class.add('create-asset');
    btnNew.text = '&#57632;';
    btnNew.on('click', function(evt) {
        var rect = btnNew.element.getBoundingClientRect();
        menu.position(rect.right, rect.top);
        menu.open = true;
    });
    controls.append(btnNew);

    var tooltipAdd = Tooltip.attach({
        target: btnNew.element,
        text: 'Add Asset',
        align: 'bottom',
        root: root
    });
    menu.on('open', function(state) {
        tooltipAdd.disabled = state;
    });

    // delete
    var btnDelete = new ui.Button({
        text: '&#57636;'
    });
    btnDelete.hidden = ! editor.call('permissions:write');
    btnDelete.style.fontWeight = 200;
    btnDelete.disabled = true;
    btnDelete.class.add('delete');
    btnDelete.on('click', function() {
        if (! editor.call('permissions:write'))
            return;

        var type = editor.call('selector:type');
        if (type !== 'asset')
            return;

        editor.call('assets:delete:picker', editor.call('selector:items'));
    });
    controls.append(btnDelete);

    var tooltipDelete = Tooltip.attach({
        target: btnDelete.element,
        text: 'Delete Asset',
        align: 'bottom',
        root: root
    });
    tooltipDelete.class.add('innactive');


    editor.on('permissions:writeState', function(state) {
        btnNew.hidden = ! state;
        btnDelete.hidden = ! state;
    });


    // folder up
    var btnUp = new ui.Button({
        text: '&#58117;'
    });
    btnUp.style.fontWeight = 200;
    btnUp.disabled = true;
    btnUp.class.add('up');
    btnUp.on('click', function() {
        var folder = editor.call('assets:panel:currentFolder');
        if (! folder) return;

        if (folder === 'scripts') {
            editor.call('assets:panel:currentFolder', null);
        } else {
            var path = folder.get('path');
            if (path.length) {
                var parent = editor.call('assets:get', path[path.length - 1]);
                if (parent) {
                    editor.call('assets:panel:currentFolder', parent);
                } else {
                    editor.call('assets:panel:currentFolder', null);
                }
            } else {
                editor.call('assets:panel:currentFolder', null);
            }
        }
    });
    controls.append(btnUp);

    editor.on('assets:panel:currentFolder', function(folder) {
        if (folder) {
            btnUp.disabled = false;
            tooltipUp.class.remove('innactive');
        } else {
            btnUp.disabled = true;
            tooltipUp.class.add('innactive');
        }
    });

    var tooltipUp = Tooltip.attach({
        target: btnUp.element,
        text: 'Folder Up',
        align: 'bottom',
        root: root
    });
    tooltipUp.class.add('innactive');


    var assetsGrid = assetsPanel.element.querySelector('.ui-panel > .content > ul.ui-grid.assets').ui;

    // thumbnails size
    var btnThumbSize = new ui.Button({
        text: '&#57669;'
    });
    btnThumbSize.style.fontWeight = 200;
    btnThumbSize.class.add('size');
    btnThumbSize.on('click', function() {
        if (assetsGrid.class.contains('small')) {
            assetsGrid.class.remove('small');
            tooltipThumbSize.html = '<span style="color:#fff">Large</span> / Small';
            editor.call('localStorage:set', 'editor:assets:thumbnail:size', 'large');
        } else {
            assetsGrid.class.add('small');
            tooltipThumbSize.html = 'Large / <span style="color:#fff">Small</span>';
            editor.call('localStorage:set', 'editor:assets:thumbnail:size', 'small');
        }
    });
    controls.append(btnThumbSize);

    var tooltipThumbSize = Tooltip.attach({
        target: btnThumbSize.element,
        align: 'bottom',
        root: root
    });

    var size = editor.call('localStorage:get', 'editor:assets:thumbnail:size');

    if (size === 'small') {
        assetsGrid.class.add('small');
        tooltipThumbSize.html = 'Large / <span style="color:#fff">Small</span>';
    } else {
        assetsGrid.class.remove('small');
        tooltipThumbSize.html = '<span style="color:#fff">Large</span> / Small';
    }
    tooltipThumbSize.class.add('innactive');


    editor.on('attributes:clear', function() {
        // btnDuplicate.disabled = true;
        btnDelete.disabled = true;
        tooltipDelete.class.add('innactive');
    });

    editor.on('attributes:inspect[*]', function(type) {
        if (type.startsWith('asset')) {
            btnDelete.enabled = true;
            tooltipDelete.class.remove('innactive');
        } else {
            btnDelete.enabled = false;
            tooltipDelete.class.add('innactive');
        }
        // btnDuplicate.enabled = type === 'asset.material';
    });
});


/* editor/assets/assets-pipeline-settings.js */
editor.once('load', function() {
    'use strict';

    var settings = new Observer({
        'auto': true,
        'texturePot': true,
        'searchRelatedAssets': true,
        'preserveMapping': false,
        'overwriteModel': true,
        'overwriteAnimation': true,
        'overwriteMaterial': false,
        'overwriteTexture': true
    });

    var projectSettings = editor.call('settings:project');

    settings.on('*:set', function(path, value) {
        editor.emit('assets:pipeline:settings:' + path, value);
    });

    var foldStates = {
        'pipeline': true
    };

    editor.on('attributes:inspect[editorSettings]', function() {
        var panel = editor.call('attributes:addPanel', {
            name: 'Asset Tasks'
        });
        panel.foldable = true;
        panel.folded = foldStates['pipeline'];
        panel.on('fold', function() { foldStates['pipeline'] = true; });
        panel.on('unfold', function() { foldStates['pipeline'] = false; });
        panel.class.add('component', 'pipeline');
        // reference
        editor.call('attributes:reference:attach', 'settings:asset-tasks', panel, panel.headerElement);

        var fieldAuto = editor.call('attributes:addField', {
            parent: panel,
            name: 'Auto-run',
            type: 'checkbox',
            link: settings,
            path: 'auto'
        });
        editor.call('attributes:reference:attach', 'settings:asset-tasks:auto', fieldAuto.parent.innerElement.firstChild.ui);

        var fieldTexturePOT = editor.call('attributes:addField', {
            parent: panel,
            name: 'Textures POT',
            type: 'checkbox',
            link: settings,
            path: 'texturePot'
        });
        editor.call('attributes:reference:attach', 'settings:asset-tasks:texturePot', fieldTexturePOT.parent.innerElement.firstChild.ui);

        var fieldSearchRelatedAssets = editor.call('attributes:addField', {
            parent: panel,
            name: 'Search related assets',
            type: 'checkbox',
            link: settings,
            path: 'searchRelatedAssets'
        });
        fieldSearchRelatedAssets.parent.innerElement.firstChild.style.width = 'auto';
        editor.call('attributes:reference:attach', 'settings:asset-tasks:searchRelatedAssets', fieldSearchRelatedAssets.parent.innerElement.firstChild.ui);

        var fieldMapping = editor.call('attributes:addField', {
            parent: panel,
            name: 'Preserve material mappings',
            type: 'checkbox',
            link: settings,
            path: 'preserveMapping'
        });
        fieldMapping.parent.innerElement.firstChild.style.width = 'auto';
        editor.call('attributes:reference:attach', 'settings:asset-tasks:preserveMapping', fieldMapping.parent.innerElement.firstChild.ui);

        var fieldModelV2 = editor.call('attributes:addField', {
            parent: panel,
            name: 'Force legacy model v2',
            type: 'checkbox',
            link: projectSettings,
            path: 'useModelV2'
        });
        fieldModelV2.parent.innerElement.firstChild.style.width = 'auto';
        editor.call('attributes:reference:attach', 'settings:asset-tasks:useModelV2', fieldModelV2.parent.innerElement.firstChild.ui);


        var fieldOverwrite = editor.call('attributes:addField', {
            parent: panel,
            name: 'Overwriting behaviour:'
        });
        fieldOverwrite.parent.innerElement.firstChild.style.width = 'auto';
        fieldOverwrite.destroy();

        var fieldOverwriteModel = editor.call('attributes:addField', {
            parent: panel,
            name: 'Model',
            type: 'checkbox',
            link: settings,
            path: 'overwriteModel'
        });
        editor.call('attributes:reference:attach', 'settings:asset-tasks:overwrite:model', fieldOverwriteModel.parent.innerElement.firstChild.ui);

        var fieldOverwriteAnimation = editor.call('attributes:addField', {
            parent: panel,
            name: 'Animation',
            type: 'checkbox',
            link: settings,
            path: 'overwriteAnimation'
        });
        editor.call('attributes:reference:attach', 'settings:asset-tasks:overwrite:animation', fieldOverwriteAnimation.parent.innerElement.firstChild.ui);

        var fieldOverwriteMaterial = editor.call('attributes:addField', {
            parent: panel,
            name: 'Material',
            type: 'checkbox',
            link: settings,
            path: 'overwriteMaterial'
        });
        editor.call('attributes:reference:attach', 'settings:asset-tasks:overwrite:material', fieldOverwriteMaterial.parent.innerElement.firstChild.ui);

        var fieldOverwriteTexture = editor.call('attributes:addField', {
            parent: panel,
            name: 'Texture',
            type: 'checkbox',
            link: settings,
            path: 'overwriteTexture'
        });
        editor.call('attributes:reference:attach', 'settings:asset-tasks:overwrite:texture', fieldOverwriteTexture.parent.innerElement.firstChild.ui);
    });

    editor.method('assets:pipeline:settings', function(name, value) {
        if (! name)
            return settings;

        if (typeof(value) === 'undefined')
            return settings.get(name);

        if (settings.has(name))
            settings.set(name, value);
    });
});


/* editor/assets/assets-pipeline-widget.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var assetsPanel = editor.call('layout.assets');
    var viewport = editor.call('layout.viewport');

    // panel
    var panel = new ui.Panel('ASSET TASKS');
    panel.class.add('pipeline-widget');
    panel.flexShrink = false;
    panel.foldable = true;
    panel.folded = true;
    panel.scroll = true;
    panel.hidden = ! editor.call('permissions:write') || editor.call('viewport:expand:state');
    editor.on('permissions:writeState', function(state) {
        panel.hidden = ! state || editor.call('viewport:expand:state');
    });
    viewport.append(panel);

    editor.on('viewport:expand', function(state) {
        panel.hidden = ! editor.call('permissions:write') || state;
    });

    // number
    var number = document.createElement('span');
    number.classList.add('number');
    number.textContent = '0';
    panel.headerAppend(number);

    // list
    var list = new ui.List();
    list.disabled = true;
    list.class.add('jobs');
    panel.append(list);


    // settings
    var btnSettings = new ui.Button({
        text: '&#57652;'
    });
    btnSettings.class.add('settings');
    btnSettings.on('click', function () {
        editor.call('selector:set', 'editorSettings', [ editor.call('settings:projectUser') ]);
        setTimeout(function() {
            editor.call('editorSettings:panel:unfold', 'pipeline');
        }, 0);
    });
    panel.append(btnSettings);

    var tooltipSettings = Tooltip.attach({
        target: btnSettings.element,
        text: 'Settings',
        align: 'bottom',
        root: root
    });


    // auto toggle
    var toggleAuto = new ui.Button({
        text: '&#57640;'
    });
    toggleAuto.class.add('toggle', 'auto', 'active');
    toggleAuto.on('click', function () {
        if (! editor.call('permissions:write'))
            return;

        editor.call('assets:pipeline:settings', 'auto', ! editor.call('assets:pipeline:settings', 'auto'));
    });
    var toggleAutoSet = function(state) {
        if (state) {
            list.disabled = true;
            toggleAuto.class.add('active');
            tooltipAuto.class.remove('innactive');
        } else {
            list.disabled = false;
            toggleAuto.class.remove('active');
            tooltipAuto.class.add('innactive');
        }
    };
    editor.on('assets:pipeline:settings:auto', toggleAutoSet);
    panel.append(toggleAuto);

    var tooltipAuto = Tooltip.attach({
        target: toggleAuto.element,
        text: 'Auto-Run',
        align: 'bottom',
        root: root
    });

    toggleAutoSet(editor.call('assets:pipeline:settings', 'auto'));


    var nearestPow2 = function(size) {
        return Math.pow(2, Math.round(Math.log(size) / Math.log(2)));
    };

    var jobs = { };


    editor.method('assets:jobs:remove', function(id) {
        if (! jobs[id])
            return;

        jobs[id].destroy();
        delete jobs[id];

        number.textContent = list.innerElement.childNodes.length;
    });


    editor.method('assets:jobs:texture-convert-options', function(meta) {
        if (! meta) return null;

        var options = {
            new: false
        };

        // normalize jpeg format
        if (meta.format === 'jpg')
            meta.format = 'jpeg';

        // target format
        if (meta.format === 'gif') {
            options.format = 'gif';
        } else {
            options.format = 'jpeg';
        }

        if ((meta.format === 'png' || meta.alpha || meta.depth > 8) && meta.format !== 'gif')
            options.format = 'png';

        // rgbm
        if (options.format === 'png' && meta.depth > 8 && [ 'hdr', 'exr', 'tiff' ].indexOf(meta.format) !== -1)
            options.rgbm = true;

        // check if resizing to nearest power of 2 required
        if (editor.call('assets:pipeline:settings', 'texturePot')) {
            options.size = {
                width: nearestPow2(meta.width),
                height: nearestPow2(meta.height)
            };
        }

        // check for different format
        if (meta.format !== options.format)
            options.new = true;

        if (! options.new && meta.depth > 8)
            options.depthConvert = true;

        return options;
    });


    editor.method('assets:jobs:thumbnails', function(source, target) {
        source = source || target;

        var task = {
            source: parseInt(source.get('id'), 10)
        };

        if (target && target !== source) {
            task.target = parseInt(target.get('id'), 10);
        } else {
            task.target = task.source;
        }

        if (! source.get('file.filename') || ! target.get('file.filename'))
            return;

        editor.call('realtime:send', 'pipeline', {
            name: 'thumbnails',
            data: task
        });
    });


    editor.method('assets:jobs:convert', function(asset, options) {
        if (options) {
            editor.call('realtime:send', 'pipeline', {
                name: 'convert',
                data: options
            });
        } else {
            // auto convert
            var item = jobs[asset.get('id')];
            var meta = asset.get('meta');

            var events = [ ];

            if (item) {
                events = item.events;
                item.class.add('processing');
            } else {
                asset.once('destroy', function() {
                    for(var i = 0; i < events.length; i++)
                        events[i].unbind();
                });
            }

            if (asset.get('type') === 'texture') {
                var task = {
                    source: parseInt(asset.get('id'), 10)
                };

                task.options = editor.call('assets:jobs:texture-convert-options', meta);

                if (! task.options.new) {
                    task.target = task.source;

                    editor.call('realtime:send', 'pipeline', {
                        name: 'convert',
                        data: task
                    });

                    var onFileSet = function(value) {
                        editor.call('assets:jobs:remove', asset.get('id'));

                        if (! value) return;
                        asset.unbind('file:set', onFileSet);

                        setTimeout(function() {
                            editor.call('assets:jobs:thumbnails', null, asset);
                        }, 0);
                    };

                    events.push(asset.on('file:set', onFileSet));

                    // no changes to asset
                    if (Object.keys(task.options).length === 2 && task.options.format === meta.format) {
                        editor.call('assets:jobs:remove', asset.get('id'));

                        if (asset.get('file')) {
                            setTimeout(function() {
                                editor.call('assets:jobs:thumbnails', null, asset);
                            }, 0);
                        }
                    }
                } else {
                    var filename = asset.get('file.filename').split('.');
                    filename = filename.slice(0, filename.length - 1).join() + '.' + task.options.format;
                    var path = asset.get('path');

                    var target = editor.call('assets:findOne', function(a) {
                        if (a.get('name') !== filename || a.get('source_asset_id') !== asset.get('id'))
                            return false;

                        if (! editor.call('assets:pipeline:settings', 'searchRelatedAssets') && ! a.get('path').equals(path))
                            return false;

                        return true;
                    });
                    if (target)
                        target = target[1];

                    var onTargetAvailable = function(target) {
                        task.target = parseInt(target.get('id'), 10);
                        task.filename = filename;

                        editor.call('realtime:send', 'pipeline', {
                            name: 'convert',
                            data: task
                        });

                        var onFileSet = function(value) {
                            editor.call('assets:jobs:remove', asset.get('id'));

                            if (! value) return;
                            target.unbind('file:set', onFileSet);

                            setTimeout(function() {
                                if (target.get('data.rgbm')) {
                                    editor.call('assets:jobs:thumbnails', asset, target);
                                } else {
                                    editor.call('assets:jobs:thumbnails', null, target);
                                }
                            }, 0);
                        };

                        events.push(target.once('file:set', onFileSet));
                    };

                    if (target) {
                        onTargetAvailable(target);
                    } else {
                        var data = null;

                        if (task.options.rgbm) {
                            data = {
                                rgbm: true
                            };
                        }
                        var assetNew = {
                            name: filename,
                            type: 'texture',
                            source: false,
                            source_asset_id: asset.get('id'),
                            preload: true,
                            data: data,
                            region: asset.get('region'),
                            parent: path.length ? path[path.length - 1] : null,
                            scope: asset.get('scope'),
                            meta: asset.get('meta')
                        };

                        editor.call('assets:create', assetNew, function(err, id) {
                            var target = editor.call('assets:get', id);

                            if (target) {
                                onTargetAvailable(target)
                            } else {
                                events.push(editor.once('assets:add[' + id + ']', onTargetAvailable));
                            }
                        });
                    }
                }
            } else if (asset.get('type') === 'scene') {
                var path = asset.get('path');
                var model = { };
                var animation = null;
                var materials = asset.get('meta.materials') || [ ];
                var textures = asset.get('meta.textures') || [ ];

                var nameModel = asset.get('name').split('.');
                nameModel = nameModel.slice(0, nameModel.length - 1).join('.') + '.json';

                // model
                var modelTarget = editor.call('assets:findOne', function(a) {
                    if (a.get('source_asset_id') !== asset.get('id') || a.get('name') !== nameModel || a.get('type') !== 'model')
                        return false;

                    if (! editor.call('assets:pipeline:settings', 'searchRelatedAssets') && ! a.get('path').equals(path))
                        return false;

                    return true;
                });
                if (modelTarget) {
                    model.asset = parseInt(modelTarget[1].get('id'), 10);
                    model.override = editor.call('assets:pipeline:settings', 'overwriteModel');
                }

                // animation
                if (asset.get('meta.animation.available')) {
                    animation = { };

                    var animationTarget = editor.call('assets:findOne', function(a) {
                        if (a.get('source_asset_id') !== asset.get('id') || a.get('name') !== nameModel || a.get('type') !== 'animation')
                            return false;

                        if (! editor.call('assets:pipeline:settings', 'searchRelatedAssets') && ! a.get('path').equals(path))
                            return false;

                        return true;
                    });

                    if (animationTarget) {
                        animation.asset = parseInt(animationTarget[1].get('id'), 10);
                        animation.override = editor.call('assets:pipeline:settings', 'overwriteAnimation');;
                    }
                }

                // materials
                for(var i = 0; i < materials.length; i++) {
                    var target = editor.call('assets:findOne', function(a) {
                        if (a.get('source_asset_id') !== asset.get('id') || a.get('name') !== materials[i].name || a.get('type') !== 'material')
                            return false;

                        if (! editor.call('assets:pipeline:settings', 'searchRelatedAssets') && ! a.get('path').equals(path))
                            return false;

                        return true;
                    });

                    if (target) {
                        materials[i].asset = parseInt(target[1].get('id'), 10);
                        materials[i].override = editor.call('assets:pipeline:settings', 'overwriteMaterial');;
                    }
                }

                // textures
                for(var i = 0; i < textures.length; i++) {
                    var name = textures[i].name.toLowerCase();
                    if (name.endsWith('.jpg'))
                        name = name.slice(0, -4) + '.jpeg';

                    textures[i].options = editor.call('assets:jobs:texture-convert-options', textures[i].meta);

                    var fileName = name.replace(/\.[0-9a-z]{3,4}$/i, '') + '.' + textures[i].options.format;

                    var target = editor.call('assets:findOne', function(a) {
                        if (a.get('source_asset_id') !== asset.get('id') || a.get('name').toLowerCase() !== fileName || a.get('type') !== 'texture' || a.get('source'))
                            return false;

                        if (! editor.call('assets:pipeline:settings', 'searchRelatedAssets') && ! a.get('path').equals(path))
                            return false;

                        return true;
                    });

                    if (target) {
                        textures[i].asset = parseInt(target[1].get('id'), 10);
                        textures[i].override = editor.call('assets:pipeline:settings', 'overwriteTexture');;
                    }
                }

                var task = {
                    source: parseInt(asset.get('id'), 10),
                    options: {
                        textures: textures,
                        materials: materials,
                        mappings: asset.get('meta.mappings'),
                        animation: animation,
                        model: model,
                        preserveMapping: editor.call('assets:pipeline:settings', 'preserveMapping')
                    }
                };

                editor.call('realtime:send', 'pipeline', {
                    name: 'convert',
                    data: task
                });

                editor.call('assets:jobs:remove', asset.get('id'));
            } else if (asset.get('type') === 'font') {
                var task = {
                    source: parseInt(asset.get('id'), 10)
                };

                var filename = asset.get('file.filename');
                var path = asset.get('path');

                var target = editor.call('assets:findOne', function(a) {
                    return a.get('name') === filename && a.get('source_asset_id') === asset.get('id');
                });

                if (target)
                    target = target[1];

                var onTargetAvailable = function(target) {
                    var chars = null;
                    if (! target.get('meta')) {
                        chars = [ ];
                        for (var i = 0x20; i <= 0x7e; i++)
                            chars.push(String.fromCharCode(i));
                        chars = chars.join('');
                    }
                    task.target = parseInt(target.get('id'), 10);
                    task.filename = filename;
                    task.chars = chars;

                    editor.call('realtime:send', 'pipeline', {
                        name: 'convert',
                        data: task
                    });

                    events.push(target.once('file:set', function() {
                        editor.call('assets:jobs:remove', asset.get('id'));
                    }));
                };

                if (target) {
                    onTargetAvailable(target);
                } else {
                    var data = {
                        intensity: 0.0
                    };

                    var chars = [ ];
                    for (var i = 0x20; i <= 0x7e; i++)
                        chars.push(String.fromCharCode(i));
                    chars = chars.join('');

                    var assetNew = {
                        name: filename,
                        type: 'font',
                        source: false,
                        source_asset_id: asset.get('id'),
                        preload: true,
                        data: data,
                        meta: { chars: chars },
                        region: asset.get('region'),
                        parent: path.length ? path[path.length - 1] : null,
                        scope: asset.get('scope')
                    };

                    editor.call('assets:create', assetNew, function(err, id) {
                        var target = editor.call('assets:get', id);

                        if (target) {
                            onTargetAvailable(target);
                        } else {
                            events.push(editor.once('assets:add[' + id + ']', onTargetAvailable));
                        }
                    });
                }
            }
        }
    });


    editor.method('assets:jobs:add', function(asset) {
        if (jobs[asset.get('id')])
            return;

        var type = asset.get('type');
        if ([ 'texture', 'scene', 'font' ].indexOf(type) === -1)
            return;

        var events = [ ];

        var item = jobs[asset.get('id')] = new ui.ListItem();
        item.events = events;
        item.asset = asset;
        item.text = asset.get('name');

        events.push(asset.on('name:set', function(value) {
            item.text = asset.get('name');
        }));
        events.push(asset.once('destroy', function() {
            editor.call('assets:jobs:remove', asset.get('id'));
        }));

        list.append(item);

        // remove on right click
        item.element.addEventListener('contextmenu', function() {
            if (! editor.call('permissions:write'))
                return;

            editor.call('assets:jobs:remove', asset.get('id'));
        }, false);

        var auto = new ui.Button({
            text: '&#57649;'
        });
        auto.class.add('auto');
        auto.parent = item;
        item.element.appendChild(auto.element);

        number.textContent = list.innerElement.childNodes.length;

        item.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();
        });

        var convertAuto = function() {
            if (! editor.call('permissions:write'))
                return;

            editor.call('assets:jobs:convert', asset);
        };

        auto.on('click', convertAuto);

        if (editor.call('assets:pipeline:settings', 'auto')) {
            if (type === 'font') {
                // convert fonts once the source file has been set
                var file = asset.get('file');
                if (file) {
                    convertAuto();
                } else {
                    events.push(asset.once('file:set', function (value) {
                        if (! editor.call('assets:pipeline:settings', 'auto'))
                            return;

                        convertAuto();
                    }));
                }
            } else {
                // convert asset once it has meta set
                var file = asset.get('file');
                var meta = asset.get('meta');

                if (file && meta && ! (asset.get('type') === 'texture' && ! meta.format)) {
                    convertAuto();
                } else {
                    var converted = false;

                    var onDataAvailable = function(path, value) {
                        if (converted)
                            return;

                        if (! editor.call('assets:pipeline:settings', 'auto'))
                            return;

                        if (! asset.get('file.filename'))
                            return;

                        if (asset.get('type') === 'texture' && ! asset.get('meta.format'))
                            return;

                        if (! asset.get('meta'))
                            return;

                        evtWaitForData.unbind();
                        converted = true;
                        setTimeout(convertAuto, 0);
                    };

                    var evtWaitForData = asset.on('*:set', onDataAvailable);

                    events.push(evtWaitForData);
                }
            }
        } else {
            if (asset.get('type') === 'texture' && ! asset.get('source')) {
                var filename = asset.get('file.filename');

                if (filename) {
                    editor.call('assets:jobs:thumbnails', null, asset);
                } else {
                    events.push(asset.once('file.filename:set', function() {
                        editor.call('assets:jobs:thumbnails', null, asset);
                    }));
                }
            }
        }

        return item;
    });



    // offset panel if assets panel header overlaps
    var canvas = null;

    var reflow = function() {
        if (! canvas)
            return;

        if ((8 + assetsPanel.headerElement.clientWidth + panel.element.clientWidth) > canvas.width) {
            panel.class.add('offset');
            panel.style.left = (assetsPanel.headerElement.clientWidth + 4) + 'px';
        } else {
            panel.class.remove('offset');
            panel.style.left = '';
        }
    };

    setTimeout(function() {
        canvas = editor.call('viewport:canvas');
        if (canvas)
            canvas.on('resize', reflow);
    });
});


/* editor/assets/assets-context-menu.js */
editor.once('load', function() {
    'use strict';

    var currentAsset = null;
    var legacyScripts = editor.call('settings:project').get('useLegacyScripts');
    var root = editor.call('layout.root');

    var customMenuItems = [ ];

    // menu
    var menu = new ui.Menu();
    root.append(menu);


    // edit
    var menuItemNewScript = new ui.MenuItem({
        text: 'New Script',
        icon: '&#57864;',
        value: 'script'
    });
    menuItemNewScript.on('select', function() {
        if (legacyScripts) {
            editor.call('sourcefiles:new');
        } else {
            editor.call('picker:script-create', function(filename) {
                editor.call('assets:create:script', {
                    filename: filename,
                    boilerplate: true
                });
            });
        }
    });
    menu.append(menuItemNewScript);


    // new asset
    var menuItemNew = new ui.MenuItem({
        text: 'New Asset',
        icon: '&#57632;',
        value: 'new'
    });
    menu.append(menuItemNew);

    var downloadable = {
        'texture': 1,
        'html': 1,
        'css': 1,
        'shader': 1,
        'scene': 1,
        'json': 1,
        'audio': 1,
        'text': 1
    };

    var icons = {
        'upload': '&#57909;',
        'folder': '&#57657;',
        'css': '&#57864;',
        'cubemap': '&#57879;',
        'html': '&#57864;',
        'json': '&#57864;',
        'material': '&#57749;',
        'script': '&#57864;',
        'shader': '&#57864;',
        'text': '&#57864;',
        'texture': '&#57857;',
        'model': '&#57735;',
        'scene': '&#57735;',
        'animation': '&#57875;',
        'audio': '&#57872;'
    };

    var assets = {
        'upload': 'Upload',
        'folder': 'Folder',
        'css': 'CSS',
        'cubemap': 'CubeMap',
        'html': 'HTML',
        'json': 'JSON',
        'material': 'Material',
        'script': 'Script',
        'shader': 'Shader',
        'text': 'Text'
    };

    var addNewMenuItem = function(key, title) {
        // new folder
        var item = new ui.MenuItem({
            text: title,
            icon: icons[key] || '',
            value: key
        });
        item.on('select', function() {
            var args = { };

            if (currentAsset && currentAsset.get('type') === 'folder') {
                args.parent = currentAsset;
            } else if (currentAsset === undefined) {
                args.parent = null;
            }

            if (key === 'upload') {
                editor.call('assets:upload:picker', args);
            } else if (key === 'script') {
                if (legacyScripts) {
                    editor.call('sourcefiles:new');
                } else {
                    editor.call('picker:script-create', function(filename) {
                        editor.call('assets:create:script', {
                            filename: filename,
                            boilerplate: true
                        });
                    });
                }
            } else {
                editor.call('assets:create:' + key, args)
            }
        });
        menuItemNew.append(item);

        if (key === 'script') {
            editor.on('repositories:load', function (repositories) {
                if (repositories.get('current') !== 'directory')
                    item.disabled = true;
            });
        }
    };

    var keys = Object.keys(assets);
    for(var i = 0; i < keys.length; i++) {
        if (! assets.hasOwnProperty(keys[i]))
            continue;

        addNewMenuItem(keys[i], assets[keys[i]]);
    }


    // related
    var menuItemReferences = new ui.MenuItem({
        text: 'References',
        icon: '&#57622;',
        value: 'references'
    });
    menu.append(menuItemReferences);


    // replace
    var replaceAvailable = {
        'material': true,
        'texture': true,
        'model': true,
        'animation': true,
        'audio': true,
        'cubemap': true,
        'css': true,
        'html': true,
        'shader': true,
        'json': true,
        'text': true
    };
    var menuItemReplace = new ui.MenuItem({
        text: 'Replace',
        icon: '&#57640;',
        value: 'replace'
    });
    menuItemReplace.on('select', function() {
        var id = parseInt(currentAsset.get('id'), 10);

        editor.call('picker:asset', currentAsset.get('type'), currentAsset);

        var evtPick = editor.once('picker:asset', function(asset) {
            editor.call('assets:replace', currentAsset, asset);
            evtPick = null;
        });

        editor.once('picker:asset:close', function() {
            if (evtPick) {
                evtPick.unbind();
                evtPick = null;
            }
        });
    });
    menu.append(menuItemReplace);


    // extract
    var menuItemExtract = new ui.MenuItem({
        text: 'Re-Import',
        icon: '&#57889;',
        value: 'extract'
    });
    menuItemExtract.on('select', function() {
        if (! currentAsset.get('meta'))
            return;

        editor.call('assets:jobs:convert', currentAsset);
    });
    menu.append(menuItemExtract);


    // re-import
    var menuItemReImport = new ui.MenuItem({
        text: 'Re-Import',
        icon: '&#57889;',
        value: 're-import'
    });
    menuItemReImport.on('select', function() {
        var target = currentAsset;
        var sourceId = target.get('source_asset_id');

        if (target.get('source') || ! sourceId)
            return;

        var source = editor.call('assets:get', sourceId);

        if (! source)
            return;

        var task = {
            source: parseInt(source.get('id'), 10)
        };

        if (source.get('type') === 'texture') {
            task.target = parseInt(target.get('id'), 10);
            task.options = editor.call('assets:jobs:texture-convert-options', source.get('meta'));

            if (target.get('meta.width') && target.get('meta.height')) {
                task.options.size = {
                    width: target.get('meta.width'),
                    height: target.get('meta.height')
                };
            }

            editor.call('realtime:send', 'pipeline', {
                name: 'convert',
                data: task
            });

            var onFileSet = function(value) {
                if (! value) return;

                target.unbind('file:set', onFileSet);

                setTimeout(function() {
                    if (target.get('data.rgbm')) {
                        editor.call('assets:jobs:thumbnails', source, target);
                    } else {
                        editor.call('assets:jobs:thumbnails', null, target);
                    }
                }, 0);
            };

            target.on('file:set', onFileSet);
        } else if (source.get('type') === 'scene') {
            if (! source.get('meta'))
                return;

            var type = target.get('type');

            if (type === 'texture') {
                // TODO
                return;
            } else if (type === 'material') {
                // TODO
                return;
            } else if (type === 'animation') {
                if (! source.get('meta.animation.available'))
                    return;

                task.target = parseInt(target.get('id'), 10);
            } else if (type === 'model') {
                task.target = parseInt(target.get('id'), 10);
            } else {
                return;
            }

            editor.call('realtime:send', 'pipeline', {
                name: 'convert',
                data: task
            });
        } else if (source.get('type') === 'font') {
            var chars = null;
            if (! target.get('meta')) {
                chars = [ ];
                for (var i = 0x20; i <= 0x7e; i++)
                    chars.push(String.fromCharCode(i));
                chars = chars.join('');
            }
            task.target = parseInt(target.get('id'), 10);
            task.chars = chars;

            editor.call('realtime:send', 'pipeline', {
                name: 'convert',
                data: task
            });
        }
    });
    menu.append(menuItemReImport);


    // download
    var menuItemDownload = new ui.MenuItem({
        text: 'Download',
        icon: '&#57896;',
        value: 'download'
    });
    menuItemDownload.on('select', function() {
        window.open(currentAsset.get('file.url'));
    });
    menu.append(menuItemDownload);


    // edit
    var menuItemEdit = new ui.MenuItem({
        text: 'Edit',
        icon: '&#57648;',
        value: 'edit'
    });
    menuItemEdit.on('select', function() {
        editor.call('assets:edit', currentAsset);
    });
    menu.append(menuItemEdit);


    // duplicate
    var menuItemDuplicate = new ui.MenuItem({
        text: 'Duplicate',
        icon: '&#57638;',
        value: 'duplicate'
    });
    menuItemDuplicate.on('select', function() {
        editor.call('assets:duplicate', currentAsset);
    });
    menu.append(menuItemDuplicate);


    // delete
    var menuItemDelete = new ui.MenuItem({
        text: 'Delete',
        icon: '&#57636;',
        value: 'delete'
    });
    menuItemDelete.style.fontWeight = 200;
    menuItemDelete.on('select', function() {
        var asset = currentAsset;
        var multiple = false;

        if (asset) {
            var assetType = asset.get('type');
            var type = editor.call('selector:type');
            var items;

            if (type === 'asset') {
                items = editor.call('selector:items');
                for(var i = 0; i < items.length; i++) {
                    if ((assetType === 'script' && items[i].get('filename') === asset.get('filename')) || (assetType !== 'script' && items[i].get('id') === asset.get('id'))) {
                        multiple = true;
                        break;
                    }
                }
            }

            editor.call('assets:delete:picker', multiple ? items : [ asset ]);
        }
    });
    menu.append(menuItemDelete);


    // filter buttons
    menu.on('open', function() {
        menuItemNewScript.hidden = ! ((currentAsset === null || (currentAsset && currentAsset.get('type') === 'script')) && editor.call('assets:panel:currentFolder') === 'scripts');
        menuItemNew.hidden = ! menuItemNewScript.hidden;

        if (currentAsset) {
            // download
            menuItemDownload.hidden = ! ((! config.project.privateAssets || (config.project.privateAssets && editor.call('permissions:read'))) && currentAsset.get('type') !== 'folder' && (currentAsset.get('source') || downloadable[currentAsset.get('type')] || (! legacyScripts && currentAsset.get('type') === 'script')) && currentAsset.get('file.url'));

            // duplicate
            if (currentAsset.get('type') === 'material') {
                menuItemEdit.hidden = true;
                if (editor.call('selector:type') === 'asset') {
                    var items = editor.call('selector:items');
                    menuItemDuplicate.hidden = (items.length > 1 && items.indexOf(currentAsset) !== -1);
                } else {
                    menuItemDuplicate.hidden = false;
                }
            } else {
                menuItemDuplicate.hidden = true;
            }

            // edit
            if (! currentAsset.get('source') && ['html', 'css', 'json', 'text', 'script', 'shader'].indexOf(currentAsset.get('type')) !== -1) {
                if (editor.call('selector:type') === 'asset') {
                    var items = editor.call('selector:items');
                    menuItemEdit.hidden = (items.length > 1 && items.indexOf(currentAsset) !== -1);
                } else {
                    menuItemEdit.hidden = false;
                }
            } else {
                menuItemEdit.hidden = true;
            }

            // delete
            menuItemDelete.hidden = false;

            if (! currentAsset.get('source')) {
                menuItemExtract.hidden = true;

                // re-import
                var sourceId = currentAsset.get('source_asset_id');
                if (sourceId) {
                    var source = editor.call('assets:get', sourceId)
                    if (source) {
                        if (source.get('type') === 'scene' && ([ 'texture', 'material' ].indexOf(currentAsset.get('type')) !== -1 || ! source.get('meta'))) {
                            menuItemReImport.hidden = true;
                        } else if (currentAsset.get('type') === 'animation' && ! source.get('meta.animation.available')) {
                            menuItemReImport.hidden = true;
                        } else if (currentAsset.get('type') === 'material' && ! currentAsset.has('meta.index')) {
                            menuItemReImport.hidden = true;
                        } else {
                            menuItemReImport.hidden = false;
                        }
                    } else {
                        menuItemReImport.hidden = true;
                    }
                } else {
                    menuItemReImport.hidden = true;
                }

                // references
                var ref = editor.call('assets:used:index')[currentAsset.get('id')];
                if (ref && ref.count && ref.ref) {
                    menuItemReferences.hidden = false;
                    menuItemReplace.hidden = replaceAvailable[currentAsset.get('type')] ? false : true;

                    while(menuItemReferences.innerElement.firstChild)
                        menuItemReferences.innerElement.firstChild.ui.destroy();

                    var menuItems = [ ];

                    var addReferenceItem = function(type, id) {
                        var menuItem = new ui.MenuItem();
                        var item = null;

                        if (type === 'editorSettings') {
                            menuItem.text = 'Scene Settings';
                            menuItem.icon = '&#57652;';
                            item = editor.call('settings:projectUser');
                            if (! item) return;
                        } else {
                            if (type === 'entity') {
                                item = editor.call('entities:get', id);
                                menuItem.icon = '&#57734;';
                            } else if (type === 'asset') {
                                item = editor.call('assets:get', id);
                                menuItem.icon = icons[item.get('type')] || '';
                            }
                            if (! item) return;
                            menuItem.text = item.get('name');
                        }

                        menuItems.push({
                            name: menuItem.text,
                            type: type,
                            element: menuItem
                        });

                        menuItem.on('select', function() {
                            editor.call('selector:set', type, [ item ]);

                            var folder = null;
                            var path = item.get('path') || [ ];
                            if (path.length)
                                folder = editor.call('assets:get', path[path.length - 1]);

                            editor.call('assets:panel:currentFolder', folder);

                            // unfold rendering tab
                            if (type === 'editorSettings') {
                                setTimeout(function() {
                                    editor.call('editorSettings:panel:unfold', 'rendering');
                                }, 0);
                            }
                        });
                    };

                    for(var key in ref.ref)
                        addReferenceItem(ref.ref[key].type, key);

                    var typeSort = {
                        'editorSettings': 1,
                        'asset': 2,
                        'entity': 3
                    };

                    menuItems.sort(function(a, b) {
                        if (a.type !== b.type) {
                            return typeSort[a.type] - typeSort[b.type];
                        } else {
                            if (a.name > b.name) {
                                return 1;
                            } else if (a.name < b.name) {
                                return -1;
                            } else {
                                return 0;
                            }
                        }
                    });

                    for(var i = 0; i < menuItems.length; i++)
                        menuItemReferences.append(menuItems[i].element);
                } else {
                    menuItemReferences.hidden = true;
                    menuItemReplace.hidden = true;
                }
            } else {
                menuItemReferences.hidden = true;
                menuItemReplace.hidden = true;
                menuItemReImport.hidden = true;
                menuItemExtract.hidden = [ 'scene', 'texture' ].indexOf(currentAsset.get('type')) === -1 || ! currentAsset.get('meta');
            }
        } else {
            // no asset
            menuItemExtract.hidden = true;
            menuItemReImport.hidden = true;
            menuItemDownload.hidden = true;
            menuItemDuplicate.hidden = true;
            menuItemEdit.hidden = true;
            menuItemDelete.hidden = true;
            menuItemReferences.hidden = true;
            menuItemReplace.hidden = true;
        }

        for(var i = 0; i < customMenuItems.length; i++) {
            if (! customMenuItems[i].filter)
                continue;

            customMenuItems[i].hidden = ! customMenuItems[i].filter(currentAsset);
        }
    });


    // for each asset added
    editor.on('assets:add', function(asset) {
        // get grid item
        var item = editor.call('assets:panel:get', asset.get('id'));
        if (! item) return;

        var contextMenuHandler = function(evt) {
            evt.stopPropagation();
            evt.preventDefault();

            if (! editor.call('permissions:write'))
                return;

            currentAsset = asset;
            menu.open = true;
            menu.position(evt.clientX + 1, evt.clientY);
        };

        // grid
        item.element.addEventListener('contextmenu', contextMenuHandler, false);

        // tree
        if (item.tree)
            item.tree.elementTitle.addEventListener('contextmenu', contextMenuHandler, false);
    });

    editor.on('sourcefiles:add', function(asset) {
        // get grid item
        var item = editor.call('assets:panel:get', asset.get('filename'));
        if (! item) return;

        // attach contextmenu event
        item.element.addEventListener('contextmenu', function(evt) {
            evt.stopPropagation();
            evt.preventDefault();

            if (! editor.call('permissions:write'))
                return;

            currentAsset = asset;
            menu.open = true;
            menu.position(evt.clientX + 1, evt.clientY);
        });
    });


    // folders
    editor.call('assets:panel:folders').innerElement.addEventListener('contextmenu', function(evt) {
        evt.preventDefault();
        evt.stopPropagation();

        if (! editor.call('permissions:write'))
            return;

        currentAsset = undefined;
        menu.open = true;
        menu.position(evt.clientX + 1, evt.clientY);
    }, false);

    // files
    editor.call('assets:panel:files').innerElement.addEventListener('contextmenu', function(evt) {
        evt.preventDefault();
        evt.stopPropagation();

        if (! editor.call('permissions:write'))
            return;

        currentAsset = null;
        menu.open = true;
        menu.position(evt.clientX + 1, evt.clientY);
    }, false);

    editor.method('assets:contextmenu:add', function(data) {
        var item = new ui.MenuItem({
            text: data.text,
            icon: data.icon,
            value: data.value
        });

        item.on('select', function() {
            data.select.call(item, currentAsset);
        });

        var parent = data.parent || menu;
        parent.append(item);

        if (data.filter)
            item.filter = data.filter;

        customMenuItems.push(item);

        return item;
    });
});


/* editor/assets/assets-store.js */
editor.once('load', function () {
    'use strict';

    var assetsPanel = editor.call('layout.assets');

    var btnStore = new ui.Button({
        text: "Library"
    });
    btnStore.class.add('store');
    assetsPanel.headerAppend(btnStore);

    btnStore.on('click', function () {
        window.open('https://store.playcanvas.com/', '_blank');
    });
});


/* editor/assets/assets-filter.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var assetsPanel = editor.call('layout.assets');
    var legacyScripts = editor.call('settings:project').get('useLegacyScripts');
    var currentFolder = null;
    var currentPath = [ ];

    var searchLastValue = '';
    var searchTags = null;

    // filters
    var panelFilters = new ui.Panel();
    panelFilters.class.add('filters');
    assetsPanel.headerAppend(panelFilters);

    var tagsCheck = function(asset, tags) {
        var data = asset.get('tags');

        if (! data.length)
            return false;

        tags = pc.Tags.prototype._processArguments(tags);

        if (! data.length || ! tags.length)
            return false;

        for(var i = 0; i < tags.length; i++) {
            if (tags[i].length === 1) {
                // single occurance
                if (data.indexOf(tags[i][0]) !== -1)
                    return true;
            } else {
                // combined occurance
                var multiple = true;

                for(var t = 0; t < tags[i].length; t++) {
                    if (data.indexOf(tags[i][t]) !== -1)
                        continue;

                    multiple = false;
                    break;
                }

                if (multiple)
                    return true;
            }
        }

        return false;
    };

    var filter = function(type, item) {
        if (! item)
            return false;

        var visible = true;

        // type
        if (visible && filterField.value !== 'all') {
            if (type === 'asset') {
                var assetType = item.get('type');

                if (assetType === 'texture') {
                    if (item.get('source')) {
                        assetType = 'textureSource';
                    } else {
                        assetType = 'textureTarget';
                    }
                }

                visible = assetType === filterField.value;
            } else if (type === 'script') {
                visible = filterField.value === 'script';
            }
        }

        // query
        if (visible && search.value) {
            var name = (type === 'scripts') ? item : item.get(type === 'asset' ? 'name' : 'filename');
            var normalSearch = true;

            if (searchTags !== false && ((searchTags instanceof Array) || (search.value[0] === '[' && search.value.length > 2 && /^\[.+\]$/.test(search.value)))) {
                if (searchTags === null) {
                    try {
                        var raw = search.value.slice(1, -1);
                        var bits = raw.split(',');
                        var tags = [ ];
                        var merge = '';

                        for(var i = 0; i < bits.length; i++) {
                            var tag = bits[i].trim();
                            if (! tag) continue;

                            if ((tag[0] === '[' && tag[tag.length - 1] !== ']') || (merge && tag[tag.length - 1] !== ']')) {
                                merge += tag + ',';
                                continue;
                            }

                            if (merge && tag[tag.length - 1] === ']') {
                                tag = merge + tag;
                                merge = '';
                            }

                            if (tag[0] === '[' && tag.length > 2 && tag[tag.length - 1] === ']') {
                                var subRaw = tag.slice(1, -1);
                                var subBits = subRaw.split(',');
                                if (subBits.length === 1) {
                                    var subTag = subBits[0].trim();
                                    if (! subTag) continue;
                                    tags.push(subTag);
                                } else {
                                    var subTags = [ ];
                                    for(var s = 0; s < subBits.length; s++) {
                                        var subTag = subBits[s].trim();
                                        if (! subTag) continue;
                                        subTags.push(subTag);
                                    }

                                    if (subTags.length === 0) {
                                        continue;
                                    } else if (subTags.length === 1) {
                                        tags.push(subTags[0]);
                                    } else {
                                        tags.push(subTags);
                                    }
                                }
                            } else {
                                tags.push(tag);
                            }
                        }

                        searchTags = tags;
                        normalSearch = false;
                    } catch(ex) {
                        searchTags = false;
                    }
                } else {
                    normalSearch = false;
                }

                if (searchTags) {
                    if (type === 'scripts' || (type === 'script' && legacyScripts)) {
                        visible = false;
                    } else {
                        visible = tagsCheck(item, searchTags);
                    }
                } else {
                    normalSearch = true;
                }
            } else if (search.value[0] === '*' && search.value.length > 1) {
                try {
                    visible = (new RegExp(search.value.slice(1), 'i')).test(name);
                    normalSearch = false;
                } catch(ex) { }
            }

            if (normalSearch) {
                visible = name.toLowerCase().indexOf(search.value.toLowerCase()) !== -1;

                if (! visible && type === 'asset') {
                    var id = parseInt(search.value, 10);
                    if (id && id.toString() === search.value)
                        visible = parseInt(item.get('id'), 10) === id;
                }
            }
        }

        // folder
        if (visible && ! search.value) {
            if (type === 'script' || currentFolder === 'scripts') {
                visible = currentFolder === 'scripts' && type === 'script';
            } else if (type === 'scripts') {
                visible = ! currentFolder && filterField.value === 'all';
            } else {
                var path = item.get('path');
                if (currentFolder === null) {
                    visible = path.length === 0;
                } else {
                    visible = (path.length === currentPath.length + 1) && path[path.length - 1] === currentFolder;
                }
            }
        }

        return visible;
    };
    editor.method('assets:panel:filter:default', function() {
        return filter;
    });


    // options
    var filterField = new ui.SelectField({
        options: {
            all: 'All',
            animation: 'Animation',
            audio: 'Audio',
            binary: 'Binary',
            cubemap: 'Cubemap',
            css: 'Css',
            font: 'Font',
            json: 'Json',
            html: 'Html',
            material: 'Material',
            model: 'Model',
            scene: 'Model (source)',
            script: 'Script',
            shader: 'Shader',
            text: 'Text',
            textureTarget: 'Texture',
            textureSource: 'Texture (source)'
        }
    });

    filterField.class.add('options');
    filterField.value = 'all';
    filterField.renderChanges = false;
    panelFilters.append(filterField);

    filterField.on('change', function(value) {
        if (value !== 'all') {
            filterField.class.add('not-empty');
        } else {
            filterField.class.remove('not-empty');
        }
        editor.call('assets:panel:filter', filter);
    });

    var tooltipFilter = Tooltip.attach({
        target: filterField.element,
        text: 'Filter Assets',
        align: 'bottom',
        root: root
    });
    filterField.on('open', function() {
        tooltipFilter.disabled = true;
    });
    filterField.on('close', function() {
        tooltipFilter.disabled = false;
    });

    editor.method('assets:filter:search', function(query) {
        if (query === undefined)
            return search.value;

        search.value = query;
    });

    editor.method('assets:filter:type', function(type) {
        if (type === undefined)
            return filterField.value;

        filterField.value = type || 'all';
    });

    editor.method('assets:filter:type:disabled', function(state) {
        filterField.disabled = state;
    });

    editor.on('assets:panel:currentFolder', function(asset) {
        if (asset) {
            if (typeof(asset) === 'string') {
                if (legacyScripts) {
                    currentFolder = 'scripts';
                } else {
                    currentFolder = null;
                }
                currentPath = null;
            } else {
                currentFolder = parseInt(asset.get('id'));
                currentPath = asset.get('path');
            }
        } else {
            currentFolder = null;
            currentPath = null;
        }


        editor.call('assets:panel:filter', filter, true);
    });

    editor.on('assets:add', function(asset) {
        if (filterField.value === 'all' && ! search.value)
            return;

        if (! filter((asset.get('type') === 'script') ? 'script' : 'asset', asset))
            editor.call('assets:panel:get', asset.get('id')).hidden = true;
        else
            editor.call('assets:panel:message', null); // clear possible no assets message
    });

    editor.on('sourcefiles:add', function (file) {
        if (filterField.value === 'all' && ! search.value)
            return;

        if (! filter('script', file))
            editor.call('assets:panel:get', file.get('filename')).hidden = true;
        else
            editor.call('assets:panel:message', null); // clear possible no assets message

    });

    // search
    var search = new ui.TextField({
        placeholder: 'Search'
    });
    search.blurOnEnter = false;
    search.keyChange = true;
    search.class.add('search');
    search.renderChanges = false;
    panelFilters.append(search);

    search.element.addEventListener('keydown', function(evt) {
        if (evt.keyCode === 27)
            searchClear.click();
    }, false);

    // hotkeys
    editor.call('hotkey:register', 'assets-focus-search', {
        key: 'a',
        alt: true,
        callback: function (e) {
            search.focus();
        }
    });

    var searchClear = document.createElement('div');
    searchClear.innerHTML = '&#57650;';
    searchClear.classList.add('clear');
    search.element.appendChild(searchClear);

    searchClear.addEventListener('click', function() {
        search.value = '';
    }, false);

    search.on('change', function(value) {
        value = value.trim();

        if (searchLastValue === value)
            return;

        searchLastValue = value;

        if (value) {
            search.class.add('not-empty');
        } else {
            search.class.remove('not-empty');
        }

        searchTags = null;

        editor.call('assets:panel:filter', filter);
    });

    var tooltipSearch = Tooltip.attach({
        target: search.element,
        align: 'bottom',
        root: root,
        hoverable: true,
        text: 'Search Assets',
        html: '<h1>Assets Search</h1><p>You can perform a global search for assets in your project using this Search box. Simply start typing into the box and the Editor will show matching results dynamically in the panel below.</p><p><strong>ID</strong> - A specific asset can be found by its unique ID, by simply typing the ID in the search field, it will recognize the exact match and only show one asset with that ID.</p><p><strong>RegExp</strong> - It is possible to search using regular expressions. Add <code>*</code> at the beginning of the search field and type a regexp query after. To search for all assets use the <code>*.</code> (any character) regexp query.</p><p><strong>Tags</strong> - To search by tags and their combinations type tags in square brackets <code>[ ]</code>. Simple query operators: AND, OR are allowed by expressing a query as an array of strings or other arrays with strings. The logic of the query is the same as for <a href="https://developer.playcanvas.com/en/api/pc.AssetRegistry.html#findByTag" target="_blank">findByTag</a> from <b>pc.AssetRegistry</b>.</p><p>Here are some examples:</p><p><code>[ level-1 ]</code> - returns all assets that are tagged by <code>level-1</code>.<br /><code>[ level-1, level-2 ]</code> - returns all assets that are tagged by <code>level-1 OR level-2</code>.<br /><code>[ [ level-1, monster ] ]</code> - returns all assets that are tagged by <code>level-1 AND monster</code>. Notice extra brackets.<br /><code>[ [ level-1, monster ], [ level-2, monster ] ]</code> - returns all assets that are tagged by <code>(level-1 AND monster) OR (level-2 AND monster)</code>.</p>'
    });
    tooltipSearch.class.add('assets-search-field');
});


/* editor/assets/assets-upload.js */
editor.once('load', function() {
    'use strict';

    var uploadJobs = 0;
    var legacyScripts = editor.call('settings:project').get('useLegacyScripts');

    var targetExtensions = [ 'jpg', 'jpeg', 'png', 'gif', 'js', 'css', 'html', 'json', 'xml', 'txt', 'vert', 'frag', 'glsl', 'mp3', 'ogg', 'wav', 'mp4', 'atlas' ];
    var tmp = { };
    for(var i = 0; i < targetExtensions.length; i++)
        tmp[targetExtensions[i]] = true;
    targetExtensions = tmp;


    var typeToExt = {
        'scene': [ 'fbx', 'dae', 'obj', '3ds' ],
        'text': [ 'txt', 'xml' ],
        'html': [ 'html' ],
        'css': [ 'css' ],
        'json': [ 'json' ],
        'texture': [ 'tif', 'tga', 'png', 'jpg', 'jpeg', 'gif', 'bmp', 'dds', 'hdr', 'exr' ],
        'audio': [ 'wav', 'mp3', 'mp4', 'ogg' ],
        'shader': [ 'glsl', 'frag', 'vert' ],
        'script': [ 'js' ],
        'font': [ 'ttf', 'ttc', 'otf', 'dfont' ]
    };
    var extToType = { };
    for(var type in typeToExt) {
        for(var i = 0; i < typeToExt[type].length; i++) {
            extToType[typeToExt[type][i]] = type;
        }
    }


    editor.method('assets:canUploadFiles', function (files) {
        // check usage first
        var totalSize = 0;
        for(var i = 0; i < files.length; i++) {
            totalSize += files[i].size;
        }

        return config.owner.size + totalSize <= config.owner.diskAllowance;
    });

    editor.method('assets:upload:script', function(file) {
        var reader = new FileReader();

        reader.addEventListener('load', function() {
            editor.call('sourcefiles:create', file.name, reader.result, function(err) {
                if (err)
                    return;

                editor.call('assets:panel:currentFolder', 'scripts');
            });
        }, false);

        reader.readAsText(file);
    });

    editor.method('assets:uploadFile', function (args, fn) {
        // NOTE
        // non-file form data should be above file,
        // to make it parsed on back-end first

        var form = new FormData();

        // scope
        form.append('project', config.project.id);

        // name
        if (args.name)
            form.append('name', args.name);

        // update asset
        if (args.asset)
            form.append('asset', args.asset.get('id'));

        // tags
        if (args.tags)
            form.append('tags', args.tags.join('\n'));

        // parent folder
        if (args.parent) {
            if (args.parent instanceof Observer) {
                form.append('parent', args.parent.get('id'));
            } else {
                var id = parseInt(args.parent, 10);
                if (! isNaN(id))
                    form.append('parent', id + '');
            }
        }

        // type
        if (args.type)
            form.append('type', args.type);

        // source_asset_id
        if (args.source_asset_id)
            form.append('source_asset_id', args.source_asset_id);

        // data
        if (args.data)
            form.append('data', JSON.stringify(args.data));

        // meta
        if (args.meta)
            form.append('meta', JSON.stringify(args.meta));

        // preload
        form.append('preload', args.preload === undefined ? true : args.preload);

        // filename
        if (args.filename)
            form.append('filename', args.filename);

        // file
        if (args.file && args.file.size)
            form.append('file', args.file, (args.filename || args.name));

        var job = ++uploadJobs;
        editor.call('status:job', 'asset-upload:' + job, 0);

        var data = {
            url: '/api/assets',
            method: 'POST',
            auth: true,
            data: form,
            ignoreContentType: true,
            headers: {
                Accept: 'application/json'
            }
        };

        Ajax(data)
            .on('load', function(status, data) {
                if (args.pipeline) {
                    var asset = editor.call('assets:get', data.asset.id);
                    if (asset) {
                        editor.call('assets:jobs:add', asset);
                    } else {
                        var evt = editor.once('assets:add[' + data.asset.id + ']', function(asset) {
                            editor.call('assets:jobs:add', asset);
                        });
                    }
                }

                editor.call('status:job', 'asset-upload:' + job);
                if (fn)
                    fn(null, data);
            })
            .on('progress', function(progress) {
                editor.call('status:job', 'asset-upload:' + job, progress);
            })
            .on('error', function(status, data) {
                if (/Disk allowance/.test(data))
                    data += '. <a href="/upgrade" target="_blank">UPGRADE</a> to get more disk space.';

                editor.call('status:error', data);
                editor.call('status:job', 'asset-upload:' + job);
                if (fn)
                    fn(data);
            });
    });

    editor.method('assets:upload:files', function(files) {
        if (! editor.call('assets:canUploadFiles', files)) {
            var msg = 'Disk allowance exceeded. <a href="/upgrade" target="_blank">UPGRADE</a> to get more disk space.';
            editor.call('status:error', msg);
            return;
        }

        var currentFolder = editor.call('assets:panel:currentFolder');

        for(var i = 0; i < files.length; i++) {
            var path = [ ];

            if (currentFolder && currentFolder.get)
                path = currentFolder.get('path').concat(parseInt(currentFolder.get('id'), 10));

            var source = false;
            var ext = files[i].name.split('.');
            if (ext.length === 1)
                continue;

            ext = ext[ext.length - 1].toLowerCase();

            if (legacyScripts && ext === 'js') {
                editor.call('assets:upload:script', files[i]);
            } else {
                var type = extToType[ext] || 'binary';
                var source = type !== 'binary' && ! targetExtensions[ext];

                // can we override another asset?
                var sourceAsset = null;
                var asset = editor.call('assets:findOne', function(item) {
                    // check files in current folder only
                    if (! item.get('path').equals(path))
                        return;

                    // try locate source when dropping on its targets
                    if (source && ! item.get('source') && item.get('source_asset_id')) {
                        var itemSource = editor.call('assets:get', item.get('source_asset_id'));
                        if (itemSource && itemSource.get('type') === type && itemSource.get('name').toLowerCase() === files[i].name.toLowerCase()) {
                            sourceAsset = itemSource;
                            return;
                        }
                    }

                    return item.get('source') === source && item.get('type') === type && item.get('name').toLowerCase() === files[i].name.toLowerCase();
                });

                var data = null;
                if (ext === 'js') {
                    data = {
                        order: 100,
                        scripts: { }
                    };
                }

                editor.call('assets:uploadFile', {
                    asset: asset ? asset[1] : sourceAsset,
                    file: files[i],
                    name: files[i].name,
                    parent: editor.call('assets:panel:currentFolder'),
                    pipeline: true,
                    data: data,
                    meta: asset ? asset[1].get('meta') : null
                }, function(err, data) {
                    if (err || ext !== 'js') return;

                    var onceAssetLoad = function(asset) {
                        var url = asset.get('file.url');
                        if (url) {
                            editor.call('scripts:parse', asset);
                        } else {
                            asset.once('file.url:set', function() {
                                editor.call('scripts:parse', asset);
                            });
                        }
                    };

                    var asset = editor.call('assets:get', data.asset.id);
                    if (asset) {
                        onceAssetLoad(asset);
                    } else {
                        editor.once('assets:add[' + data.asset.id + ']', onceAssetLoad);
                    }
                });
            }
        }
    });

    editor.method('assets:upload:picker', function(args) {
        args = args || { };

        var parent = args.parent || editor.call('assets:panel:currentFolder');

        var fileInput = document.createElement('input');
        fileInput.type = 'file';
        // fileInput.accept = '';
        fileInput.multiple = true;
        fileInput.style.display = 'none';
        editor.call('layout.assets').append(fileInput);

        var onChange = function() {
            editor.call('assets:upload:files', this.files);

            this.value = null;
            fileInput.removeEventListener('change', onChange);
        };

        fileInput.addEventListener('change', onChange, false);
        fileInput.click();

        fileInput.parentNode.removeChild(fileInput);
    });
});


/* editor/assets/assets-drop.js */
editor.once('load', function() {
    'use strict';

    var assetsPanel = editor.call('layout.assets');

    var dropRef = editor.call('drop:target', {
        ref: assetsPanel.element,
        type: 'files',
        drop: function(type, data) {
            if (type !== 'files')
                return;

            editor.call('assets:upload:files', data);
        }
    });

    dropRef.element.classList.add('assets-drop-area');
});


/* editor/assets/assets-messenger.js */
editor.once('load', function() {
    'use strict';

    var create = function(data) {
        var assetId = data.asset.id;

        if (data.asset.source === false && data.asset.status && data.asset.status !== 'complete')
            return;

        var asset = editor.call('assets:get', assetId);
        if (asset)
            return;

        editor.call('loadAsset', assetId);
    };

    // create new asset
    editor.on('messenger:asset.new', create);

    // remove
    editor.on('messenger:asset.delete', function(data) {
        var asset = editor.call('assets:get', data.asset.id);
        if (! asset) return;
        editor.call('assets:remove', asset);
    });

    // remove multiple
    editor.on('messenger:assets.delete', function(data) {
        for(var i = 0; i < data.assets.length; i++) {
            var asset = editor.call('assets:get', parseInt(data.assets[i], 10));
            if (! asset) continue;
            editor.call('assets:remove', asset);
        }
    });
});


/* editor/assets/assets-delete.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:delete:picker', function(items) {
        if (! editor.call('permissions:write'))
            return;

        var msg = 'Delete Asset?';

        if (items.length === 1 && items[0].get('type') === 'folder')
            msg = 'Delete Folder?';

        if (items.length > 1)
            msg = 'Delete ' + items.length + ' Assets?';

        editor.call('picker:confirm:class', 'asset-delete');

        editor.call('picker:confirm', msg, function() {
            if (! editor.call('permissions:write'))
                return;

            editor.call('assets:delete', items);
        });
    });

    var deleteCallback = function() {
        if (! editor.call('permissions:write'))
            return;

        var type = editor.call('selector:type');
        if (type !== 'asset')
            return;

        editor.call('assets:delete:picker', editor.call('selector:items'));
    };
    // delete
    editor.call('hotkey:register', 'asset:delete', {
        key: 'delete',
        callback: deleteCallback
    });
    // ctrl + backspace
    editor.call('hotkey:register', 'asset:delete', {
        ctrl: true,
        key: 'backspace',
        callback: deleteCallback
    });
});


/* editor/assets/assets-duplicate.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:duplicate', function(asset) {
        var path = asset.get('path');
        var parent = path.length ? path[path.length - 1] : null;

        var raw = {
            type: 'material',
            name: asset.get('name') + ' Copy',
            tags: asset.get('tags'),
            source: false,
            data: asset.get('data'),
            preload: asset.get('preload'),
            parent: parent ? editor.call('assets:get', parent) : null,
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', raw);
    });
});


/* editor/assets/assets-edit.js */
editor.once('load', function() {
    'use strict';

    var types = {
        'css': 1,
        'html': 1,
        'json': 1,
        'script': 1,
        'shader': 1,
        'text': 1
    };

    editor.method('assets:edit', function (asset) {
        if (asset.get('type') === 'script' && editor.call('settings:project').get('useLegacyScripts')) {
            window.open('/editor/code/' + config.project.id + '/' + asset.get('filename'));
        } else {
            if (config.self.codeEditor2 && ! editor.call('settings:project').get('useLegacyScripts')) {
                editor.call('picker:codeeditor', asset);
            } else {
                window.open('/editor/asset/' + asset.get('id'), asset.get('id')).focus();
            }
        }
    });

    var dblClick = function(key, asset) {
        var gridItem = editor.call('assets:panel:get', asset.get(key));
        if (! gridItem)
            return;

        gridItem.element.addEventListener('dblclick', function(evt) {
            editor.call('assets:edit', asset);
        }, false);
    };

    editor.on('assets:add', function(asset) {
        if (! types[asset.get('type')])
            return;

        dblClick('id', asset);
    });

    editor.on('sourcefiles:add', function(file) {
        dblClick('filename', file);
    });
});


/* editor/assets/assets-replace.js */
editor.once('load', function() {
    'use strict';

    var slots = [ 'aoMap', 'diffuseMap', 'emissiveMap', 'glossMap', 'lightMap', 'metalnessMap', 'opacityMap', 'specularMap', 'normalMap', 'sphereMap' ];

    editor.method('assets:replace', function(asset, replacement) {
        var id = parseInt(asset.get('id'), 10);
        var idNew = parseInt(replacement.get('id'), 10);

        var entities = editor.call('entities:list');
        var assets = editor.call('assets:list');

        var records = [ ];

        // TODO
        // history

        var set = function(obj, path) {
            var history = obj.history.enabled;
            obj.history.enabled = false;
            obj.set(path, idNew);
            obj.history.enabled = history;

            if (history) {
                records.push({
                    get: obj.history._getItemFn,
                    path: path
                });
            }
        };

        switch(asset.get('type')) {
            case 'material':
                // entity
                for(var i = 0; i < entities.length; i++) {
                    var obj = entities[i];

                    // model
                    var model = obj.get('components.model');
                    if (model) {
                        if (model.materialAsset === id) {
                            // components.model.materialAsset
                            set(obj, 'components.model.materialAsset');
                        }
                        if (model.mapping) {
                            for(var ind in model.mapping) {
                                if (model.mapping[ind] === id) {
                                    // components.model.mapping.?
                                    set(obj, 'components.model.mapping.' + ind);
                                }
                            }
                        }
                    }

                    // element
                    var element = obj.get('components.element');
                    if (element && element.materialAsset === id) {
                        // components.element.materialAsset
                        set(obj, 'components.element.materialAsset');
                    }
                }

                // asset
                for(var i = 0; i < assets.length; i++) {
                    var obj = assets[i];

                    if (obj.get('type') === 'model') {
                        var mapping = obj.get('data.mapping');
                        if (mapping) {
                            for(var ind = 0; ind < mapping.length; ind++) {
                                if (mapping[ind].material !== id)
                                    continue;

                                // data.mapping.?.material
                                set(obj, 'data.mapping.' + ind + '.material');

                                // change meta.userMapping as well
                                var history = obj.history.enabled;
                                obj.history.enabled = false;
                                if (! obj.get('meta')) {
                                    obj.set('meta', {
                                        userMapping: {}
                                    });
                                } else {
                                    if (! obj.has('meta.userMapping'))
                                        obj.set('meta.userMapping', {});
                                }

                                obj.set('meta.userMapping.' + ind, true);

                                obj.history.enabled = history;
                            }
                        }
                    }
                }
                break;

            case 'texture':
                // entity
                for(var i = 0; i < entities.length; i++) {
                    var obj = entities[i];

                    // light
                    var light = obj.get('components.light');
                    if (light && light.cookieAsset === id) {
                        // components.light.cookieAsset
                        set(obj, 'components.light.cookieAsset');
                    }

                    // particlesystem
                    var particlesystem = obj.get('components.particlesystem');
                    if (particlesystem) {
                        if (particlesystem.colorMapAsset === id) {
                            // components.particlesystem.colorMapAsset
                            set(obj, 'components.particlesystem.colorMapAsset');
                        }
                        if (particlesystem.normalMapAsset === id) {
                            // components.particlesystem.normalMapAsset
                            set(obj, 'components.particlesystem.normalMapAsset');
                        }
                    }

                    // element
                    var element = obj.get('components.element');
                    if (element && element.textureAsset === id) {
                        // components.element.textureAsset
                        set(obj, 'components.element.textureAsset');
                    }
                }

                // asset
                for(var i = 0; i < assets.length; i++) {
                    var obj = assets[i];

                    if (obj.get('type') === 'cubemap') {
                        var textures = obj.get('data.textures');
                        if (textures && textures instanceof Array) {
                            for(var ind = 0; ind < textures.length; ind++) {
                                if (textures[ind] !== id)
                                    continue;

                                // data.mapping.?.material
                                set(obj, 'data.textures.' + ind);
                            }
                        }
                    } else if (obj.get('type') === 'material') {
                        var data = obj.get('data');
                        if (data) {
                            for(var s = 0; s < slots.length; s++) {
                                if (data[slots[s]] !== id)
                                    continue;

                                set(obj, 'data.' + slots[s]);
                            }
                        }
                    }
                }
                break;

            case 'model':
                // entity
                for(var i = 0; i < entities.length; i++) {
                    var obj = entities[i];

                    // model
                    var model = obj.get('components.model');
                    if (model && model.asset === id) {
                        // components.model.asset
                        set(obj, 'components.model.asset');
                    }

                    // collision
                    var collision = obj.get('components.collision');
                    if (collision && collision.asset === id) {
                        // components.collision.asset
                        set(obj, 'components.collision.asset');
                    }

                    // particlesystem
                    var particlesystem = obj.get('components.particlesystem');
                    if (particlesystem && particlesystem.mesh === id) {
                        // components.particlesystem.mesh
                        set(obj, 'components.particlesystem.mesh');
                    }
                }
                break;

            case 'animation':
                // entity
                for(var i = 0; i < entities.length; i++) {
                    var obj = entities[i];

                    // animation
                    var animation = obj.get('components.animation');
                    if (animation && animation.assets) {
                        for(ind = 0; ind < animation.assets.length; ind++) {
                            if (animation.assets[ind] !== id)
                                continue;

                            // components.animation.assets.?
                            set(obj, 'components.animation.assets.' + ind);
                        }
                    }
                }
                break;

            case 'audio':
                // entity
                for(var i = 0; i < entities.length; i++) {
                    var obj = entities[i];

                    // sound
                    var sound = obj.get('components.sound');
                    if (sound) {
                        for(var ind in sound.slots) {
                            if (! sound.slots[ind] || sound.slots[ind].asset !== id)
                                continue;

                            // components.sound.slots.?.asset
                            set(obj, 'components.sound.slots.' + ind + '.asset');
                        }
                    }

                    // audiosource
                    var audiosource = obj.get('components.audiosource');
                    if (audiosource && audiosource.assets) {
                        for(var a = 0; a < audiosource.assets.length; a++) {
                            if (audiosource.assets[a] !== id)
                                continue;

                            // components.audiosource.assets.?
                            set(obj, 'components.audiosource.assets.' + a);
                        }
                    }
                }
                break;

            case 'cubemap':
                // entity
                for(var i = 0; i < entities.length; i++) {
                    var obj = entities[i];

                    // light
                    var light = obj.get('components.light');
                    if (light && light.cookieAsset === id) {
                        // components.light.cookieAsset
                        set(obj, 'components.light.cookieAsset');
                    }
                }

                // asset
                for(var i = 0; i < assets.length; i++) {
                    var obj = assets[i];

                    if (obj.get('type') === 'material' && obj.get('data.cubeMap') === id) {
                        // data.cubeMap
                        set(obj, 'data.cubeMap');
                    }
                }

                // sceneSettings
                var obj = editor.call('sceneSettings');
                if (obj.get('render.skybox') === id) {
                    // render.skybox
                    set(obj, 'render.skybox');
                }
                break;
        }

        // entity.components.script
        for(var i = 0; i < entities.length; i++) {
            var obj = entities[i];

            // script
            var scripts = obj.get('components.script.scripts');
            if (scripts) {
                for (var script in scripts) {
                    var assetScript = editor.call('assets:scripts:assetByScript', script);
                    if (! assetScript)
                        continue;

                    var assetScripts = assetScript.get('data.scripts');
                    if (! assetScripts || ! assetScripts[script] || ! assetScripts[script].attributes)
                        continue;

                    var attributes = assetScripts[script].attributes;

                    for(var attrName in scripts[script].attributes) {
                        if (scripts[script].attributes[attrName] !== id)
                            continue;

                        if (! attributes[attrName] || attributes[attrName].type !== 'asset')
                            continue;

                        // components.script.scripts.?.attributes.?
                        set(obj, 'components.script.scripts.' + script + '.attributes.' + attrName);
                    }
                }
            }
        }

        if (records.length) {
            editor.call('history:add', {
                name: 'asset replace',
                undo: function() {
                    for(var i = 0; i < records.length; i++) {
                        var obj = records[i].get();
                        if (! obj || ! obj.has(records[i].path))
                            continue;

                        var history = asset.history.enabled;
                        obj.history.enabled = false;

                        obj.set(records[i].path, id);

                        // if we changed data.mapping also change meta.userMapping
                        if (/^data.mapping/.test(records[i].path)) {
                            if (obj.has('meta.userMapping')) {
                                var parts = records[i].path.split('.');
                                obj.unset('meta.userMapping.' + parts[2], true);
                                if (Object.keys(obj.get('meta.userMapping')).length === 0)
                                    obj.unset('meta.userMapping');
                            }
                        }

                        obj.history.enabled = history;
                    }
                },
                redo: function() {
                    for(var i = 0; i < records.length; i++) {
                        var obj = records[i].get();
                        if (! obj || ! obj.has(records[i].path))
                            continue;

                        var history = asset.history.enabled;
                        obj.history.enabled = false;
                        obj.set(records[i].path, idNew);

                        // if we changed data.mapping also change meta.userMapping
                        if (/^data.mapping/.test(records[i].path)) {
                            if (! obj.get('meta')) {
                                obj.set('meta', {
                                    userMapping: {}
                                });
                            } else {
                                if (! obj.has('meta.userMapping'))
                                    obj.set('meta.userMapping', {});
                            }


                            var parts = records[i].path.split('.');
                            obj.set('meta.userMapping.' + parts[2], true);
                        }

                        obj.history.enabled = history;
                    }
                }
            });
        }
    });
});


/* editor/assets/assets-rename.js */
editor.once('load', function() {
    'use strict';

    var onRename = function() {
        if (! editor.call('permissions:write'))
            return;

        var type = editor.call('selector:type');
        if (type !== 'asset')
            return;

        var items = editor.call('selector:items');
        if (items.length !== 1)
            return;

        var root = editor.call('attributes.rootPanel');
        if (! root)
            return;

        var input = root.element.querySelector('.ui-text-field.asset-name');

        if (! input || ! input.ui)
            return;

        input.ui.flash();
        input.ui.elementInput.select();
    };

    editor.method('assets:rename', onRename);

    editor.call('hotkey:register', 'assets:rename', {
        key: 'n',
        callback: onRename
    });

    editor.call('hotkey:register', 'assets:rename:f2', {
        key: 'f2',
        callback: onRename
    });
});


/* editor/assets/assets-history.js */
editor.once('load', function() {
    'use strict';

    editor.on('assets:add', function(asset) {
        if (asset.history)
            return;

        var id = asset.get('id');

        asset.history = new ObserverHistory({
            item: asset,
            prefix: 'asset.' + id + '.',
            getItemFn: function () {
                return editor.call('assets:get', id);
            }
        });

        // record history
        asset.history.on('record', function(action, data) {
            editor.call('history:' + action, data);
        });
    });
});


/* editor/assets/assets-migrate.js */
editor.once('load', function() {
    'use strict';

    var migrateAsset = function(asset) {
        asset.history.enabled = false;

        if (asset.get('type') === 'material' && asset.get('data')) {
            if (! asset.has('data.useFog'))
                asset.set('data.useFog', true);

            if (! asset.has('data.useLighting'))
                asset.set('data.useLighting', true);

            if (! asset.has('data.useSkybox'))
                asset.set('data.useSkybox', true);

            if (! asset.has('data.useGammaTonemap'))
                asset.set('data.useGammaTonemap', true);

            if (! asset.get('data.cubeMapProjectionBox'))
                asset.set('data.cubeMapProjectionBox', { center: [ 0, 0, 0 ], halfExtents: [ 0.5, 0.5, 0.5 ] });

            if (! asset.has('data.alphaToCoverage'))
                asset.set('data.alphaToCoverage', false);
        }

        if (asset.get('type') === 'texture' && ! asset.get('source')) {
            if (asset.get('meta')) {
                if (! asset.has('meta.compress')) {
                    var alpha = asset.get('meta.alpha') || (asset.get('meta.type').toLowerCase() || '') === 'truecoloralpha' || false;

                    asset.set('meta.compress', {
                        alpha: alpha,
                        dxt: false,
                        pvr: false,
                        pvrBpp: 4,
                        etc1: false
                    });
                } else {
                    if (! asset.has('meta.compress.pvr'))
                        asset.set('meta.compress.pvr', false);

                    if (! asset.has('meta.compress.pvrBpp'))
                        asset.set('meta.compress.pvrBpp', 4);

                    if (! asset.has('meta.compress.etc1'))
                        asset.set('meta.compress.etc1', false);
                }
            }
            if (asset.get('data')) {
                if (! asset.has('data.mipmaps'))
                    asset.set('data.mipmaps', true);
            }
        }

        if (asset.get('type') === 'font' && !asset.get('source')) {
            if (asset.get('data') && !asset.has('data.intensity')) {
                asset.set('data.intensity', 0.0);
            }
        }

        asset.history.enabled = true;
    };

    editor.on('assets:add', migrateAsset);
    editor.call('assets:list').forEach(migrateAsset);
});


/* editor/assets/assets-create-folder.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:create:folder', function (args) {
        if (! editor.call('permissions:write'))
            return;

        args = args || { };

        var asset = {
            name: 'New Folder',
            type: 'folder',
            source: true,
            preload: false,
            data: null,
            parent: (args.parent !== undefined) ? args.parent : editor.call('assets:panel:currentFolder'),
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', asset);
    });
});


/* editor/assets/assets-cubemap-prefiltering.js */
editor.once('load', function () {

    var app = null;

    editor.once('viewport:load', function() {
        app = editor.call('viewport:app');
    });

    // var device = editor.call('preview:device');
    // var assets = editor.call('preview:assetRegistry');

    var getTextureAssets = function (assetCubeMap) {
        var result = [];
        var textures = assetCubeMap.get('data.textures');
        for (var i = 0; i < textures.length; i++) {
            var id = textures[i];
            if (parseInt(id) >= 0) {
                var texture = editor.call('assets:get', id);
                if (!texture) {
                    return null;
                }

                result.push(texture);
            } else {
                return null;
            }
        }

        return result;
    };

    var prefilterHdrCubemap = function (assetCubeMap, cubemap, callback) {
        if (! app) {
            // webgl not available
            callback(new Error('webgl not available'));
            return;
        }

        try {
            var textureAssets = getTextureAssets(assetCubeMap);
            if (textureAssets) {
                var l = textureAssets.length;
                var count = l;
                var textures = [];

                var onLoad = function () {
                    editor.call('status:job', 'prefilter');

                    cubemap = new pc.Texture(app.graphicsDevice, {
                        cubemap: true,
                        rgbm: false,
                        fixCubemapSeams: true,
                        format: textures[0].format,
                        width: textures[0].width,
                        height: textures[0].height
                    });

                    cubemap.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
                    cubemap.addressV = pc.ADDRESS_CLAMP_TO_EDGE;

                    cubemap._levels[0] = [ textures[0]._levels[0],
                        textures[1]._levels[0],
                        textures[2]._levels[0],
                        textures[3]._levels[0],
                        textures[4]._levels[0],
                        textures[5]._levels[0] ];

                    // prefilter cubemap
                    var options = {
                        device: app.graphicsDevice,
                        sourceCubemap: cubemap,
                        method: 1,
                        samples: 4096,
                        cpuSync: true,
                        filteredFixed: [],
                        filteredFixedRgbm: [],
                        singleFilteredFixedRgbm: true
                    };

                    pc.prefilterCubemap(options);

                    // get dds and create blob
                    var dds = options.singleFilteredFixedRgbm.getDds();
                    var blob = new Blob([dds], {type: 'image/dds'});

                    // upload blob as dds
                    editor.call('assets:uploadFile', {
                        file: blob,
                        name: assetCubeMap.get('name') + '.dds',
                        asset: assetCubeMap,
                        type: 'cubemap'
                    }, function (err, data) {
                        if (!err) {
                            callback();
                        } else {
                            editor.call('status:job', 'prefilter');
                            callback(err);
                        }
                    });
                };

                textureAssets.forEach(function (asset, index) {
                    editor.call('status:job', 'prefilter', index);

                    var url = asset.get('file.url').replace(/.png$/, '.dds');

                    app.assets._loader.load(url, "texture", function (err, resource) {
                        if (!err) {
                            textures[index] = resource;
                        } else {
                            console.warn(err);
                        }

                        count--;
                        if (count === 0) {
                            onLoad();
                        }
                    });
                });
            }
        } catch (ex) {
            callback(ex);
        }
    };

    var prefilterCubemap = function (assetCubeMap, cubemap, callback) {
        if (! app) {
            // webgl not available
            callback(new Error('webgl not available'));
            return;
        }

        try {
            var count = 0;
            var textures = [ ];
            var texturesAssets = [ ];
            var textureIds = assetCubeMap.get('data.textures');

            for(var i = 0; i < 6; i++) {
                // missing texture
                if (! textureIds[i])
                    return;

                texturesAssets[i] = editor.call('assets:get', textureIds[i]);

                // texture is not in registry
                if (! texturesAssets[i])
                    return;
            }

            var texturesReady = function() {
                editor.call('status:job', 'prefilter');

                var options = {
                    device: app.graphicsDevice,
                    sourceCubemap: cubemap,
                    method: 1,
                    samples: 4096,
                    cpuSync: true,
                    filteredFixed: [ ],
                    singleFilteredFixed: true
                };

                pc.prefilterCubemap(options);

                var dds = options.singleFilteredFixed.getDds();
                var blob = new Blob([ dds ], { type: 'image/dds' });

                // upload blob as dds
                editor.call('assets:uploadFile', {
                    file: blob,
                    name: assetCubeMap.get('name') + '.dds',
                    asset: assetCubeMap,
                    type: 'cubemap'
                }, function (err, data) {
                    if (callback)
                        callback(null);
                });
            };

            var textureLoad = function(ind, url) {
                editor.call('status:job', 'prefilter', ind);

                app.assets._loader.load(url, 'texture', function (err, resource) {
                    if (err)
                        console.warn(err);

                    textures[ind] = resource;

                    count++;
                    if (count === 6)
                        texturesReady();
                });
            };

            for(var i = 0; i < 6; i++)
                textureLoad(i, texturesAssets[i].get('file.url'))
        } catch (ex) {
            if (callback)
                callback(ex);
        }
    };

    editor.method('assets:cubemaps:prefilter', function (assetCubeMap, callback) {
        if (! app) {
            // webgl not available
            callback(new Error('webgl not available'));
            return;
        }

        var asset = app.assets.get(parseInt(assetCubeMap.get('id'), 10));
        if (! asset)
            return;

        var cubemap;
        var onLoad = function() {
            if (app.graphicsDevice.extTextureFloatRenderable && cubemap.rgbm) {
                prefilterHdrCubemap(assetCubeMap, cubemap, callback);
            } else {
                prefilterCubemap(assetCubeMap, cubemap, callback);
            }
        };

        if (asset.resource) {
            cubemap = asset.resource;
            onLoad();
        } else {
            asset.once('load', function(asset) {
                cubemap = asset.resource;
                onLoad();
            });
            app.assets.load(asset);
        }
    });

    // invalidate prefiltering data on cubemaps
    // when one of face textures file is changed
    editor.on('assets:add', function(asset) {
        if (asset.get('type') !== 'cubemap')
            return;

        asset._textures = [ ];

        var invalidate = function() {
            if (! asset.get('file'))
                return;

            asset.set('file', null);
        };

        var watchTexture = function(ind, id) {
            if (asset._textures[ind])
                asset._textures[ind].unbind();

            asset._textures[ind] = null;

            if (! id)
                return;

            var texture = editor.call('assets:get', id);
            if (texture)
                asset._textures[ind] = texture.on('file.hash:set', invalidate);
        };

        var watchFace = function(ind) {
            // update watching on face change
            asset.on('data.textures.' + ind + ':set', function(id) {
                watchTexture(ind, id);
            });
            // start watching
            watchTexture(ind, asset.get('data.textures.' + ind));
        };

        for(var i = 0; i < 6; i++)
            watchFace(i);
    });
});


/* editor/assets/assets-create-material.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:create:material', function (args) {
        if (! editor.call('permissions:write'))
            return;

        args = args || { };

        var data = editor.call('material:default');

        var asset = {
            name: 'New Material',
            type: 'material',
            source: false,
            preload: true,
            data: data,
            parent: (args.parent !== undefined) ? args.parent : editor.call('assets:panel:currentFolder'),
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', asset);
    });
});


/* editor/assets/assets-create-cubemap.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:create:cubemap', function (args) {
        if (! editor.call('permissions:write'))
            return;

        args = args || { };

        var asset = {
            name: 'New Cubemap',
            type: 'cubemap',
            source: false,
            preload: true,
            parent: (args.parent !== undefined) ? args.parent : editor.call('assets:panel:currentFolder'),
            data: {
                name: 'New Cubemap',
                textures: [ null, null, null, null, null, null ],
                minFilter: 5, // linear mipmap linear
                magFilter: 1, // linear
                anisotropy: 1
            },
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', asset);
    });
});


/* editor/assets/assets-create-html.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:create:html', function (args) {
        if (! editor.call('permissions:write'))
            return;

        args = args || { };

        var asset = {
            name: 'New Html',
            type: 'html',
            source: false,
            preload: true,
            parent: (args.parent !== undefined) ? args.parent : editor.call('assets:panel:currentFolder'),
            filename: 'asset.html',
            file: new Blob([ '\n' ], { type: 'text/html' }),
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', asset);
    });
});


/* editor/assets/assets-create-css.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:create:css', function (args) {
        if (! editor.call('permissions:write'))
            return;

        args = args || { };

        var asset = {
            name: 'New Css',
            type: 'css',
            source: false,
            preload: true,
            parent: (args.parent !== undefined) ? args.parent : editor.call('assets:panel:currentFolder'),
            filename: 'asset.css',
            file: new Blob([ '\n' ], { type: 'text/css' }),
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', asset);
    });
});


/* editor/assets/assets-create-json.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:create:json', function (args) {
        if (! editor.call('permissions:write'))
            return;

        args = args || { };

        var asset = {
            name: 'New Json',
            type: 'json',
            source: false,
            preload: true,
            parent: (args.parent !== undefined) ? args.parent : editor.call('assets:panel:currentFolder'),
            filename: 'asset.json',
            file: new Blob([ '{ }' ], { type: 'application/json' }),
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', asset);
    });
});


/* editor/assets/assets-create-text.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:create:text', function (args) {
        if (! editor.call('permissions:write'))
            return;

        args = args || { };

        var asset = {
            name: 'New Text',
            type: 'text',
            source: false,
            preload: true,
            parent: (args.parent !== undefined) ? args.parent : editor.call('assets:panel:currentFolder'),
            filename: 'asset.txt',
            file: new Blob([ '\n' ], { type: 'text/plain' }),
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', asset);
    });
});


/* editor/assets/assets-create-script.js */
editor.once('load', function() {
    'use strict';

    var scriptBoilerplate = "var {className} = pc.createScript('{scriptName}');\n\n// initialize code called once per entity\n{className}.prototype.initialize = function() {\n    \n};\n\n// update code called every frame\n{className}.prototype.update = function(dt) {\n    \n};\n\n// swap method called for script hot-reloading\n// inherit your script state here\n// {className}.prototype.swap = function(old) { };\n\n// to learn more about script anatomy, please read:\n// http://developer.playcanvas.com/en/user-manual/scripting/";
    var filenameValid = /^([^0-9.#<>$+%!`&='{}@\\/:*?"<>|\n])([^#<>$+%!`&='{}@\\/:*?"<>|\n])*$/i;


    editor.method('assets:create:script', function (args) {
        if (! editor.call('permissions:write'))
            return;

        args = args || { };

        var filename = args.filename || 'script.js';

        if (args.boilerplate) {
            var name = filename.slice(0, -3);
            var className = args.className || '';
            var scriptName = args.scriptName || '';

            if (! className || ! scriptName) {
                // tokenize filename
                var tokens = [ ];
                var string = name.replace(/([^A-Z])([A-Z][^A-Z])/g, '$1 $2').replace(/([A-Z0-9]{2,})/g, ' $1');
                var parts = string.split(/(\s|\-|_|\.)/g);

                // filter valid tokens
                for(var i = 0; i < parts.length; i++) {
                    parts[i] = parts[i].toLowerCase().trim();
                    if (parts[i] && parts[i] !== '-' && parts[i] !== '_' && parts[i] !== '.')
                        tokens.push(parts[i]);
                }

                if (tokens.length) {
                    if (! scriptName) {
                        scriptName = tokens[0];

                        for(var i = 1; i < tokens.length; i++) {
                            scriptName += tokens[i].charAt(0).toUpperCase() + tokens[i].slice(1);
                        }
                    }

                    if (! className) {
                        for(var i = 0; i < tokens.length; i++) {
                            className += tokens[i].charAt(0).toUpperCase() + tokens[i].slice(1);
                        }
                    }
                } else {
                    if (! className)
                        className = 'Script';

                    if (! scriptName)
                        scriptName = 'script';
                }
            }

            if (! filenameValid.test(className))
                className = 'Script';

            args.content = scriptBoilerplate.replace(/\{className\}/g, className).replace(/\{scriptName\}/g, scriptName);
        }

        var asset = {
            name: filename,
            type: 'script',
            source: false,
            preload: true,
            parent: (args.parent !== undefined) ? args.parent : editor.call('assets:panel:currentFolder'),
            filename: filename,
            file: new Blob([ args.content || '' ], { type: 'text/javascript' }),
            data: {
                scripts: { },
                loading: false
            },
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', asset, function(err, assetId) {
            if (err) return;

            var onceAssetLoad = function(asset) {
                var url = asset.get('file.url');
                if (url) {
                    onParse(asset);
                } else {
                    asset.once('file.url:set', function() {
                        onParse(asset)
                    });
                }
            };

            var onParse = function(asset) {
                editor.call('scripts:parse', asset, function(err, result) {
                    if (args.callback)
                        args.callback(err, asset, result);
                });
            };

            var asset = editor.call('assets:get', assetId);
            if (asset) {
                onceAssetLoad(asset);
            } else {
                editor.once('assets:add[' + assetId + ']', onceAssetLoad);
            }
        }, args.noSelect);
    });
});





/* editor/assets/assets-create-shader.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:create:shader', function (args) {
        if (! editor.call('permissions:write'))
            return;

        args = args || { };

        var asset = {
            name: 'New Shader',
            type: 'shader',
            source: false,
            preload: true,
            parent: (args.parent !== undefined) ? args.parent : editor.call('assets:panel:currentFolder'),
            filename: 'asset.glsl',
            file: new Blob([ '\n' ], { type: 'text/x-glsl' }),
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', asset);
    });
});


/* editor/assets/assets-unwrap.js */
editor.once('load', function() {
    'use strict';

    var unwrapping = { };

    editor.method('assets:model:unwrap', function(asset, args, fn) {
        if (asset.get('type') !== 'model' || ! asset.has('file.filename') || unwrapping[asset.get('id')])
            return;

        if (typeof(args) === 'function')
            fn = args;

        if (typeof(args) !== 'object')
            args = { };

        args = args || { };

        var filename = asset.get('file.filename');
        var worker = new Worker('/editor/scene/js/editor/assets/assets-unwrap-worker.js');
        worker.asset = asset;
        worker.progress = 0;

        unwrapping[asset.get('id')] = worker;

        worker.onmessage = function(evt) {
            if (! evt.data.name)
                return;

            switch(evt.data.name) {
                case 'finish':
                    var data = evt.data.data;

                    // save area
                    asset.set('data.area', evt.data.area);

                    var blob = new Blob([
                        JSON.stringify(data)
                    ], {
                        type: 'application/json'
                    });

                    // upload blob as dds
                    editor.call('assets:uploadFile', {
                        file: blob,
                        name: filename,
                        asset: asset,
                        type: 'model'
                    }, function (err, data) {
                        // remove from unwrapping list
                        delete unwrapping[asset.get('id')];
                        // render
                        editor.call('viewport:render');
                        // callback
                        if (fn) fn(err, asset);
                        // emit global event
                        editor.emit('assets:model:unwrap', asset);
                    });
                    break;

                case 'progress':
                    worker.progress = evt.data.progress;
                    editor.emit('assets:model:unwrap:progress:' + asset.get('id'), evt.data.progress);
                    editor.emit('assets:model:unwrap:progress', asset, evt.data.progress);
                    break;
            }
        };

        worker.onerror = function(err) {
            if (fn) fn(err);
            // remove from unwrapping list
            delete unwrapping[asset.get('id')];
        };

        worker.postMessage({
            name: 'start',
            id: asset.get('id'),
            filename: filename,
            padding: args.padding || 2.0
        });
    });


    editor.method('assets:model:unwrap:cancel', function(asset) {
        var worker = unwrapping[asset.get('id')];
        if (! worker)
            return;

        worker.terminate();
        delete unwrapping[asset.get('id')];
    });


    editor.method('assets:model:unwrapping', function(asset) {
        if (asset) {
            return unwrapping[asset.get('id')] || null;
        } else {
            var list = [ ];
            for(var key in unwrapping) {
                if (! unwrapping.hasOwnProperty(key))
                    continue;

                list.push(unwrapping[key]);
            }
            return list.length ? list : null;
        }
    });


    editor.method('assets:model:area', function(asset, fn) {
        if (asset.get('type') !== 'model' || ! asset.has('file.filename'))
            return;

        var filename = asset.get('file.filename');
        var worker = new Worker('/editor/scene/js/editor/assets/assets-unwrap-worker.js');

        worker.onmessage = function(evt) {
            if (evt.data.name && evt.data.name === 'finish') {
                // save area
                asset.set('data.area', evt.data.area || null);
                // callback
                if (fn) fn(null, asset, evt.data.area || null);
            }
        };

        worker.onerror = function(err) {
            if (fn) fn(err);
        };

        worker.postMessage({
            name: 'area',
            id: asset.get('id'),
            filename: filename
        });
    });
});


/* editor/assets/assets-used.js */
editor.once('load', function() {
    'use strict';

    var legacyScripts = editor.call('settings:project').get('useLegacyScripts');
    var index = { };
    var keys = {
        'cubemap': {
            'data.textures.0': true,
            'data.textures.1': true,
            'data.textures.2': true,
            'data.textures.3': true,
            'data.textures.4': true,
            'data.textures.5': true
        },
        'material': {
            'data.aoMap': true,
            'data.diffuseMap': true,
            'data.specularMap': true,
            'data.metalnessMap': true,
            'data.glossMap': true,
            'data.emissiveMap': true,
            'data.opacityMap': true,
            'data.normalMap': true,
            'data.heightMap': true,
            'data.sphereMap': true,
            'data.cubeMap': true,
            'data.lightMap': true
        },
        'model': { },
        'entity': {
            'components.model.materialAsset': true,
            'components.model.asset': true,
            'components.collision.asset': true,
            'components.particlesystem.colorMapAsset': true,
            'components.particlesystem.normalMapAsset': true,
            'components.particlesystem.mesh': true,
            'components.element.textureAsset': true,
            'components.element.materialAsset': true,
            'components.element.fontAsset': true,
        },
        'entity-lists': {
            'components.animation.assets': true,
            'components.audiosource.assets': true,
            // 'components.script.scripts': true
        }
    };
    var updateAsset = function(referer, type, oldId, newId) {
        if (oldId && index[oldId] !== undefined) {
            index[oldId].count--;

            if (index[oldId].ref[referer]) {
                if (editor.call('assets:used:get', referer)) {
                    index[oldId].parent--;
                    if (index[oldId].count !== 0 && index[oldId].parent === 0)
                        editor.emit('assets:used:' + oldId, false);
                }

                index[oldId].ref[referer][0].unbind();
                if (index[oldId].ref[referer][1])
                    index[oldId].ref[referer][1].unbind();

                delete index[oldId].ref[referer];
            }

            if (index[oldId].count === 0)
                editor.emit('assets:used:' + oldId, false);
        }

        if (newId) {
            if (index[newId] === undefined) {
                index[newId] = {
                    count: 0,
                    parent: 0,
                    ref: { }
                };
            }

            index[newId].count++;

            if (! index[newId].ref[referer]) {
                index[newId].ref[referer] = [ ];
                index[newId].ref[referer].type = type;

                index[newId].ref[referer][0] = editor.on('assets:used:' + referer, function(state) {
                    if (! index[newId])
                        return;

                    index[newId].parent += state * 2 - 1;

                    if (index[newId].parent === 0) {
                        // now not used
                        editor.emit('assets:used:' + newId, false);
                    } else if (index[newId].parent === 1) {
                        // now used
                        editor.emit('assets:used:' + newId, true);
                    }
                });

                // referer can be destroyed
                var itemType = 'asset';
                var item = editor.call('assets:get', referer);
                if (! item) {
                    item = editor.call('entities:get', referer);
                    itemType = 'entity';
                }

                if (item) {
                    index[newId].ref[referer][1] = item.once('destroy', function() {
                        updateAsset(referer, itemType, newId);
                    });
                }

                if (editor.call('assets:used:get', referer)) {
                    index[newId].parent++;

                    if (index[newId].count !== 1 && index[newId].parent === 1)
                        editor.emit('assets:used:' + newId, true);
                }
            }

            if (index[newId].count === 1 && index[newId].parent)
                editor.emit('assets:used:' + newId, true);
        }
    };
    var onSetMethods = {
        'cubemap': function(path, value, valueOld) {
            if (! keys['cubemap'][path])
                return;

            updateAsset(this.get('id'), 'asset', valueOld, value);
        },
        'material': function(path, value, valueOld) {
            if (! keys['standardMaterial'][path])
                return;

            updateAsset(this.get('id'), 'asset', valueOld, value);
        },
        'model': function(path, value, valueOld) {
            if (path.startsWith('data.mapping.') && path.slice(-8) === 'material')
                updateAsset(this.get('id'), 'asset', valueOld, value);

            if (! keys['model'][path])
                return;

            updateAsset(this.get('id'), 'asset', valueOld, value);
        },
        'model-insert': function(path, value) {
            if (! path.startsWith('data.mapping.'))
                return;

            updateAsset(this.get('id'), 'asset', null, value);
        },
        'model-remove': function(path, value) {
            if (! path.startsWith('data.mapping.'))
                return;

            updateAsset(this.get('id'), 'asset', value);
        },
        'entity': function(path, value, valueOld) {
            if (path.startsWith('components.model.mapping.')) {
                var parts = path.split('.');
                if (parts.length !== 4)
                    return;
            } else if (path.startsWith('components.sound.slots')) {
                var parts = path.split('.');
                if (parts.length !== 5 || parts[4] !== 'asset')
                    return;
            } else if (! legacyScripts && path.startsWith('components.script.scripts')) {
                var parts = path.split('.');
                if (parts.length === 6 && parts[4] === 'attributes') {
                    var primaryScript = editor.call('assets:scripts:assetByScript', parts[3]);
                    if (primaryScript) {
                        var type = primaryScript.get('data.scripts.' + parts[3] + '.attributes.' + parts[5] + '.type');
                        if (type !== 'asset')
                            return;
                    } else {
                        return;
                    }
                } else if (parts.length === 4) {
                    var primaryScript = editor.call('assets:scripts:assetByScript', parts[3]);
                    if (primaryScript) {
                        updateAsset(this.get('resource_id'), 'entity', null, primaryScript.get('id'));
                        return;
                    } else {
                        return;
                    }
                } else {
                    return;
                }
            } else if (! keys['entity'][path]) {
                return;
            }

            if (value instanceof Array) {
                for(var i = 0; i < value.length; i++) {
                    updateAsset(this.get('resource_id'), 'entity', valueOld && valueOld[i] || null, value[i]);
                }
            } else {
                updateAsset(this.get('resource_id'), 'entity', valueOld, value);
            }
        },
        'entity-unset': function(path, value) {
            if (path.startsWith('components.model.mapping.')) {
                var parts = path.split('.');
                if (parts.length !== 4)
                    return;
            } else if (path.startsWith('components.sound.slots')) {
                var parts = path.split('.');
                if (parts.length !== 5 || parts[4] !== 'asset')
                    return;
            } else if (! legacyScripts && path.startsWith('components.script.scripts')) {
                var parts = path.split('.');
                if (parts.length === 6 && parts[4] === 'attributes') {
                    var primaryScript = editor.call('assets:scripts:assetByScript', parts[3]);
                    if (primaryScript) {
                        var type = primaryScript.get('data.scripts.' + parts[3] + '.attributes.' + parts[5] + '.type');
                        if (type !== 'asset')
                            return;
                    } else {
                        return;
                    }
                } else if (parts.length === 5) {
                    var primaryScript = editor.call('assets:scripts:assetByScript', parts[3]);
                    if (primaryScript) {
                        var type = primaryScript.get('data.scripts.' + parts[3] + '.attributes.' + parts[5] + '.type');
                        if (type === 'asset') {
                            if (value.attributes[parts[5]] instanceof Array) {
                                for(var i = 0; i < value.attributes[parts[5]].length; i++) {
                                    updateAsset(this.get('resource_id'), 'entity', value.attributes[parts[5]][i], null);
                                }
                            } else {
                                updateAsset(this.get('resource_id'), 'entity', value.attributes[parts[5]], null);
                            }
                        }
                    } else {
                        return;
                    }
                } else if (parts.length === 4) {
                    var primaryScript = editor.call('assets:scripts:assetByScript', parts[3]);
                    if (primaryScript) {
                        updateAsset(this.get('resource_id'), 'entity', primaryScript.get('id'), null);

                        for(var attrName in value.attributes) {
                            var type = primaryScript.get('data.scripts.' + parts[3] + '.attributes.' + attrName + '.type');
                            if (type === 'asset') {
                                if (value.attributes[attrName] instanceof Array) {
                                    for(var i = 0; i < value.attributes[attrName].length; i++) {
                                        updateAsset(this.get('resource_id'), 'entity', value.attributes[attrName][i], null);
                                    }
                                } else {
                                    updateAsset(this.get('resource_id'), 'entity', value.attributes[attrName], null);
                                }
                            }
                        }
                    }
                    return;
                } else {
                    return;
                }
            } else if (! keys['entity'][path]) {
                return;
            }

            if (value instanceof Array) {
                for(var i = 0; i < value.length; i++) {
                    updateAsset(this.get('resource_id'), 'entity', value[i], null);
                }
            } else {
                updateAsset(this.get('resource_id'), 'entity', value, null);
            }
        },
        'entity-insert': function(path, value) {
            if (legacyScripts && path.startsWith('components.script.scripts.')) {
                var parts = path.split('.');
                if (parts.length !== 7 || parts[4] !== 'attributes' || parts[6] !== 'value' || this.get(parts.slice(0, 6).join('.') + '.type') !== 'asset')
                    return;
            } else if (! legacyScripts && path.startsWith('components.script.scripts')) {
                var parts = path.split('.');
                if (parts.length === 6 && parts[4] === 'attributes') {
                    var primaryScript = editor.call('assets:scripts:assetByScript', parts[3]);
                    if (primaryScript) {
                        var type = primaryScript.get('data.scripts.' + parts[3] + '.attributes.' + parts[5] + '.type');
                        if (type !== 'asset')
                            return;
                    } else {
                        return;
                    }
                } else {
                    return;
                }
            } else if (! keys['entity-lists'][path]) {
                return;
            }

            if (value instanceof Array) {
                for(var i = 0; i < value.length; i++) {
                    updateAsset(this.get('resource_id'), 'entity', null, value[i]);
                }
            } else {
                updateAsset(this.get('resource_id'), 'entity', null, value);
            }
        },
        'entity-remove': function(path, value) {
            if (legacyScripts && path.startsWith('components.script.scripts.')) {
                var parts = path.split('.');
                if (parts.length !== 7 || parts[4] !== 'attributes' || parts[6] !== 'value' || this.get(parts.slice(0, 6).join('.') + '.type') !== 'asset')
                    return;
            } else if (! legacyScripts && path.startsWith('components.script.scripts')) {
                var parts = path.split('.');
                if (parts.length === 6 && parts[4] === 'attributes') {
                    var primaryScript = editor.call('assets:scripts:assetByScript', parts[3]);
                    if (primaryScript) {
                        var type = primaryScript.get('data.scripts.' + parts[3] + '.attributes.' + parts[5] + '.type');
                        if (type !== 'asset')
                            return;
                    } else {
                        return;
                    }
                } else {
                    return;
                }
            } else if (! keys['entity-lists'][path]) {
                return;
            }

            updateAsset(this.get('resource_id'), 'entity', value, null);
        }
    };

    editor.on('assets:scripts:primary:set', function(asset, script) {
        var entities = editor.call('entities:list:byScript', script);
        if (! entities || Object.keys(entities).length === 0)
            return;

        var itemsOrder = asset.get('data.scripts.' + script + '.attributesOrder');
        var items = asset.get('data.scripts.' + script + '.attributes');
        var attributes = [ ];
        for(var i = 0; i < itemsOrder.length; i++) {
            if (items[itemsOrder[i]].type === 'asset')
                attributes.push(itemsOrder[i]);
        }

        for(var i in entities) {
            if (! entities.hasOwnProperty(i))
                continue;

            var entity = entities[i].entity;

            updateAsset(entity.get('resource_id'), 'entity', null, asset.get('id'));

            for(var a = 0; a < attributes.length; a++) {
                var value = entity.get('components.script.scripts.' + script + '.attributes.' + attributes[a]);
                if (! value)
                    continue;

                if (value instanceof Array) {
                    for(var v = 0; v < value.length; v++) {
                        if (typeof(value[v]) === 'number') {
                            updateAsset(entity.get('resource_id'), 'entity', null, value[v]);
                        }
                    }
                } else if (typeof(value) === 'number') {
                    updateAsset(entity.get('resource_id'), 'entity', null, value);
                }
            }
        }
    });

    editor.on('assets:scripts:primary:unset', function(asset, script) {
        var entities = editor.call('entities:list:byScript', script);
        if (! entities || Object.keys(entities).length === 0)
            return;

        var data = asset.get('data.scripts.' + script);
        var attributes = [ ];

        if (data) {
            var itemsOrder = data.attributesOrder;
            var items = data.attributes;

            for(var i = 0; i < itemsOrder.length; i++) {
                if (items[itemsOrder[i]].type === 'asset')
                    attributes.push(itemsOrder[i]);
            }
        }

        for(var i in entities) {
            if (! entities.hasOwnProperty(i))
                continue;

            var entity = entities[i].entity;

            updateAsset(entity.get('resource_id'), 'entity', asset.get('id'), null);

            for(var a = 0; a < attributes.length; a++) {
                var value = entity.get('components.script.scripts.' + script + '.attributes.' + attributes[a]);
                if (! value)
                    continue;

                if (value instanceof Array) {
                    for(var v = 0; v < value.length; v++) {
                        if (typeof(value[v]) === 'number') {
                            updateAsset(entity.get('resource_id'), 'entity', value[v], null);
                        }
                    }
                } else if (typeof(value) === 'number') {
                    updateAsset(entity.get('resource_id'), 'entity', value, null);
                }
            }
        }
    });

    // assets
    editor.on('assets:add', function(asset) {
        if (asset.get('source'))
            return;

        var type = asset.get('type');

        if (type === 'folder')
            return;

        if (onSetMethods[type]) {
            asset.on('*:set', onSetMethods[type]);

            if (onSetMethods[type + '-insert'])
                asset.on('*:insert', onSetMethods[type + '-insert']);

            if (onSetMethods[type + '-remove'])
                asset.on('*:remove', onSetMethods[type + '-remove']);

            for(var key in keys[type])
                updateAsset(asset.get('id'), 'asset', null, asset.get(key));

            if (type === 'model') {
                var mapping = asset.get('data.mapping');
                if (mapping) {
                    for(var i = 0; i < mapping.length; i++)
                        updateAsset(asset.get('id'), 'asset', null, mapping[i].material);
                }
            }
        }
    });

    // entities
    editor.on('entities:add', function(entity) {
        entity.on('*:set', onSetMethods['entity']);
        entity.on('*:unset', onSetMethods['entity-unset']);
        entity.on('*:insert', onSetMethods['entity-insert']);
        entity.on('*:remove', onSetMethods['entity-remove']);

        for(var key in keys['entity'])
            updateAsset(entity.get('resource_id'), 'entity', null, entity.get(key));

        var mappings = entity.get('components.model.mapping');
        if (mappings) {
            for(var ind in mappings) {
                if (! mappings.hasOwnProperty(ind) || ! mappings[ind])
                    continue;

                updateAsset(entity.get('resource_id'), 'entity', null, mappings[ind]);
            }
        }

        for(var key in keys['entity-lists']) {
            var items = entity.get(key);
            if (! items || ! items.length)
                continue;

            for(var i = 0; i < items.length; i++)
                updateAsset(entity.get('resource_id'), 'entity', null, items[i]);
        }

        var slots = entity.get('components.sound.slots');
        if (slots) {
            for(var i in slots) {
                if (! slots.hasOwnProperty(i) || ! slots[i].asset)
                    continue;

                updateAsset(entity.get('resource_id'), 'entity', null, slots[i].asset);
            }
        }

        var scripts = entity.get('components.script.scripts');

        if (scripts) {
            for(var script in scripts) {
                if (! scripts.hasOwnProperty(script))
                    continue;

                var primaryScript = editor.call('assets:scripts:assetByScript', script);
                if (primaryScript) {
                    updateAsset(entity.get('resource_id'), 'entity', null, primaryScript.get('id'));

                    var attributes = scripts[script].attributes;
                    for(var attr in attributes) {
                        if (! attributes.hasOwnProperty(attr))
                            continue;

                        var type = primaryScript.get('data.scripts.' + script + '.attributes.' + attr + '.type');
                        if (type === 'asset') {
                            var value = attributes[attr];

                            if (value instanceof Array) {
                                for(var v = 0; v < value.length; v++) {
                                    updateAsset(entity.get('resource_id'), 'entity', null, value[v]);
                                }
                            } else if (value) {
                                updateAsset(entity.get('resource_id'), 'entity', null, value);
                            }
                        }
                    }
                }
            }
        }
    });

    // scene settings
    var sceneSettings = editor.call('sceneSettings');
    sceneSettings.on('render.skybox:set', function(value, valueOld) {
        updateAsset('sceneSettings', 'editorSettings', valueOld, value);
    });

    editor.method('assets:used:index', function() {
        return index;
    });
    editor.method('assets:used:get', function(id) {
        if (isNaN(id))
            return true;

        if (! index[id])
            return false;

        return !! (index[id].count && index[id].parent);
    });
});


/* editor/assets/assets-user-color.js */
editor.once('load', function() {
    'use strict';

    var colors = { };
    var items = { };
    var pool = { };

    editor.on('selector:sync', function(user, data) {
        // deselect
        if (items[user] && items[user].length) {
            for(var i = 0; i < items[user].length; i++) {
                var element = items[user][i];
                element.parentNode.removeChild(element);
                pool[user].push(element);
            }

            items[user] = [ ];
        }

        if (data.type === 'asset') {
            // select
            if (! items[user]) {
                items[user] = [ ];
                pool[user] = [ ];
            }

            if (! colors[user])
                colors[user] = editor.call('whoisonline:color', user, 'hex');

            for(var i = 0; i < data.ids.length; i++) {
                var element = editor.call('assets:panel:get', data.ids[i]);
                if (! element)
                    continue;

                var point;

                if (pool[user].length) {
                    point = pool[user].pop();
                } else {
                    point = document.createElement('span');
                    point.style.backgroundColor = colors[user];
                }

                element.users.appendChild(point);
                items[user].push(point);
            }
        }
    });

    editor.on('whoisonline:remove', function(id) {
        if (! items[id])
            return;

        for(var i = 0; i < items[id].length; i++)
            items[id][i].parentNode.removeChild(items[id][i]);

        delete items[id];
        delete pool[id];
        delete colors[id];
    });
});


/* editor/assets/assets-script-parse.js */
editor.once('load', function() {
    'use strict';

    if (editor.call('settings:project').get('useLegacyScripts'))
        return;


    // parse script file and its attributes
    // update attributes accordingly


    editor.method('scripts:parse', function(asset, fn) {
        var worker = new Worker('/editor/scene/js/editor/assets/assets-script-parse-worker.js');
        worker.asset = asset;
        worker.progress = 0;

        worker.onmessage = function(evt) {
            if (! evt.data.name)
                return;

            switch(evt.data.name) {
                case 'results':
                    worker.terminate();
                    var result = evt.data.data;

                    var scripts = asset.get('data.scripts');

                    asset.history.enabled = false;

                    // loading screen?
                    if (result.loading !== asset.get('data.loading'))
                        asset.set('data.loading', result.loading);

                    // remove scripts
                    for(var key in scripts) {
                        if (! scripts.hasOwnProperty(key) || result.scripts.hasOwnProperty(key))
                            continue;

                        asset.unset('data.scripts.' + key);
                    }

                    // add scripts
                    for(var key in result.scripts) {
                        if (! result.scripts.hasOwnProperty(key))
                            continue;

                        var attributes = { };

                        // TODO scripts2
                        // attributes validation

                        for(var attr in result.scripts[key].attributes) {
                            if (! result.scripts[key].attributes.hasOwnProperty(attr))
                                continue;

                            attributes[attr] = result.scripts[key].attributes[attr];
                        }

                        var script = asset.get('data.scripts.' + key);
                        var attributesOrder = result.scripts[key].attributesOrder;

                        if (! script) {
                            // new script
                            asset.set('data.scripts.' + key, {
                                'attributesOrder': attributesOrder || [ ],
                                'attributes': attributes
                            });
                        } else {
                            // change attributes
                            for(var attr in attributes) {
                                if (! attributes.hasOwnProperty(attr) || ! script.attributes.hasOwnProperty(attr))
                                    continue;

                                asset.set('data.scripts.' + key + '.attributes.' + attr, attributes[attr]);
                            }

                            // remove attributes
                            for(var attr in script.attributes) {
                                if (! script.attributes.hasOwnProperty(attr) || attributes.hasOwnProperty(attr))
                                    continue;

                                asset.unset('data.scripts.' + key + '.attributes.' + attr);
                                asset.removeValue('data.scripts.' + key + '.attributesOrder', attr);
                            }

                            // add attributes
                            for(var attr in attributes) {
                                if (! attributes.hasOwnProperty(attr) || script.attributes.hasOwnProperty(attr))
                                    continue;

                                var ind = attributesOrder.indexOf(attr);
                                asset.set('data.scripts.' + key + '.attributes.' + attr, attributes[attr]);
                                asset.insert('data.scripts.' + key + '.attributesOrder', attr, ind);
                            }

                            // TODO scritps2
                            // move attribute
                            var attrIndex = { };
                            for(var i = 0; i < attributesOrder.length; i++)
                                attrIndex[attributesOrder[i]] = i;

                            var scriptAttributeOrder = asset.get('data.scripts.' + key + '.attributesOrder');
                            var i = scriptAttributeOrder.length;
                            while(i--) {
                                var attr = scriptAttributeOrder[i];
                                var indOld = asset.get('data.scripts.' + key + '.attributesOrder').indexOf(attr);
                                var indNew = attrIndex[attr];
                                if (indOld !== indNew)
                                    asset.move('data.scripts.' + key + '.attributesOrder', indOld, indNew);
                            }
                        }
                    }

                    asset.history.enabled = true;

                    if (fn) fn(null, result);
                    break;
            }
        };

        worker.onerror = function(err) {
            console.log('worker onerror', err);
            if (fn) fn(err);
        };

        worker.postMessage({
            name: 'parse',
            asset: asset.get('id'),
            url: asset.get('file.url'),
            engine: config.url.engine
        });
    });
});


/* editor/assets/assets-script-registry.js */
editor.once('load', function() {
    'use strict';

    if (editor.call('settings:project').get('useLegacyScripts'))
        return;


    // track all script assets
    // detect any collisions of script object within assets
    // notify about primary script asset
    // provide api to access assets by scripts and list available script objects


    var collisionAssets = { };
    var collisionScripts = { };
    var collisionStates = { };

    var assetToScripts = { };
    var scriptsList = [ ];
    var scripts = { };
    var scriptsPrimary = { };


    var addScript = function(asset, script) {
        var assetId = asset.get('id');

        if (! assetToScripts[assetId])
            assetToScripts[assetId] = { };

        if (assetToScripts[assetId][script]) {
            // 1. check if already indexed, then update
            editor.emit('assets:scripts:change', asset, script);
            editor.emit('assets:scripts[' + script + ']:change', asset);
            // console.log('assets:scripts:change', asset.json(), script);
        } else {
            // 2. if not indexed, then add
            assetToScripts[assetId][script] = true;
            if (! scripts[script]) scripts[script] = { };
            scripts[script][assetId] = asset;

            editor.emit('assets:scripts:add', asset, script);
            editor.emit('assets[' + asset.get('id') + ']:scripts:add', script);
            // console.log('assets:scripts:add', asset.json(), script);
        }

        // 3. check for collisions
        if (scriptsList.indexOf(script) === -1) {
            scriptsList.push(script);

            primaryScriptSet(asset, script);
        } else {
            if (! collisionScripts[script])
                collisionScripts[script] = { };

            if (! collisionScripts[script][assetId]) {
                for(var key in scripts[script]) {
                    if (! scripts[script].hasOwnProperty(key) || collisionScripts[script][key])
                        continue;

                    collisionScripts[script][key] = scripts[script][key];
                }

                checkCollisions(asset, script);
            }
        }
    };

    var removeScript = function(asset, script) {
        var assetId = asset.get('id');

        if (! assetToScripts[assetId] || ! assetToScripts[assetId][script] || ! scripts[script])
            return;

        delete assetToScripts[assetId][script];
        if (Object.keys(assetToScripts[assetId]).length === 0)
            delete assetToScripts[assetId];

        checkCollisions(null, script);

        delete scripts[script][assetId];
        var scriptAssets = Object.keys(scripts[script]).length;
        if (scriptAssets === 0) {
            delete scripts[script];
            var ind = scriptsList.indexOf(script);
            scriptsList.splice(ind, 1);
        } else if (collisionScripts[script] && collisionScripts[script][assetId]) {
            delete collisionScripts[script][assetId];
            var collisions = collisionScripts[script];
            if (Object.keys(collisionScripts[script]).length === 1)
                delete collisionScripts[script];

            for(var key in collisions)
                checkCollisions(collisions[key], script);
        }

        editor.emit('assets:scripts:remove', asset, script);
        editor.emit('assets[' + assetId + ']:scripts:remove', script);
        editor.emit('assets:scripts[' + script + ']:remove', asset);
        editor.emit('assets[' + assetId + ']:scripts[' + script + ']:remove');
        // console.log('assets:scripts:remove', asset.json(), script);
    };

    var checkCollisions = function(asset, script) {
        var collides = [ ];

        if (collisionScripts[script]) {
            for(var key in collisionScripts[script]) {
                if (! collisionScripts[script].hasOwnProperty(key))
                    continue;

                if (collisionScripts[script][key].get('preload'))
                    collides.push(collisionScripts[script][key]);
            }
        }

        if (collides.length > 1) {
            // collision occurs
            if (! collisionStates[script])
                collisionStates[script] = { };

            for(var i = 0; i < collides.length; i++) {
                var key = collides[i].get('id');
                if (collisionStates[script][key])
                    continue;

                collisionStates[script][key] = collides[i];
                editor.emit('assets:scripts:collide', collides[i], script);
                editor.emit('assets[' + key + ']:scripts:collide', script);
                editor.emit('assets:scripts[' + script + ']:collide', collides[i]);
                editor.emit('assets[' + key + ']:scripts[' + script + ']:collide');
            }

            primaryScriptSet(null, script);
        } else {
            // no collision
            if (collisionStates[script]) {
                for(var key in collisionStates[script]) {
                    if (! collisionStates[script].hasOwnProperty(key))
                        continue;

                    editor.emit('assets:scripts:resolve', collisionStates[script][key], script);
                    editor.emit('assets[' + key + ']:scripts:resolve', script);
                    editor.emit('assets:scripts[' + script + ']:resolve', collisionStates[script][key]);
                    editor.emit('assets[' + key + ']:scripts[' + script + ']:resolve');
                }

                delete collisionStates[script];
            }

            if (collides.length === 1) {
                primaryScriptSet(collides[0], script);
            } else if (asset && asset.get('preload')) {
                primaryScriptSet(asset, script);
            } else {
                primaryScriptSet(null, script);
            }
        }
    };

    var primaryScriptSet = function(asset, script) {
        if (asset === null && scriptsPrimary[script]) {
            // unset
            asset = scriptsPrimary[script];
            delete scriptsPrimary[script];
            editor.emit('assets:scripts:primary:unset', asset, script);
            editor.emit('assets[' + asset.get('id') + ']:scripts:primary:unset', script);
            editor.emit('assets:scripts[' + script + ']:primary:unset', asset);
            editor.emit('assets[' + asset.get('id') + ']:scripts[' + script + ']:primary:unset');
        } else if (asset && asset.get('preload') && (! scriptsPrimary[script] || scriptsPrimary[script] !== asset)) {
            // set
            scriptsPrimary[script] = asset;
            editor.emit('assets:scripts:primary:set', asset, script);
            editor.emit('assets[' + asset.get('id') + ']:scripts:primary:set', script);
            editor.emit('assets:scripts[' + script + ']:primary:set', asset);
            editor.emit('assets[' + asset.get('id') + ']:scripts[' + script + ']:primary:set');
        }
    };

    editor.on('assets:add', function(asset) {
        if (asset.get('type') !== 'script')
            return;

        var assetId = asset.get('id');

        // index scripts
        var scripts = asset.get('data.scripts');
        for(var key in scripts) {
            if (! scripts.hasOwnProperty(key))
                continue;

            addScript(asset, key);
        }

        // subscribe to changes
        asset.on('*:set', function(path, value, old) {
            if (path === 'preload') {
                var scripts = Object.keys(this.get('data.scripts'));
                for(var i = 0; i < scripts.length; i++)
                    checkCollisions(this, scripts[i]);

                return;
            }

            if (! path.startsWith('data.scripts.'))
                return;

            var parts = path.split('.');
            if (parts.length < 3) return;

            var script = parts[2];

            if (parts.length === 3) {
                // data.scripts.*
                addScript(asset, script);
            } else if (parts.length === 5 && parts[3] === 'attributes') {
                // data.scripts.*.attributes.*
                var attr = parts[4];
                editor.emit('assets:scripts:attribute:change', asset, script, attr, value, old);
                editor.emit('assets:scripts[' + script + ']:attribute:change', asset, attr, value, old);
            }
        });

        asset.on('*:unset', function(path, value) {
            if (! path.startsWith('data.scripts.'))
                return;

            var parts = path.split('.');
            if (parts.length < 3) return;

            var script = parts[2];

            if (parts.length === 3) // data.scripts.*
                removeScript(asset, script);
        });

        // add attribute
        asset.on('*:insert', function(path, value, ind) {
            if (! path.startsWith('data.scripts.'))
                return;

            var parts = path.split('.');
            if (parts.length !== 4 || parts[3] !== 'attributesOrder') return;

            var script = parts[2];
            editor.emit('assets:scripts:attribute:set', asset, script, value, ind);
            editor.emit('assets[' + asset.get('id') + ']:scripts:attribute:set', script, value, ind);
            editor.emit('assets:scripts[' + script + ']:attribute:set', asset, value, ind);
            editor.emit('assets[' + asset.get('id') + ']:scripts[' + script + ']:attribute:set', value, ind);
        });

        // remove attribute
        asset.on('*:remove', function(path, value) {
            if (! path.startsWith('data.scripts.'))
                return;

            var parts = path.split('.');
            if (parts.length !== 4 || parts[3] !== 'attributesOrder') return;

            var script = parts[2];
            editor.emit('assets:scripts:attribute:unset', asset, script, value);
            editor.emit('assets[' + asset.get('id') + ']:scripts:attribute:unset', script, value);
            editor.emit('assets:scripts[' + script + ']:attribute:unset', asset, value);
            editor.emit('assets[' + asset.get('id') + ']:scripts[' + script + ']:attribute:unset', value);
        });

        asset.on('*:move', function(path, value, ind, indOld) {
            if (! path.startsWith('data.scripts.'))
                return;

            var parts = path.split('.');

            if (parts.length === 4 && parts[3] === 'attributesOrder') {
                var script = parts[2];

                editor.emit('assets:scripts:attribute:move', asset, script, value, ind, indOld);
                editor.emit('assets[' + asset.get('id') + ']:scripts:attribute:move', script, value, ind, indOld);
                editor.emit('assets:scripts[' + script + ']:attribute:move', asset, value, ind, indOld);
                editor.emit('assets[' + asset.get('id') + ']:scripts[' + script + ']:attribute:move', value, ind, indOld);
            }
        });

        asset.once('destroy', function() {
            var scripts = asset.get('data.scripts');
            for(var key in scripts) {
                if (! scripts.hasOwnProperty(key))
                    continue;

                removeScript(asset, key);
            }
        });
    });

    editor.method('assets:scripts:list', function() {
        return scriptsList.slice(0);
    });

    editor.method('assets:scripts:assetByScript', function(script) {
        return scriptsPrimary[script] || null;
    });

    editor.method('assets:scripts:collide', function(script) {
        return collisionStates[script];
    });
});


/* editor/project/project-scripts-order.js */
editor.once('load', function() {
    'use strict';

    if (editor.call('settings:project').get('useLegacyScripts'))
        return;

    var foldStates = {
        'scripts': true
    };

    var projectSettings = editor.call('settings:project');


    editor.on('attributes:inspect[editorSettings]', function() {
        var events = [ ];

        // scripts order
        var panel = editor.call('attributes:addPanel', {
            name: 'Scripts Loading Order'
        });
        panel.foldable = true;
        panel.folded = foldStates['scripts'];
        panel.on('fold', function() { foldStates['scripts'] = true; });
        panel.on('unfold', function() { foldStates['scripts'] = false; });
        panel.class.add('component', 'scripts-order');
        panel.element.tabIndex = 0;


        var panelItems = new ui.Panel();
        panelItems.class.add('scripts-order');
        panel.append(panelItems);

        var itemsIndex = { };
        var dragPlaceholder = null;
        var dragInd = null;
        var dragOut = true;
        var dragItem = null;
        var dragItemInd = null;
        var dragItems = [ ];

        // drop area
        var target = editor.call('drop:target', {
            ref: panelItems.innerElement,
            type: 'script-order',
            hole: true,
            passThrough: true
        });
        target.element.style.outline = '1px dotted #f60';
        panelItems.once('drestroy', function() {
            target.unregister();
        });

        var dragCalculateSizes = function() {
            dragItems = [ ];
            var children = panelItems.innerElement.children;

            for(var i = 0; i < children.length; i++) {
                var item = children[i].ui ? children[i].ui.assetId : children[i].assetId;

                dragItems.push({
                    item: item,
                    ind: projectSettings.get('scripts').indexOf(item),
                    y: children[i].offsetTop,
                    height: children[i].clientHeight
                });
            }
        };
        var onItemDragStart = function(evt) {
            // dragend
            window.addEventListener('blur', onItemDragEnd, false);
            window.addEventListener('mouseup', onItemDragEnd, false);
            window.addEventListener('mouseleave', onItemDragEnd, false);
            document.body.addEventListener('mouseleave', onItemDragEnd, false);
            // dragmove
            window.addEventListener('mousemove', onItemDragMove, false);

            itemsIndex[dragItem].class.add('dragged');

            dragCalculateSizes();
            for(var i = 0; i < dragItems.length; i++) {
                if (dragItems[i].item === dragItem)
                    dragItemInd = i;
            }

            var panel = itemsIndex[dragItem];
            var parent = panel.element.parentNode;
            dragPlaceholder = document.createElement('div');
            dragPlaceholder.assetId = dragItem;
            dragPlaceholder.classList.add('dragPlaceholder');
            dragPlaceholder.style.height = (dragItems[dragItemInd].height - 8) + 'px';
            parent.insertBefore(dragPlaceholder, panel.element);
            parent.removeChild(panel.element);

            onItemDragMove(evt);

            editor.call('drop:set', 'script-order', { asset: dragItem });
            editor.call('drop:activate', true);
        };
        var onItemDragMove = function(evt) {
            if (! dragItem) return;

            var rect = panelItems.innerElement.getBoundingClientRect();

            dragOut = (evt.clientX < rect.left || evt.clientX > rect.right || evt.clientY < rect.top || evt.clientY > rect.bottom);

            if (! dragOut) {
                var y = evt.clientY - rect.top;
                var ind = null;
                var height = dragPlaceholder.clientHeight;

                var c = 0;
                for(var i = 0; i < dragItems.length; i++) {
                    if (dragItems[i].item === dragItem) {
                        c = i;
                        break;
                    }
                }

                // hovered item
                for(var i = 0; i < dragItems.length; i++) {
                    var off = Math.max(0, dragItems[i].height - height);
                    if (c < i) {
                        if (y >= (dragItems[i].y + off) && y <= (dragItems[i].y + dragItems[i].height)) {
                            ind = i;
                            if (ind > dragItemInd) ind++;
                            break;
                        }
                    } else {
                        if (y >= dragItems[i].y && y <= (dragItems[i].y + dragItems[i].height - off)) {
                            ind = i;
                            if (ind > dragItemInd) ind++;
                            break;
                        }
                    }
                }

                if (ind !== null && dragInd !== ind) {
                    dragInd = ind;

                    var parent = dragPlaceholder.parentNode;
                    parent.removeChild(dragPlaceholder);

                    var ind = dragInd;
                    if (ind > dragItemInd) ind--;
                    var next = parent.children[ind];

                    if (next) {
                        parent.insertBefore(dragPlaceholder, next);
                    } else {
                        parent.appendChild(dragPlaceholder);
                    }

                    dragCalculateSizes();
                }
            } else {
                dragInd = dragItemInd;
                var parent = dragPlaceholder.parentNode;
                parent.removeChild(dragPlaceholder);
                var next = parent.children[dragItemInd];
                if (next) {
                    parent.insertBefore(dragPlaceholder, next);
                } else {
                    parent.appendChild(dragPlaceholder);
                }
                dragCalculateSizes();
            }
        };
        var onItemDragEnd = function() {
            // dragend
            window.removeEventListener('blur', onItemDragEnd);
            window.removeEventListener('mouseup', onItemDragEnd);
            window.removeEventListener('mouseleave', onItemDragEnd);
            document.body.removeEventListener('mouseleave', onItemDragEnd);
            // dragmove
            window.removeEventListener('mousemove', onItemDragMove);

            if (dragItem) {
                itemsIndex[dragItem].class.remove('dragged');

                var panel = itemsIndex[dragItem];
                panelItems.innerElement.removeChild(dragPlaceholder);
                var next = panelItems.innerElement.children[dragItemInd];
                if (next) {
                    panelItems.innerElement.insertBefore(panel.element, next);
                } else {
                    panelItems.innerElement.appendChild(panel.element);
                }

                if (! dragOut && dragInd !== null && dragInd !== dragItemInd && dragInd !== (dragItemInd + 1)) {
                    var ind = dragInd;
                    if (ind > dragItemInd) ind--;
                    projectSettings.move('scripts', dragItemInd, ind);

                    var data = {
                        item: dragItem,
                        indNew: ind,
                        indOld: dragItemInd
                    };

                    editor.call('history:add', {
                        name: 'project.scripts.move',
                        undo: function() {
                            var indOld = projectSettings.get('scripts').indexOf(data.item);
                            if (indOld === -1) return;
                            projectSettings.move('scripts', indOld, data.indOld);
                        },
                        redo: function() {
                            var indOld = projectSettings.get('scripts').indexOf(data.item);
                            if (indOld === -1) return;
                            projectSettings.move('scripts', indOld, data.indNew);
                        }
                    });
                }
            }

            dragItem = null;
            dragItems = [ ];
            dragInd = null;

            editor.call('drop:activate', false);
            editor.call('drop:set');
        };


        var assetFullSet = function() {
            var scripts = projectSettings.get('scripts');

            // clear panel
            var first = panelItems.innerElement.firstChild;
            while(first) {
                panelItems.innerElement.removeChild(first);
                first = panelItems.innerElement.firstChild;
            }

            // reappend
            for(var i = 0; i < scripts.length; i++) {
                if (itemsIndex[scripts[i]]) {
                    panelItems.innerElement.appendChild(itemsIndex[scripts[i]].element);
                } else {
                    assetAdd(scripts[i]);
                }
            }

            assetUpdateNumbers();
        };


        var assetUpdateNumbers = function() {
            var children = panelItems.innerElement.children;
            for(var i = 0; i < children.length; i++)
                children[i].ui.number.textContent = i + 1;
        };


        var assetAdd = function(assetId, ind) {
            var events = [ ];
            var asset = editor.call('assets:get', assetId);
            if (! asset)
                return;

            assetId = parseInt(assetId, 10);

            if (itemsIndex[assetId])
                return;

            var panel = itemsIndex[assetId] = new ui.Panel();
            panel.header = asset.get('name');
            panel.assetId = assetId;
            panel.class.add('asset');

            panel.headerElement.addEventListener('click', function() {
                editor.call('selector:set', 'asset', [ asset ]);
            }, false);

            // name
            events.push(asset.on('name:set', function(value) {
                panel.header = value;
            }));

            // number
            panel.number = document.createElement('div');
            panel.number.classList.add('number');
            panel.number.textContent = projectSettings.get('scripts').indexOf(assetId) + 1;
            panel.headerAppend(panel.number);

            // handle
            panel.handle = document.createElement('div');
            panel.handle.classList.add('handle');
            panel.handle.addEventListener('mousedown', function(evt) {
                evt.stopPropagation();
                evt.preventDefault();

                dragItem = panel.assetId;
                onItemDragStart(evt);
            }, false);
            panel.headerAppend(panel.handle);

            // position
            var next = null;
            if (typeof(ind) === 'number')
                next = panelItems.innerElement.children[ind];

            if (next) {
                panelItems.appendBefore(panel, next);
            } else {
                panelItems.append(panel);
            }

            panel.once('destroy', function() {
                for(var i = 0; i < events.length; i++)
                    events[i].unbind();

                events = null;
            });
        };


        var assetMove = function(assetId, ind) {
            var panel = itemsIndex[assetId];
            if (! panel) return;

            panelItems.innerElement.removeChild(panel.element);
            var next = panelItems.innerElement.children[ind];

            if (next) {
                panelItems.innerElement.insertBefore(panel.element, next);
            } else {
                panelItems.innerElement.appendChild(panel.element);
            }

            assetUpdateNumbers();
        };


        var assetRemove = function(assetId) {
            if (! itemsIndex[assetId])
                return;

            itemsIndex[assetId].destroy();
            delete itemsIndex[assetId];

            assetUpdateNumbers();
        };

        // get assets
        var assets = projectSettings.get('scripts') || [ ];

        // remove null assets
        if (editor.call('permissions:write')) {
            var i = assets.length;
            while(i--) {
                if (assets[i] === null)
                    projectSettings.remove('scripts', i);
            }
        }

        // add assets
        for(var i = 0; i < assets.length; i++)
            assetAdd(assets[i]);


        // on add
        events.push(projectSettings.on('scripts:insert', function(assetId, ind) {
            assetAdd(assetId, ind);
        }));
        // on move
        events.push(projectSettings.on('scripts:move', function(assetId, ind) {
            assetMove(parseInt(assetId, 10), ind);
        }));
        // on remove
        events.push(projectSettings.on('scripts:remove', function(assetId) {
            assetRemove(parseInt(assetId, 10));
        }));
        // on set
        events.push(projectSettings.on('scripts:set', function() {
            assetFullSet();
        }));
        // on asset add
        events.push(editor.on('assets:add', function(asset) {
            if (asset.get('type') !== 'script') return;

            var assetId = parseInt(asset.get('id'), 10);
            if (projectSettings.get('scripts').indexOf(assetId) !== -1)
                assetAdd(assetId);
        }));


        panel.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();

            events = null;
        });
    });
});


/* editor/images/images-upload.js */
editor.once('load', function () {
    editor.method('images:upload', function (file, callback, error) {
        if (!file || !file.size)
            return;

        var form = new FormData();
        form.append('file', file);

        var data = {
            url: '/api/projects/{{project.id}}/image',
            method: 'POST',
            auth: true,
            data: form,
            ignoreContentType: true,
            headers: {
                Accept: 'application/json'
            }
        };

        Ajax(data)
            .on('load', function(status, data) {
                if (callback)
                    callback(data);
            })
            .on('progress', function(progress) {
            })
            .on('error', function(status, data) {
                if (error)
                    error(status, data);
            });
    });
});


/* editor/userdata/userdata-realtime.js */
editor.once('load', function() {
    'use strict';

    var userData = null;

    var loadUserData = function () {
        if (! userData && config.scene.id) {
            userData = editor.call('realtime:subscribe:userdata', config.scene.id, config.self.id);
        }
    };

    editor.method('realtime:subscribe:userdata', function (sceneId, userId) {
        var connection = editor.call('realtime:connection');
        var data = connection.get('user_data', '' + sceneId + '_' + userId);

        // error
        data.on('error', function (err) {
            editor.emit('realtime:userdata:error', err);
        });

        // ready to sync
        data.on('ready', function() {
            // notify of operations
            data.on('after op', function(ops, local) {
                if (local) return;

                for (var i = 0; i < ops.length; i++) {
                    if (ops[i].p[0])
                        editor.emit('realtime:userdata:' + userId + ':op:' + ops[i].p[0], ops[i]);
                }
            });

            // notify of scene load
            editor.emit('userdata:' + userId + ':raw', data.getSnapshot());
        });

        // subscribe for realtime events
        data.subscribe();

        if (data.state === 'ready')
            editor.emit('userdata:' + userId + ':raw', data.getSnapshot());

        return data;
    });

    // write userdata operations
    editor.method('realtime:userdata:op', function(op) {
        if (! editor.call('permissions:read') || ! userData)
            return;

        // console.trace();
        // console.log('out: [ ' + Object.keys(op).filter(function(i) { return i !== 'p' }).join(', ') + ' ]', op.p.join('.'));
        // console.log(op)

        userData.submitOp([ op ]);
    });

    // subscribe to permission changes for userdata
    editor.on('permissions:set:' + config.self.id, function () {
        if (editor.call('permissions:read') && config.scene.id) {
            loadUserData();
        } else {
            if (userData) {
                userData.destroy();
                userData = null;
            }
        }
    });

    editor.on('realtime:disconnected', function () {
        if (userData) {
            userData.destroy();
            userData = null;
        }
    });

    editor.on('scene:unload', function () {
        if (userData) {
            userData.destroy();
            userData = null;
        }
    });

    editor.on('scene:raw', function () {
        if (editor.call('permissions:read'))
            loadUserData();
    });

});


/* editor/userdata/userdata.js */
editor.once('load', function() {
    'use strict';

    var userdata = new Observer();

    editor.on('userdata:' + config.self.id + ':raw', function (data) {

        userdata.sync = new ObserverSync({
            item: userdata,
            paths: [ 'cameras' ]
        });

        // client > server
        var evt = userdata.sync.on('op', function(op) {
            if (op.oi === null) {
                console.error('Tried to send invalid userdata op', op);
                return;
            }

            editor.call('realtime:userdata:op', op);
        });

        editor.once('scene:unload', function () {
            if (evt) {
                evt.unbind();
                evt = null;
            }
        });

        editor.once('realtime:disconnected', function () {
            if (evt) {
                evt.unbind();
                evt = null;
            }
        });

        userdata.sync.enabled = false;
        userdata.patch(data);
        userdata.sync.enabled = true;

        editor.emit('userdata:load', userdata);
    });

    editor.method('userdata', function () {
        return userdata;
    });
});


/* editor/scenes/scenes.js */
editor.once('load', function () {
    'use strict';

    // Fetch list of scenes from the server and
    // pass them to the callback
    editor.method('scenes:list', function (callback) {
        Ajax({
            url: '{{url.api}}/projects/{{project.id}}/scenes',
            auth: true
        })
            .on('load', function (status, data) {
                if (callback)
                    callback(data.result);
            });
    });

    // Get a specific scene from the server and pass result to callback
    editor.method('scenes:get', function (sceneId, callback) {
        Ajax({
            url: '{{url.api}}/scenes/' + sceneId,
            auth: true
        })
            .on('load', function (status, data) {
                if (callback)
                    callback(data);
            });
    });

    // Create a scene and pass result to callback
    editor.method('scenes:new', function (name, callback) {
        var data = {
            project_id: config.project.id
        };

        if (name) data.name = name;

        Ajax({
            url: '{{url.api}}/scenes',
            auth: true,
            method: 'POST',
            data: data
        })
            .on('load', function (status, data) {
                if (callback)
                    callback(data);
            });
    });

    // Duplicate scene and pass result to callback
    editor.method('scenes:duplicate', function (sceneId, newName, callback) {
        Ajax({
            url: '{{url.api}}/scenes',
            auth: true,
            method: 'POST',
            data: {
                project_id: config.project.id,
                duplicate_from: sceneId,
                name: newName
            }
        })
            .on('load', function (status, data) {
                if (callback)
                    callback(data);
            });
    });


    // Delete a scene
    editor.method('scenes:delete', function (sceneId, callback) {
        Ajax({
            url: '{{url.api}}/scenes/' + sceneId,
            auth: true,
            method: 'DELETE'
        })
            .on('load', function (status, data) {
                if (callback)
                    callback();
            });
    });

});

/* editor/scenes/scenes-load.js */
editor.once('load', function () {
    'use strict';

    var pushState = true;
    var sceneSelected = false;
    var deletedScenes = {};

    var realtimeAuthenticated = false;

    editor.on('realtime:authenticated', function () {
        realtimeAuthenticated = true;
    });

    editor.on('realtime:disconnected', function () {
        realtimeAuthenticated = false;
    });

    var evtLoadOnAuthenticated = null;

    // Load scene with specified id. If isNew is true
    // then scene settings will open right after loading the new scene
    editor.method('scene:load', function (id, isNew) {
        if (config.scene.id)
            editor.call('scene:unload');

        if (evtLoadOnAuthenticated) {
            evtLoadOnAuthenticated.unbind();
        }

        // if we have not been authenticated with sharejs yet
        // then defer loading until we are authenticated
        if (! realtimeAuthenticated) {
            evtLoadOnAuthenticated = editor.once('realtime:authenticated', function () {
                evtLoadOnAuthenticated = null;
                editor.call('scene:load', id, isNew);
            });

            return;
        }

        editor.emit('scene:beforeload', id);

        editor.call('realtime:loadScene', id);

        if (isNew) {
            editor.once('entities:load', function () {
                editor.call('selector:set', 'editorSettings', [ editor.call('settings:projectUser') ]);
            });
        }
    });

    // When scene is loaded
    editor.on('scene:load', function (id) {
        // set config
        config.scene.id = id.toString();
        Ajax.param('scene.id', config.scene.id);

        // add history state
        if (pushState) {
            if (history.length === 1 && window.location.pathname.startsWith('/editor/scene/')) {
                history.replaceState(null, 'Editor', '/editor/scene/' + id + window.location.search);
            } else {
                history.pushState(null, 'Editor', '/editor/scene/' + id + window.location.search);
            }
        }

        pushState = true;

        // clear history in a timeout
        // otherwise some select events might remain
        setTimeout(function () {
            editor.call('history:clear');
        });
    });

    // Unload current scene
    editor.method('scene:unload', function () {
        var id = config.scene.id;
        config.scene.id = null;

        editor.emit('scene:unload', id);
    });

    // When history state changes make sure we load the
    // correct scene based on the new URL
    window.addEventListener('popstate', function (e) {
        var location = window.location.href;

        // close scene picker
        editor.call('picker:scene:close');

        // if this is a scene URL
        if (/scene/.test(location)) {
            var parts = location.split('/');
            var sceneId = parts[parts.length-1];
            // if this is not the current scene
            if (parseInt(sceneId, 10) !== parseInt(config.scene.id)) {
                // if the current scene has been deleted then don't load it
                // but rather make the current URL a project URL so that the scene picker opens
                if (deletedScenes[sceneId]) {
                    history.replaceState(null, 'Editor', '/editor/project/' + config.project.id + window.location.search);
                    // unload current scene
                    editor.call('scene:unload');
                    // open scene picker
                    editor.call('picker:scene');
                } else {
                    // load scene but don't add it to the history
                    pushState = false;
                    editor.call('scene:load', sceneId);
                }
            }
        } else {
            // if this is not a scene URL then
            // unload current scene and show scene picker
            editor.call('scene:unload');
            editor.call('picker:scene');
        }
    });

    // subscribe to messenger pack.delete
    editor.on('messenger:pack.delete', function (data) {
        // add scene to deleted so that we don't try to reopen it
        // on the 'popstate' event
        deletedScenes[data.pack.id] = true;

        // if the current scene has been deleted then change URL to project URL
        if (parseInt(config.scene.id, 10) === parseInt(data.pack.id, 10)) {
            history.replaceState(null, 'Editor', '/editor/project/' + config.project.id + window.location.search);
            editor.call('scene:unload');
            editor.call('picker:scene');
        }
    });
});


/* editor/camera/camera.js */
editor.once('load', function() {
    'use strict';

    editor.once('viewport:load', function() {
        var cameras = [ ];
        var camerasIndex = { };
        var editorCameras = { };
        var currentCamera = null;
        var defaultCamera = null;
        var app = editor.call('viewport:app');
        if (! app) return; // webgl not available


        editor.method('camera:get', function(name) {
            return editorCameras[name] || null;
        });

        editor.method('camera:editor', function() {
            return editorCameras;
        });

        editor.method('camera:current', function() {
            return currentCamera;
        });

        editor.method('camera:set', function(entity) {
            if (! entity) entity = defaultCamera

            if (currentCamera === entity || ! entity.camera)
                return;

            var old = currentCamera;
            if (old && old.__editorCamera) old.enabled = false;

            currentCamera = entity;
            if (currentCamera.__editorCamera)
                currentCamera.enabled = true;

            editor.emit('camera:change', currentCamera, old);
            editor.call('viewport:render');
        });

        editor.method('camera:add', function(entity) {
            if (camerasIndex[entity.getGuid()])
                return;

            cameras.push(entity);
            camerasIndex[entity.getGuid()] = entity;

            editor.emit('camera:add', entity);
        });

        editor.method('camera:remove', function(entity) {
            if (! camerasIndex[entity.getGuid()])
                return;

            var ind = cameras.indexOf(entity);
            if (ind !== -1)
                cameras.splice(ind, 1);

            delete camerasIndex[entity.getGuid()];

            if (entity === currentCamera)
                editor.call('camera:set');

            editor.emit('camera:remove', entity);
        });

        editor.method('camera:list', function() {
            return cameras.slice(0);
        });

        editor.on('permissions:writeState', function(state) {
            if (state || currentCamera.__editorCamera)
                return;

            editor.call('camera:set', editorCameras['perspective']);
        });


        var list = [{
            name: 'perspective',
            title: 'Perspective',
            position: new pc.Vec3(9.2, 6, 9),
            rotation: new pc.Vec3(-25, 45, 0),
            default: true
        }, {
            name: 'top',
            title: 'Top',
            position: new pc.Vec3(0, 1000, 0),
            rotation: new pc.Vec3(-90, 0, 0),
            ortho: true
        }, {
            name: 'bottom',
            title: 'Bottom',
            position: new pc.Vec3(0, -1000, 0),
            rotation: new pc.Vec3(90, 0, 0),
            ortho: true
        }, {
            name: 'front',
            title: 'Front',
            position: new pc.Vec3(0, 0, 1000),
            rotation: new pc.Vec3(0, 0, 0),
            ortho: true
        }, {
            name: 'back',
            title: 'Back',
            position: new pc.Vec3(0, 0, -1000),
            rotation: new pc.Vec3(0, 180, 0),
            ortho: true
        }, {
            name: 'left',
            title: 'Left',
            position: new pc.Vec3(-1000, 0, 0),
            rotation: new pc.Vec3(0, -90, 0),
            ortho: true
        }, {
            name: 'right',
            title: 'Right',
            position: new pc.Vec3(1000, 0, 0),
            rotation: new pc.Vec3(0, 90, 0),
            ortho: true
        }];


        var createCamera = function(args) {
            var entity = new pc.Entity();
            entity.__editorCamera = true;
            entity.__editorName = args.name;
            entity.enabled = false;
            entity.name = args.title;
            entity.setPosition(args.position);
            entity.setEulerAngles(args.rotation);
            entity.focus = new pc.Vec3();

            editorCameras[args.name] = entity;

            var params = {
                nearClip: 0.1,
                farClip: 10000,
                priority: 0,
                clearColorBuffer: true,
                clearDepthBuffer: true,
                frustumCulling: true
            };

            if (args.ortho) {
                params.projection = pc.PROJECTION_ORTHOGRAPHIC;
                params.orthoHeight = 5;
            } else {
                params.projection = pc.PROJECTION_PERSPECTIVE;
                params.fov = 45;
            }

            entity.addComponent('camera', params);

            app.root.addChild(entity);

            return entity;
        };

        // add default cameras
        for(var i = 0; i < list.length; i++) {
            var entity = createCamera(list[i]);

            editor.call('camera:add', entity);

            if (list[i].default && ! defaultCamera) {
                defaultCamera = entity;
                editor.call('camera:set', entity);
            }
        }

        editor.emit('camera:load');
    });
});


/* editor/camera/camera-history.js */
editor.once('load', function() {
    'use strict';

    var camera;
    var overlapping = 0;
    var position, rotation, eulers, orthoHeight;

    editor.method('camera:history:start', function(entity) {
        if (entity === camera) {
            overlapping++;
            return;
        } else if (camera) {
            editor.call('camera:history:stop');
        }

        var obj = editor.call('entities:get', entity.getGuid());
        if (! obj) return;

        camera = entity;
        overlapping = 1;
        position = camera.getLocalPosition().clone();
        rotation = camera.getLocalRotation().clone();
        eulers = obj.get('rotation');
        orthoHeight = camera.camera.orthoHeight;

        obj.history.enabled = false;
    });

    editor.method('camera:history:stop', function(entity) {
        if (! camera) return;

        if (entity) {
            if (entity !== camera)
                return;

            overlapping--;
            if (overlapping > 0)
                return;
        }

        var obj = editor.call('entities:get', camera.getGuid());
        if (! obj) {
            camera = null;
            return;
        }

        obj.history.enabled = true;

        var dist = position.clone().sub(camera.getLocalPosition()).length();
        var rotA = rotation;
        var rotB = camera.getLocalRotation();
        var theta = rotA.w * rotB.w + rotA.x * rotB.x + rotA.y * rotB.y + rotA.z * rotB.z;

        // not changed
        if (dist < 0.001 && theta > 0.999 && orthoHeight === camera.camera.orthoHeight) {
            camera = null;
            return;
        }

        var get = obj.history._getItemFn;

        var posCur = Array.prototype.slice.call(camera.getLocalPosition().data);
        var rotCur = Array.prototype.slice.call(camera.getLocalEulerAngles().data);
        var ortCur = camera.camera.orthoHeight;

        var posPrev = Array.prototype.slice.call(position.data);
        var rotPrev = eulers.slice(0);
        var ortPrev = orthoHeight;

        camera = null;

        editor.call('history:add', {
            name: 'camera.user',
            undo: function() {
                var item = get();
                if (! item) return;

                item.history.enabled = false;
                item.set('position', posPrev);
                item.set('rotation', rotPrev);
                item.set('components.camera.orthoHeight', ortPrev);
                item.history.enabled = true;
            },
            redo: function() {
                var item = get();
                if (! item) return;

                item.history.enabled = false;
                item.set('position', posCur);
                item.set('rotation', rotCur);
                item.set('components.camera.orthoHeight', ortCur);
                item.history.enabled = true;
            }
        });
    });
});


/* editor/camera/camera-userdata.js */
editor.once('camera:load', function() {
    'use strict';

    var userdata = editor.call('userdata');
    var camera = editor.call('camera:current');


    editor.on('viewport:update', function() {
        var name = camera.__editorName;

        var data = userdata.get('cameras.' + name);
        if (data) {
            var pos = camera.getPosition();
            if (data.position[0] !== pos.x || data.position[1] !== pos.y || data.position[2] !== pos.z)
                userdata.set('cameras.' + name + '.position', [ pos.x, pos.y, pos.z ]);

            var rot = camera.getEulerAngles();
            if (data.rotation[0] !== rot.x || data.rotation[1] !== rot.y || data.rotation[2] !== rot.z)
                userdata.set('cameras.' + name + '.rotation', [ rot.x, rot.y, rot.z ]);

            var focus = camera.focus;
            if (data.focus[0] !== focus.x || data.focus[1] !== focus.y || data.focus[2] !== focus.z)
                userdata.set('cameras.' + name + '.focus', [ focus.x, focus.y, focus.z ]);

            if (camera.camera.projection === pc.PROJECTION_ORTHOGRAPHIC) {
                var orthoHeight = camera.camera.orthoHeight;
                if (data.orthoHeight !== orthoHeight)
                    userdata.set('cameras.' + name + '.orthoHeight', orthoHeight);
            }
        } else if (! camera.__editorCamera) {
            var obj = editor.call('entities:get', camera.getGuid());
            if (! obj) return;

            var pos = camera.getLocalPosition();
            var posOld = obj.get('position');

            if (pos.x !== posOld[0] || pos.y !== posOld[1] || pos.z !== posOld[2])
                obj.set('position', [ pos.x, pos.y, pos.z ]);

            var rotA = camera.getLocalRotation();
            var rotOld = obj.get('rotation');
            var rotB = new pc.Quat();
            rotB.setFromEulerAngles(rotOld[0], rotOld[1], rotOld[2]);
            var theta = rotA.w * rotB.w + rotA.x * rotB.x + rotA.y * rotB.y + rotA.z * rotB.z;

            if (theta < 0.999) {
                var rot = camera.getLocalEulerAngles();
                if (rot.x !== rotOld[0] || rot.y !== rotOld[1] || rot.z !== rotOld[2])
                    obj.set('rotation', [ rot.x, rot.y, rot.z ]);
            }

            if (camera.camera.projection === pc.PROJECTION_ORTHOGRAPHIC) {
                var orthoHeight = camera.camera.orthoHeight;
                if (obj.get('components.camera.orthoHeight') !== orthoHeight)
                    obj.set('components.camera.orthoHeight', orthoHeight);
            }
        }
    });

    editor.on('camera:change', function(cameraNew) {
        camera = cameraNew;
    });
});


/* editor/camera/camera-depth.js */
editor.once('viewport:load', function() {
    'use strict';

    var depthTarget;
    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var scene = app.scene;
    var renderer = app.renderer;
    var device = renderer.device;
    var rendered = false;


    editor.on('viewport:preUpdate', function() {
        rendered = false;
    });

    editor.method('camera:depth:render', function(camera) {
        var rect = camera._rect;
        var width = Math.floor(rect.width * device.width);
        var height = Math.floor(rect.height * device.height);

        if (depthTarget && (depthTarget.width !== width || depthTarget.height !== height)) {
            depthTarget.destroy();
            depthTarget = null;
        }

        if (! depthTarget) {
            var colorBuffer = new pc.Texture(device, {
                format: pc.PIXELFORMAT_R8_G8_B8_A8,
                width: width,
                height: height
            });
            colorBuffer.minFilter = pc.FILTER_NEAREST;
            colorBuffer.magFilter = pc.FILTER_NEAREST;
            colorBuffer.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
            colorBuffer.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
            depthTarget = new pc.RenderTarget(device, colorBuffer, {
                depth: true
            });
        }

        var oldTarget = camera.renderTarget;
        camera.renderTarget = depthTarget;
        renderer.setCamera(camera);

        var oldBlending = device.getBlending();
        device.setBlending(false);

        var drawCalls = scene.drawCalls;
        var drawCallsCount = drawCalls.length;

        for (var i = 0; i < drawCallsCount; i++) {
            var opChan = 'r';
            var meshInstance = drawCalls[i];
            if (! meshInstance.command && meshInstance.drawToDepth && meshInstance.material && meshInstance.material.blendType === pc.BLEND_NONE && meshInstance.layer === pc.LAYER_WORLD) {
                var mesh = meshInstance.mesh;

                renderer.modelMatrixId.setValue(meshInstance.node.worldTransform.data);

                var material = meshInstance.material;
                if (material.opacityMap) {
                    renderer.opacityMapId.setValue(material.opacityMap);
                    renderer.alphaTestId.setValue(material.alphaTest);
                    if (material.opacityMapChannel) opChan = material.opacityMapChannel;
                }

                if (meshInstance.skinInstance) {
                    renderer._skinDrawCalls++;
                    renderer.skinPosOffsetId.setValue(meshInstance.skinInstance.rootNode.getPosition().data);
                    if (device.supportsBoneTextures) {
                        var boneTexture = meshInstance.skinInstance.boneTexture;
                        renderer.boneTextureId.setValue(boneTexture);
                        renderer.boneTextureSizeId.setValue([boneTexture.width, boneTexture.height]);
                    } else {
                        renderer.poseMatrixId.setValue(meshInstance.skinInstance.matrixPalette);
                    }
                    device.setShader(material.opacityMap ? renderer._depthShaderSkinOp[opChan] : renderer._depthShaderSkin);
                } else {
                    device.setShader(material.opacityMap ? renderer._depthShaderStaticOp[opChan] : renderer._depthShaderStatic);
                }

                var style = meshInstance.renderStyle;

                device.setVertexBuffer(mesh.vertexBuffer, 0);
                device.setIndexBuffer(mesh.indexBuffer[style]);
                device.draw(mesh.primitive[style]);
                renderer._depthDrawCalls++;
            }
        }
        camera.renderTarget = oldTarget;
        device.setBlending(oldBlending);

        rendered = true;

        return depthTarget;
    });


    editor.method('camera:depth:pixelAt', function(camera, x, y) {
        if (! depthTarget || ! rendered)
            editor.call('camera:depth:render', camera);

        var prevRenderTarget = device.renderTarget;

        device.setRenderTarget(depthTarget);
        device.updateBegin();

        var pixels = new Uint8Array(4);
        device.readPixels(x, depthTarget.height - y, 1, 1, pixels);

        device.updateEnd();

        device.setRenderTarget(prevRenderTarget);

        var bitShift = new pc.Vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
        var color = new pc.Vec4(pixels[0], pixels[1], pixels[2], pixels[3]);
        var colorDistance = color.dot(bitShift);

        if (colorDistance >= 255)
            return null;

        var distance = (camera._nearClip || 0.0001) + (camera._farClip * (colorDistance / 255.0));
        var point = new pc.Vec3();

        camera.screenToWorld(x, y, distance, depthTarget.width, depthTarget.height, point);

        return point;
    });
});


/* editor/camera/camera-user.js */
editor.once('load', function() {
    'use sctrict';

    editor.on('entities:add:entity', function(entity) {
        if (entity.get('components.camera'))
            editor.call('camera:add', entity.entity);

        entity.on('components.camera:set', function() {
            editor.call('camera:add', entity.entity);
        });

        entity.on('components.camera:unset', function() {
            editor.call('camera:remove', entity.entity);
        });

        entity.once('destroy', function() {
            editor.call('camera:remove', entity.entity);
        });
    });
});


/* editor/camera/camera-focus.js */
editor.once('viewport:load', function() {
    'use strict';

    // Focusing on a point and a distance

    var focusTarget = new pc.Vec3();
    var focusPoint = new pc.Vec3();
    var focusOrthoHeight = 0;
    var focusCamera;
    var focusing = false;
    var firstUpdate = false;
    var flySpeed = 0.25;
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();


    editor.method('camera:focus', function(point, distance) {
        var camera = editor.call('camera:current');

        if (! focusing) {
            focusCamera = camera;
            editor.call('camera:history:start', focusCamera);
        }

        focusing = true;
        firstUpdate = true;

        if (camera.camera.projection === pc.PROJECTION_ORTHOGRAPHIC) {
            focusOrthoHeight = distance / 2;
            distance = (camera.camera.farClip - (camera.camera.nearClip || 0.0001)) / 2 + (camera.camera.nearClip || 0.0001);
        }

        focusTarget.copy(point);
        vecA.copy(camera.forward).scale(-distance);
        focusPoint.copy(point).add(vecA);

        editor.emit('camera:focus', point, distance);
        editor.call('viewport:render');
    });

    editor.method('camera:focus:stop', function() {
        if (! focusing)
            return;

        focusing = false;
        var camera = editor.call('camera:current');
        editor.emit('camera:focus:end', focusTarget, vecA.copy(focusTarget).sub(camera.getPosition()).length());
        editor.once('viewport:postUpdate', function() {
            editor.call('camera:history:stop', focusCamera);
        });
    });

    editor.on('viewport:update', function(dt) {
        if (focusing) {
            var camera = editor.call('camera:current');

            var pos = camera.getPosition();
            var dist = vecA.copy(pos).sub(focusPoint).length();
            if (dist > 0.01) {
                var speed = Math.min(1.0, Math.min(1.0, flySpeed * ((firstUpdate ? 1 / 60 : dt) / (1 / 60))));
                vecA.copy(pos).lerp(pos, focusPoint, speed);
                camera.setPosition(vecA);

                if (camera.camera.projection === pc.PROJECTION_ORTHOGRAPHIC) {
                    var orthoHeight = camera.camera.orthoHeight;
                    orthoHeight += (focusOrthoHeight - orthoHeight) * Math.min(1.0, flySpeed * ((firstUpdate ? 1 / 60 : dt) / (1 / 60)));
                    camera.camera.orthoHeight = orthoHeight;
                }

                editor.call('viewport:render');
            } else {
                camera.setPosition(focusPoint);
                if (camera.camera.projection === pc.PROJECTION_ORTHOGRAPHIC)
                    camera.camera.orthoHeight = focusOrthoHeight;

                focusing = false;

                editor.emit('camera:focus:end', focusTarget, vecA.copy(focusTarget).sub(camera.getPosition()).length());
                editor.once('viewport:postUpdate', function() {
                    editor.call('camera:history:stop', focusCamera);
                });
            }

            firstUpdate = false;
        }
    });
});


/* editor/camera/camera-fly.js */
editor.once('viewport:load', function() {
    'use strict';

    // Flying with WASD or Arrows

    var vecA = new pc.Vec3();
    var direction = new pc.Vec3();

    var flying = false;
    var flySpeed = 7;
    var flySpeedFast = 25;
    var flySpeedTarget = 0;
    var flyEasing = 0.5;
    var flyVec = new pc.Vec3();
    var flyCamera = null;
    var firstUpdate = false;
    var shiftKey = false;

    var keys = {
        forward: false,
        left: false,
        back: false,
        right: false,
        up: false,
        down: false
    };
    var keysMovement = { 87: 1, 38: 1, 65: 1, 37: 1, 83: 1, 40: 1, 68: 1, 39: 1, 81: 1, 69: 1, 34: 1, 33: 1 };


    editor.method('camera:fly:state', function() {
        return flying;
    });

    editor.on('viewport:update', function(dt) {
        var camera;
        var speed = 0;

        if (flying) {
            speed = shiftKey ? flySpeedFast : flySpeed;
            speed *= firstUpdate ? (1 / 60) : dt;

            camera = editor.call('camera:current');

            vecA.copy(direction).scale(speed);

            if (camera.camera.projection === pc.PROJECTION_ORTHOGRAPHIC) {
                vecA.y = -vecA.z;
                vecA.z = 0;
            }

            if (vecA.length()) {
                camera.getRotation().transformVector(vecA, vecA);
                flyVec.lerp(flyVec, vecA, Math.min(1.0, flyEasing * ((firstUpdate ? 1 / 60 : dt) / (1 / 60))));
            } else {
                speed = 0;
            }

            editor.call('viewport:render');
        }

        if (flyVec.length() > 0.01) {
            if (speed === 0)
                flyVec.lerp(flyVec, vecA.set(0, 0, 0), Math.min(1.0, flyEasing * ((firstUpdate ? 1 / 60 : dt) / (1 / 60))));

            if (flyVec.length()) {
                camera = camera || editor.call('camera:current');
                camera.setPosition(camera.getPosition().add(flyVec));
            }

            firstUpdate = false;
            editor.call('viewport:render');
        }
    });

    editor.on('hotkey:shift', function(state) {
        shiftKey = state;
    });

    window.addEventListener('keydown', function(evt) {
        if (! keysMovement[evt.keyCode] || evt.ctrlKey || evt.metaKey || evt.altKey)
            return;

        if (evt.target && /(input)|(textarea)/i.test(evt.target.tagName))
            return;

        if (evt.keyCode === 87 || evt.keyCode === 38) {
            keys.forward = true;
        } else if (evt.keyCode === 65 || evt.keyCode === 37) {
            keys.left = true;
        } else if (evt.keyCode === 83 || evt.keyCode === 40) {
            keys.back = true;
        } else if (evt.keyCode === 68 || evt.keyCode === 39) {
            keys.right = true;
        } else if (evt.keyCode === 69 || evt.keyCode === 33) {
            keys.up = true;
        } else if (evt.keyCode === 81 || evt.keyCode === 34) {
            keys.down = true;
        }

        direction.set(keys.right - keys.left, keys.up - keys.down, keys.back - keys.forward).normalize();

        if (! flying) {
            flyCamera = editor.call('camera:current');
            editor.call('camera:history:start', flyCamera);
        }

        flying = true;
        firstUpdate = true;
        editor.call('camera:focus:stop');
        editor.call('viewport:render');
    }, false);

    window.addEventListener('keyup', function(evt) {
        if (! flying || ! keysMovement[evt.keyCode] || evt.ctrlKey || evt.metaKey || evt.altKey)
            return;

        if (evt.target && /(input)|(textarea)/i.test(evt.target.tagName))
            return;

        if (evt.keyCode === 87 || evt.keyCode === 38) {
            keys.forward = false;
        } else if (evt.keyCode === 65 || evt.keyCode === 37) {
            keys.left = false;
        } else if (evt.keyCode === 83 || evt.keyCode === 40) {
            keys.back = false;
        } else if (evt.keyCode === 68 || evt.keyCode === 39) {
            keys.right = false;
        } else if (evt.keyCode === 69 || evt.keyCode === 33) {
            keys.up = false;
        } else if (evt.keyCode === 81 || evt.keyCode === 34) {
            keys.down = false;
        }

        direction.set(keys.right - keys.left, keys.up - keys.down, keys.back - keys.forward).normalize();

        if (! keys.forward && ! keys.left && ! keys.back && ! keys.right && ! keys.up && ! keys.down) {
            flying = false;
            editor.call('camera:history:stop', flyCamera);
            editor.call('viewport:render');
        }
    }, false);
});


/* editor/camera/camera-orbit.js */
editor.once('viewport:load', function() {
    'use strict';

    // Orbit camera with virtual point of focus
    // Zooming / Flying will not move virtual point forward/backwards

    var orbiting = false;
    var orbitCamera;
    var pivot = new pc.Vec3();
    var distance = 1;
    var sensivity = 0.2;
    var pitch = 0;
    var yaw = 0;
    var vec2 = new pc.Vec2();
    var vecA = new pc.Vec3();
    var quat = new pc.Quat();


    editor.on('viewport:update', function(dt) {
        var camera = editor.call('camera:current');

        if (camera.camera.projection !== pc.PROJECTION_PERSPECTIVE)
            return;

        distance = Math.max(0.01, vecA.copy(pivot).sub(camera.getPosition()).length());
        pivot.copy(camera.forward).scale(distance).add(camera.getPosition());

        if (orbiting) {
            quat.setFromEulerAngles(pitch, yaw, 0);
            vecA.set(0, 0, distance);
            quat.transformVector(vecA, vecA);
            vecA.add(pivot);

            camera.setPosition(vecA);
            camera.lookAt(pivot);

            editor.call('viewport:render');
        }

        if (camera.focus)
            camera.focus.copy(pivot);
    });

    editor.on('camera:change', function(camera) {
        if (! camera.focus)
            return;

        pivot.copy(camera.focus);
    });

    editor.on('camera:focus', function(point) {
        pivot.copy(point);

        var camera = editor.call('camera:current');
        if (camera.focus)
            camera.focus.copy(pivot);
    });

    editor.on('camera:focus:end', function(point, value) {
        var camera = editor.call('camera:current');
        distance = value;
        pivot.copy(camera.forward).scale(distance).add(camera.getPosition());

        var camera = editor.call('camera:current');
        if (camera.focus)
            camera.focus.copy(pivot);
    });

    editor.on('viewport:tap:start', function(tap, evt) {
        if (tap.button !== 0 || evt.shiftKey || orbiting)
            return;

        editor.call('camera:focus:stop');

        var camera = editor.call('camera:current');

        if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
            orbiting = true;

            // disable history
            orbitCamera = camera;
            editor.call('camera:history:start', orbitCamera);

            // pitch
            var x = Math.cos(Math.asin(camera.forward.y));
            vec2.set(x, camera.forward.y).normalize();
            pitch =  Math.max(-89.99, Math.min(89.99, Math.atan2(vec2.y, vec2.x) / (Math.PI / 180)));

            // yaw
            vec2.set(camera.forward.x, -camera.forward.z).normalize();
            yaw = -Math.atan2(vec2.x, vec2.y) / (Math.PI / 180);

            editor.call('viewport:render');
        } else {
            editor.call('camera:pan:start', tap);
        }
    });

    editor.on('viewport:tap:end', function(tap) {
        if (tap.button !== 0 || ! orbiting)
            return;

        orbiting = false;
        editor.call('camera:history:stop', orbitCamera);
    });

    editor.on('viewport:tap:move', function(tap) {
        if (! orbiting || tap.button !== 0)
            return;

        pitch = Math.max(-89.99, Math.min(89.99, pitch - (tap.y - tap.ly) * sensivity));
        yaw += (tap.lx - tap.x) * sensivity;

        editor.call('viewport:render');
    });

    editor.on('camera:toggle', function(state) {
        if (! state && orbiting) {
            orbiting = false;
            editor.call('camera:history:stop', orbitCamera);
        }
    });
});


/* editor/camera/camera-zoom.js */
editor.once('viewport:load', function() {
    'use strict';

    // Moving towards mouse point in world using mouse wheel
    // Speed is relative to distance of point in world

    var zoom = 0;
    var zoomTarget = 0;
    var zoomSpeed = 0.1;
    var zoomSpeedFast = 0.5;
    var zoomEasing = 0.3;
    var zoomMax = 300;
    var zoomCamera;
    var shiftKey = false;
    var hovering = false;
    var firstUpdate = 3;
    var mouseCoords = new pc.Vec2();
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var distance = 1;

    var selectorLastType = null;
    var aabbSelection = new pc.BoundingBox();
    var aabbSelectionLast = 0;
    var aabbRoot = new pc.BoundingBox();
    var aabbRootLast = 0;

    editor.on('hotkey:shift', function(state) {
        shiftKey = state;
    });
    editor.on('viewport:hover', function(state) {
        hovering = state;
    });

    editor.on('selector:change', function(type) {
        if (selectorLastType !== type || type === 'entity') {
            selectorLastType = type;
            aabbSelectionLast = 0;
        }
    });

    editor.on('viewport:update', function(dt) {
        if (zoomTarget !== zoom) {
            var diff = zoom;
            zoom += (zoomTarget - zoom) * Math.min(1.0, zoomEasing * ((firstUpdate === 1 ? 1 / 60 : dt) / (1 / 60)));
            diff = zoom - diff;

            var orbiting = editor.call('camera:orbit:state');
            var camera = editor.call('camera:current');

            if (firstUpdate === 1) {
                zoomCamera = camera;
                editor.call('camera:history:start', zoomCamera);
            }

            if (diff !== 0) {
                if (orbiting) {
                    var dist = editor.call('camera:orbit:distance');
                    dist -= diff * Math.max(1, Math.min(zoomMax, dist));
                    editor.call('camera:orbit:distance', dist);
                } else {
                    if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
                        var mouseWPos = camera.camera.screenToWorld(mouseCoords.x, mouseCoords.y, 1);
                        var rayDirection = vecB.copy(mouseWPos).sub(camera.getPosition()).normalize();

                        var point = editor.call('camera:depth:pixelAt', camera.camera.camera, mouseCoords.x, mouseCoords.y);
                        if (point) {
                            point.sub(camera.getPosition());
                            distance = Math.max(1, Math.min(zoomMax, point.length()));
                        } else {
                            // distance to selected entity
                            var aabb;

                            // cache and recalculate aabb only periodically
                            if (selectorLastType === 'entity') {
                                if ((Date.now() - aabbSelectionLast > 1000)) {
                                    aabbSelectionLast = Date.now();
                                    aabb = editor.call('selection:aabb');
                                    if (aabb) aabbSelection.copy(aabb);
                                } else {
                                    aabb = aabbSelection;
                                }
                            }

                            if (aabb) {
                                distance = Math.max(1, Math.min(zoomMax, aabb.center.clone().sub(camera.getPosition()).length()));
                            } else {
                                // nothing selected, then size of aabb of scene or distance to center of aabb

                                if ((Date.now() - aabbRootLast) > 1000) {
                                    aabbRootLast = Date.now();
                                    aabbRoot.copy(editor.call('entities:aabb', editor.call('entities:root')));
                                }

                                aabb = aabbRoot;

                                if (editor.call('entities:root')) {
                                    distance = Math.max(aabb.halfExtents.length(), aabb.center.clone().sub(camera.getPosition()).length());
                                    distance = Math.max(1, Math.min(zoomMax, distance));
                                }
                            }
                        }

                        diff *= distance;

                        if (diff) {
                            vecA.copy(rayDirection).scale(diff);
                            camera.setPosition(camera.getPosition().add(vecA));
                        }
                    } else {
                        var orthoHeight = camera.camera.orthoHeight;
                        diff *= -orthoHeight;
                        if (diff) camera.camera.orthoHeight = Math.max(0.1, orthoHeight + diff);

                        // TODO
                        // on zoom, move camera same as google maps does
                    }
                }

                if (Math.abs(zoomTarget - zoom) < 0.001)
                    zoom = zoomTarget;
            }

            editor.call('viewport:render');
            firstUpdate = 2;
        } else {
            if (firstUpdate === 2) {
                firstUpdate = 3;
                editor.once('viewport:postUpdate', function() {
                    editor.call('camera:history:stop', zoomCamera);
                });
            }
        }
    });

    var onMouseWheel = function(evt) {
        if (! hovering)
            return;

        shiftKey = evt.shiftKey;

        var delta = 0;
        if (evt.detail) {
            delta = -1 * evt.detail / 3;
        } else if (evt.wheelDelta) {
            delta = evt.wheelDelta / 120;
        }

        if (delta !== 0) {
            editor.call('camera:focus:stop');

            if (firstUpdate === 3)
                firstUpdate = 1;

            var speed = delta * (shiftKey ? zoomSpeedFast : zoomSpeed);
            zoomTarget += speed;

            editor.call('viewport:render');
        }
    };

    var onFocus = function(point, dist) {
        distance = Math.max(1, Math.min(zoomMax, dist));
    };

    editor.on('camera:focus', onFocus);
    editor.on('camera:focus:end', onFocus);

    editor.on('viewport:mouse:move', function(tap) {
        mouseCoords.x = tap.x;
        mouseCoords.y = tap.y;
    });

    window.addEventListener('mousewheel', onMouseWheel, false);
    window.addEventListener('DOMMouseScroll', onMouseWheel, false);
});


/* editor/camera/camera-pan.js */
editor.once('viewport:load', function(app) {
    'use strict';

    // Panning with left mouse button while shift key is down

    var panning = false;
    var panSpeed = 0.01;
    var panCamera;
    var shiftKey = false;
    var vecA = new pc.Vec2();
    var vecB = new pc.Vec3();
    var vecC = new pc.Vec3();
    var vecD = new pc.Vec3();
    var vecE = new pc.Vec3();
    var quat = new pc.Quat();
    var panLastPosition = new pc.Vec3();
    var panPosition = new pc.Vec3();
    var firstPan = false;
    var panPoint = new pc.Vec3();
    var grabbed = false;
    var panButton = 0;


    editor.on('hotkey:shift', function(state) {
        shiftKey = state;
    });

    editor.on('viewport:update', function(dt) {
        if (! panning)
            return;

        var camera = editor.call('camera:current');

        if (grabbed) {
            var mouseWPos = camera.camera.screenToWorld(vecA.x, vecA.y, 1);
            var rayOrigin = vecB.copy(camera.getPosition());
            var rayDirection = vecC.set(0, 0, -1);
            var planeNormal = vecD.copy(camera.forward);

            if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
                rayDirection.copy(mouseWPos).sub(rayOrigin).normalize();
            } else {
                rayOrigin.copy(mouseWPos);
                camera.getWorldTransform().transformVector(rayDirection, rayDirection);
            }

            var rayPlaneDot = planeNormal.dot(rayDirection);
            var planeDist = panPoint.dot(planeNormal);
            var pointPlaneDist = (planeNormal.dot(rayOrigin) - planeDist) / rayPlaneDot;
            var pickedPos = rayDirection.scale(-pointPlaneDist).add(rayOrigin);

            vecB.copy(panPoint).sub(pickedPos);

            if (vecB.length())
                camera.setPosition(camera.getPosition().add(vecB));
        } else {

        }

        editor.call('viewport:render');
    });

    var onPanStart = function(tap) {
        if (panning)
            return;

        panButton = tap.button;

        editor.call('camera:focus:stop');
        panning = true;
        firstPan = true;

        var camera = editor.call('camera:current');
        var point = editor.call('camera:depth:pixelAt', camera.camera.camera, tap.x, tap.y);

        panCamera = camera;
        editor.call('camera:history:start', panCamera);

        vecA.x = tap.x;
        vecA.y = tap.y;

        if (point) {
            panPoint.copy(point);
            grabbed = true;
        } else {
            // distance to selected entity
            var aabb = editor.call('selection:aabb');

            if (aabb) {
                var dist = aabb.center.clone().sub(camera.getPosition()).length();
                panPoint.copy(camera.camera.screenToWorld(vecA.x, vecA.y, dist));
                grabbed = true;
            } else {
                // nothing selected, then size of aabb of scene or distance to center of aabb
                aabb = editor.call('entities:aabb', editor.call('entities:root'));

                if (editor.call('entities:root')) {
                    var dist = Math.max(aabb.halfExtents.length(), aabb.center.clone().sub(camera.getPosition()).length());
                    panPoint.copy(camera.camera.screenToWorld(vecA.x, vecA.y, dist));
                    grabbed = true;
                } else {
                    grabbed = false;
                }
            }
        }

        editor.call('viewport:render');
    };
    editor.method('camera:pan:start', onPanStart);

    editor.on('viewport:tap:start', function(tap) {
        if (panning || ((tap.button !== 0 || ! shiftKey) && tap.button !== 1))
            return;

        onPanStart(tap);
    });

    editor.on('viewport:tap:end', function(tap) {
        if (! panning || tap.button !== panButton)
            return;

        panning = false;
        editor.call('camera:history:stop', panCamera);
    });

    editor.on('viewport:tap:move', function(tap) {
        if (! panning)
            return;

        vecA.x = tap.x;
        vecA.y = tap.y;

        editor.call('viewport:render');
    });

    editor.on('camera:toggle', function(state) {
        if (! state && panning) {
            panning = false;
            editor.call('camera:history:stop', panCamera);
        }
    });
});


/* editor/camera/camera-look-around.js */
editor.once('viewport:load', function() {
    'use strict';

    // Looking around with right mouse button

    var looking = false;
    var sensivity = 0.2;
    var vecA = new pc.Vec2();
    var lookCamera;

    var pitch = 0;
    var yaw = 0;

    editor.on('viewport:tap:start', function(tap) {
        if (tap.button !== 2 || looking)
            return;

        editor.call('camera:focus:stop');
        var camera = editor.call('camera:current');

        if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
            looking = true;
            lookCamera = camera;
            editor.call('camera:history:start', lookCamera);

            // pitch
            var x = Math.cos(Math.asin(camera.forward.y));
            vecA.set(x, camera.forward.y).normalize();
            pitch =  Math.max(-89.99, Math.min(89.99, Math.atan2(vecA.y, vecA.x) / (Math.PI / 180)));

            // yaw
            vecA.set(camera.forward.x, -camera.forward.z).normalize();
            yaw = -Math.atan2(vecA.x, vecA.y) / (Math.PI / 180);
        } else {
            editor.call('camera:pan:start', tap);
        }
    });

    editor.on('viewport:tap:end', function(tap) {
        if (tap.button !== 2 || ! looking)
            return;

        looking = false;
        editor.call('camera:history:stop', lookCamera);
    });

    editor.on('viewport:tap:move', function(tap) {
        if (! looking || tap.button !== 2)
            return;

        var camera = editor.call('camera:current');

        if (camera.camera.projection !== pc.PROJECTION_PERSPECTIVE)
            return;

        pitch = Math.max(-89.99, Math.min(89.99, pitch + (tap.ly - tap.y) * sensivity));
        yaw += (tap.lx - tap.x) * sensivity;

        camera.setEulerAngles(pitch, yaw, 0);

        editor.call('viewport:render');
    });
});


/* editor/camera/camera-preview.js */
editor.once('load', function() {
    'use sctrict';

    var selectedEntity = null;
    var currentCamera = null;
    var renderCamera = false;
    var pinnedCamera = null;
    var lastCamera = null;
    var events = [ ];
    var evtUpdate = null;
    var rect = new pc.Vec4(0, 0.8, 0.2, 0.2);
    var app = null;

    var viewport = editor.call('layout.viewport');

    var cameraPreviewBorder = document.createElement('div');
    cameraPreviewBorder.classList.add('camera-preview');
    if (editor.call('permissions:write'))
        cameraPreviewBorder.classList.add('clickable');

    var btnPin = new ui.Button({
        text: '&#58177;'
    });
    btnPin.class.add('pin');
    cameraPreviewBorder.appendChild(btnPin.element);

    btnPin.on('click', function(evt) {
        evt.stopPropagation();

        if (lastCamera) {
            lastCamera.cullingMask = 0xFFFFFFFF;
            lastCamera = null;
        }

        if (pinnedCamera) {
            pinnedCamera = null;
            btnPin.class.remove('active');
        } else {
            pinnedCamera = selectedEntity;
            btnPin.class.add('active');
        }

        updateCameraState();
    });

    viewport.append(cameraPreviewBorder);

    cameraPreviewBorder.addEventListener('click', function() {
        var obj = pinnedCamera || selectedEntity;
        if (! obj || ! obj.entity || ! editor.call('permissions:write'))
            return;

        editor.call('camera:set', obj.entity);
    }, false);


    editor.once('viewport:load', function(application) {
        app = application;
    });

    editor.on('permissions:writeState', function(state) {
        if (state) {
            cameraPreviewBorder.classList.add('clickable');
        } else {
            cameraPreviewBorder.classList.remove('clickable');
        }
    });

    editor.on('viewport:resize', function(width, height) {
        rect.x = 6.0 / width;
        rect.y = 1.0 - ((43.0 + 196.0) / (height || 1.0));
        rect.z = 258.0 / width;
        rect.w = 198.0 / height;
    });

    var update = function() {
        if (! app) return; // WebGL might not be created

        if (! renderCamera)
            return;

        var obj = pinnedCamera || selectedEntity;

        if (! obj.entity)
            return;

        var camera = obj.entity.camera;
        if (! camera)
            return;

        camera.camera.renderTarget = null;
        camera.camera.cullingMask = 1;
        camera.rect = rect;

        lastCamera = camera.camera;

        camera.frameBegin();
        app.renderer.render(app.scene, camera.camera);
        camera.frameEnd();
    };

    var updateCameraState = function() {
        if (pinnedCamera) {
            if (currentCamera && currentCamera === pinnedCamera.entity) {
                renderCamera = false;
            } else {
                renderCamera = true;
            }
        } else if (selectedEntity && selectedEntity.entity && ! (currentCamera && selectedEntity.entity === currentCamera) && selectedEntity.has('components.camera')) {
            renderCamera = true;
        } else {
            renderCamera = false;
        }

        if (renderCamera) {
            cameraPreviewBorder.classList.add('active');

            if (! evtUpdate)
                evtUpdate = editor.on('viewport:postRender', update);
        } else {
            cameraPreviewBorder.classList.remove('active');

            if (lastCamera) {
                lastCamera.cullingMask = 0xFFFFFFFF;
                lastCamera = null;
            }

            if (evtUpdate) {
                evtUpdate.unbind();
                evtUpdate = null;
            }
        }
    };

    editor.on('camera:change', function(camera) {
        if (camera && ! camera.__editorCamera) {
            currentCamera = camera;
        } else {
            currentCamera = null;
        }

        updateCameraState();
    });

    editor.on('selector:change', function(type, items) {
        if (events.length) {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();

            events = [ ];
        }

        if (lastCamera) {
            lastCamera.cullingMask = 0xFFFFFFFF;
            lastCamera = null;
        }

        if (type === 'entity' && items.length === 1) {
            selectedEntity = items[0];
            events.push(selectedEntity.on('components.camera:set', updateCameraState));
            events.push(selectedEntity.on('components.camera:unset', updateCameraState));
            events.push(selectedEntity.on('destroy', updateCameraState));
        } else {
            selectedEntity = null;
        }

        updateCameraState();
    });
});


/* editor/apps/apps.js */
editor.once('load', function () {
    'use strict';

    // Fetch list of apps from the server and
    // pass them to the callback
    editor.method('apps:list', function (callback) {
        Ajax({
            url: '{{url.api}}/projects/{{project.id}}/apps?limit=0',
            auth: true
        })
            .on('load', function (status, data) {
                if (callback)
                    callback(data.result);
            });
    });

    // Get a specific app from the server and pass result to callback
    editor.method('apps:get', function (appId, callback) {
        Ajax({
            url: '{{url.api}}/apps/' + appId,
            auth: true
        })
            .on('load', function (status, data) {
                if (callback)
                    callback(data);
            });
    });

    // Create app and pass result to callback
    editor.method('apps:new', function (data, callback, error) {
        Ajax({
            url: '{{url.api}}/apps',
            auth: true,
            method: 'POST',
            data: data
        })
            .on('load', function (status, result) {
                if (callback)
                    callback(result);
            })
            .on('error', function () {
                if (error)
                    error.apply(this, arguments);
            });
    });

    // Download app
    editor.method('apps:download', function (data, callback, error) {
        Ajax({
            url: '{{url.api}}/apps/download',
            auth: true,
            method: 'POST',
            data: data
        })
            .on('load', function (status, result) {
                if (callback)
                    callback(result);
            })
            .on('error', function () {
                if (error)
                    error.apply(this, arguments);
            });
    });

    // Publish on facebook
    editor.method('apps:publishFb', function (data, callback, error) {
        Ajax({
            url: '{{url.api}}/apps/facebook',
            auth: true,
            method: 'POST',
            data: data
        })
            .on('load', function (status, result) {
                if (callback)
                    callback(result);
            })
            .on('error', function () {
                if (error)
                    error.apply(this, arguments);
            });
    });

    // Delete a app
    editor.method('apps:delete', function (appId, callback) {
        Ajax({
            url: '{{url.api}}/apps/' + appId,
            auth: true,
            method: 'DELETE'
        })
            .on('load', function (status, data) {
                if (callback)
                    callback();
            });
    });

});

/* editor/whoisonline/whoisonline.js */
editor.once('load', function() {
    'use strict';

    var whoisonline = new ObserverList();

    // Set whoisonline
    editor.method('whoisonline:set', function (data) {
        whoisonline.clear();
        if (data) {
            data.forEach(function (id) {
                whoisonline.add(id);
            });
        }
    });

    // Get whoisonline
    editor.method('whoisonline:get', function () {
        return whoisonline;
    });

    // Add to whoiseonline
    editor.method('whoisonline:add', function (id) {
        whoisonline.add(id);
    });

    // Remove from whoisonline
    editor.method('whoisonline:remove', function (id) {
        whoisonline.remove(id);
    });

    // Returns true if specified user id is online
    editor.method('whoisonline:find', function (id) {
        return whoisonline.indexOf(id) >= 0;
    });

    // 'add' event
    whoisonline.on('add', function (id) {
        editor.emit('whoisonline:add', id);
    });

    // 'remove' event
    whoisonline.on('remove', function (id, index) {
        editor.emit('whoisonline:remove', id, index);
    });

    // remove all users when disconnected
    editor.on('realtime:disconnected', function () {
        whoisonline.clear();
    });

});


/* editor/whoisonline/whoisonline-colors.js */
editor.once('load', function() {
    'use strict';

    var users = { };
    var pallete = [
        [ 5, 0.63, 0.46 ],
        [ 6, 0.78, 0.57 ],
        [ 24, 1.00, 0.41 ],
        [ 28, 0.80, 0.52 ],
        [ 37, 0.90, 0.51 ],
        [ 48, 0.89, 0.50 ],
        [ 145, 0.76, 0.49 ],
        [ 146, 0.63, 0.42 ],
        [ 168, 0.76, 0.42 ],
        [ 169, 0.76, 0.36 ],
        [ 204, 0.70, 0.53 ],
        [ 205, 0.64, 0.44 ],
        [ 282, 0.39, 0.53 ],
        [ 283, 0.44, 0.47 ]
    ];

    var hue2rgb = function hue2rgb(p, q, t){
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    };

    var hslToRgb = function(h, s, l) {
        var r, g, b;

        if(s == 0) {
            r = g = b = l;
        }else{
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }

        return [ r, g, b ];
    };

    editor.method('color:hsl2rgb', hslToRgb);

    var rgbToHex = function(r, g, b) {
        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    };


    var hsl = pallete[0];
    var rgb = hslToRgb(hsl[0] / 360, hsl[1], hsl[2]);

    var colorDefault = {
        data: rgb.slice(0),
        rgb: 'rgb(' + Math.round(rgb[0] * 255) + ', ' + Math.round(rgb[1] * 255) + ', ' + Math.round(rgb[2] * 255) + ')',
        hsl: 'hsl(' + hsl[0] + ', ' + Math.round(hsl[1] * 100) + '%, ' + Math.round(hsl[2] * 100) + '%)',
        hex: rgbToHex(Math.round(rgb[0] * 255), Math.round(rgb[1] * 255), Math.round(rgb[2] * 255))
    };


    editor.on('whoisonline:add', function(id) {
        var hash = id % 14;
        if (Math.floor(hash / 2) !== hash / 2)
            hash = (hash + Math.floor(pallete.length / 2)) % 14;

        var hsl = pallete[hash];
        var rgb = hslToRgb(hsl[0] / 360, hsl[1], hsl[2]);

        users[id] = {
            id: id,
            color: {
                data: rgb.slice(0),
                rgb: 'rgb(' + Math.round(rgb[0] * 255) + ', ' + Math.round(rgb[1] * 255) + ', ' + Math.round(rgb[2] * 255) + ')',
                hsl: 'hsl(' + hsl[0] + ', ' + Math.round(hsl[1] * 100) + '%, ' + Math.round(hsl[2] * 100) + '%)',
                hex: rgbToHex(Math.round(rgb[0] * 255), Math.round(rgb[1] * 255), Math.round(rgb[2] * 255))
            }
        };
    });

    editor.on('whoisonline:remove', function(id) {
        delete users[id];
    });

    editor.method('whoisonline:color', function(id, type) {
        type = type || 'data';
        var color = users[id] && users[id].color || colorDefault;
        return color[type];
    });
});


/* editor/attributes/attributes-panel.js */
editor.once('load', function() {
    'use strict';

    var legacyScripts = editor.call('settings:project').get('useLegacyScripts');
    var title = 'INSPECTOR';
    var root = editor.call('layout.right');
    root.header = title;

    var clearPanel = function() {
        editor.emit('attributes:beforeClear');
        root.clear();
        editor.emit('attributes:clear');
    };

    // clearing
    editor.method('attributes:clear', clearPanel);

    // set header
    editor.method('attributes:header', function(text) {
        root.header = text;
    });

    // return root panel
    editor.method('attributes.rootPanel', function() {
        return root;
    });

    // add panel
    editor.method('attributes:addPanel', function(args) {
        args = args || { };

        // panel
        var panel = new ui.Panel(args.name || '');
        // parent
        (args.parent || root).append(panel);

        // folding
        panel.foldable = args.foldable || args.folded;
        panel.folded = args.folded;

        return panel;
    });

    var historyState = function(item, state) {
        if (item.history !== undefined) {
            if (typeof(item.history) === 'boolean') {
                item.history = state;
            } else {
                item.history.enabled = state;
            }
        } else {
            if (item._parent && item._parent.history !== undefined) {
                item._parent.history.enabled = state;
            }
        }
    };

    editor.method('attributes:linkField', function(args) {
        var update, changeField, changeFieldQueue;
        args.field._changing = false;
        var events = [ ];

        if (! (args.link instanceof Array))
            args.link = [ args.link ];

        update = function() {
            var different = false;
            var value = args.link[0].has(args.path) ? args.link[0].get(args.path) : undefined;
            if (args.type === 'rgb') {
                if (value) {
                    for(var i = 1; i < args.link.length; i++) {
                        if (! value.equals(args.link[i].get(args.path))) {
                            value = null;
                            different = true;
                            break;
                        }
                    }
                }
                if (value) {
                    value = value.map(function(v) {
                        return Math.floor(v * 255);
                    });
                }
            } else if (args.type === 'asset') {
                var countUndefined = value === undefined ? 1 : 0;
                for(var i = 1; i < args.link.length; i++) {
                    if (!args.link[i].has(args.path)) {
                        countUndefined++;
                        continue;
                    }

                    var val = args.link[i].get(args.path);

                    if ((value || 0) !== (args.link[i].get(args.path) || 0)) {
                        if (value !== undefined) {
                            value = args.enum ? '' : null;
                            different = true;
                            break;
                        }
                    }

                    value = val;
                }

                if (countUndefined && countUndefined != args.link.length) {
                    args.field.class.add('star');
                    if (! /^\* /.test(args.field._title.text))
                        args.field._title.text = '* ' + args.field._title.text;
                } else {
                    args.field.class.remove('star');
                    if (/^\* /.test(args.field._title.text))
                        args.field._title.text = args.field._title.text.substring(2);
                }

                if (different) {
                    args.field.class.add('null');
                    args.field._title.text = 'various';
                } else {
                    args.field.class.remove('null');
                }
            } else if (args.type === 'entity' || ! args.type) {
                for(var i = 1; i < args.link.length; i++) {
                    if (value !== args.link[i].get(args.path)) {
                        value = 'various';
                        different = true;
                        break;
                    }
                }
                if (different) {
                    args.field.class.add('null');
                    args.field.text = 'various';
                } else {
                    args.field.class.remove('null');
                }
            } else {
                var valueFound = false;
                for(var i = 0; i < args.link.length; i++) {
                    if (! args.link[i].has(args.path))
                        continue;

                    if (! valueFound) {
                        valueFound = true;
                        value = args.link[i].get(args.path);
                    } else {
                        var v = args.link[i].get(args.path);
                        if ((value || 0) !== (v || 0)) {
                            value = args.enum ? '' : null;
                            different = true;
                            break;
                        }
                    }
                }
            }

            args.field._changing = true;
            args.field.value = value;

            if (args.type === 'checkbox')
                args.field._onLinkChange(value);

            args.field._changing = false;

            if (args.enum) {
                var opt = args.field.optionElements[''];
                if (opt) opt.style.display = value !== '' ? 'none' : '';
            } else {
                args.field.proxy = value == null ? '...' : null;
            }
        };

        changeField = function(value) {
            if (args.field._changing)
                return;

            if (args.enum) {
                var opt = this.optionElements[''];
                if (opt) opt.style.display = value !== '' ? 'none' : '';
            } else {
                this.proxy = value === null ? '...' : null;
            }

            if (args.trim)
                value = value.trim();

            if (args.type === 'rgb') {
                value = value.map(function(v) {
                    return v / 255;
                });
            } else if (args.type === 'asset') {
                args.field.class.remove('null');
            }

            var items = [ ];

            // set link value
            args.field._changing = true;
            if (args.type === "string" && args.trim)
                args.field.value = value;

            for(var i = 0; i < args.link.length; i++) {
                if (! args.link[i].has(args.path)) continue;

                items.push({
                    get: args.link[i].history !== undefined ? args.link[i].history._getItemFn : null,
                    item: args.link[i],
                    value: args.link[i].has(args.path) ? args.link[i].get(args.path) : undefined
                });

                historyState(args.link[i], false);
                args.link[i].set(args.path, value);
                historyState(args.link[i], true);
            }
            args.field._changing = false;

            // history
            if (args.type !== 'rgb' && ! args.slider && ! args.field._stopHistory) {
                editor.call('history:add', {
                    name: args.path,
                    undo: function() {
                        var different = false;
                        for(var i = 0; i < items.length; i++) {
                            var item;
                            if (items[i].get) {
                                item = items[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = items[i].item;
                            }

                            if (! different && items[0].value !== items[i].value)
                                different = true;

                            historyState(item, false);
                            if (items[i].value === undefined)
                                item.unset(args.path);
                            else
                                item.set(args.path, items[i].value);
                            historyState(item, true);
                        }

                        if (different) {
                            args.field.class.add('null');
                        } else {
                            args.field.class.remove('null');
                        }
                    },
                    redo: function() {
                        for(var i = 0; i < items.length; i++) {
                            var item;
                            if (items[i].get) {
                                item = items[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = items[i].item;
                            }

                            historyState(item, false);
                            if (value === undefined)
                                item.unset(args.path);
                            else
                                item.set(args.path, value);
                            item.set(args.path, value);
                            historyState(item, true);
                        }

                        args.field.class.remove('null');
                    }
                });
            }
        };

        changeFieldQueue = function() {
            if (args.field._changing)
                return;

            args.field._changing = true;
            setTimeout(function() {
                args.field._changing = false;
                update();
            }, 0);
        };

        var historyStart, historyEnd;

        if (args.type === 'rgb' || args.slider) {
            historyStart = function() {
                var items = [ ];

                for(var i = 0; i < args.link.length; i++) {
                    var v = args.link[i].get(args.path);
                    if (v instanceof Array)
                        v = v.slice(0);

                    items.push({
                        get: args.link[i].history !== undefined ? args.link[i].history._getItemFn : null,
                        item: args.link[i],
                        value: v
                    });
                }

                return items;
            };

            historyEnd = function(items, value) {
                // history
                editor.call('history:add', {
                    name: args.path,
                    undo: function() {
                        for(var i = 0; i < items.length; i++) {
                            var item;
                            if (items[i].get) {
                                item = items[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = items[i].item;
                            }

                            historyState(item, false);
                            item.set(args.path, items[i].value);
                            historyState(item, true);
                        }
                    },
                    redo: function() {
                        for(var i = 0; i < items.length; i++) {
                            var item;
                            if (items[i].get) {
                                item = items[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = items[i].item;
                            }

                            historyState(item, false);
                            item.set(args.path, value);
                            historyState(item, true);
                        }
                    }
                });
            };
        }

        if (args.type === 'rgb') {
            var colorPickerOn = false;
            events.push(args.field.on('click', function() {
                colorPickerOn = true;

                // set picker color
                editor.call('picker:color', args.field.value);

                var items = [ ];

                // picking starts
                var evtColorPickStart = editor.on('picker:color:start', function() {
                    items = historyStart();
                });

                // picked color
                var evtColorPick = editor.on('picker:color', function(color) {
                    args.field.value = color;
                });

                var evtColorPickEnd = editor.on('picker:color:end', function() {
                    historyEnd(items.slice(0), args.field.value.map(function(v) {
                        return v / 255;
                    }));
                });

                // position picker
                var rectPicker = editor.call('picker:color:rect');
                var rectField = args.field.element.getBoundingClientRect();
                editor.call('picker:color:position', rectField.left - rectPicker.width, rectField.top);

                // color changed, update picker
                var evtColorToPicker = args.field.on('change', function() {
                    editor.call('picker:color:set', this.value);
                });

                // picker closed
                editor.once('picker:color:close', function() {
                    evtColorPick.unbind();
                    evtColorPickStart.unbind();
                    evtColorPickEnd.unbind();
                    evtColorToPicker.unbind();
                    colorPickerOn = false;
                    args.field.element.focus();
                });
            }));

            // close picker if field destroyed
            args.field.once('destroy', function() {
                if (colorPickerOn)
                    editor.call('picker:color:close');
            });
        } else if (args.slider) {
            var sliderRecords;

            events.push(args.field.on('start', function() {
                sliderRecords = historyStart();
            }));

            events.push(args.field.on('end', function() {
                historyEnd(sliderRecords.slice(0), args.field.value);
            }));
        }

        update();
        events.push(args.field.on('change', changeField));

        for(var i = 0; i < args.link.length; i++) {
            events.push(args.link[i].on(args.path + ':set', changeFieldQueue));
            events.push(args.link[i].on(args.path + ':unset', changeFieldQueue));
        }

        events.push(args.field.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();
        }));

        return events;
    });

    // add field
    editor.method('attributes:addField', function(args) {
        var panel = args.panel;

        if (! panel) {
            panel = new ui.Panel();
            panel.flexWrap = 'nowrap';
            panel.WebkitFlexWrap = 'nowrap';
            panel.style.display = '';

            if (args.type) {
                panel.class.add('field-' + args.type);
            } else {
                panel.class.add('field');
            }

            (args.parent || root).append(panel);
        }

        if (args.name) {
            var label = new ui.Label({
                text: args.name
            });
            label.class.add('label-field');
            panel._label = label;
            panel.append(label);

            if (args.reference) {
                var tooltip = label._tooltip = editor.call('attributes:reference', {
                    element: label.element,
                    title: args.reference.title,
                    subTitle: args.reference.subTitle,
                    description: args.reference.description
                });

                tooltip.attach({
                    target: label,
                    element: label.element
                });
            }
        }

        var field;

        args.linkEvents = [ ];

        var linkField = args.linkField = function() {
            if (args.link) {
                var link = function(field, path) {
                    args.linkEvents = args.linkEvents.concat(editor.call('attributes:linkField', {
                        field: field,
                        path: path || args.path,
                        type: args.type,
                        slider: args.slider,
                        enum: args.enum,
                        link: args.link,
                        trim: args.trim
                    }));
                };
                if (field instanceof Array) {
                    for(var i = 0; i < field.length; i++) {
                        link(field[i], args.path + '.' + i);
                    }
                } else {
                    link(field);
                }
            }
        };

        var unlinkField = args.unlinkField = function() {
            for(var i = 0; i < args.linkEvents.length; i++)
                args.linkEvents[i].unbind();

            args.linkEvents = [ ];
        };

        switch(args.type) {
            case 'string':
                if (args.enum) {
                    field = new ui.SelectField({
                        options: args.enum
                    });
                } else {
                    field = new ui.TextField();
                }

                field.value = args.value || '';
                field.flexGrow = 1;

                if (args.placeholder)
                    field.placeholder = args.placeholder;

                linkField();

                panel.append(field);
                break;

            case 'strings':
                var innerPanel = new ui.Panel();

                field = new ui.TextField();
                field.blurOnEnter = false;
                field.renderChanges = false;
                innerPanel.append(field);

                field.element.addEventListener('keydown', function(evt) {
                    if (evt.keyCode !== 13 || ! field.value)
                        return;

                    addTag(field.value.trim());
                    field.value = '';
                });

                var btnAdd = new ui.Button({
                    text: '&#57632'
                });
                btnAdd.flexGrow = 0;
                btnAdd.on('click', function() {
                    if (! field.value)
                        return;

                    addTag(field.value.trim());
                    field.value = '';
                });
                innerPanel.append(btnAdd);

                var tagsPanel = new ui.Panel();
                tagsPanel.class.add('tags');
                tagsPanel.flex = true;
                innerPanel.append(tagsPanel);

                var tagItems = { };
                var tagIndex = { };
                var tagList = [ ];

                var onRemoveClick = function() {
                    if (innerPanel.disabled)
                        return;

                    removeTag(this.tag);
                };

                var removeTag = function(tag) {
                    if (! tag || ! tagIndex.hasOwnProperty(tag))
                        return;

                    var records = [ ];

                    for(var i = 0; i < args.link.length; i++) {
                        if (args.link[i].get(args.path).indexOf(tag) === -1)
                            continue;

                        records.push({
                            get: args.link[i].history !== undefined ? args.link[i].history._getItemFn : null,
                            item: args.link[i],
                            path: args.path,
                            value: tag
                        });

                        historyState(args.link[i], false);
                        args.link[i].removeValue(args.path, tag);
                        historyState(args.link[i], true);
                    }

                    editor.call('history:add', {
                        name: args.path,
                        undo: function() {
                            for(var i = 0; i < records.length; i++) {
                                var item;
                                if (records[i].get) {
                                    item = records[i].get();
                                    if (! item)
                                        continue;
                                } else {
                                    item = records[i].item;
                                }

                                historyState(item, false);
                                item.insert(records[i].path, records[i].value);
                                historyState(item, true);
                            }
                        },
                        redo: function() {
                            for(var i = 0; i < records.length; i++) {
                                var item;
                                if (records[i].get) {
                                    item = records[i].get();
                                    if (! item)
                                        continue;
                                } else {
                                    item = records[i].item;
                                }

                                historyState(item, false);
                                item.removeValue(records[i].path, records[i].value);
                                historyState(item, true);
                            }
                        }
                    });
                };

                var addTag = function(tag) {
                    var records = [ ];

                    for(var i = 0; i < args.link.length; i++) {
                        if (args.link[i].get(args.path).indexOf(tag) !== -1)
                            continue;

                        records.push({
                            get: args.link[i].history !== undefined ? args.link[i].history._getItemFn : null,
                            item: args.link[i],
                            path: args.path,
                            value: tag
                        });

                        historyState(args.link[i], false);
                        args.link[i].insert(args.path, tag);
                        historyState(args.link[i], true);
                    }

                    editor.call('history:add', {
                        name: args.path,
                        undo: function() {
                            for(var i = 0; i < records.length; i++) {
                                var item;
                                if (records[i].get) {
                                    item = records[i].get();
                                    if (! item)
                                        continue;
                                } else {
                                    item = records[i].item;
                                }

                                historyState(item, false);
                                item.removeValue(records[i].path, records[i].value);
                                historyState(item, true);
                            }
                        },
                        redo: function() {
                            for(var i = 0; i < records.length; i++) {
                                var item;
                                if (records[i].get) {
                                    item = records[i].get();
                                    if (! item)
                                        continue;
                                } else {
                                    item = records[i].item;
                                }

                                historyState(item, false);
                                item.insert(records[i].path, records[i].value);
                                historyState(item, true);
                            }
                        }
                    });
                };

                var onInsert = function(tag) {
                    if (! tagIndex.hasOwnProperty(tag)) {
                        tagIndex[tag] = 0;
                        tagList.push(tag);
                    }

                    tagIndex[tag]++;
                    insertElement(tag);
                };

                var onRemove = function(tag) {
                    if (! tagIndex[tag])
                        return;

                    tagIndex[tag]--;

                    if (! tagIndex[tag]) {
                        tagsPanel.innerElement.removeChild(tagItems[tag]);
                        var ind = tagList.indexOf(tag);
                        if (ind !== -1)
                            tagList.splice(ind, 1);

                        delete tagItems[tag];
                        delete tagIndex[tag];
                    } else {
                        if (tagIndex[tag] === args.link.length) {
                            tagItems[tag].classList.remove('partial');
                        } else {
                            tagItems[tag].classList.add('partial');
                        }
                    }
                };

                var insertElement = function(tag) {
                    if (! tagItems[tag]) {
                        sortTags();

                        var item = document.createElement('div');
                        tagItems[tag] = item;
                        item.classList.add('tag');
                        item.textContent = tag;

                        var icon = document.createElement('span');
                        icon.innerHTML = '&#57650;';
                        icon.classList.add('icon');
                        icon.tag = tag;
                        icon.addEventListener('click', onRemoveClick, false);
                        item.appendChild(icon);

                        var ind = tagList.indexOf(tag);
                        if (tagItems[tagList[ind + 1]]) {
                            tagsPanel.appendBefore(item, tagItems[tagList[ind + 1]]);
                        } else {
                            tagsPanel.append(item);
                        }
                    }

                    if (tagIndex[tag] === args.link.length) {
                        tagItems[tag].classList.remove('partial');
                    } else {
                        tagItems[tag].classList.add('partial');
                    }
                };

                var sortTags = function() {
                    tagList.sort(function(a, b) {
                        if (a > b) {
                            return 1;
                        } else if (a < b) {
                            return -1;
                        } else {
                            return 0;
                        }
                    });
                };

                if (args.placeholder)
                    field.placeholder = args.placeholder;

                // list
                args.linkEvents = [ ];

                args.linkField = function() {
                    if (args.link) {
                        if (! (args.link instanceof Array))
                            args.link = [ args.link ];

                        for(var i = 0; i < args.link.length; i++) {
                            var tags = args.link[i].get(args.path);

                            args.linkEvents.push(args.link[i].on(args.path + ':insert', onInsert));
                            args.linkEvents.push(args.link[i].on(args.path + ':remove', onRemove));

                            if (! tags)
                                continue;

                            for(var t = 0; t < tags.length; t++) {
                                if (! tags[t])
                                    continue;

                                if (! tagIndex.hasOwnProperty(tags[t])) {
                                    tagIndex[tags[t]] = 0;
                                    tagList.push(tags[t]);
                                }

                                tagIndex[tags[t]]++;
                            }
                        }
                    }

                    sortTags();

                    for(var i = 0; i < tagList.length; i++)
                        insertElement(tagList[i]);
                };

                args.unlinkField = function() {
                    for(var i = 0; i < args.linkEvents.length; i++)
                        args.linkEvents[i].unbind();

                    args.linkEvents = [ ];

                    for(var key in tagItems)
                        tagsPanel.innerElement.removeChild(tagItems[key]);

                    tagList = [ ];
                    tagIndex = { };
                    tagItems = { };
                };

                args.linkField();

                panel.once('destroy', args.unlinkField);

                panel.append(innerPanel);
                break;

            case 'text':
                field = new ui.TextAreaField();

                field.value = args.value || '';
                field.flexGrow = 1;

                if (args.placeholder)
                    field.placeholder = args.placeholder;

                linkField();

                panel.append(field);
                break;

            case 'number':
                if (args.enum) {
                    field = new ui.SelectField({
                        options: args.enum,
                        type: 'number'
                    });
                } else if (args.slider) {
                    field = new ui.Slider();
                } else {
                    field = new ui.NumberField();
                }

                field.value = args.value || 0;
                field.flexGrow = 1;
                if (args.placeholder)
                    field.placeholder = args.placeholder;

                if (args.precision != null)
                    field.precision = args.precision;

                if (args.step != null)
                    field.step = args.step;

                if (args.min != null)
                    field.min = args.min;

                if (args.max != null)
                    field.max = args.max;

                linkField();

                panel.append(field);
                break;

            case 'checkbox':
                if (args.enum) {
                    field = new ui.SelectField({
                        options: args.enum,
                        type: 'boolean'
                    });
                    field.flexGrow = 1;
                } else {
                    field = new ui.Checkbox();
                }

                field.value = args.value || 0;
                field.class.add('tick');

                linkField();

                panel.append(field);
                break;

            case 'vec2':
            case 'vec3':
            case 'vec4':
                var channels = parseInt(args.type[3], 10);
                field = [ ];

                for(var i = 0; i < channels; i++) {
                    field[i] = new ui.NumberField();
                    field[i].flexGrow = 1;
                    field[i].style.width = '24px';
                    field[i].value = (args.value && args.value[i]) || 0;
                    panel.append(field[i]);

                    if (args.placeholder)
                        field[i].placeholder = args.placeholder[i];

                    if (args.precision != null)
                        field[i].precision = args.precision;

                    if (args.step != null)
                        field[i].step = args.step;

                    if (args.min != null)
                        field[i].min = args.min;

                    if (args.max != null)
                        field[i].max = args.max;

                    // if (args.link)
                    //     field[i].link(args.link, args.path + '.' + i);
                }

                linkField();
                break;

            case 'rgb':
                field = new ui.ColorField();

                linkField();

                var colorPickerOn = false;
                field.on('click', function() {
                    colorPickerOn = true;
                    var first = true;

                    // set picker color
                    editor.call('picker:color', field.value);

                    // picking starts
                    var evtColorPickStart = editor.on('picker:color:start', function() {
                        first = true;
                    });

                    // picked color
                    var evtColorPick = editor.on('picker:color', function(color) {
                        first = false;
                        field.value = color;
                    });

                    // position picker
                    var rectPicker = editor.call('picker:color:rect');
                    var rectField = field.element.getBoundingClientRect();
                    editor.call('picker:color:position', rectField.left - rectPicker.width, rectField.top);

                    // color changed, update picker
                    var evtColorToPicker = field.on('change', function() {
                        editor.call('picker:color:set', this.value);
                    });

                    // picker closed
                    editor.once('picker:color:close', function() {
                        evtColorPick.unbind();
                        evtColorPickStart.unbind();
                        evtColorToPicker.unbind();
                        colorPickerOn = false;
                        field.element.focus();
                    });
                });

                // close picker if field destroyed
                field.on('destroy', function() {
                    if (colorPickerOn)
                        editor.call('picker:color:close');
                });

                panel.append(field);
                break;

            case 'asset':
                field = new ui.ImageField({
                    canvas: args.kind === 'material' || args.kind === 'model' || args.kind === 'cubemap' || args.kind === 'font'
                });
                var evtPick;

                label.renderChanges = false;
                field._label = label;

                label.style.width = '32px';
                label.flexGrow = 1;

                var panelFields = document.createElement('div');
                panelFields.classList.add('top');

                var panelControls = document.createElement('div');
                panelControls.classList.add('controls');

                var fieldTitle = field._title = new ui.Label();
                fieldTitle.text = 'Empty';
                fieldTitle.parent = panel;
                fieldTitle.flexGrow = 1;
                fieldTitle.placeholder = '...';

                var btnEdit = new ui.Button({
                    text: '&#57648;'
                });
                btnEdit.disabled = true;
                btnEdit.parent = panel;
                btnEdit.flexGrow = 0;

                var btnRemove = new ui.Button({
                    text: '&#57650;'
                });
                btnRemove.disabled = true;
                btnRemove.parent = panel;
                btnRemove.flexGrow = 0;

                fieldTitle.on('click', function() {
                    var asset = editor.call('assets:get', field.value);
                    editor.call('picker:asset', args.kind, asset);

                    evtPick = editor.once('picker:asset', function(asset) {
                        var oldValues = { };
                        if (args.onSet && args.link && args.link instanceof Array) {
                            for(var i = 0; i < args.link.length; i++) {
                                var id = 0;
                                if (args.link[i]._type === 'asset') {
                                    id = args.link[i].get('id');
                                } else if (args.link[i]._type === 'entity') {
                                    id = args.link[i].get('resource_id');
                                } else {
                                    continue;
                                }

                                oldValues[id] = args.link[i].get(args.path);
                            }
                        }

                        field.emit('beforechange', asset.get('id'));
                        field.value = asset.get('id');
                        evtPick = null;
                        if (args.onSet) args.onSet(asset, oldValues);
                    });

                    editor.once('picker:asset:close', function() {
                        if (evtPick) {
                            evtPick.unbind();
                            evtPick = null;
                        }
                        field.element.focus();
                    });
                });

                field.on('click', function() {
                    if (! this.value)
                        return;

                    var asset = editor.call('assets:get', this.value);
                    if (! asset) return;
                    editor.call('selector:set', 'asset', [ asset ]);

                    if (legacyScripts && asset.get('type') === 'script') {
                        editor.call('assets:panel:currentFolder', 'scripts');
                    } else {
                        var path = asset.get('path');
                        if (path.length) {
                            editor.call('assets:panel:currentFolder', editor.call('assets:get', path[path.length - 1]));
                        } else {
                            editor.call('assets:panel:currentFolder', null);
                        }
                    }
                });
                btnEdit.on('click', function() {
                    field.emit('click');
                });

                btnRemove.on('click', function() {
                    field.emit('beforechange', null);
                    field.value = null;
                });

                var watch = null;
                var watchAsset = null;
                var renderQueued;
                var queueRender;

                var evtThumbnailChange;
                var updateThumbnail = function(empty) {
                    var asset = editor.call('assets:get', field.value);

                    if (watch) {
                        editor.call('assets:' + watchAsset.get('type') + ':unwatch', watchAsset, watch);
                        watchAsset = watch = null;
                    }

                    if (empty) {
                        field.image = '';
                    } else if (! asset) {
                        field.image = config.url.home + '/editor/scene/img/asset-placeholder-texture.png';
                    } else {
                        if (asset.has('thumbnails.m')) {
                            var src = asset.get('thumbnails.m');
                            if (src.startsWith('data:image/png;base64')) {
                                field.image = asset.get('thumbnails.m');
                            } else {
                                field.image = config.url.home + asset.get('thumbnails.m') + '?t=' + asset.get('file.hash');
                            }
                        } else {
                            field.image = '/editor/scene/img/asset-placeholder-' + asset.get('type') + '.png';
                        }

                        if (args.kind === 'material' || args.kind === 'model' || args.kind === 'cubemap' || args.kind == 'font') {
                            watchAsset = asset;
                            watch = editor.call('assets:' + args.kind + ':watch', {
                                asset: watchAsset,
                                autoLoad: true,
                                callback: queueRender
                            });
                        }
                    }

                    if (queueRender)
                        queueRender();
                };

                if (args.kind === 'material' || args.kind === 'model' || args.kind === 'font') {
                    field.elementImage.classList.add('flipY');

                    var renderPreview = function() {
                        renderQueued = false;

                        var ctx = field.elementImage.ctx;
                        if (! ctx)
                            ctx = field.elementImage.ctx = field.elementImage.getContext('2d');

                        if (watchAsset) {
                            // render
                            var imageData = editor.call('preview:render', watchAsset, 128, 128);
                            if (! imageData) return;

                            field.elementImage.width = imageData.width;
                            field.elementImage.height = imageData.height;

                            ctx.putImageData(imageData, 0, 0);
                        } else {
                            ctx.clearRect(0, 0, field.elementImage.width, field.elementImage.height);
                        }
                    };

                    renderPreview();

                    queueRender = function() {
                        if (renderQueued) return;
                        renderQueued = true;
                        requestAnimationFrame(renderPreview);
                    };

                    var evtSceneSettings = editor.on('preview:scene:changed', queueRender);

                    field.once('destroy', function() {
                        evtSceneSettings.unbind();
                        evtSceneSettings = null;

                        if (watch) {
                            editor.call('assets:' + watchAsset.get('type') + ':unwatch', watchAsset, watch);
                            watchAsset = watch = null;
                        }
                    });
                } else if (args.kind === 'cubemap') {
                    field.elementImage.width = 60;
                    field.elementImage.height = 60;

                    var positions = [ [ 30, 22 ], [ 0, 22 ], [ 15, 7 ], [ 15, 37 ], [ 15, 22 ], [ 45, 22 ] ];
                    var images = [ null, null, null, null, null, null ];

                    var renderPreview = function() {
                        renderQueued = false;

                        var ctx = field.elementImage.ctx;
                        if (! ctx)
                            ctx = field.elementImage.ctx = field.elementImage.getContext('2d');

                        ctx.clearRect(0, 0, field.elementImage.width, field.elementImage.height);

                        if (watchAsset) {
                            for(var i = 0; i < 6; i++) {
                                var id = watchAsset.get('data.textures.' + i);
                                var image = null;

                                if (id) {
                                    var texture = editor.call('assets:get', id);
                                    if (texture) {
                                        var hash = texture.get('file.hash');
                                        if (images[i] && images[i].hash === hash) {
                                            image = images[i];
                                        } else {
                                            var url = texture.get('thumbnails.s');

                                            if (images[i])
                                                images[i].onload = null;

                                            images[i] = null;

                                            if (url) {
                                                image = images[i] = new Image();
                                                image.hash = hash;
                                                image.onload = queueRender;
                                                image.src = url + '?t=' + hash;
                                            }
                                        }
                                    } else if (images[i]) {
                                        images[i].onload = null;
                                        images[i] = null;
                                    }
                                } else if (images[i]) {
                                    images[i].onload = null;
                                    images[i] = null;
                                }

                                if (image) {
                                    ctx.drawImage(image, positions[i][0], positions[i][1], 15, 15);
                                } else {
                                    ctx.beginPath();
                                    ctx.rect(positions[i][0], positions[i][1], 15, 15);
                                    ctx.fillStyle = '#000';
                                    ctx.fill();
                                }
                            }
                        }
                    };

                    renderPreview();

                    queueRender = function() {
                        if (renderQueued) return;
                        renderQueued = true;
                        requestAnimationFrame(renderPreview);
                    };

                    field.once('destroy', function() {
                        if (watch) {
                            editor.call('assets:cubemap:unwatch', watchAsset, watch);
                            watchAsset = watch = null;
                        }
                    });
                }

                linkField();

                var updateField = function() {
                    var value = field.value;

                    fieldTitle.text = field.class.contains('null') ? 'various' : 'Empty';

                    btnEdit.disabled = ! value;
                    btnRemove.disabled = ! value && ! field.class.contains('null');

                    if (evtThumbnailChange) {
                        evtThumbnailChange.unbind();
                        evtThumbnailChange = null;
                    }

                    if (! value) {
                        if (field.class.contains('star'))
                            fieldTitle.text = '* ' + fieldTitle.text;

                        field.empty = true;
                        updateThumbnail(true);

                        return;
                    }

                    field.empty = false;

                    var asset = editor.call('assets:get', value);

                    if (! asset)
                        return updateThumbnail();

                    evtThumbnailChange = asset.on('file.hash.m:set', updateThumbnail);
                    updateThumbnail();

                    fieldTitle.text = asset.get('name');

                    if (field.class.contains('star'))
                        fieldTitle.text = '* ' + fieldTitle.text;
                };
                field.on('change', updateField);

                if (args.value)
                    field.value = args.value;

                updateField();

                var dropRef = editor.call('drop:target', {
                    ref: panel.element,
                    filter: function(type, data) {
                        var rectA = root.innerElement.getBoundingClientRect();
                        var rectB = panel.element.getBoundingClientRect();
                        return data.id && (args.kind === '*' || type === 'asset.' + args.kind) && parseInt(data.id, 10) !== field.value && ! editor.call('assets:get', parseInt(data.id, 10)).get('source') && rectB.top > rectA.top && rectB.bottom < rectA.bottom;
                    },
                    drop: function(type, data) {
                        if ((args.kind !== '*' && type !== 'asset.' + args.kind) || editor.call('assets:get', parseInt(data.id, 10)).get('source'))
                            return;

                        var oldValues = { };
                        if (args.onSet && args.link && args.link instanceof Array) {
                            for(var i = 0; i < args.link.length; i++) {
                                var id = 0;
                                if (args.link[i]._type === 'asset') {
                                    id = args.link[i].get('id');
                                } else if (args.link[i]._type === 'entity') {
                                    id = args.link[i].get('resource_id');
                                } else {
                                    continue;
                                }

                                oldValues[id] = args.link[i].get(args.path);
                            }
                        }

                        field.emit('beforechange', parseInt(data.id, 10));
                        field.value = parseInt(data.id, 10);

                        if (args.onSet) {
                            var asset = editor.call('assets:get', parseInt(data.id, 10));
                            if (asset) args.onSet(asset, oldValues);
                        }
                    },
                    over: function(type, data) {
                        if (args.over)
                            args.over(type, data);
                    },
                    leave: function() {
                        if (args.leave)
                            args.leave();
                    }
                });
                field.on('destroy', function() {
                    dropRef.unregister();
                    if (evtThumbnailChange) {
                        evtThumbnailChange.unbind();
                        evtThumbnailChange = null;
                    }
                });

                // thumbnail
                panel.append(field);
                // right side
                panel.append(panelFields);
                // controls
                panelFields.appendChild(panelControls);
                // label
                panel.innerElement.removeChild(label.element);
                panelControls.appendChild(label.element);
                panelControls.classList.remove('label-field');
                // edit
                panelControls.appendChild(btnEdit.element);
                // remove
                panelControls.appendChild(btnRemove.element);

                // title
                panelFields.appendChild(fieldTitle.element);
                break;

            // entity picker
            case 'entity':
                field = new ui.Label();
                field.class.add('add-entity');
                field.flexGrow = 1;
                field.class.add('null');

                field.text = 'Select Entity';
                field.placeholder = '...';

                panel.append(field);

                var icon = document.createElement('span');
                icon.classList.add('icon');

                icon.addEventListener('click', function (e) {
                    e.stopPropagation();

                    if (editor.call('permissions:write'))
                        field.text = '';
                });

                field.on('change', function (value) {
                    if (value) {
                        var entity = editor.call('entities:get', value);
                        if (!entity) {
                            field.text = null;
                            return;
                        }

                        field.element.innerHTML = entity.get('name');
                        field.element.appendChild(icon);
                        field.placeholder = '';

                        if (value !== 'various')
                            field.class.remove('null');
                    } else {
                        field.element.innerHTML = 'Select Entity';
                        field.placeholder = '...';
                        field.class.add('null');
                    }
                });

                linkField();

                var getCurrentEntity = function () {
                    var entity = null;
                    if (args.link) {
                        if (! (args.link instanceof Array)) {
                            args.link = [args.link];
                        }

                        // get initial value only if it's the same for all
                        // links otherwise set it to null
                        for (var i = 0, len = args.link.length; i < len; i++) {
                            var val = args.link[i].get(args.path);
                            if (entity !== val) {
                                if (entity) {
                                    entity = null;
                                    break;
                                } else {
                                    entity = val;
                                }
                            }
                        }
                    }

                    return entity;
                };

                field.on('click', function () {
                    var evtEntityPick = editor.once('picker:entity', function (entity) {
                        field.text = entity ? entity.get('resource_id') : null;
                        evtEntityPick = null;
                    });

                    var initialValue = getCurrentEntity();

                    editor.call('picker:entity', initialValue, args.filter || null);

                    editor.once('picker:entity:close', function () {
                        if (evtEntityPick) {
                            evtEntityPick.unbind();
                            evtEntityPick = null;
                        }
                    });
                });

                // highlight on hover
                field.on('hover', function () {
                    var entity = getCurrentEntity();
                    if (! entity) return;

                    editor.call('entities:panel:highlight', entity, true);

                    field.once('blur', function () {
                        editor.call('entities:panel:highlight', entity, false);
                    });

                    field.once('click', function () {
                        editor.call('entities:panel:highlight', entity, false);
                    });
                });

                var dropRef = editor.call('drop:target', {
                    ref: field.element,
                    filter: function(type, data) {
                        var rectA = root.innerElement.getBoundingClientRect();
                        var rectB = field.element.getBoundingClientRect();
                        return type === 'entity' && data.resource_id !== field.value && rectB.top > rectA.top && rectB.bottom < rectA.bottom;
                    },
                    drop: function(type, data) {
                        if (type !== 'entity')
                            return;

                        field.value = data.resource_id;
                    },
                    over: function(type, data) {
                        if (args.over)
                            args.over(type, data);
                    },
                    leave: function() {
                        if (args.leave)
                            args.leave();
                    }
                });
                field.on('destroy', function() {
                    dropRef.unregister();
                });

                break;
            case 'image':
                panel.flex = false;

                field = new Image();
                field.style.maxWidth = '100%';
                field.style.display = 'block';
                field.src = args.src;

                panel.append(field);
                break;

            case 'progress':
                field = new ui.Progress();
                field.flexGrow = 1;

                panel.append(field);
                break;

            case 'code':
                field = new ui.Code();
                field.flexGrow = 1;

                if (args.value)
                    field.text = args.value;

                panel.append(field);
                break;

            case 'button':
                field = new ui.Button();
                field.flexGrow = 1;
                field.text = args.text || 'Button';
                panel.append(field);
                break;

            case 'element':
                field = args.element;
                panel.append(field);
                break;

            case 'curveset':
                field = new ui.CurveField(args);
                field.flexGrow = 1;
                field.text = args.text || '';

                if (args.link) {
                    var link = args.link;
                    if (args.link instanceof Array)
                        link = args.link[0];

                    field.link(link, args.paths || [args.path]);
                }

                var curvePickerOn = false;

                var toggleCurvePicker = function () {
                    if (!field.class.contains('disabled') && !curvePickerOn) {
                        editor.call('picker:curve', field.value, args);

                        curvePickerOn = true;

                        // position picker
                        var rectPicker = editor.call('picker:curve:rect');
                        var rectField = field.element.getBoundingClientRect();
                        editor.call('picker:curve:position', rectField.right - rectPicker.width, rectField.bottom);

                        args.keepZoom = false;

                        var combine = false;

                        var evtChangeStart = editor.on('picker:curve:change:start', function () {
                            combine = true;
                        });

                        var evtChangeEnd = editor.on('picker:curve:change:end', function () {
                            combine = false;
                        });

                        var evtPickerChanged = editor.on('picker:curve:change', function (paths, values) {
                            if (! field._link) return;

                            var previous = {
                                paths: [],
                                values: []
                            };

                            var path;
                            for (var i = 0, len = paths.length; i < len; i++) {
                                if (args.paths) {
                                    path = args.paths[parseInt(paths[i][0])] + paths[i].substring(1);
                                } else {
                                    path = args.path + paths[i].substring(1);
                                }

                                previous.paths.push(path);
                                previous.values.push(field._link.get(path));
                            }


                            var undo = function () {
                                if (! field._link)
                                    return;

                                args.keepZoom = true;

                                var history = false;
                                if (field._link.history) {
                                    history = field._link.history.enabled;
                                    field._link.history.enabled = false;
                                }

                                for (var i = 0, len = previous.paths.length; i < len; i++) {
                                    field._link.set(previous.paths[i], previous.values[i]);
                                }

                                if (field._link.history)
                                    field._link.history.enabled = history;

                                args.keepZoom = false;
                            };

                            var redo = function () {
                                if (! field._link)
                                    return;

                                args.keepZoom = true;

                                var history = false;
                                if (field._link.history) {
                                    history = field._link.history.enabled;
                                    field._link.history.enabled = false;
                                }

                                for (var i = 0, len = paths.length; i < len; i++) {
                                    if (args.paths) {
                                        path = args.paths[parseInt(paths[i][0])] + paths[i].substring(1);
                                    } else {
                                        path = args.path + paths[i].substring(1);
                                    }

                                    field._link.set(path, values[i]);
                                }

                                if (field._link.history)
                                    field._link.history.enabled = history;

                                args.keepZoom = false;
                            };

                            redo();

                            // add custom history event
                            editor.call('history:' + (combine ? 'update' : 'add'), {
                                name: path + '.curves',
                                undo: undo,
                                redo: redo
                            });

                        });

                        var evtRefreshPicker = field.on('change', function (value) {
                            editor.call('picker:curve:set', value, args);
                        });

                        editor.once('picker:curve:close', function () {
                            evtRefreshPicker.unbind();
                            evtPickerChanged.unbind();
                            evtChangeStart.unbind();
                            evtChangeEnd.unbind();
                            curvePickerOn = false;
                        });
                    }
                };

                // open curve editor on click
                field.on('click', toggleCurvePicker);

                // close picker if field destroyed
                field.on('destroy', function() {
                    if (curvePickerOn) {
                        editor.call('picker:curve:close');
                    }
                });

                panel.append(field);
                break;

            default:
                field = new ui.Label();
                field.flexGrow = 1;
                field.text = args.value || '';
                field.class.add('selectable');

                if (args.placeholder)
                    field.placeholder = args.placeholder;

                linkField();

                panel.append(field);
                break;
        }

        return field;
    });

    editor.method('attributes:addAssetsList', function(args) {
        var link = args.link;
        var title = args.title;
        var assetType = args.type;
        var path = args.path;
        var panel = args.panel;
        var events = [ ];

        // assets
        var fieldAssetsList = new ui.List();
        fieldAssetsList.flexGrow = 1;

        fieldAssetsList.on('select', function(item) {
            if (item === itemAdd || ! item.asset)
                return;

            editor.call('selector:set', 'asset', [ item.asset ]);
        });

        // drop
        var dropRef = editor.call('drop:target', {
            ref: fieldAssetsList.element,
            type: 'asset.' + assetType,
            filter: function(type, data) {
                // type
                if ((assetType && assetType !== '*' && type !== 'asset.' + assetType) || ! type.startsWith('asset') || editor.call('assets:get', parseInt(data.id, 10)).get('source'))
                    return false;

                // overflowed
                var rectA = root.innerElement.getBoundingClientRect();
                var rectB = fieldAssetsList.element.getBoundingClientRect();
                if (rectB.top <= rectA.top || rectB.bottom >= rectA.bottom)
                    return false;

                // already added
                var id = parseInt(data.id, 10);
                for(var i = 0; i < link.length; i++) {
                    if (link[i].get(path).indexOf(id) === -1)
                        return true;
                }

                return false;
            },
            drop: function(type, data) {
                if ((assetType && assetType !== '*' && type !== 'asset.' + assetType) || ! type.startsWith('asset') || editor.call('assets:get', parseInt(data.id, 10)).get('source'))
                    return;

                var records = [ ];

                var id = parseInt(data.id, 10);

                for(var i = 0; i < link.length; i++) {
                    if (link[i].get(path).indexOf(id) !== -1)
                        continue;

                    records.push({
                        get: link[i].history !== undefined ? link[i].history._getItemFn : null,
                        item: link[i],
                        path: path,
                        value: id
                    });

                    historyState(link[i], false);
                    link[i].insert(path, id);
                    historyState(link[i], true);
                }

                editor.call('history:add', {
                    name: path,
                    undo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item;
                            if (records[i].get) {
                                item = records[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = records[i].item;
                            }

                            historyState(item, false);
                            item.removeValue(records[i].path, records[i].value);
                            historyState(item, true);
                        }
                    },
                    redo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item;
                            if (records[i].get) {
                                item = records[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = records[i].item;
                            }

                            historyState(item, false);
                            item.insert(records[i].path, records[i].value);
                            historyState(item, true);
                        }
                    }
                });
            }
        });
        dropRef.disabled = panel.disabled;
        panel.on('enable', function() {
            dropRef.disabled = false;
        });
        panel.on('disable', function() {
            dropRef.disabled = true;

            // clear list item
            var items = fieldAssetsList.element.children;
            var i = items.length;
            while(i-- > 1) {
                if (! items[i].ui || ! (items[i].ui instanceof ui.ListItem))
                    continue;

                items[i].ui.destroy();
            }

            assetIndex = { };
        });
        fieldAssetsList.on('destroy', function() {
            dropRef.unregister();
        });

        var fieldAssets = editor.call('attributes:addField', {
            parent: panel,
            name: args.name || 'Assets',
            type: 'element',
            element: fieldAssetsList,
            reference: args.reference
        });
        fieldAssets.class.add('assets');

        // reference assets
        editor.call('attributes:reference:attach', assetType + ':assets', fieldAssets.parent.innerElement.firstChild.ui);

        // assets list
        var itemAdd = new ui.ListItem({
            text: 'Add ' + title
        });
        itemAdd.class.add('add-asset');
        fieldAssetsList.append(itemAdd);

        // add asset icon
        var iconAdd = document.createElement('span');
        iconAdd.classList.add('icon');
        itemAdd.element.appendChild(iconAdd);

        // index list items by asset id
        var assetIndex = { };

        // add asset
        var addAsset = function(assetId, after) {
            assetId = parseInt(assetId, 10);

            var item = assetIndex[assetId];
            if (item) {
                item.count++;
                item.text = (item.count === link.length ? '' : '* ') + item._assetText;
                return;
            }

            var asset = editor.call('assets:get', assetId);
            var text = assetId;
            if (asset && asset.get('name'))
                text = asset.get('name');

            item = new ui.ListItem({
                text: (link.length === 1) ? text : '* ' + text
            });
            item.count = 1;
            item.asset = asset;
            item._assetText = text;

            if (after) {
                fieldAssetsList.appendAfter(item, after);
            } else {
                fieldAssetsList.append(item);
            }

            assetIndex[assetId] = item;

            // remove button
            var btnRemove = new ui.Button();
            btnRemove.class.add('remove');
            btnRemove.on('click', function() {
                var records = [ ];

                for(var i = 0; i < link.length; i++) {
                    var ind = link[i].get(path).indexOf(assetId);
                    if (ind === -1)
                        continue;

                    records.push({
                        get: link[i].history !== undefined ? link[i].history._getItemFn : null,
                        item: link[i],
                        path: path,
                        value: assetId,
                        ind: ind
                    });

                    historyState(link[i], false);
                    link[i].removeValue(path, assetId);
                    historyState(link[i], true);
                }

                editor.call('history:add', {
                    name: path,
                    undo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item;
                            if (records[i].get) {
                                item = records[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = records[i].item;
                            }

                            historyState(item, false);
                            item.insert(records[i].path, records[i].value, records[i].ind);
                            historyState(item, true);
                        }
                    },
                    redo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item;
                            if (records[i].get) {
                                item = records[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = records[i].item;
                            }

                            historyState(item, false);
                            item.removeValue(records[i].path, records[i].value);
                            historyState(item, true);
                        }
                    }
                });
            });
            btnRemove.parent = item;
            item.element.appendChild(btnRemove.element);

            item.once('destroy', function() {
                delete assetIndex[assetId];
            });
        };

        var removeAsset = function(assetId) {
            var item = assetIndex[assetId];

            if (! item)
                return;

            item.count--;

            if (item.count === 0) {
                item.destroy();
                fieldAssets.emit('remove', item);
            } else {
                item.text = (item.count === link.length ? '' : '* ') + item._assetText;
            }
        };

        // on adding new asset
        itemAdd.on('click', function() {
            // call picker
            editor.call('picker:asset', assetType, null);

            // on pick
            var evtPick = editor.once('picker:asset', function(asset) {
                if (legacyScripts && asset.get('type') === 'script')
                    return;

                var records = [ ];
                var assetId = parseInt(asset.get('id'), 10);

                for(var i = 0; i < link.length; i++) {
                    // already in list
                    if (link[i].get(path).indexOf(assetId) !== -1)
                        continue;

                    records.push({
                        get: link[i].history !== undefined ? link[i].history._getItemFn : null,
                        item: link[i],
                        path: path,
                        value: assetId
                    });

                    historyState(link[i], false);
                    link[i].insert(path, assetId);
                    historyState(link[i], true);
                    evtPick = null;
                }

                editor.call('history:add', {
                    name: path,
                    undo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item;
                            if (records[i].get) {
                                item = records[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = records[i].item;
                            }

                            historyState(item, false);
                            item.removeValue(records[i].path, records[i].value);
                            historyState(item, true);
                        }
                    },
                    redo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item;
                            if (records[i].get) {
                                item = records[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = records[i].item;
                            }

                            historyState(item, false);
                            item.insert(records[i].path, records[i].value);
                            historyState(item, true);
                        }
                    }
                });
            });

            editor.once('picker:asset:close', function() {
                if (evtPick) {
                    evtPick.unbind();
                    evtPick = null;
                }
            });
        });

        // list
        for(var i = 0; i < link.length; i++) {
            var assets = link[i].get(path);
            if (assets) {
                for(var a = 0; a < assets.length; a++)
                    addAsset(assets[a]);
            }

            events.push(link[i].on(path + ':set', function(assets, assetsOld) {
                if (! (assets instanceof Array))
                    return;

                if (! (assetsOld instanceof Array))
                    assetsOld = [ ];

                var assetIds = { };
                for(var a = 0; a < assets.length; a++)
                    assetIds[assets[a]] = true;

                var assetOldIds = { };
                for(var a = 0; a < assetsOld.length; a++)
                    assetOldIds[assetsOld[a]] = true;

                // remove
                for(var id in assetOldIds) {
                    if (assetIds[id])
                        continue;

                    removeAsset(id);
                }

                // add
                for(var id in assetIds)
                    addAsset(id);
            }));

            events.push(link[i].on(path + ':insert', function(assetId, ind) {
                var before;
                if (ind === 0) {
                    before = itemAdd;
                } else {
                    before = assetIndex[this.get(path + '.' + ind)];
                }
                addAsset(assetId, before);
            }));

            events.push(link[i].on(path + ':remove', removeAsset));
        }

        fieldAssetsList.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();
        });

        return fieldAssetsList;
    });

    var inspectedItems = [ ];

    editor.on('attributes:clear', function() {
        for(var i = 0; i < inspectedItems.length; i++) {
            inspectedItems[i].unbind();
        }
        inspectedItems = [ ];
    });

    editor.method('attributes:inspect', function(type, item) {
        clearPanel();

        // clear if destroyed
        inspectedItems.push(item.once('destroy', function() {
            editor.call('attributes:clear');
        }));

        root.header = type;
        editor.emit('attributes:inspect[' + type + ']', [ item ]);
        editor.emit('attributes:inspect[*]', type, [ item ]);
    });

    editor.on('selector:change', function(type, items) {
        clearPanel();

        // nothing selected
        if (items.length === 0) {
            var label = new ui.Label({ text: 'Select anything to Inspect' });
            label.style.display = 'block';
            label.style.textAlign = 'center';
            root.append(label);

            root.header = title;

            return;
        }

        // clear if destroyed
        for(var i = 0; i < items.length; i++) {
            inspectedItems.push(items[i].once('destroy', function() {
                editor.call('attributes:clear');
            }));
        }

        root.header = type;
        editor.emit('attributes:inspect[' + type + ']', items);
        editor.emit('attributes:inspect[*]', type, items);
    });

    editor.emit('selector:change', null, [ ]);
});


/* editor/attributes/attributes-history.js */
editor.once('load', function() {
    'use strict';

    var list = [ ];
    var selecting = false;


    var root = editor.call('layout.root');
    var panel = editor.call('layout.right');


    var controls = new ui.Panel();
    controls.class.add('inspector-controls');
    controls.parent = panel;
    panel.headerAppend(controls);


    var selectorReturn = function() {
        var item = getLast();
        if (! item)
            return;

        // remove last one
        list = list.slice(0, list.length - 1);

        selecting = true;
        editor.call('selector:set', item.type, item.items);
        editor.once('selector:change', function() {
            selecting = false;

            updateTooltipContent();
        });
    };
    editor.method('selector:return', selectorReturn);


    var btnBack = new ui.Button({
        text: '&#57649;'
    });
    btnBack.disabledClick = true;
    btnBack.hidden = true;
    btnBack.class.add('back');
    btnBack.on('click', selectorReturn);
    controls.append(btnBack);


    editor.on('selector:change', function(type, items) {
        if (selecting)
            return;

        updateTooltipContent();

        if (! type || ! items)
            return;

        var last = getLast();

        if (last && last.items.length === 1 && items.length === 1 && last.items[0] === items[0])
            return;

        list.push({
            type: type,
            items: items
        });
    });

    var getLast = function() {
        if (! list.length)
            return;

        var ignoreType = editor.call('selector:type');
        var ignore = editor.call('selector:items');

        var i = list.length - 1;
        var candidate = list[i];

        while(candidate && ignoreType && ignoreType === candidate.type && candidate.items.equals(ignore))
            candidate = list[--i];

        return candidate || null;
    };

    var updateTooltipContent = function() {
        var item = getLast();

        if (! item && ! btnBack.hidden) {
            btnBack.hidden = true;
        } else if (item && btnBack.hidden) {
            btnBack.hidden = false;
        }

        if (item && ! tooltip.hidden) {
            if (item.type === 'entity') {
                if (item.items.length === 1) {
                    setTooltipText(item.items[0].get('name') + ' [entity]');
                } else {
                    setTooltipText('[' + item.items.length + ' entities]');
                }
            } else if (item.type === 'asset') {
                if (item.items.length === 1) {
                    setTooltipText(item.items[0].get('name') + ' [' + item.items[0].get('type') + ']');
                } else {
                    setTooltipText('[' + item.items.length + ' assets]');
                }
            } else if (item.type === 'editorSettings') {
                setTooltipText('Settings');
            }
        }
    };


    var tooltip = Tooltip.attach({
        target: btnBack.element,
        text: '-',
        align: 'top',
        root: root
    });
    tooltip.on('show', updateTooltipContent);
    tooltip.class.add('previous-selection');

    btnBack.on('hide', function() {
        tooltip.hidden = true;
    });

    var setTooltipText = function(str) {
        tooltip.html = '<span>Previous Selection</span><br />' + str;
    };


    editor.call('hotkey:register', 'selector:return', {
        key: 'z',
        shift: true,
        callback: selectorReturn
    });
});


/* editor/attributes/attributes-reference.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var panel = editor.call('layout.right');
    var index = { };
    var missing = { };


    var sanitize = function(str) {
        return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    };


    editor.method('attributes:reference:add', function(args) {
        index[args.name] = editor.call('attributes:reference', args);
    });

    editor.method('attributes:reference:attach', function(name, target, element) {
        var tooltip = index[name];

        if (! tooltip) {
            if (! missing[name]) {
                missing[name] = true;
                console.log('reference', name, 'is not defined');
            }
            return;
        }

        tooltip.attach({
            target: target,
            element: element || target.element
        });

        return tooltip;
    });


    editor.method('attributes:reference:template', function(args) {
        var html = '';

        if (args.title)
            html += '<h1>' + sanitize(args.title) + '</h1>';
        if (args.subTitle)
            html += '<h2>' + sanitize(args.subTitle) + '</h2>';
        if (args.webgl2)
            html += '<div class="tag">WebGL 2.0 Only</div>';
        if (args.description) {
            var description = sanitize(args.description);
            description = description.replace(/\n/g, '<br />'); // new lines
            description = description.replace(/&lt;b&gt;/g, '<b>').replace(/&lt;\/b&gt;/g, '</b>'); // bold
            html += '<p>' + description + '</p>';
        }
        if (args.code)
            html += '<pre class="ui-code">' + sanitize(args.code) + '</pre>';
        if (args.url)
            html += '<a class="reference" href="' + sanitize(args.url) + '" target="_blank">API Reference</a>';

        return html;
    });


    editor.method('attributes:reference', function(args) {
        var tooltip = new ui.Tooltip({
            align: 'right'
        });
        tooltip.hoverable = true;
        tooltip.class.add('reference');

        tooltip.html = editor.call('attributes:reference:template', args);

        var links = { };
        var timerHover = null;
        var timerBlur = null;

        tooltip.attach = function(args) {
            var target = args.target;
            var element = args.element;

            var show = function() {
                if (! target || target.hidden) return;
                tooltip.position(panel.element.getBoundingClientRect().left, element.getBoundingClientRect().top + 16);
                tooltip.hidden = false;
            };

            var evtHide = function() {
                clearTimeout(timerHover);
                clearTimeout(timerBlur);
                tooltip.hidden = true;
            };

            var evtHover = function() {
                clearTimeout(timerBlur);
                timerHover = setTimeout(show, 500);
            };

            var evtBlur = function() {
                clearTimeout(timerHover);
                timerBlur = setTimeout(hide, 200);
            };

            var evtClick = function() {
                clearTimeout(timerBlur);
                clearTimeout(timerHover);
                show();
            };

            target.on('hide', evtHide);

            target.once('destroy', function() {
                element.removeEventListener('mouseover', evtHover);
                element.removeEventListener('mouseout', evtBlur);
                element.removeEventListener('click', evtClick);
                target.unbind('hide', evtHide);
                target = null;
                element = null;
                clearTimeout(timerHover);
                clearTimeout(timerBlur);
                tooltip.hidden = true;
            });

            element.addEventListener('mouseover', evtHover, false);
            element.addEventListener('mouseout', evtBlur, false);
            element.addEventListener('click', evtClick, false);
        };

        var hide = function() {
            tooltip.hidden = true;
        };

        tooltip.on('hover', function() {
            clearTimeout(timerBlur);
        });

        root.append(tooltip);

        return tooltip;
    });
});


/* editor/attributes/reference/attributes-settings-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        title: 'name',
        subTitle: '{String}',
        description: 'Name of the Scene for better navigation across content.'
    }, {
        name: 'editor',
        description: 'Editor Settings are applied per user basis and only visible to you, and not team collaborators. Although rest of other sections are shared for the Scene for all collaborators.'
    }, {
        name: 'snap',
        description: 'Change increment value for Snap gizmo state. Use SHIFT or Snap Toggle on toolbar to enable Snapping during use of Gizmos.'
    }, {
        name: 'grid',
        description: 'To disable grid set Divisions to 0. Divisions specify number of grid rectangles in each horizontal direction. And Size specifies the size of a rectangles.'
    }, {
        name: 'cameraClip',
        description: 'If your scene is too large or objects needs to be too close, change Near/Far clip values of a camera for Editor. This setting does not affects the game.'
    }, {
        name: 'clearColor',
        description: 'Set the Camera Clear Color of your preference to affect Editor. This color will not affect the game.'
    }, {
        name: 'iconsSize',
        description: 'Size of icons displayed in Editor viewport',
    }, {
        name: 'localServer',
        description: 'Set a URL to use as the local server. When you click on "Launch Local" all your scripts will be loaded from this URL.'
    }, {
        title: 'gravity',
        subTitle: '{pc.Vec3}',
        description: 'Gravity is the acceleration applied every frame to all rigid bodies in your scene. By default, it is set to -9.8 meters per second per second, which essentially approximates Earth\'s gravity. If you are making a game in space, you might want to set this to 0, 0, 0 (zero g).',
        url: 'http://developer.playcanvas.com/api/pc.RigidBodyComponentSystem.html#setGravity'
    }, {
        title: 'ambientColor',
        subTitle: '{pc.Color}',
        description: 'The color of the scene\'s ambient light source. PlayCanvas allows you to create directional, point and spot lights. These lights account for direct light that falls on objects. But in reality, light actually bounces around the environment and we call this indirect light. A global ambient light is a crude approximation of this and allows you to set a light source that appears to shine from all directions. The global ambient color is multiplied with the Ambient property of a Phong Material to add a contribution to the final color of an object. Note, if you are using a Skybox and Physical Materials the Ambient Color has no effect.',
        url: 'http://developer.playcanvas.com/api/pc.Scene.html#ambientLight'
    }, {
        title: 'skybox',
        subTitle: '{pc.Texture}',
        description: 'The Skybox is a cubemap asset that is rendered behind your 3D scene. This lets your use a set of 6 2D images to display the distant world beyond the 3D models in your scene. To add a skybox, create a cubemap asset and then assign it to the cubemap slot in the settings panel. Note, if you are using a Prefiltered Cubemap, the skybox will be used as the default environment map for all Physical materials.',
        url: 'http://developer.playcanvas.com/api/pc.Scene.html#skybox'
    }, {
        title: 'skyboxIntensity',
        subTitle: '{Number}',
        description: 'Intensity of the skybox to match the exposure levels.',
        url: 'http://developer.playcanvas.com/api/pc.Scene.html#skyboxIntensity'
    }, {
        title: 'skyboxMip',
        subTitle: '{Number}',
        description: 'Mip level of the prefiletered skybox, higher value is lower mip level which is lower resolution and more prefiltered (blured).',
        url: 'http://developer.playcanvas.com/api/pc.Scene.html#skyboxMip'
    }, {
        title: 'toneMapping',
        subTitle: '{Number}',
        description: 'Tonemapping is the process of compressing High Dynamic Range (HDR) colors into limited Low Dynamic Range (e.g. into visible monitor output values). There are two options for tonemapping. Linear: imply scales HDR colors by exposure. Filmic: More sophisticated curve, good at softening overly bright spots, while preserving dark shades as well. Linear tonemapping is active by default, it\'s simply (color * exposure). You can tweak exposure to make quick changes to brightness. Note that it\'s not just simple brightness  la Photoshop because your input can be HDR. e.g. If you have a light source with intensity = 8, it will still be quite bright (4) after exposure = 0.5. So, all visible things won\'t just fade out linearly. Filmic tonemapping is a good choice in high-contrast environments, like scenes lit by bright Sun, or interiors with bright lights being close to walls/ceiling. It will nicely remap out-of-range super bright values to something more perceptually realistic (our eyes and film do tonemapping as well, we don\'t see physically linear values). Well, ask any photographer: nobody likes to leave extremely bright spots as well as pitch black spots on a photo. Filmic tonemapping gives you nice abilities to get rid of such spots.',
        url: 'http://developer.playcanvas.com/api/pc.Scene.html#tomeMapping'
    }, {
        title: 'exposure',
        subTitle: '{Number}',
        description: 'The exposure value tweaks the overall brightness of the scene.',
        url: 'http://developer.playcanvas.com/api/pc.Scene.html#exposure'
    }, {
        title: 'gammaCorrection',
        subTitle: '{pc.GAMMA_*}',
        description: 'Computer screens are set up to output not physically linear, but perceptually linear (sRGB) signal. However, for correct appearance when performing lighting calculations, color textures must be converted to physically linear space, and then the fully lit image must be fit again into sRGB. Rendering with gamma correction enabled reduces the number of ugly, overly saturated highlights and better preserves color after lighting, and it\'s generally recommended that this be enabled in your scene. The following image shows a simple scene with a sphere. On the left the scene has been gamma corrected while on the right, the scene is uncorrected.',
        url: 'http://developer.playcanvas.com/api/pc.Scene.html#gammaCorrection'
    }, {
        title: 'fog',
        subTitle: '{pc.FOG_*}',
        description: 'The Fog Type property can be used to control an approximation of an ambient fog in your scene. Here is an example of fog being enabled: The types available are as follows: None - Fog is disabled Linear - Fog fades in linearly between a Fog Start and Fog End distance Exp - Fog fades in from the view position according to an exponential function Exp2 - Fog fades in from the view position according to an exponential squared function',
        url: 'http://developer.playcanvas.com/api/pc.Scene.html#fog'
    }, {
        title: 'fogDensity',
        subTitle: '{Number}',
        description: 'The fog density controls the rate at which fog fades in for Exp and Exp2 fog types. Larger values cause fog to fade in more quickly. Fog density must be a positive number.',
        url: 'http://developer.playcanvas.com/api/pc.Scene.html#fogDensity'
    }, {
        name: 'fogDistance',
        title: 'fogStart / fogEnd',
        subTitle: '{Number}',
        description: 'The distance in scene units from the viewpoint from where the fog starts to fade in and reaches a maximum. Any objects beyond maximum distance will be rendered with the fog color.',
        url: 'http://developer.playcanvas.com/api/pc.Scene.html#fogEnd'
    }, {
        title: 'fogColor',
        subTitle: '{pc.Color}',
        description: 'The color of the fog. This color is blended with a surface\'s color more as the fog fades in.',
        url: 'http://developer.playcanvas.com/api/pc.Scene.html#fogColor'
    }, {
        name: 'loadingScreenScript',
        title: 'Loading Screen Script',
        description: 'The name of the script to use for creating the loading screen of the application. The script needs to call pc.script.createLoadingScreen.',
        url: 'http://developer.playcanvas.com/en/api/pc.script.html#createLoadingScreen'
    }, {
        name: 'project',
        title: 'Project Settings',
        description: 'Settings that affect the entire Project and not just this Scene.'
    }, {
        name: 'project:width',
        title: 'Resolution Width',
        description: 'The width of your application in pixels.'
    }, {
        name: 'project:height',
        title: 'Resolution Height',
        description: 'The height of your application in pixels.'
    }, {
        name: 'project:fillMode',
        title: 'Fill Mode',
        description: 'Fill Mode decides how the canvas fills the browser window.'
    }, {
        name: 'project:resolutionMode',
        title: 'Resolution Mode',
        description: 'Resolution Mode decides whether the canvas resolution will change when it is resized.'
    }, {
        name: 'project:physics',
        description: 'When enabled the Physics library code is included in your app.'
    }, {
        name: 'project:pixelRatio',
        title: 'Device Pixel Ratio',
        description: 'When enabled the canvas resolution will be calculated including the device pixel ratio. Enabling this might affect performance.'
    }, {
        name: 'project:preferWebGl2',
        title: 'Prefer WebGL 2.0',
        description: 'When enabled (default) application will use WebGL 2.0 if platform supports it.'
    }, {
        name: 'project:antiAlias',
        title: 'Anti-Alias',
        description: 'When disabled, anti-aliasing will be disabled for back-buffer.'
    }, {
        name: 'project:transparentCanvas',
        title: 'Transparent Canvas',
        description: 'When enabled the canvas will blend with the web page.'
    }, {
        name: 'project:preserveDrawingBuffer',
        title: 'Preserve drawing buffer',
        description: 'When enabled the drawing buffer will be preserved until its explicitely cleared. Useful if you want to take screenshots.'
    }, {
        name: 'project:vr',
        title: 'Enable VR',
        description: 'Initialize WebVR specific code in the engine. If device doesnt support WebVR then load additional library to enable support.'
    }, {
        name: 'project:useLegacyAudio',
        title: 'Use Legacy Audio',
        description: 'If checked the old AudioSource component will be available in the Editor otherwise you will only see the new Sound component.'
    }, {
        name: 'asset-tasks',
        title: 'Asset Tasks',
        description: 'Settings for defining default behaviour rules for asset pipeline jobs: assets extracting, textures resizing, etc.'
    }, {
        name: 'asset-tasks:auto',
        title: 'Auto-run',
        description: 'Automatically run the asset import pipeline when you upload a new asset.'
    }, {
        name: 'asset-tasks:texturePot',
        title: 'Texture power of two',
        description: 'When a texture is imported it will be resized to use the nearest power of two resolution.'
    }, {
        name: 'asset-tasks:searchRelatedAssets',
        title: 'Search related assets',
        description: 'If enabled, importing a source asset will update target assets where ever they are located. If disabled, assets will only be updated if they are in the same folder, otherwise new assets will be created.'
    }, {
        name: 'asset-tasks:preserveMapping',
        title: 'Preserve model material mappings',
        description: 'If enabled, after importing an existing source model we will try to preserve the material mappings that were set by the user on the existing model.'
    }, {
        name: 'asset-tasks:useModelV2',
        title: 'Force legacy model v2',
        description: 'Create model assets in legacy format (V2). Enable this for compatibility with older model imports.'
    }, {
        name: 'asset-tasks:overwrite:model',
        title: 'Overwrite model',
        description: 'When a model is imported, overwrite a previously imported model asset.'
    }, {
        name: 'asset-tasks:overwrite:animation',
        title: 'Overwrite animation',
        description: 'When a model is imported, overwrite previously imported animation assets.'
    }, {
        name: 'asset-tasks:overwrite:material',
        title: 'Overwrite material',
        description: 'When a model is imported, overwrite previously imported material assets.'
    }, {
        name: 'asset-tasks:overwrite:texture',
        title: 'Overwrite texture',
        description: 'When a model is imported, overwrite previously imported texture assets.'
    }, {
        title: 'lightmapSizeMultiplier',
        subTitle: '{Number}',
        description: 'Auto-generated lightmap textures resolution is calculated using area of geometry in world space and size multiplier of model and scene. Changing this value will affect resolution of lightmaps for whole scene.',
        url: 'http://developer.playcanvas.com/api/pc.Scene.html#lightmapSizeMultiplier'
    }, {
        title: 'lightmapMaxResolution',
        subTitle: '{Number}',
        description: 'Maximum resolution for auto-generated lightmap textures.',
        url: 'http://developer.playcanvas.com/api/pc.Scene.html#lightmapMaxResolution'
    }, {
        name: 'facebook',
        title: 'Facebook Settings',
        description: 'Settings for publishing on Facebook Instant Games'
    }, {
        name: 'facebook:app-id',
        title: 'App ID',
        description: 'This is the Facebook App ID which you can find at the dashboard of your Facebook application.'
    }, {
        name: 'facebook:upload-token',
        title: 'Upload Access Token',
        description: 'An Access Token for uploading a build to Facebook.'
    }, {
        name: 'facebook:sdk-version',
        title: 'SDK Version',
        description: 'The Facebook Instant SDK version to use when publishing to Facebook. If you want you can also enter a version manually.'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'settings:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-entity-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        title: 'enabled',
        subTitle: '{Boolean}',
        description: 'If unchecked, entity wont be processed nor any of its components.',
        url: 'http://developer.playcanvas.com/api/pc.Entity.html'
    }, {
        title: 'name',
        subTitle: '{String}',
        description: 'Human-readable name for this graph node.',
        url: 'http://developer.playcanvas.com/api/pc.Entity.html#name'
    }, {
        title: 'tags',
        subTitle: '{pc.Tags}',
        description: '',
        url: 'http://developer.playcanvas.com/api/pc.Entity.html#tags'
    }, {
        title: 'position',
        subTitle: '{pc.Vec3}',
        description: 'Position in Local Space',
        url: 'http://developer.playcanvas.com/api/pc.Entity.html'
    }, {
        title: 'rotation',
        subTitle: '{pc.Vec3}',
        description: 'Rotation in Local Space',
        url: 'http://developer.playcanvas.com/api/pc.Entity.html'
    }, {
        title: 'scale',
        subTitle: '{pc.Vec3}',
        description: 'Scale in Local Space',
        url: 'http://developer.playcanvas.com/api/pc.Entity.html'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'entity:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-animation-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'component',
        title: 'pc.AnimationComponent',
        subTitle: '{pc.Component}',
        description: 'Enables an entity to specify which animations can be applied to the model assigned to its model component.',
        url: 'http://developer.playcanvas.com/api/pc.AnimationComponent.html'
    }, {
        title: 'assets',
        subTitle: '{Number[]}',
        description: 'The animation assets that can be utilized by this entity. Multiple animations can be assigned via the picker control.',
        url: 'http://developer.playcanvas.com/api/pc.AnimationComponent.html#assets'
    }, {
        title: 'speed',
        subTitle: '{Number}',
        description: 'A multiplier for animation playback speed. 0 will freeze animation playback, and 1 represents the normal playback speed of the asset.',
        url: 'http://developer.playcanvas.com/api/pc.AnimationComponent.html#speed'
    }, {
        title: 'activate',
        subTitle: '{Boolean}',
        description: 'If checked, the component will start playing the animation on load.',
        url: 'http://developer.playcanvas.com/api/pc.AnimationComponent.html#activate'
    }, {
        title: 'loop',
        subTitle: '{Boolean}',
        description: 'If checked, the animation will continue to loop back to the start on completion. Otherwise, the animation will come to a stop on its final frame.',
        url: 'http://developer.playcanvas.com/api/pc.AnimationComponent.html#loop'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'animation:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-audiolistener-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'component',
        title: 'pc.AudioListenerComponent',
        subTitle: '{pc.Component}',
        description: 'Specifies the listener\'s position in 3D space. All 3D audio playback will be relative to this position.',
        url: 'http://developer.playcanvas.com/api/pc.AudioListenerComponent.html'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'audiolistener:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-audiosource-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'component',
        title: 'pc.AudioSourceComponent',
        subTitle: '{pc.Component}',
        description: 'The AudioSource Component controls playback of an audio sample. This class will be deprecated in favor of {@link pc.SoundComponent}.',
        url: 'http://developer.playcanvas.com/api/pc.AudioSourceComponent.html'
    }, {
        title: '3d',
        subTitle: '{Boolean}',
        description: 'If checked, the component will play back audio assets as if played from the location of the entity in 3D space.',
        url: 'http://developer.playcanvas.com/api/pc.AudioSourceComponent.html#3d'
    }, {
        title: 'activate',
        subTitle: '{Boolean}',
        description: 'If checked, the first audio asset specified by the Assets property will be played on load. Otherwise, audio assets will need to be played using script.',
        url: 'http://developer.playcanvas.com/api/pc.AudioSourceComponent.html#activate'
    }, {
        title: 'assets',
        subTitle: '{Number[]}',
        description: 'The audio assets that can be played from this audio source. Multiple audio assets can be specified by the picker control.',
        url: 'http://developer.playcanvas.com/api/pc.AudioSourceComponent.html#assets'
    }, {
        title: 'loop',
        subTitle: '{Boolean}',
        description: 'If checked, the component will loop played audio assets continuously. Otherwise, audio assets are played once to completion.',
        url: 'http://developer.playcanvas.com/api/pc.AudioSourceComponent.html#loop'
    }, {
        title: 'distance',
        subTitle: '{Number}',
        description: 'minDistance - the distance at which the volume of playback begins to fall from its maximum. maxDistance - The distance at which the volume of playback falls to zero.',
        url: 'http://developer.playcanvas.com/api/pc.AudioSourceComponent.html#maxDistance'
    }, {
        title: 'pitch',
        subTitle: '{Number}',
        description: 'The pitch to playback the audio at. A value of 1 means the audio is played back at the original pitch.',
        url: 'http://developer.playcanvas.com/api/pc.AudioSourceComponent.html#pitch'
    }, {
        title: 'rollOffFactor',
        subTitle: '{Number}',
        description: 'The rate at which volume fall-off occurs.',
        url: 'http://developer.playcanvas.com/api/pc.AudioSourceComponent.html#rollOffFactor'
    }, {
        title: 'volume',
        subTitle: '{Number}',
        description: 'The volume of the audio assets played back by the component.',
        url: 'http://developer.playcanvas.com/api/pc.AudioSourceComponent.html#volume'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'audiosource:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }

    editor.call('attributes:reference:add', {
        name: 'audio:assets',
        title: 'assets',
        subTitle: '{Number[]}',
        description: 'The audio assets that can be played from this audio source. Multiple audio assets can be specified by the picker control.',
        url: 'http://developer.playcanvas.com/api/pc.AudioSourceComponent.html#assets'
    });
});


/* editor/attributes/reference/attributes-components-sound-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'sound',
        title: 'pc.SoundComponent',
        subTitle: '{pc.Component}',
        description: 'The Sound Component controls playback of sounds',
        url: 'http://developer.playcanvas.com/api/pc.SoundComponent.html'
    }, {
        title: 'positional',
        subTitle: '{Boolean}',
        description: 'If checked, the component will play back audio assets as if played from the location of the entity in 3D space.',
        url: 'http://developer.playcanvas.com/api/pc.SoundComponent.html#positional'
    }, {
        title: 'distance',
        subTitle: '{Number}',
        description: "refDistance - The reference distance for reducing volume as the sound source moves further from the listener. maxDistance - The maximum distance from the listener at which audio falloff stops. Note the volume of the audio is not 0 after this distance, but just doesn't fall off anymore.",
        url: 'http://developer.playcanvas.com/api/pc.SoundComponent.html#refDistance'
    }, {
        title: 'pitch',
        subTitle: '{Number}',
        description: 'The pitch to playback the audio at. A value of 1 means the audio is played back at the original pitch. The pitch of each slot is multiplied with this value.',
        url: 'http://developer.playcanvas.com/api/pc.SoundComponent.html#pitch'
    }, {
        title: 'rollOffFactor',
        subTitle: '{Number}',
        description: 'The rate at which volume fall-off occurs.',
        url: 'http://developer.playcanvas.com/api/pc.SoundComponent.html#rollOffFactor'
    }, {
        title: 'volume',
        subTitle: '{Number}',
        description: 'The volume modifier to play the audio with. The volume of each slot is multiplied with this value.',
        url: 'http://developer.playcanvas.com/api/pc.SoundComponent.html#volume'
    }, {
        title: 'distanceModel',
        subTitle: '{String}',
        description: 'Determines which algorithm to use to reduce the volume of the audio as it moves away from the listener.'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'sound:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-soundslot-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'slot',
        title: 'pc.SoundSlot',
        description: 'The SoundSlot controls playback of an audio asset.',
        url: 'http://developer.playcanvas.com/api/pc.SoundSlot.html'
    }, {
        title: 'name',
        subTitle: '{String}',
        description: 'The name of the slot',
        url: 'http://developer.playcanvas.com/api/pc.SoundSlot.html#name'
    }, {
        title: 'startTime',
        subTitle: '{Number}',
        description: 'The start time from which the sound will start playing.',
        url: 'http://developer.playcanvas.com/api/pc.SoundSlot.html#startTime'
    }, {
        title: 'duration',
        subTitle: '{String}',
        description: 'The duration of the sound that the slot will play starting from startTime.',
        url: 'http://developer.playcanvas.com/api/pc.SoundSlot.html#duration'
    }, {
        title: 'autoPlay',
        subTitle: '{Boolean}',
        description: 'If checked, the slot will be played on load. Otherwise, sound slots will need to be played by scripts.',
        url: 'http://developer.playcanvas.com/api/pc.SoundSlot.html#autoPlay'
    }, {
        title: 'overlap',
        subTitle: '{Boolean}',
        description: 'If true then sounds played from slot will be played independently of each other. Otherwise the slot will first stop the current sound before starting the new one.',
        url: 'http://developer.playcanvas.com/api/pc.SoundSlot.html#overlap'
    }, {
        title: 'asset',
        subTitle: '{Number}',
        description: 'The audio asset that can be played from this sound slot.',
        url: 'http://developer.playcanvas.com/api/pc.SoundSlot.html#asset'
    }, {
        title: 'loop',
        subTitle: '{Boolean}',
        description: 'If checked, the slot will loop playback continuously. Otherwise, it will be played once to completion.',
        url: 'http://developer.playcanvas.com/api/pc.SoundSlot.html#loop'
    }, {
        title: 'pitch',
        subTitle: '{Number}',
        description: 'The pitch to playback the audio at. A value of 1 means the audio is played back at the original pitch.',
        url: 'http://developer.playcanvas.com/api/pc.SoundComponent.html#pitch'
    }, {
        title: 'volume',
        subTitle: '{Number}',
        description: 'The volume modifier to play the audio with.',
        url: 'http://developer.playcanvas.com/api/pc.SoundComponent.html#volume'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'sound:slot:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-camera-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'component',
        title: 'pc.CameraComponent',
        subTitle: '{pc.Component}',
        description: 'Enables an entity to render a scene from a certain viewpoint.',
        url: 'http://developer.playcanvas.com/api/pc.CameraComponent.html'
    }, {
        title: 'clearColor',
        subTitle: '{pc.Color}',
        description: 'The color used to clear the camera\'s render target.',
        url: 'http://developer.playcanvas.com/api/pc.CameraComponent.html#clearColor'
    }, {
        title: 'clearColorBuffer',
        subTitle: '{Boolean}',
        description: 'If selected, the camera will explicitly clear its render target to the chosen clear color before rendering the scene.',
        url: 'http://developer.playcanvas.com/api/pc.CameraComponent.html#clearColorBuffer'
    }, {
        title: 'clearDepthBuffer',
        subTitle: '{Boolean}',
        description: 'If selected, the camera will explicitly clear the depth buffer of its render target before rendering the scene.',
        url: 'http://developer.playcanvas.com/api/pc.CameraComponent.html#clearDepthBuffer'
    }, {
        name: 'clip',
        title: 'nearClip / farClip',
        subTitle: '{Number}',
        description: 'The distance in camera space from the camera\'s eye point to the near and far clip planes.',
        url: 'http://developer.playcanvas.com/api/pc.CameraComponent.html#farClip'
    }, {
        title: 'fov',
        subTitle: '{Number}',
        description: 'Field of View is the angle between top and bottom clip planes of a perspective camera.',
        url: 'http://developer.playcanvas.com/api/pc.CameraComponent.html#fov'
    }, {
        title: 'frustumCulling',
        subTitle: '{Boolean}',
        description: 'Controls the culling of mesh instances against the camera frustum. If true, culling is enabled. If false, all mesh instances in the scene are rendered by the camera, regardless of visibility. Defaults to false.',
        url: 'http://developer.playcanvas.com/api/pc.CameraComponent.html#frustumCulling'
    }, {
        title: 'orthoHeight',
        subTitle: '{Number}',
        description: 'The distance in world units between the top and bottom clip planes of an orthographic camera.',
        url: 'http://developer.playcanvas.com/api/pc.CameraComponent.html#orthoHeight'
    }, {
        title: 'priority',
        subTitle: '{Number}',
        description: 'A number that defines the order in which camera views are rendered by the engine. Smaller numbers are rendered first.',
        url: 'http://developer.playcanvas.com/api/pc.CameraComponent.html#priority'
    }, {
        title: 'projection',
        subTitle: '{pc.PROJECTION_*}',
        description: 'The projection type of the camera.',
        url: 'http://developer.playcanvas.com/api/pc.CameraComponent.html#projection'
    }, {
        title: 'rect',
        subTitle: '{pc.Vec4}',
        description: 'A rectangle that specifies the viewport onto the camera\'s attached render target. This allows you to implement features like split-screen or picture-in-picture. It is defined by normalised coordinates (0 to 1) in the following format: x: The lower left x coordinate y: The lower left y coordinate w: The width of the rectangle h: The height of the rectangle',
        url: 'http://developer.playcanvas.com/api/pc.CameraComponent.html#rect'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'camera:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-collision-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'component',
        title: 'pc.CollisionComponent',
        subTitle: '{pc.Component}',
        description: 'A collision volume. use this in conjunction with a pc.RigidBodyComponent to make a collision volume that can be simulated using the physics engine. If the pc.Entity does not have a pc.RigidBodyComponent then this collision volume will act as a trigger volume. When an entity with a dynamic or kinematic body enters or leaves an entity with a trigger volume, both entities will receive trigger events.',
        url: 'http://developer.playcanvas.com/api/pc.CollisionComponent.html'
    }, {
        title: 'asset',
        subTitle: '{Number}',
        description: 'The model asset that will be used as a source for the triangle-based collision mesh.',
        url: 'http://developer.playcanvas.com/api/pc.CollisionComponent.html#asset'
    }, {
        title: 'axis',
        subTitle: '{Number}',
        description: 'Aligns the capsule/cylinder with the local-space X, Y or Z axis of the entity',
        url: 'http://developer.playcanvas.com/api/pc.CollisionComponent.html#axis'
    }, {
        title: 'halfExtents',
        subTitle: '{pc.Vec3}',
        description: 'The half-extents of the collision box. This is a 3-dimensional vector: local space half-width, half-height, and half-depth.',
        url: 'http://developer.playcanvas.com/api/pc.CollisionComponent.html#halfExtents'
    }, {
        title: 'height',
        subTitle: '{Number}',
        description: 'The tip-to-tip height of the capsule/cylinder.',
        url: 'http://developer.playcanvas.com/api/pc.CollisionComponent.html#height'
    }, {
        title: 'radius',
        subTitle: '{Number}',
        description: 'The radius of the capsule/cylinder body.',
        url: 'http://developer.playcanvas.com/api/pc.CollisionComponent.html#radius'
    }, {
        title: 'type',
        subTitle: '{String}',
        description: 'The type of collision primitive. Can be: box, sphere, capsulse, cylinder, mesh.',
        url: 'http://developer.playcanvas.com/api/pc.CollisionComponent.html#type'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'collision:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-light-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'component',
        title: 'pc.LightComponent',
        subTitle: '{pc.Component}',
        description: 'The Light Component enables the Entity to light the scene.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html'
    }, {
        title: 'isStatic',
        subTitle: '{Boolean}',
        description: 'Mark light as non-movable (optimization).',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#isStatic'
    }, {
        title: 'castShadows',
        subTitle: '{Boolean}',
        description: 'If checked, the light will cause shadow casting models to cast shadows.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#castShadows'
    }, {
        title: 'color',
        subTitle: '{pc.Color}',
        description: 'The color of the emitted light.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#color'
    }, {
        title: 'falloffMode',
        subTitle: '{pc.LIGHTFALLOFF_*}',
        description: 'Controls the rate at which a light attentuates from its position.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#falloffMode'
    }, {
        title: 'coneAngles',
        subTitle: '{Number}',
        description: 'The angles from the spotlight\'s direction at which light begins to fall from its maximum (innerConeAngle) and zero value (outerConeAngle).',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#innerConeAngle'
    }, {
        title: 'intensity',
        subTitle: '{Number}',
        description: 'The intensity of the light, this acts as a scalar value for the light\'s color. This value can exceed 1.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#intensity'
    }, {
        title: 'normalOffsetBias',
        subTitle: '{Number}',
        description: 'Normal offset depth bias.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#normalOffsetBias'
    }, {
        title: 'range',
        subTitle: '{Number}',
        description: 'The distance from the spotlight source at which its contribution falls to zero.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#range'
    }, {
        title: 'shadowBias',
        subTitle: '{Number}',
        description: 'Constant depth offset applied to a shadow map that enables the tuning of shadows in order to eliminate rendering artifacts, namely \'shadow acne\' and \'peter-panning\'.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#shadowBias'
    }, {
        title: 'shadowDistance',
        subTitle: '{Number}',
        description: 'The shadow distance is the maximum distance from the camera beyond which shadows that come from Directional Lights are no longer visible. Smaller values produce more detailed shadows. The closer the limit the less shadow data has to be mapped to, and represented by, any shadow map; shadow map pixels are mapped spatially and so the less distance the shadow map has to cover, the smaller the pixels and so the more resolution any shadow has.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#shadowDistance'
    }, {
        title: 'shadowResolution',
        subTitle: '{Number}',
        description: 'The size of the texture used for the shadow map.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#shadowResolution'
    },{
        title: 'type',
        subTitle: '{String}',
        description: 'The type of light. Can be: directional, point, spot.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#type'
    }, {
        title: 'affectDynamic',
        subTitle: '{Boolean}',
        description: 'If enabled the light will affect non-lightmapped objects.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#affectDynamic'
    }, {
        title: 'affectLightmapped',
        subTitle: '{Boolean}',
        description: 'If enabled the light will affect lightmapped objects.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#affectLightmapped'
    }, {
        title: 'bake',
        subTitle: '{Boolean}',
        description: 'If enabled the light will be rendered into lightmaps.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#bake'
    }, {
        title: 'bakeDir',
        subTitle: '{Boolean}',
        description: 'If enabled and bake=true, the light\'s direction will contribute to directional lightmaps.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#bakeDir'
    }, {
        title: 'shadowUpdateMode',
        subTitle: '{pc.SHADOWUPDATE_*}',
        description: 'Tells the renderer how often shadows must be updated for this light. Options:\n<b>pc.SHADOWUPDATE_NONE</b>: Don\'t render shadows.\n<b>pc.SHADOWUPDATE_THISFRAME</b>: Render shadows only once (then automatically switches to pc.SHADOWUPDATE_NONE).\n<b>pc.SHADOWUPDATE_REALTIME</b>: Render shadows every frame (default)',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#shadowUpdateMode'
    }, {
        title: 'shadowType',
        subTitle: '{pc.SHADOW_*}',
        description: 'Type of shadows being rendered by this light. Options:\n<b>pc.SHADOW_PCF3</b>: Render packed depth, can be used for PCF sampling.\n<b>pc.SHADOW_PCF5</b>: Render depth buffer only, can be used for better hardware-accelerated PCF sampling. Requires WebGL2. Falls back to pc.SHADOW_PCF3 on WebGL 1.0.\n<b>pc.SHADOW_VSM8</b>: Render packed variance shadow map. All shadow receivers must also cast shadows for this mode to work correctly.\n<b>pc.SHADOW_VSM16</b>: Render 16-bit exponential variance shadow map. Requires OES_texture_half_float extension. Falls back to pc.SHADOW_VSM8, if not supported.\n<b>pc.SHADOW_VSM32</b>: Render 32-bit exponential variance shadow map. Requires OES_texture_float extension. Falls back to pc.SHADOW_VSM16, if not supported.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#shadowType'
    }, {
        title: 'vsmBlurMode',
        subTitle: '{pc.BLUR_*}',
        description: 'Blurring mode for variance shadow maps:\n<b>pc.BLUR_BOX</b>: Box filter.\n<b>pc.BLUR_GAUSSIAN</b>: Gaussian filter. May look smoother than box, but requires more samples.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#vsmBlurMode'
    }, {
        title: 'vsmBlurSize',
        subTitle: '{Number}',
        description: 'Number of samples used for blurring a variance shadow map. Only uneven numbers work, even are incremented. Minimum value is 1, maximum is 25',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#vsmBlurSize'
    }, {
        title: 'vsmBias',
        subTitle: '{Number}',
        description: 'Constant depth offset applied to a shadow map that enables the tuning of shadows in order to eliminate rendering artifacts, namely \'shadow acne\' and \'peter-panning\'',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#vsmBias'
    }, {
        title: 'cookie',
        subTitle: '{pc.Texture}',
        description: 'Projection texture. Must be 2D for spot and cubemap for point (ignored if incorrect type is used).',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#cookie'
    }, {
        title: 'cookieAsset',
        subTitle: '{pc.Asset}',
        description: 'Asset that has texture that will be assigned to cookie internally once asset resource is available.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#cookieAsset'
    }, {
        title: 'cookieIntensity',
        subTitle: '{Number}',
        description: 'Projection texture intensity.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#cookieIntensity'
    }, {
        title: 'cookieFalloff',
        subTitle: '{Boolean}',
        description: 'Toggle normal spotlight falloff when projection texture is used. When set to false, spotlight will work like a pure texture projector (only fading with distance)',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#cookieFalloff'
    }, {
        title: 'cookieChannel',
        subTitle: '{String}',
        description: 'Color channels of the projection texture to use. Can be "r", "g", "b", "a", "rgb" or any swizzled combination.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#cookieChannel'
    }, {
        title: 'cookieAngle',
        subTitle: '{Number}',
        description: 'Angle for spotlight cookie rotation.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#cookieAngle'
    }, {
        title: 'cookieOffset',
        subTitle: '{pc.Vec2}',
        description: 'Spotlight cookie position offset.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#cookieOffset'
    }, {
        title: 'cookieScale',
        subTitle: '{pc.Vec2}',
        description: 'Spotlight cookie scale.',
        url: 'http://developer.playcanvas.com/api/pc.LightComponent.html#cookieScale'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'light:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-model-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'component',
        title: 'pc.ModelComponent',
        subTitle: '{pc.Component}',
        description: 'Enables an Entity to render a model or a primitive shape. This Component attaches additional model geometry in to the scene graph below the Entity.',
        url: 'http://developer.playcanvas.com/api/pc.ModelComponent.html'
    }, {
        title: 'isStatic',
        subTitle: '{Boolean}',
        description: 'Mark model as non-movable (optimization).',
        url: 'http://developer.playcanvas.com/api/pc.ModelComponent.html#isStatic'
    }, {
        title: 'asset',
        subTitle: '{Number}',
        description: 'The model asset rendered by this model component. Only a single model can be rendered per model component.',
        url: 'http://developer.playcanvas.com/api/pc.ModelComponent.html#asset'
    }, {
        title: 'castShadows',
        subTitle: '{Boolean}',
        description: 'If enabled, the model rendered by this component will cast shadows onto other models in the scene.',
        url: 'http://developer.playcanvas.com/api/pc.ModelComponent.html#castShadows'
    }, {
        title: 'materialAsset',
        subTitle: '{Number}',
        description: 'The material that will be used to render the model (only applies to primitives)',
        url: 'http://developer.playcanvas.com/api/pc.ModelComponent.html#materialAsset'
    }, {
        title: 'receiveShadows',
        subTitle: '{Boolean}',
        description: 'If enabled, the model rendered by this component will receive shadows cast by other models in the scene.',
        url: 'http://developer.playcanvas.com/api/pc.ModelComponent.html#receiveShadows'
    }, {
        title: 'type',
        subTitle: '{String}',
        description: 'The type of the model to be rendered. Can be: asset, box, capsule, cone, cylinder, sphere.',
        url: 'http://developer.playcanvas.com/api/pc.ModelComponent.html#type'
    }, {
        title: 'castShadowsLightmap',
        subTitle: '{Boolean}',
        description: 'If true, this model will cast shadows when rendering lightmaps',
        url: 'http://developer.playcanvas.com/api/pc.ModelComponent.html#castShadowsLightmap'
    }, {
        title: 'lightmapped',
        subTitle: '{Boolean}',
        description: 'If true, this model will be lightmapped after using lightmapper.bake()',
        url: 'http://developer.playcanvas.com/api/pc.ModelComponent.html#lightmapped'
    }, {
        title: 'lightmapSizeMultiplier',
        subTitle: '{Number}',
        description: 'Changing this value will affect resolution of lightmaps for this model',
        url: 'http://developer.playcanvas.com/api/pc.ModelComponent.html#lightmapSizeMultiplier'
    }, {
        name: 'resolution',
        description: 'Auto-generated lightmap textures resolution is calculated using area of geometry in world space and size multiplier of model and scene.',
        url: 'http://developer.playcanvas.com/en/user-manual/graphics/lighting/lightmaps/#lightmap-size-multipliers'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'model:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-particlesystem-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'component',
        title: 'pc.ParticleSystemComponent',
        subTitle: '{pc.Component}',
        description: 'Used to simulate particles and produce renderable particle mesh in scene.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html'
    }, {
        title: 'autoPlay',
        subTitle: '{Boolean}',
        description: 'If checked, the particle system will play immediately on creation. If this option is left unchecked, you will need to call the particle system component\'s play function from script.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#autoPlay'
    }, {
        title: 'alignToMotion',
        subTitle: '{Boolean}',
        description: 'Orient particle in their direction of motion.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#alignToMotion'
    }, {
        title: 'alphaGraph',
        subTitle: '{pc.Curve}',
        description: 'A curve defining how each particle\'s opacity changes over time. If two curves are specified in the curve editor, the opacity will be a random lerp between both curves.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#alphaGraph'
    }, {
        title: 'animTilesX',
        subTitle: '{Number}',
        description: 'Number of horizontal tiles in the sprite sheet',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#animTilesX'
    }, {
        title: 'animTilesY',
        subTitle: '{Number}',
        description: 'Number of vertical tiles in the sprite sheet',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#animTilesY'
    }, {
        title: 'animNumFrames',
        subTitle: '{Number}',
        description: 'Number of sprite sheet frames to play',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#animNumFrames'
    }, {
        title: 'animSpeed',
        subTitle: '{Number}',
        description: 'Sprite sheet animation speed. 1 = particle lifetime, 2 = twice during lifetime etc...',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#animSpeed'
    }, {
        title: 'animLoop',
        subTitle: '{Boolean}',
        description: 'If true then the sprite sheet animation will repeat indefinitely',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#animLoop'
    }, {
        title: 'blend',
        subTitle: '{pc.BLEND_*}',
        description: 'The blending mode determines how particles are composited when they are written to the frame buffer. Let\'s consider that Prgb is the RGB color of a particle\'s pixel, Pa is its alpha value, and Drgb is the RGB color already in the frame buffer.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#blend'
    }, {
        title: 'colorGraph',
        subTitle: '{pc.CurveSet}',
        description: 'A curve defining how each particle\'s color changes over time.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#colorGraph'
    }, {
        title: 'colorMap',
        subTitle: '{pc.Texture}',
        description: 'The color map texture to apply to all particles in the system. If no texture asset is assigned, a default spot texture is used.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#colorMap'
    }, {
        title: 'depthSoftening',
        subTitle: '{Number}',
        description: 'This variable value determines how much particles fade out as they get closer to another surface. This avoids the situation where particles appear to cut into surfaces.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#depthSoftening'
    }, {
        title: 'depthWrite',
        subTitle: '{Boolean}',
        description: 'If checked, the particles will write depth information to the depth buffer. If unchecked, the depth buffer is left unchanged and particles will be guaranteed to overwrite one another in the order in which they are rendered.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#depthWrite'
    }, {
        title: 'emitterExtents',
        subTitle: '{pc.Vec3}',
        description: 'The half extents of a local space bounding box within which particles are spawned at random positions.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#emitterExtents'
    }, {
        title: 'emitterRadius',
        subTitle: '{Number}',
        description: 'The radius within which particles are spawned at random positions.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#emitterRadius'
    }, {
        title: 'emitterShape',
        subTitle: '{pc.EMITTERSHAPE_*}',
        description: 'Shape of the emitter. Can be: pc.EMITTERSHAPE_BOX, pc.EMITTERSHAPE_SPHERE.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#emitterShape'
    }, {
        title: 'halfLambert',
        subTitle: '{Boolean}',
        description: 'Enabling Half Lambert lighting avoids particles looking too flat when lights appear to be shining towards the back sides of the particles. It is a completely non-physical lighting model but can give more pleasing visual results. This option is only available when Lighting is enabled.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#halfLambert'
    }, {
        title: 'intensity',
        subTitle: '{Number}',
        description: 'Scales the color of particles to allow them to have arbitrary brightness.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#intensity'
    }, {
        title: 'lifetime',
        subTitle: '{Number}',
        description: 'The length of time in seconds between a particle\'s birth and its death.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#lifetime'
    }, {
        title: 'lighting',
        subTitle: '{Boolean}',
        description: 'If checked, the particle will be lit by the directional and ambient light in the scene. In some circumstances, it may be advisable to set a normal map on the particle system in order to achieve more realistic lighting.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#lighting'
    }, {
        title: 'localVelocityGraph',
        subTitle: '{pc.CurveSet}',
        description: 'A curve defining how each particle\'s velocity with respect to the particle system\'s local coordinate system changes over time. If two curves are specified in the curve editor, local velocity will be a random lerp between both curves.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#localVelocityGraph'
    }, {
        title: 'loop',
        subTitle: '{Boolean}',
        description: 'If checked, the particle system will emit indefinitely. Otherwise, it will emit the number of particles specified by the \'Particle Count\' property and then stop.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#loop'
    }, {
        title: 'mesh',
        subTitle: '{pc.Mesh}',
        description: 'A model asset. The first mesh found in the model is used to represent all particles rather than a flat billboard.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#mesh'
    }, {
        title: 'normalMap',
        subTitle: '{pc.Texture}',
        description: 'The normal map texture to apply to all particles in the system. Applying a normal map can make billboard particles appear more consistent with the scenes lighting.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#normalMap'
    }, {
        title: 'numParticles',
        subTitle: '{Number}',
        description: 'The maximum number of particles managed by this particle system.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#numParticles'
    }, {
        title: 'paused',
        subTitle: '{Boolean}',
        description: 'Pauses or unpauses the simulation.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#paused'
    }, {
        title: 'preWarm',
        subTitle: '{Boolean}',
        description: 'If enabled, the particle system will be initialized as though it had already completed a full cycle. This option is only available for looping particle systems.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#preWarm'
    }, {
        title: 'rate',
        subTitle: '{Number}',
        description: 'The bounds of the time range defining the interval in seconds between particle births. The time for the next particle emission will be chosen at random between rate and rate2.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#rate'
    }, {
        title: 'rotationSpeedGraph',
        subTitle: '{pc.Curve}',
        description: 'A curve defining how each particle\'s angular velocity changes over time. If two curves are specified in the curve editor, the angular velocity will be a random lerp between both curves.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#rotationSpeedGraph'
    }, {
        title: 'scaleGraph',
        subTitle: '{pc.Curve}',
        description: 'A curve defining how each particle\'s scale changes over time. By default, a particle is 1 unit in width and height. If two curves are specified in the curve editor, the scale will be a random lerp between both curves.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#scaleGraph'
    }, {
        title: 'sort',
        subTitle: '{pc.PARTICLESORT_*}',
        description: 'Sorting mode gives you control over the order in which particles are rendered. The options are: None: Particles are rendered in arbitrary order. When this option is selected, the particle system is simulated on the GPU (if the underlying hardware supports floating point textures) and it is recommended you use this setting to get the best performance. Camera Distance: Particles are sorted on the CPU and rendered in back to front order (in terms of camera z depth). Newer First: Particles are sorted on the CPU and rendered in age order, youngest first. Older First: Particles are sorted on the CPU and rendered in age order, oldest first.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#sort'
    }, {
        title: 'startAngle',
        subTitle: '{Number}',
        description: 'The bounds of the initial particle rotation specified in degrees. For each particle, this angle is chosen at random between startAngle and startAngle2.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#startAngle'
    }, {
        title: 'stretch',
        subTitle: '{Number}',
        description: 'A value in world units that controls the amount by which particles are stretched based on their velocity. Particles are stretched from their center towards their previous position.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#stretch'
    }, {
        title: 'velocityGraph',
        subTitle: '{pc.CurveSet}',
        description: 'A curve defining how each particle\'s velocity with respect to the world coordinate system changes over time. If two curves are specified in the curve editor, velocity will be a random lerp between both curves.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#velocityGraph'
    }, {
        title: 'wrap',
        subTitle: '{Boolean}',
        description: 'Enables wrap bounds.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#wrap'
    }, {
        title: 'wrapBounds',
        subTitle: '{pc.Vec3}',
        description: 'World space AABB volume centered on the owner entity\'s position. If a particle crosses the boundary of one side of the volume, it teleports to the opposite side. You can use this to make environmental effects like rain by moving a wrapped emitter\'s owner entity.',
        url: 'http://developer.playcanvas.com/api/pc.ParticleSystemComponent.html#wrapBounds'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'particlesystem:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-rigidbody-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'component',
        title: 'pc.RigidBodyComponent',
        subTitle: '{pc.Component}',
        description: 'The rigidbody Component, when combined with a pc.CollisionComponent, allows your Entities to be simulated using realistic physics. A rigidbody Component will fall under gravity and collide with other rigid bodies, using scripts you can apply forces to the body.',
        url: 'http://developer.playcanvas.com/api/pc.RigidBodyComponent.html'
    }, {
        name: 'damping',
        title: 'angularDamping / linearDamping',
        subTitle: '{Number}',
        description: 'Controls the rate at which a body loses angular/linear velocity over time.',
        url: 'http://developer.playcanvas.com/api/pc.RigidBodyComponent.html#angularDamping'
    }, {
        title: 'angularFactor',
        subTitle: '{pc.Vec3}',
        description: 'Scaling factor for angular movement of the body in each axis.',
        url: 'http://developer.playcanvas.com/api/pc.RigidBodyComponent.html#angularFactor'
    }, {
        title: 'friction',
        subTitle: '{Number}',
        description: 'The friction value used when contacts occur between two bodies.',
        url: 'http://developer.playcanvas.com/api/pc.RigidBodyComponent.html#friction'
    }, {
        title: 'group',
        subTitle: '{Number}',
        description: 'description',
        url: 'http://developer.playcanvas.com/api/pc.RigidBodyComponent.html#group'
    }, {
        title: 'linearFactor',
        subTitle: '{pc.Vec3}',
        description: 'Scaling factor for linear movement of the body in each axis.',
        url: 'http://developer.playcanvas.com/api/pc.RigidBodyComponent.html#linearFactor'
    }, {
        title: 'mass',
        subTitle: '{Number}',
        description: 'The mass of the body.',
        url: 'http://developer.playcanvas.com/api/pc.RigidBodyComponent.html#mass'
    }, {
        title: 'restitution',
        subTitle: '{Number}',
        description: 'The amount of energy lost when two objects collide, this determines the bounciness of the object.',
        url: 'http://developer.playcanvas.com/api/pc.RigidBodyComponent.html#restitution'
    }, {
        title: 'type',
        subTitle: '{pc.RIGIDBODY_TYPE_*}',
        description: 'The type of RigidBody determines how it is simulated.',
        url: 'http://developer.playcanvas.com/api/pc.RigidBodyComponent.html#type'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'rigidbody:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-script-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'component',
        title: 'pc.ScriptComponent',
        subTitle: '{pc.Component}',
        description: 'The ScriptComponent allows you to extend the functionality of an Entity by attaching your own javascript files to be executed with access to the Entity. For more details on scripting see Scripting.',
        url: 'http://developer.playcanvas.com/api/pc.ScriptComponent.html'
    }, {
        title: 'scripts',
        subTitle: '{Object[]}',
        description: 'Add scripts by clicking on the button or drag scripts on the script component.',
        url: 'http://developer.playcanvas.com/api/pc.ScriptComponent.html#scripts'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'script:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-screen-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'component',
        title: 'pc.ScreenComponent',
        subTitle: '{pc.Component}',
        description: '',
        url: 'http://developer.playcanvas.com/api/pc.ScreenComponent.html'
    }, {
        title: 'screenSpace',
        subTitle: '{Boolean}',
        description: 'If true then the screen will display its child Elements in 2D. Set this to false to make this a 3D screen.',
        url: 'http://developer.playcanvas.com/api/pc.ScreenComponent.html#screenSpace'
    }, {
        title: 'resolution',
        subTitle: '{pc.Vec2}',
        description: 'The resolution of the screen.',
        url: 'http://developer.playcanvas.com/api/pc.ScreenComponent.html#resolution'
    }, {
        title: 'referenceResolution',
        subTitle: '{pc.Vec2}',
        description: 'The reference resolution of the screen. If the window size changes the screen will adjust its size based on scaleMode using the reference resolution.',
        url: 'http://developer.playcanvas.com/api/pc.ScreenComponent.html#referenceResolution'
    }, {
        title: 'scaleMode',
        subTitle: '{String}',
        description: 'Controls how a screen-space screen is resized when the window size changes. Use Blend to have the screen adjust between the difference of the window resolution and the screen\'s reference resolution. Use None to make the screen always have a size equal to its resolution.',
        url: 'http://developer.playcanvas.com/api/pc.ScreenComponent.html#scaleMode'
    }, {
        title: 'scaleBlend',
        subTitle: '{Number}',
        description: 'Set this to 0 to only adjust to changes between the width of the window and the x of the reference resolution. Set this to 1 to only adjust to changes between the window height and the y of the reference resolution. A value in the middle will try to adjust to both.',
        url: 'http://developer.playcanvas.com/api/pc.ScreenComponent.html#scaleBlend'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'screen:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-element-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'component',
        title: 'pc.ElementComponent',
        subTitle: '{pc.Component}',
        description: '',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html'
    }, {
        title: 'type',
        subTitle: '{String}',
        description: 'The type of the Element.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#type'
    }, {
        title: 'preset',
        subTitle: 'Anchor / Pivot preset',
        description: 'Quickly change the anchor and the pivot of the Element to common presets.'
    }, {
        title: 'anchor',
        subTitle: '{pc.Vec4}',
        description: 'The left, bottom, right and top anchors of the Element. These range from 0 to 1. If the horizontal or vertical anchors are split (not equal) then the Element will grow to fill the difference.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#anchor'
    }, {
        title: 'pivot',
        subTitle: '{pc.Vec2}',
        description: 'The origin of the Element. Rotation and scaling is done based on the pivot.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#pivot'
    }, {
        title: 'text',
        subTitle: '{String}',
        description: 'The text content of the Element. Hit Shift+Enter to add new lines.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#text'
    }, {
        title: 'fontAsset',
        subTitle: '{pc.Asset}',
        description: 'The font asset used by the Element.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#fontAsset'
    }, {
        title: 'textureAsset',
        subTitle: '{pc.Asset}',
        description: 'The texture used by the Element.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#textureAsset'
    }, {
        title: 'materialAsset',
        subTitle: '{pc.Asset}',
        description: 'The material used by the element.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#materialAsset'
    }, {
        title: 'autoWidth',
        subTitle: '{Booelan}',
        description: 'Make the width of the element match the width of the text content automatically.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#autoWidth'
    }, {
        title: 'autoHeight',
        subTitle: '{Booelan}',
        description: 'Make the height of the element match the height of the text content automatically.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#autoHeight'
    }, {
        title: 'size',
        subTitle: 'width / height {Number}',
        description: 'The width and height of the Element. You can only edit the width or the height if the corresponding anchors of the Element are not split.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#width'
    }, {
        title: 'margin',
        subTitle: 'margin {pc.Vec4}',
        description: 'Controls the spacing between each edge of the Element and the respective anchor. You can only edit the margin if the related anchors are split.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#margin'
    }, {
        title: 'alignment',
        subTitle: 'alignment {pc.Vec2}',
        description: 'Controls the horizontal and vertical alignment of the text relative to its element transform.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#alignment'
    }, {
        title: 'rect',
        subTitle: '{pc.Vec4}',
        description: 'The u, v, width and height of the rectangle that represents the portion of the texture that this image maps to.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#rect'
    }, {
        title: 'fontSize',
        subTitle: '{Number}',
        description: 'The size of the font used by the Element.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#fontSize'
    }, {
        title: 'lineHeight',
        subTitle: '{Number}',
        description: 'The height of each line of text.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#lineHeight'
    }, {
        title: 'spacing',
        subTitle: '{Number}',
        description: 'The spacing between each letter of the text.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#spacing'
    }, {
        title: 'color',
        subTitle: '{pc.Color}',
        description: 'The color of the Element.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#color'
    }, {
        title: 'opacity',
        subTitle: '{Number}',
        description: 'The opacity of the Element.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#opacity'
    }, {
        title: 'useInput',
        subTitle: '{Boolean}',
        description: 'Enable this if you want the element to receive input events.',
        url: 'http://developer.playcanvas.com/api/pc.ElementComponent.html#useInput'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'element:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        title: 'id',
        subTitle: '{Number}',
        description: 'Unique identifier of an Asset.',
        url: 'http://developer.playcanvas.com/api/pc.Asset.html'
    }, {
        title: 'name',
        subTitle: '{String}',
        description: 'The name of the asset.',
        url: 'http://developer.playcanvas.com/api/pc.Asset.html#name'
    }, {
        title: 'type',
        subTitle: '{String}',
        description: 'The type of the asset. One of: animation, audio, image, json, material, model, text, texture.',
        url: 'http://developer.playcanvas.com/api/pc.Asset.html#type'
    }, {
        name: 'size',
        description: 'Size of an asset. Keeping this value as tiny as possible will lead to faster application loading and less bandwidth required to launch the app.'
    }, {
        title: 'tags',
        subTitle: '{pc.Tags}',
        description: 'Interface for tagging assets. Allows to find assets by tags using app.assets.findByTag method.',
        url: 'http://developer.playcanvas.com/api/pc.Asset.html#tags'
    }, {
        name: 'runtime',
        description: 'If this asset is runtime-friendly and can be used within the app.'
    }, {
        title: 'preload',
        subTitle: '{Boolean}',
        description: 'If true the asset will be loaded during the preload phase of application set up.',
        url: 'http://developer.playcanvas.com/api/pc.Asset.html#preload'
    }, {
        name: 'source',
        description: 'Reference to another asset where this asset were imported from.'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'asset:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-audio-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'asset',
        title: 'pc.Sound',
        subTitle: '{Class}',
        description: 'Audio resource file that is used by Web Audio API.',
        url: 'http://developer.playcanvas.com/api/pc.Sound.html'
    }, {
        title: 'duration',
        subTitle: '{Number}',
        description: 'Duration of the audio file in seconds.',
        url: 'http://developer.playcanvas.com/api/pc.Sound.html#duration'
    }];

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'asset:audio:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-animation-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'asset',
        title: 'pc.Animation',
        subTitle: '{Class}',
        description: 'An animation is a sequence of keyframe arrays which map to the nodes of a skeletal hierarchy. It controls how the nodes of the hierarchy are transformed over time.',
        url: 'http://developer.playcanvas.com/api/pc.Animation.html'
    }, {
        title: 'duration',
        description: 'Duration of the animation in seconds.',
        url: 'http://developer.playcanvas.com/api/pc.Animation.html'
    }];

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'asset:animation:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-css-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'asset',
        title: 'CSS',
        subTitle: '{String}',
        description: 'CSS string to be used in application.'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'asset:css:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-cubemap-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'asset',
        title: 'pc.Texture',
        subTitle: '{Class}',
        description: 'Cube maps are a special type of texture asset. They are formed from 6 texture assets where each texture represents the face of a cube. They typically have two uses: A cube map can define your scene\'s sky box. A sky box contains imagery of the distant visuals of your scene such as hills, mountains, the sky and so on. A cube map can add reflections to any material. Imagine a shiny, chrome ball bearing in your scene. The ball reflects the surrounding scene. For open environments, you would normally set the scene\'s sky box cube map as the cube map on a reflective object\'s materials.',
        url: 'http://developer.playcanvas.com/api/pc.Texture.html'
    }, {
        title: 'anisotropy',
        subTitle: '{Number}',
        description: 'Integer value specifying the level of anisotropic to apply to the texture ranging from 1 (no anisotropic filtering) to the pc.GraphicsDevice property maxAnisotropy.',
        url: 'http://developer.playcanvas.com/api/pc.Texture.html#anisotropy'
    }, {
        title: 'magFilter',
        subTitle: '{pc.FILTER_*}',
        description: 'The magnification filter to be applied to the texture.',
        url: 'http://developer.playcanvas.com/api/pc.Texture.html#magFilter'
    }, {
        title: 'mipFilter',
        subTitle: '{pc.FILTER_*}',
        description: 'The minification mipmap filter to be applied to the texture.',
        url: 'http://developer.playcanvas.com/api/pc.Texture.html#mipFilter'
    }, {
        title: 'minFilter',
        subTitle: '{pc.FILTER_*}',
        description: 'The minification filter to be applied to the texture.',
        url: 'http://developer.playcanvas.com/api/pc.Texture.html#minFilter'
    }, {
        name: 'slots',
        title: 'Texture Slots',
        description: 'The six texture assets that correspond to the faces of a cube. Helping you to connect faces together correctly. Think of the preview as a box unfolded to a flat plane.'
    }, {
        name: 'prefilter',
        title: 'Prefiltering',
        description: 'Prefilter button generates a set of low-resolution filtered textures which are used in the environment map of the Physical material. Prefiltering the cube map is essential for using the Physical material.'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'asset:cubemap:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-html-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'asset',
        title: 'HTML',
        subTitle: '{String}',
        description: 'HTML string to be used in application.'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'asset:html:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-json-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'asset',
        title: 'JSON',
        subTitle: '{Object}',
        description: 'JSON data to be used in application.'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'asset:json:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-material-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'asset',
        title: 'pc.Material',
        subTitle: '{Class}',
        description: 'Every surface on a 3D model is rendered using a material. The material defines the properties of that surface, such as its color, shininess, bumpiness. In PlayCanvas, a material is an Asset type which collects all these properties together. By default, it represents a Physical material. This exposes the fundamental properties that can be used to create many different types for visual effects, from smooth plastic, to rough wood, or scratched metal.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html'
    }, {
        name: 'ambientOverview',
        description: 'Ambient properties determine how the material appears in ambient light.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html'
    }, {
        title: 'ambient',
        subTitle: '{pc.Color}',
        description: 'The tint color to multiply the scene\'s global ambient color.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#ambient'
    }, {
        title: 'ambientTint',
        subTitle: '{Boolean}',
        description: 'Check this to multiply the scene\'s global ambient color with a material specific color.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#ambientTint'
    }, {
        title: 'aoMap',
        subTitle: '{pc.Texture}',
        description: 'An ambient occlusion map containing pre-baked ambient occlusion.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#aoMap'
    }, {
        title: 'aoMapChannel',
        subTitle: '{String}',
        description: 'An ambient occlusion map color channel to extract color value from texture. Can be: r, g, b, a',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#aoMapChannel'
    }, {
        title: 'aoMapUv',
        subTitle: '{Number}',
        description: 'AO map UV channel',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#aoMapUv'
    }, {
        title: 'aoMapVertexColor',
        subTitle: '{Boolean}',
        description: 'Use vertex colors for AO instead of a map',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#aoMapVertexColor'
    }, {
        title: 'aoMapTiling',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D tiling of the AO map.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#aoMapTiling'
    }, {
        title: 'aoMapOffset',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D offset of the AO map. Each component is between 0 and 1.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#aoMapOffset'
    }, {
        title: 'blendType',
        subTitle: '{pc.BLEND_*}',
        description: 'The type of blending for this material. Options are:\n \
        <b>None {pc.BLEND_NONE}</b>: The mesh is opaque. This is the default.\n \
        <b>Normal {pc.BLEND_NORMAL}</b>: The mesh is transparent, like stained glass. Called as Alpha Blend as well.\n \
        <b>Additive {pc.BLEND_ADDITIVE}</b>: The mesh color is added to whatever has already been rendered to the frame buffer.\n \
        <b>Additive Alpha {pc.BLEND_ADDITIVEALPHA}</b>: Same as Additive except source RGB is multiplied by the source alpha.\n \
        <b>Screen {pc.BLEND_SCREEN}</b>: Softer version of Additive.\n \
        <b>Pre-multiply {pc.BLEND_PREMULTIPLIED}</b>: Like \'Normal\' blending except it is assumed that the color of the mesh being rendered with this material has already been modulated by its alpha value.\n \
        <b>Multiply {pc.BLEND_MULTIPLICATIVE}</b>: When rendered, the mesh color is multiplied by whatever has already been rendered to the frame buffer.\n \
        <b>Modulate 2x {pc.BLEND_MULTIPLICATIVE2X}</b>: Multiplies colors and doubles the result.\n \
        <b>Min {pc.BLEND_MIN}</b>: [Partial Support, check `app.graphicsDevice.extBlendMinmax` for support] Minimum color.\n \
        <b>Max {pc.BLEND_MAX}</b>: [Partial Support, check `app.graphicsDevice.extBlendMinmax` for support] Maximum color.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#blendType'
    }, {
        title: 'bumpiness',
        subTitle: '{Number}',
        description: 'The strength of the applied normal map. This is a value between 0 (the normal map has no effect) and 2 (the effect of the normal map is exagerrated). It defaults to 1.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#bumpiness'
    }, {
        title: 'conserveEnergy',
        subTitle: '{Boolean}',
        description: 'Defines how diffuse and specular components are combined when Fresnel is on. It is recommended that you leave this option enabled, although you may want to disable it in case when all reflection comes only from a few light sources, and you don\'t use an environment map, therefore having mostly black reflection.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#conserveEnergy'
    }, {
        title: 'cubeMap',
        subTitle: '{pc.Texture}',
        description: 'A cube map texture asset that approximates environment reflection (with greater accuracy than is possible with a sphere map). If scene has SkyBox set, then it will be used as default cubeMap',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#cubeMap'
    }, {
        title: 'cubeMapProjection',
        subTitle: '{pc.CUBEPROJ_*}',
        description: 'The type of projection applied to the cubeMap property, with available options: pc.CUBEPROJ_NONE and pc.CUBEPROJ_BOX. Set to Box to enable world-space axis-aligned projection of cubemap based on bounding box.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#cubeMapProjection'
    }, {
        name: 'cubeMapProjectionBoxCenter',
        title: 'cubeMapProjectionBox',
        subTitle: '{pc.BoundingBox}',
        description: 'The world space axis-aligned bounding box defining the box-projection used for the cubeMap property. Only used when cubeMapProjection is set to pc.CUBEPROJ_BOX.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#cubeMapProjectionBox'
    }, {
        name: 'cubeMapProjectionBoxHalfExtents',
        title: 'cubeMapProjectionBox',
        subTitle: '{pc.BoundingBox}',
        description: 'The world space axis-aligned bounding box defining the box-projection used for the cubeMap property. Only used when cubeMapProjection is set to pc.CUBEPROJ_BOX.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#cubeMapProjectionBox'
    }, {
        title: 'cull',
        subTitle: '{pc.CULLFACE_*}',
        description: 'Options are: None {pc.CULLFACE_NONE}: Both front faces and back faces are rendered. Front Faces {pc.CULLFACE_FRONT}: front faces are rendered and back faces are not. Back Faces {pc.CULLFACE_BACK}: back faces are rendered and front faces are not. This is the default. PlayCanvas dictates that a counter-clockwise vertex winding specifies a front face triangle. Note that backface culling is often good for performance because backface pixels are often overwritten (for convex meshes) which can result in redundant filling of pixels.'
    }, {
        title: 'depthTest',
        subTitle: '{Boolean}',
        description: 'If checked, when a mesh with the material is rendered, a per pixel check is performed to determine if the pixel passes the engine\'s depth test. By default, the test is that the pixel must have a z depth less than or equal to whatever is already in the depth buffer. In other words, the mesh is only visible if nothing is in front of it. If unchecked, the mesh is rendered regardless of what is already in the depth buffer. Defaults to on.'
    }, {
        title: 'depthWrite',
        subTitle: '{Boolean}',
        description: 'If checked, when a mesh with the material is rendered, its depth information is written to the depth buffer. This ensures that when subsequent meshes are rendered, they can be successfully depth tested against meshes rendered with this material. Defaults to on.'
    }, {
        name: 'diffuseOverview',
        description: 'Diffuse properties define the how a material reflects diffuse light emitted by dynamic light sources in the scene.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html'
    }, {
        title: 'diffuse',
        subTitle: '{pc.Color}',
        description: 'If no diffuse map is set or tint is enabled, this is the diffuse color of the material.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#diffuse'
    }, {
        title: 'diffuseMap',
        subTitle: '{pc.Texture}',
        description: 'The diffuse map that specifies the per-pixel diffuse material color. If no diffuse map is set, the diffuse color is used instead.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#diffuseMap'
    }, {
        title: 'diffuseMapChannel',
        subTitle: '{String}',
        description: 'An diffuse map color channel to extract color value from texture. Can be: r, g, b, a, rgb',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#diffuseMapChannel'
    }, {
        title: 'diffuseMapOffset',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D offset of the diffuseMap. Each component is between 0 and 1.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#diffuseMapOffset'
    }, {
        title: 'diffuseMapTiling',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D tiling of the diffuseMap.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#diffuseMapTiling'
    }, {
        title: 'diffuseMapTint',
        subTitle: '{Boolean}',
        description: 'Check this to modulate the material\'s diffuse map with a material specific diffuse color.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#diffuseMapTint'
    }, {
        title: 'diffuseMapUv',
        subTitle: '{Number}',
        description: 'Diffuse map UV channel',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#diffuseMapUv'
    }, {
        title: 'diffuseMapVertexColor',
        subTitle: '{Boolean}',
        description: 'Use vertex colors for diffuse instead of a map',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#diffuseMapVertexColor'
    }, {
        name: 'emissiveOverview',
        description: 'Emissive properties control how the material emits light (as opposed to reflecting light).',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html'
    }, {
        title: 'emissive',
        subTitle: '{pc.Color}',
        description: 'If no emissive map is set or tint is enabled, this is the emissive color of the material.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#emissive'
    }, {
        title: 'emissiveIntensity',
        subTitle: '{Number}',
        description: 'A multiplier for emissive color that can achieve overbright effects for exceptionally bright emissive materials.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#emissiveIntensity'
    }, {
        title: 'emissiveMap',
        subTitle: '{pc.Texture}',
        description: 'The emissive map that specifies the per-pixel emissive color. If no emissive map is set, the emissive color is used instead.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#emissiveMap'
    }, {
        title: 'emissiveMapChannel',
        subTitle: '{String}',
        description: 'An emissive map color channel to extract color value from texture. Can be: r, g, b, a, rgb',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#emissiveMapChannel'
    }, {
        title: 'emissiveMapOffset',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D offset of the emissiveMap. Each component is between 0 and 1.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#emissiveMapOffset'
    }, {
        title: 'emissiveMapTiling',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D tiling of the emissiveMap.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#emissiveMapTiling'
    }, {
        title: 'emissiveMapTint',
        subTitle: '{Boolean}',
        description: 'Check this to modulate the material\'s emissive map with a material specific emissive color.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#emissiveMapTint'
    }, {
        title: 'emissiveMapUv',
        subTitle: '{Number}',
        description: 'Emissive map UV channel',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#emissiveMapUv'
    }, {
        title: 'emissiveMapVertexColor',
        subTitle: '{Boolean}',
        description: 'Use vertex colors for emission instead of a map',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#emissiveMapVertexColor'
    }, {
        name: 'environmentOverview',
        description: 'Environment properties determine how a material reflects and refracts the environment.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html'
    }, {
        title: 'fresnelFactor',
        subTitle: '{Number}',
        description: 'description',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#fresnelFactor'
    }, {
        title: 'fresnelModel',
        subTitle: '{pc.FRESNEL_*}',
        description: 'A parameter for Fresnel. May mean different things depending on fresnelModel.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#fresnelModel'
    }, {
        title: 'glossMap',
        subTitle: '{pc.Texture}',
        description: 'The gloss map that specifies a per-pixel shininess value. The gloss map is modulated by the shininess property.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#glossMap'
    }, {
        title: 'glossMapChannel',
        subTitle: '{String}',
        description: 'An gloss map color channel to extract color value from texture. Can be: r, g, b, a',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#glossMapChannel'
    }, {
        title: 'glossMapOffset',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D offset of the glossMap. Each component is between 0 and 1.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#glossMapOffset'
    }, {
        title: 'glossMapTiling',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D tiling of the glossMap.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#glossMapTiling'
    }, {
        title: 'glossMapUv',
        subTitle: '{Number}',
        description: 'Gloss map UV channel',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#glossMapUv'
    }, {
        title: 'glossMapVertexColor',
        subTitle: '{Boolean}',
        description: 'Use vertex colors for glossiness instead of a map',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#glossMapVertexColor'
    }, {
        title: 'heightMap',
        subTitle: '{pc.Texture}',
        description: 'The height map that specifies the per-pixel strength of the parallax effect. White is full height and black is zero height.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#heightMap'
    }, {
        title: 'heightMapChannel',
        subTitle: '{String}',
        description: 'An height map color channel to extract color value from texture. Can be: r, g, b, a',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#heightMapChannel'
    }, {
        title: 'heightMapFactor',
        subTitle: '{Number}',
        description: 'The strength of a parallax effect (a value between 0 and 2, defaulting to 1).',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#heightMapFactor'
    }, {
        title: 'heightMapOffset',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D offset of the heightMap. Each component is between 0 and 1.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#heightMapOffset'
    }, {
        title: 'heightMapTiling',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D tiling of the heightMap.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#heightMapTiling'
    }, {
        title: 'heightMapUv',
        subTitle: '{Number}',
        description: 'Height map UV channel',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#heightMapUv'
    }, {
        name: 'lightMapOverview',
        description: 'Light maps contain pre-baked diffuse lighting. Using light maps is considered an optimization in that runtime dynamic lighting calculations can be pre-calculated.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html'
    }, {
        title: 'lightMap',
        subTitle: '{pc.Texture}',
        description: 'The lightmap texture that contains pre-baked diffuse lighting. The lightmap usually is applied to the second UV set.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#lightMap'
    }, {
        title: 'lightMapChannel',
        subTitle: '{String}',
        description: 'An light map color channel to extract color value from texture. Can be: r, g, b, a, rgb',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#lightMapChannel'
    }, {
        title: 'lightMapUv',
        subTitle: '{Number}',
        description: 'Lightmap UV channel',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#lightMapUv'
    }, {
        title: 'lightMapVertexColor',
        subTitle: '{Boolean}',
        description: 'Use vertex lightmap instead of a texture-based one',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#lightMapVertexColor'
    }, {
        title: 'lightMapTiling',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D tiling of the lightmap.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#lightMapTiling'
    }, {
        title: 'lightMapOffset',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D offset of the lightmap. Each component is between 0 and 1.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#lightMapOffset'
    }, {
        title: 'metalness',
        subTitle: '{Number}',
        description: 'Metalness factor multiplier.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#metalness'
    }, {
        title: 'metalnessMap',
        subTitle: '{pc.Texture}',
        description: 'This map specifies per-pixel metalness values. A value of 1 is metal and a value of 0 is non-metal.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#metalnessMap'
    }, {
        title: 'metalnessMapChannel',
        subTitle: '{String}',
        description: 'An metalness map color channel to extract color value from texture. Can be: r, g, b, a',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#metalnessMapChannel'
    }, {
        title: 'metalnessMapUv',
        subTitle: '{Number}',
        description: 'Metnalness map UV channel',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#metalnessMapUv'
    }, {
        title: 'metalnessMapVertexColor',
        subTitle: '{Boolean}',
        description: 'Use vertex colors for metalness instead of a map',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#metalnessMapVertexColor'
    }, {
        title: 'metalnessMapTiling',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D tiling of the metalness map.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#metalnessMapTiling'
    }, {
        title: 'metalnessMapOffset',
        subTitle: '{String}',
        description: 'Controls the 2D offset of the metalness map. Each component is between 0 and 1.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#metalnessMapChannel'
    }, {
        name: 'normalOverview',
        description: 'Use this to specify normal maps in order to simulate \'Bumpiness\' effect.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html'
    }, {
        title: 'normalMap',
        subTitle: '{pc.Texture}',
        description: 'The normal map that specifies the per-pixel surface normals. The normal map is modulated by the \'Bumpiness\' property.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#normalMap'
    }, {
        title: 'normalMapOffset',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D offset of the normalMap. Each component is between 0 and 1.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#normalMapOffset'
    }, {
        title: 'normalMapTiling',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D tiling of the normalMap.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#normalMapTiling'
    }, {
        title: 'normalMapUv',
        subTitle: '{Number}',
        description: 'Normal map UV channel',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#normalMapUv'
    }, {
        title: 'occludeSpecular',
        subTitle: '{Boolean}',
        description: 'If checked, ambient color will occlude specular factor of a material.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#occludeSpecular'
    }, {
        name: 'other',
        description: 'Other Render States gives additional controls over how a mesh is rendered with the specified material.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html'
    }, {
        name: 'offset',
        description: 'The offset in U and V to apply to the first UV channel referenced by maps in this material.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html'
    }, {
        name: 'offsetTiling',
        description: 'The offset and tiling in U and V to apply to the UV channel referenced by all maps in this material.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html'
    }, {
        name: 'opacityOverview',
        description: 'Opacity sets the transparency level.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html'
    }, {
        title: 'opacity',
        subTitle: '{Number}',
        description: 'The opacity of the material. This is a value between 0 (completely transparent) and 1 (complately opaque. It defaults to 1.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#opacity'
    }, {
        title: 'opacityMap',
        subTitle: '{pc.Texture}',
        description: 'The opacity map that specifies the per-pixel opacity. The opacity map is modulated by the \'Amount\' property.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#opacityMap'
    }, {
        title: 'opacityMapChannel',
        subTitle: '{String}',
        description: 'An opacity map color channel to extract color value from texture. Can be: r, g, b, a',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#opacityMapChannel'
    }, {
        title: 'opacityMapOffset',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D offset of the opacityMap. Each component is between 0 and 1.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#opacityMapOffset'
    }, {
        title: 'opacityMapTiling',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D tiling of the opacityMap.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#opacityMapTiling'
    }, {
        title: 'opacityMapUv',
        subTitle: '{Number}',
        description: 'Opacity map UV channel',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#opacityMapUv'
    }, {
        title: 'opacityMapVertexColor',
        subTitle: '{Boolean}',
        description: 'Use vertex colors for opacity instead of a map',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#opacityMapVertexColor'
    }, {
        name: 'parallaxOverview',
        description: 'A height map gives further realism to a normal map by giving the illusion of depth to a surface. Note that parallax options are only enabled if you have set a normal map on the material.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html'
    }, {
        title: 'reflectivity',
        subTitle: '{Number}',
        description: 'A factor to determin what portion of light is reflected from the material. This value defaults to 1 (full reflectivity).',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#reflectivity'
    }, {
        title: 'refraction',
        subTitle: '{Number}',
        description: 'A factor to determine what portion of light passes through the material.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#refraction'
    }, {
        title: 'refractionIndex',
        subTitle: '{Number}',
        description: 'Determines the amount of distortion of light passing through the material.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#refractionIndex'
    }, {
        title: 'shadingModel',
        subTitle: '{pc.SPECULAR_*}',
        description: 'Defines the shading model. Phong {pc.SPECULAR_PHONG}: Phong without energy conservation. You should only use it as a backwards compatibility with older projects. Physical {pc.SPECULAR_BLINN}: Energy-conserving Blinn-Phong.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#shadingModel'
    }, {
        title: 'shininess',
        subTitle: '{Number}',
        description: 'A value determining the smoothness of a surface. For smaller shininess values, a surface is rougher and specular highlights will be broader. For larger shininess values, a surface is smoother and will exhibit more concentrated specular highlights (as is the surace is polished and shiny).',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#shininess'
    }, {
        name: 'specularOverview',
        description: 'Specular properties defines the color of the specular highlights. i.e. the shininess',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html'
    }, {
        title: 'specular',
        subTitle: '{pc.Color}',
        description: 'If no specular map is set or tint is checked, this is the specular color of the material.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#specular'
    }, {
        title: 'specularAntialias',
        subTitle: '{Boolean}',
        description: 'Enables Toksvig AA for mipmapped normal maps with specular.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#specularAntialias'
    }, {
        title: 'specularMap',
        subTitle: '{pc.Texture}',
        description: 'The specular map that specifies the per-pixel specular color. If no specular map is set, the specular color is used instead.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#specularMap'
    }, {
        title: 'specularMapChannel',
        subTitle: '{String}',
        description: 'An specular map color channel to extract color value from texture. Can be: r, g, b, a, rgb',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#specularMapChannel'
    }, {
        title: 'specularMapOffset',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D offset of the specularMap. Each component is between 0 and 1.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#specularMapOffset'
    }, {
        title: 'specularMapTiling',
        subTitle: '{pc.Vec2}',
        description: 'Controls the 2D tiling of the specularMap.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#specularMapTiling'
    }, {
        title: 'specularMapTint',
        subTitle: '{Boolean}',
        description: 'Check this to modulate the material\'s specular map with a material specific specular color.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#specularMapTint'
    }, {
        title: 'specularMapUv',
        subTitle: '{Number}',
        description: 'Specular map UV channel.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#specularMapUv'
    }, {
        title: 'specularMapVertexColor',
        subTitle: '{Boolean}',
        description: 'Use vertex colors for specular instead of a map.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#specularMapVertexColor'
    }, {
        title: 'sphereMap',
        subTitle: '{pc.Texture}',
        description: 'A sphere map texture asset that approximates environment reflection. If a sphere map is set, the Cube Map property will be hidden (since these properties are mutually exclusive).',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#sphereMap'
    }, {
        name: 'tiling',
        description: 'The scale in U and V to apply to the first UV channel referenced by maps in this material.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html'
    }, {
        title: 'useMetalness',
        subTitle: '{Boolean}',
        description: 'Toggle between specular and metalness workflow.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#useMetalness'
    }, {
        title: 'alphaTest',
        subTitle: '{Number}',
        description: 'The alpha test reference value to control which fragements are written to the currently active render target based on alpha value. All fragments with an alpha value of less than the alphaTest reference value will be discarded. alphaTest defaults to 0 (all fragments pass).',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#alphaTest'
    }, {
        title: 'alphaToCoverage',
        subTitle: '{Boolean}',
        webgl2: true,
        description: 'Enables or disables alpha to coverage. When enabled, and if hardware anti-aliasing is on, limited order-independent transparency can be achieved. Quality depends on the number of MSAA samples of the current render target. It can nicely soften edges of otherwise sharp alpha cutouts, but isn\'t recommended for large area semi-transparent surfaces. Note, that you don\'t need to enable blending to make alpha to coverage work. It will work without it, just like alphaTest.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#alphaToCoverage'
    }, {
        title: 'useFog',
        subTitle: '{Boolean}',
        description: 'Apply fogging (as configured in scene settings).',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#useFog'
    }, {
        title: 'useLighting',
        subTitle: '{Boolean}',
        description: 'Apply lighting.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#useLighting'
    }, {
        title: 'useSkybox',
        subTitle: '{Boolean}',
        description: 'Apply scene skybox as prefiltered environment map.',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#useSkybox'
    }, {
        title: 'useGammaTonemap',
        subTitle: '{Boolean}',
        description: 'Apply gamma correction and tonemapping (as configured in scene settings).',
        url: 'http://developer.playcanvas.com/api/pc.StandardMaterial.html#useGammaTonemap'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'asset:material:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-model-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        title: 'meshInstances',
        subTitle: '{pc.MeshInstance[]}',
        description: 'An array of meshInstances contained in this model. Materials are defined for each individual Mesh Instance.',
        url: 'http://developer.playcanvas.com/api/pc.Model.html#meshInstances'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'asset:model:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-script-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        title: 'filename',
        subTitle: '{String}',
        description: 'Filename of a script..'
    }, {
        name: 'order',
        description: 'Sometimes specific order of loading and executing JS files is required. All preloaded script assets will be loaded in order speecified in Project Settings.'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'asset:script:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-text-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'asset',
        title: 'TEXT',
        subTitle: '{String}',
        description: 'String data to be used in application.'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'asset:text:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-texture-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'asset',
        title: 'pc.Texture',
        subTitle: '{Class}',
        description: 'Textures assets are image files which are used as part of a material to give a 3D model a realistic appearance.',
        url: 'http://developer.playcanvas.com/api/pc.Texture.html'
    }, {
        name: 'dimensions',
        title: 'width / height',
        subTitle: '{Number}',
        description: 'The width and height of the texture.',
        url: 'http://developer.playcanvas.com/api/pc.Texture.html#width'
    }, {
        title: 'magFilter',
        subTitle: '{pc.FILTER_*}',
        description: 'The magnification filter to be applied to the texture.',
        url: 'http://developer.playcanvas.com/api/pc.Texture.html#magFilter'
    }, {
        title: 'mipFilter',
        subTitle: '{pc.FILTER_*}',
        description: 'The minification mipmap filter to be applied to the texture.',
        url: 'http://developer.playcanvas.com/api/pc.Texture.html#mipFilter'
    }, {
        title: 'minFilter',
        subTitle: '{pc.FILTER_*}',
        description: 'The minification filter to be applied to the texture.',
        url: 'http://developer.playcanvas.com/api/pc.Texture.html#minFilter'
    }, {
        title: 'addressU',
        subTitle: '{pc.ADDRESS_*}',
        description: 'The addressing mode to be applied to the texture.',
        url: 'http://developer.playcanvas.com/api/pc.Texture.html#addressU'
    }, {
        title: 'addressV',
        subTitle: '{pc.ADDRESS_*}',
        description: 'The addressing mode to be applied to the texture.',
        url: 'http://developer.playcanvas.com/api/pc.Texture.html#addressV'
    }, {
        title: 'anisotropy',
        subTitle: '{Number}',
        description: 'Integer value specifying the level of anisotropic to apply to the texture ranging from 1 (no anisotropic filtering) to the pc.GraphicsDevice property maxAnisotropy.',
        url: 'http://developer.playcanvas.com/api/pc.Texture.html#anisotropy'
    }, {
        title: 'width',
        subTitle: '{Number}',
        description: 'The width of the base mip level in pixels.',
        url: 'http://developer.playcanvas.com/api/pc.Texture.html#width'
    }, {
        title: 'height',
        subTitle: '{Number}',
        description: 'The height of the base mip level in pixels.',
        url: 'http://developer.playcanvas.com/api/pc.Texture.html#height'
    }, {
        title: 'depth',
        description: 'Bits per pixel.'
    }, {
        title: 'alpha',
        description: 'If picture has alpha data.'
    }, {
        title: 'interlaced',
        description: 'If picture is Interlaced. This picture (PNG, JPG) format feature is unavailable for WebGL but is available for use in DOM, making pictures to appear before fully loaded, and load progresively.'
    }, {
        title: 'rgbm',
        subTitle: '{Boolean}',
        description: 'Specifies whether the texture contains RGBM-encoded HDR data. Defaults to false.',
        url: 'http://developer.playcanvas.com/api/pc.Texture.html#rgbm'
    }, {
        title: 'filtering',
        subTitle: '{pc.FILTER_*}',
        description: 'This property is exposed as minFilter and magFilter to specify how texture is filtered.',
        url: 'http://developer.playcanvas.com/api/pc.Texture.html#magFilter'
    }, {
        name: 'compression',
        title: 'Compression',
        description: 'Compressed textures load faster and consume much less VRAM on GPU allowing texture intense applications to have bigger scale.'
    }, {
        name: 'compress:alpha',
        title: 'Compress Alpha',
        description: 'If compressed texture should have alpha.'
    }, {
        name: 'compress:original',
        title: 'Original Format',
        description: 'Original file format.'
    }, {
        name: 'compress:dxt',
        title: 'DXT (S3 Texture Compression)',
        description: 'S3TC is widely available on Desktop machines. It is very GZIP friendly, download sizes shown are gzip\'ed. It offers two formats available to WebGL: DXT1 and DXT5. Second has extra alpha available and is twice bigger than DXT1. Texture must be power of two resolution. Compression is Lossy and does leak RGB channel values.'
    }, {
        name: 'compress:pvr',
        title: 'PVTC (PowerVR Texture Compression)',
        description: 'Widely available on iOS devices. It is very GZIP friendly, download sizes shown are gzip\'ed. Version 1 of compresison offers four formats to WebGL, differs in BPP and extra Alpha channel. Texture resolution must be square and power of two otherwise will be upscaled to nearest pot square. This format allows to store alpha. Compression is Lossy and does leak RGB channel values, as well as Alpha channel but much less than RGB.'
    }, {
        name: 'compress:pvrBpp',
        title: 'PVR Bits Per Pixel',
        description: 'Bits Per Pixel to store. With options to store 2 or 4 bits per pixel. 2bpp is twice smaller with worse quality.'
    }, {
        name: 'compress:etc',
        title: 'ETC (Ericsson Texture Compression)',
        description: 'This format covers well some Android devices as well as Destop. It is very GZIP friendly, download sizes shown are gzip\'ed. WebGL exposes support for ETC1 only whcih only stores RGB so this format is not available for storing Alpha channel. It is Lossy and suffers from RGB channel leaking.'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'asset:texture:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-shader-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'asset',
        title: 'Shader',
        subTitle: '{String}',
        description: 'Text containing GLSL to be used in the application.'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'asset:shader:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-font-reference.js */
editor.once('load', function() {
    'use strict';

    var fields = [{
        name: 'asset',
        title: 'FONT',
        subTitle: '{Font}',
        description: 'A Font that can be used to render text using the Text Component.'
    }, {
        name: 'intensity',
        title: 'intensity',
        description: 'Intensity is used to boost the value read from the signed distance field, 0 is no boost, 1 is max boost. This can be useful if the font does not render with clean smooth edges with the default intensity or if you are rendering the font at small font sizes.'
    }, {
        name: 'customRange',
        title: 'CUSTOM CHARACTER RANGE',
        description: 'Add a custom range of characters by entering their Unicode codes in the From and To fields. E.g. to add all basic Latin characters you could enter 0x20 - 0x7e and click the + button.'
    }, {
        name: 'presets',
        title: 'CHARACTER PRESETS',
        description: 'Click on a character preset to add it to the selected font'
    }, {
        name: 'characters',
        title: 'CHARACTERS',
        description: 'All the characters that should be included in the runtime font asset. Note that in order for a character to be included in the runtime font, it must be supported by the source font. Click Process Font after you make changes to the characters.'
    }, {
        name: 'invert',
        title: 'INVERT',
        description: 'Enable this to invert the generated font texture. Click Process Font after changing this option.'
    }, {
        name: 'pxrange',
        title: 'MULTI-CHANNEL SIGNED DISTANCE PIXEL RANGE',
        description: 'Specifies the width of the range around each font glyph between the minimum and maximum representable signed distance, in pixels. Click Process Font after changing this option.'
    }];

    for(var i = 0; i < fields.length; i++) {
        fields[i].name = 'asset:font:' + (fields[i].name || fields[i].title);
        editor.call('attributes:reference:add', fields[i]);
    }
});


/* editor/attributes/attributes-entity.js */
editor.once('load', function() {
    'use strict';

    var panelComponents;

    editor.method('attributes:entity.panelComponents', function() {
        return panelComponents;
    });

    // add component menu
    var menuAddComponent = new ui.Menu();
    var components = editor.call('components:schema');
    var list = editor.call('components:list');
    for(var i = 0; i < list.length; i++) {
        menuAddComponent.append(new ui.MenuItem({
            text: components[list[i]].title,
            value: list[i]
        }));
    }
    menuAddComponent.on('open', function() {
        var items = editor.call('selector:items');

        var legacyAudio = editor.call('settings:project').get('useLegacyAudio');
        for(var i = 0; i < list.length; i++) {
            var different = false;
            var disabled = items[0].has('components.' + list[i]);

            for(var n = 1; n < items.length; n++) {
                if (disabled !== items[n].has('components.' + list[i])) {
                    var different = true;
                    break;
                }
            }
            this.findByPath([ list[i] ]).disabled = different ? false : disabled;

            if (list[i] === 'audiosource')
                this.findByPath([list[i]]).hidden = ! legacyAudio;
        }
    });
    menuAddComponent.on('select', function(path) {
        var items = editor.call('selector:items');
        var component = path[0];
        editor.call('entities:addComponent', items, component);
    });
    editor.call('layout.root').append(menuAddComponent);


    editor.method('attributes:entity:addComponentPanel', function(args) {
        var title = args.title;
        var name = args.name;
        var entities = args.entities;
        var events = [ ];

        // panel
        var panel = editor.call('attributes:addPanel', {
            parent: panelComponents,
            name: title
        });
        panel.class.add('component', 'entity', name);
        // reference
        editor.call('attributes:reference:' + name + ':attach', panel, panel.headerElementTitle);

        // show/hide panel
        var checkingPanel;
        var checkPanel = function() {
            checkingPanel = false;

            var show = entities[0].has('components.' + name);
            for(var i = 1; i < entities.length; i++) {
                if (show !== entities[i].has('components.' + name)) {
                    show = false;
                    break;
                }
            }

            panel.disabled = ! show;
            panel.hidden = ! show;
        };
        var queueCheckPanel = function() {
            if (checkingPanel)
                return;

            checkingPanel = true;
            setTimeout(checkPanel);
        }
        checkPanel();
        for(var i = 0; i < entities.length; i++) {
            events.push(entities[i].on('components.' + name + ':set', queueCheckPanel));
            events.push(entities[i].on('components.' + name + ':unset', queueCheckPanel));
        }
        panel.once('destroy', function() {
            for(var i = 0; i < entities.length; i++)
                events[i].unbind();
        });

        // remove
        var fieldRemove = new ui.Button();

        fieldRemove.hidden = ! editor.call('permissions:write');
        events.push(editor.on('permissions:writeState', function(state) {
            fieldRemove.hidden = ! state;
        }));

        fieldRemove.class.add('component-remove');
        fieldRemove.on('click', function() {
            var records = [ ];

            for(var i = 0; i < entities.length; i++) {
                records.push({
                    get: entities[i].history._getItemFn,
                    value: entities[i].get('components.' + name)
                });

                entities[i].history.enabled = false;
                entities[i].unset('components.' + name);
                entities[i].history.enabled = true;
            }

            editor.call('history:add', {
                name: 'entities.set[components.' + name + ']',
                undo: function() {
                    for(var i = 0; i < records.length; i++) {
                        var item = records[i].get();
                        if (! item)
                            continue;

                        item.history.enabled = false;
                        item.set('components.' + name, records[i].value);
                        item.history.enabled = true;
                    }
                },
                redo: function() {
                    for(var i = 0; i < records.length; i++) {
                        var item = records[i].get();
                        if (! item)
                            continue;

                        item.history.enabled = false;
                        item.unset('components.' + name);
                        item.history.enabled = true;
                    }
                }
            });
        });
        panel.headerAppend(fieldRemove);

        // enable/disable
        var fieldEnabled = editor.call('attributes:addField', {
            panel: panel,
            type: 'checkbox',
            link: entities,
            path: 'components.' + name + '.enabled'
        });
        fieldEnabled.class.remove('tick');
        fieldEnabled.class.add('component-toggle');
        fieldEnabled.element.parentNode.removeChild(fieldEnabled.element);
        panel.headerAppend(fieldEnabled);

        // toggle-label
        var labelEnabled = new ui.Label();
        labelEnabled.renderChanges = false;
        labelEnabled.class.add('component-toggle-label');
        panel.headerAppend(labelEnabled);
        labelEnabled.text = fieldEnabled.value ? 'On' : 'Off';
        fieldEnabled.on('change', function(value) {
            labelEnabled.text = value ? 'On' : 'Off';
        });

        return panel;
    });


    var items = null;
    var argsList = [ ];
    var argsFieldsChanges = [ ];


    // initialize fields
    var initialize = function() {
        items = { };

        // panel
        var panel = items.panel = editor.call('attributes:addPanel');
        panel.class.add('component');


        // enabled
        var argsEnabled = {
            parent: panel,
            name: 'Enabled',
            type: 'checkbox',
            path: 'enabled'
        };
        items.fieldEnabled = editor.call('attributes:addField', argsEnabled);
        editor.call('attributes:reference:attach', 'entity:enabled', items.fieldEnabled.parent.innerElement.firstChild.ui);
        argsList.push(argsEnabled);
        argsFieldsChanges.push(items.fieldEnabled);


        // name
        var argsName = {
            parent: panel,
            name: 'Name',
            type: 'string',
            trim: true,
            path: 'name'
        };
        items.fieldName = editor.call('attributes:addField', argsName);
        items.fieldName.class.add('entity-name');
        editor.call('attributes:reference:attach', 'entity:name', items.fieldName.parent.innerElement.firstChild.ui);
        argsList.push(argsName);
        argsFieldsChanges.push(items.fieldName);


        // tags
        var argsTags = {
            parent: panel,
            name: 'Tags',
            placeholder: 'Add Tag',
            type: 'strings',
            path: 'tags'
        };
        items.fieldTags = editor.call('attributes:addField', argsTags);
        editor.call('attributes:reference:attach', 'entity:tags', items.fieldTags.parent.parent.innerElement.firstChild.ui);
        argsList.push(argsTags);


        // position
        var argsPosition = {
            parent: panel,
            name: 'Position',
            placeholder: [ 'X', 'Y', 'Z' ],
            precision: 3,
            step: 0.05,
            type: 'vec3',
            path: 'position'
        };
        items.fieldPosition = editor.call('attributes:addField', argsPosition);
        editor.call('attributes:reference:attach', 'entity:position', items.fieldPosition[0].parent.innerElement.firstChild.ui);
        argsList.push(argsPosition);
        argsFieldsChanges = argsFieldsChanges.concat(items.fieldPosition);

        // rotation
        var argsRotation = {
            parent: panel,
            name: 'Rotation',
            placeholder: [ 'X', 'Y', 'Z' ],
            precision: 2,
            step: 0.1,
            type: 'vec3',
            path: 'rotation'
        };
        items.fieldRotation = editor.call('attributes:addField', argsRotation);
        editor.call('attributes:reference:attach', 'entity:rotation', items.fieldRotation[0].parent.innerElement.firstChild.ui);
        argsList.push(argsRotation);
        argsFieldsChanges = argsFieldsChanges.concat(items.fieldRotation);


        // scale
        var argsScale = {
            parent: panel,
            name: 'Scale',
            placeholder: [ 'X', 'Y', 'Z' ],
            precision: 3,
            step: 0.05,
            type: 'vec3',
            path: 'scale'
        };
        items.fieldScale = editor.call('attributes:addField', argsScale);
        editor.call('attributes:reference:attach', 'entity:scale', items.fieldScale[0].parent.innerElement.firstChild.ui);
        argsList.push(argsScale);
        argsFieldsChanges = argsFieldsChanges.concat(items.fieldScale);


        // components
        panelComponents = items.panelComponents = editor.call('attributes:addPanel');

        // add component
        var btnAddComponent = items.btnAddComponent = new ui.Button();

        btnAddComponent.hidden = ! editor.call('permissions:write');
        editor.on('permissions:writeState', function(state) {
            btnAddComponent.hidden = ! state;
        });

        btnAddComponent.text = 'Add Component';
        btnAddComponent.class.add('add-component');
        btnAddComponent.on('click', function(evt) {
            menuAddComponent.position(evt.clientX, evt.clientY);
            menuAddComponent.open = true;
        });
        panel.append(btnAddComponent);
    };

    // before clearing inspector, preserve elements
    editor.on('attributes:beforeClear', function() {
        if (! items || ! items.panel.parent)
            return;

        // remove panel from inspector
        items.panel.parent.remove(items.panel);

        // clear components
        items.panelComponents.parent.remove(items.panelComponents);
        items.panelComponents.clear();

        // unlink fields
        for(var i = 0; i < argsList.length; i++) {
            argsList[i].link = null;
            argsList[i].unlinkField();
        }
    });

    var inspectEvents = [];

    // link data to fields when inspecting
    editor.on('attributes:inspect[entity]', function(entities) {
        if (entities.length > 1) {
            editor.call('attributes:header', entities.length + ' Entities');
        } else {
            editor.call('attributes:header', 'Entity');
        }

        if (! items)
            initialize();

        var root = editor.call('attributes.rootPanel');

        if (! items.panel.parent)
            root.append(items.panel);

        if (! items.panelComponents.parent)
            root.append(items.panelComponents);

        // disable renderChanges
        for(var i = 0; i < argsFieldsChanges.length; i++)
            argsFieldsChanges[i].renderChanges = false;

        // link fields
        for(var i = 0; i < argsList.length; i++) {
            argsList[i].link = entities;
            argsList[i].linkField();
        }

        // enable renderChanges
        for(var i = 0; i < argsFieldsChanges.length; i++)
            argsFieldsChanges[i].renderChanges = true;

        // disable fields if needed
        toggleFields(entities);

        onInspect(entities);
    });

    editor.on('attributes:clear', function () {
        onUninspect();
    });

    var toggleFields = function (selectedEntities) {
        var disablePosition = false;
        var disableRotation = false;
        var disableScale = false;

        for (var i = 0, len = selectedEntities.length; i < len; i++) {
            // disable rotation / scale for 2D screens
            if (selectedEntities[i].get('components.screen.screenSpace')) {
                disableRotation = true;
                disableScale = true;
            }
        }

        for (var i = 0; i < 3; i++) {
            items.fieldRotation[i].enabled = !disableRotation;
            items.fieldScale[i].enabled = !disableScale;

            items.fieldRotation[i].renderChanges = !disableRotation;
            items.fieldScale[i].renderChanges = !disableScale;
        }

    };

    var onInspect = function (entities) {
        onUninspect();

        var addEvents = function (entity) {
            inspectEvents.push(entity.on('*:set', function (path) {
                if (/components.screen.screenSpace/.test(path)) {
                    toggleFieldsIfNeeded(entity);
                }
            }));
        };

        var toggleFieldsIfNeeded = function (entity) {
            if (editor.call('selector:has', entity))
                toggleFields(editor.call('selector:items'));
        };


        for (var i = 0, len = entities.length; i < len; i++) {
            addEvents(entities[i]);
        }
    };

    var onUninspect = function () {
        for (var i = 0; i < inspectEvents.length; i++) {
            inspectEvents[i].unbind();
        }

        inspectEvents.length = 0;

    };
});


/* editor/attributes/components/attributes-components-animation.js */
editor.once('load', function() {
    'use strict';


    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var app = editor.call('viewport:app');
        if (! app) return; // webgl not available


        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Animation',
            name: 'animation',
            entities: entities
        });

        // animation.assets
        var fieldAssets = editor.call('attributes:addAssetsList', {
            panel: panel,
            title: 'Animation',
            type: 'animation',
            link: entities,
            path: 'components.animation.assets'
        });

        var first = true;
        var initial = true;

        var onAssetAdd = function(item) {
            var btnPlay = new ui.Button();
            btnPlay.class.add('play');
            btnPlay.on('click', function(evt) {
                evt.stopPropagation();

                var id = parseInt(item.asset.get('id'), 10);

                for(var i = 0; i < entities.length; i++) {
                    if (! entities[i].entity || ! entities[i].entity.animation)
                        continue;

                    if (entities[i].entity.animation.assets.indexOf(id) === -1) {
                        entities[i].entity.animation._stopCurrentAnimation();
                        continue;
                    }

                    var name = entities[i].entity.animation.animationsIndex[id];
                    if (! name) continue;

                    entities[i].entity.animation.play(name);
                }
            });
            btnPlay.parent = item;
            item.element.appendChild(btnPlay.element);

            if (first || ! initial) {
                first = false;
                var id = item.asset.get('id');
                var asset = app.assets.get(id);

                var onAssetAdd = function(asset) {
                    if (asset.resource) {
                        editor.once('viewport:update', function() {
                            btnPlay.element.click();
                        });
                    } else {
                        asset.once('load', function() {
                            btnPlay.element.click();
                        });
                    }
                };

                if (asset) {
                    onAssetAdd(asset);
                } else {
                    app.assets.once('add:' + id, onAssetAdd);
                }
            }

            item.once('destroy', function() {
                var id = parseInt(item.asset.get('id'), 10);

                for(var i = 0; i < entities.length; i++) {
                    if (! entities[i].entity || ! entities[i].entity.animation || entities[i].entity.animation.assets.indexOf(id) === -1)
                        continue;

                    var name = entities[i].entity.animation.animationsIndex[id];
                    if (! name || entities[i].entity.animation.currAnim !== name)
                        continue;

                    entities[i].entity.animation._stopCurrentAnimation();
                }
            });
        };

        var nodes = fieldAssets.element.childNodes;
        for(var i = 0; i < nodes.length; i++) {
            if (! nodes[i].ui || ! nodes[i].ui.asset)
                continue;

            onAssetAdd(nodes[i].ui);
        }
        initial = false;

        if (first) {
            first = false;

            for(var i = 0; i < entities.length; i++) {
                if (! entities[i].entity || ! entities[i].entity.animation)
                    continue;

                entities[i].entity.animation._stopCurrentAnimation();
            }
        }

        fieldAssets.on('append', onAssetAdd);

        // animation.speed
        var fieldSpeed = editor.call('attributes:addField', {
            parent: panel,
            name: 'Speed',
            type: 'number',
            precision: 3,
            step: 0.1,
            link: entities,
            path: 'components.animation.speed'
        });
        fieldSpeed.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'animation:speed', fieldSpeed.parent.innerElement.firstChild.ui);

        // intensity slider
        var fieldSpeedSlider = editor.call('attributes:addField', {
            panel: fieldSpeed.parent,
            precision: 3,
            step: 0.1,
            min: -2,
            max: 2,
            type: 'number',
            slider: true,
            link: entities,
            path: 'components.animation.speed'
        });
        fieldSpeedSlider.flexGrow = 4;


        // animation.playback
        var panelPlayback = new ui.Panel();
        editor.call('attributes:addField', {
            parent: panel,
            name: 'Playback',
            type: 'element',
            element: panelPlayback
        });

        // animation.activate
        var fieldActivate = editor.call('attributes:addField', {
            panel: panelPlayback,
            type: 'checkbox',
            link: entities,
            path: 'components.animation.activate'
        });
        // label
        var label = new ui.Label({ text: 'Activate' });
        label.class.add('label-infield');
        label.style.paddingRight = '12px';
        panelPlayback.append(label);
        // reference activate
        editor.call('attributes:reference:attach', 'animation:activate', label);

        // animation.loop
        var fieldLoop = editor.call('attributes:addField', {
            panel: panelPlayback,
            type: 'checkbox',
            link: entities,
            path: 'components.animation.loop'
        });
        // label
        var label = new ui.Label({ text: 'Loop' });
        label.class.add('label-infield');
        panelPlayback.append(label);
        // reference loop
        editor.call('attributes:reference:attach', 'animation:loop', label);
    });
});


/* editor/attributes/components/attributes-components-audiolistener.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Audio Listener',
            name: 'audiolistener',
            entities: entities
        });
    });
});


/* editor/attributes/components/attributes-components-audiosource.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Audio Source',
            name: 'audiosource',
            entities: entities
        });

        // audiosource.assets
        var fieldAssets = editor.call('attributes:addAssetsList', {
            title: 'Audio',
            type: 'audio',
            link: entities,
            panel: panel,
            path: 'components.audiosource.assets'
        });

        // audiosource.playback
        var panelPlayback = new ui.Panel();
        editor.call('attributes:addField', {
            parent: panel,
            name: 'Playback',
            type: 'element',
            element: panelPlayback
        });

        // audiosource.activate
        var fieldActivate = editor.call('attributes:addField', {
            panel: panelPlayback,
            type: 'checkbox',
            link: entities,
            path: 'components.audiosource.activate'
        });
        // label
        var label = new ui.Label({ text: 'Activate' });
        label.class.add('label-infield');
        panelPlayback.append(label);
        // reference
        editor.call('attributes:reference:attach', 'audiosource:activate', label);

        // audiosource.loop
        var fieldLoop = editor.call('attributes:addField', {
            panel: panelPlayback,
            type: 'checkbox',
            link: entities,
            path: 'components.audiosource.loop'
        });
        // label
        var label = new ui.Label({ text: 'Loop' });
        label.class.add('label-infield');
        panelPlayback.append(label);
        // reference
        editor.call('attributes:reference:attach', 'audiosource:loop', label);

        // audiosource.3d
        var field3d = editor.call('attributes:addField', {
            panel: panelPlayback,
            type: 'checkbox',
            link: entities,
            path: 'components.audiosource.3d'
        });
        field3d.on('change', function (value) {
            panelDistance.hidden = fieldRollOffFactor.parent.hidden = ! (field3d.value || field3d.class.contains('null'));
        });
        // label
        label = new ui.Label({ text: '3D' });
        label.class.add('label-infield');
        panelPlayback.append(label);
        // reference
        editor.call('attributes:reference:attach', 'audiosource:3d', label);


        // volume
        var fieldVolume = editor.call('attributes:addField', {
            parent: panel,
            name: 'Volume',
            type: 'number',
            precision: 2,
            step: 0.01,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.audiosource.volume'
        });
        fieldVolume.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'audiosource:volume', fieldVolume.parent.innerElement.firstChild.ui);

        // volume slider
        var fieldVolumeSlider = editor.call('attributes:addField', {
            panel: fieldVolume.parent,
            precision: 2,
            step: 0.01,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: entities,
            path: 'components.audiosource.volume'
        });
        fieldVolumeSlider.flexGrow = 4;

        // pitch
        var fieldPitch = editor.call('attributes:addField', {
            parent: panel,
            name: 'Pitch',
            type: 'number',
            precision: 2,
            step: 0.1,
            min: 0,
            link: entities,
            path: 'components.audiosource.pitch'
        });
        // reference
        editor.call('attributes:reference:attach', 'audiosource:pitch', fieldPitch.parent.innerElement.firstChild.ui);


        // distance
        var panelDistance = editor.call('attributes:addField', {
            parent: panel,
            name: 'Distance'
        });
        var label = panelDistance;
        panelDistance = panelDistance.parent;
        label.destroy();
        panelDistance.hidden = ! (field3d.value || field3d.class.contains('null'));

        // reference
        editor.call('attributes:reference:attach', 'audiosource:distance', panelDistance.innerElement.firstChild.ui);

        // minDistance
        var fieldMinDistance = editor.call('attributes:addField', {
            panel: panelDistance,
            placeholder: 'Min',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            link: entities,
            path: 'components.audiosource.minDistance'
        });
        fieldMinDistance.style.width = '32px';
        fieldMinDistance.flexGrow = 1;

        // maxDistance
        var fieldMaxDistance = editor.call('attributes:addField', {
            panel: panelDistance,
            placeholder: 'Max',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            link: entities,
            path: 'components.audiosource.maxDistance'
        });
        fieldMaxDistance.style.width = '32px';
        fieldMaxDistance.flexGrow = 1;

        // audiosource.rollOffFactor
        var fieldRollOffFactor = editor.call('attributes:addField', {
            parent: panel,
            name: 'Roll-off factor',
            type: 'number',
            precision: 2,
            step: 0.1,
            min: 0,
            link: entities,
            path: 'components.audiosource.rollOffFactor'
        });
        fieldRollOffFactor.parent.hidden = ! (field3d.value || field3d.class.contains('null'));
        // reference
        editor.call('attributes:reference:attach', 'audiosource:rollOffFactor', fieldRollOffFactor.parent.innerElement.firstChild.ui);
    });
});


/* editor/attributes/components/attributes-components-sound.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Sound',
            name: 'sound',
            entities: entities
        });

        // positional
        var fieldPositional = editor.call('attributes:addField', {
            parent: panel,
            type: 'checkbox',
            name: 'Positional',
            link: entities,
            path: 'components.sound.positional'
        });
        // reference
        editor.call('attributes:reference:attach', 'sound:positional', fieldPositional.parent.innerElement.firstChild.ui);

        fieldPositional.on('change', function (value) {
            panelDistance.hidden = fieldDistanceModel.parent.hidden = fieldRollOffFactor.parent.hidden = ! (fieldPositional.value || fieldPositional.class.contains('null'));
        });

        // volume
        var fieldVolume = editor.call('attributes:addField', {
            parent: panel,
            name: 'Volume',
            type: 'number',
            precision: 2,
            step: 0.01,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.sound.volume'
        });
        fieldVolume.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'sound:volume', fieldVolume.parent.innerElement.firstChild.ui);

        // volume slider
        var fieldVolumeSlider = editor.call('attributes:addField', {
            panel: fieldVolume.parent,
            precision: 2,
            step: 0.01,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: entities,
            path: 'components.sound.volume'
        });
        fieldVolumeSlider.flexGrow = 4;

        // pitch
        var fieldPitch = editor.call('attributes:addField', {
            parent: panel,
            name: 'Pitch',
            type: 'number',
            precision: 2,
            step: 0.1,
            min: 0,
            link: entities,
            path: 'components.sound.pitch'
        });
        // reference
        editor.call('attributes:reference:attach', 'sound:pitch', fieldPitch.parent.innerElement.firstChild.ui);


        // distance
        var panelDistance = editor.call('attributes:addField', {
            parent: panel,
            name: 'Distance'
        });
        var label = panelDistance;
        panelDistance = panelDistance.parent;
        label.destroy();
        panelDistance.hidden = ! (fieldPositional.value || fieldPositional.class.contains('null'));

        // reference
        editor.call('attributes:reference:attach', 'sound:distance', panelDistance.innerElement.firstChild.ui);

        // refDistance
        var fieldRefDistance = editor.call('attributes:addField', {
            panel: panelDistance,
            placeholder: 'Ref',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            link: entities,
            path: 'components.sound.refDistance'
        });
        fieldRefDistance.style.width = '32px';
        fieldRefDistance.flexGrow = 1;

        // maxDistance
        var fieldMaxDistance = editor.call('attributes:addField', {
            panel: panelDistance,
            placeholder: 'Max',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            link: entities,
            path: 'components.sound.maxDistance'
        });
        fieldRefDistance.style.width = '32px';
        fieldRefDistance.flexGrow = 1;

        // distanceModel
        var fieldDistanceModel = editor.call('attributes:addField', {
            parent: panel,
            name: 'Distance Model',
            type: 'string',
            enum: {
                linear: 'Linear',
                exponential: 'Exponential',
                inverse: 'Inverse'
            },
            link: entities,
            path: 'components.sound.distanceModel'
        });

        fieldDistanceModel.parent.hidden = ! (fieldPositional.value || fieldPositional.class.contains('null'));

        // reference
        editor.call('attributes:reference:attach', 'sound:distanceModel', fieldDistanceModel.parent.innerElement.firstChild.ui);

        // rollOffFactor
        var fieldRollOffFactor = editor.call('attributes:addField', {
            parent: panel,
            name: 'Roll-off factor',
            type: 'number',
            precision: 2,
            step: 0.1,
            min: 0,
            link: entities,
            path: 'components.sound.rollOffFactor'
        });
        fieldRollOffFactor.parent.hidden = ! (fieldPositional.value || fieldPositional.class.contains('null'));

        // reference
        editor.call('attributes:reference:attach', 'sound:rollOffFactor', fieldRollOffFactor.parent.innerElement.firstChild.ui);

        // show something when multiple entities are enabled for slots
        if (entities.length > 1) {
            editor.call('attributes:addField', {
                parent: panel,
                name: 'Slots',
                value: '...'
            });
        }

        // slots
        var panelSlots = new ui.Panel();
        panelSlots.class.add('sound-slots');
        panel.append(panelSlots);
        panelSlots.hidden = (entities.length > 1);

        // Create UI for each slot
        var createSlot = function (key, slot, focus) {
            // slot panel
            var panelSlot = new ui.Panel(slot.name || 'New Slot' );
            panelSlot.class.add('sound-slot');
            panelSlot.element.id = 'sound-slot-' + key;
            panelSlot.foldable = true;
            panelSlot.folded = false;
            panelSlots.append(panelSlot);

            // reference
            editor.call('attributes:reference:attach', 'sound:slot:slot', panelSlot, panelSlot.headerElementTitle);

            // button to remove slot
            var btnRemove = new ui.Button();
            btnRemove.class.add('remove');
            panelSlot.headerElement.appendChild(btnRemove.element);
            btnRemove.on('click', function () {
                entities[0].unset('components.sound.slots.' + key);
            });

            // slot name
            var fieldSlotName = editor.call('attributes:addField', {
                parent: panelSlot,
                name: 'Name',
                type: 'string'
            });

            // reference
            editor.call('attributes:reference:attach', 'sound:slot:name', fieldSlotName.parent.innerElement.firstChild.ui);

            // set initial value
            fieldSlotName.value = slot.name;

            var suspendKeyUp = false;
            fieldSlotName.elementInput.addEventListener('keyup', function (e) {
                if (suspendKeyUp) return;

                // if the name already exists show error
                var error = false;
                var value = fieldSlotName.value;
                for (var k in slots) {
                    if (k === key) continue;

                    if (slots[k].name === value) {
                        fieldSlotName.class.add('error');
                        return;
                    }
                }

                // no error so make the field go back to normal
                fieldSlotName.class.remove('error');
            });

            var suspend = false;
            // manually change entity on change event
            fieldSlotName.on('change', function (value) {
                // change header to new name
                panelSlot.header = value || 'New Slot';

                if (suspend) return;

                var prevValue = entities[0].get('components.sound.slots.' + key + '.name');
                var slots = entities[0].get('components.sound.slots');
                for (var k in slots) {

                    // revert slot name to previous value
                    if (slots[k].name === value) {
                        suspend = true;
                        suspendKeyUp = true;
                        fieldSlotName.value = prevValue;
                        fieldSlotName.class.remove('error');
                        suspendKeyUp = false;
                        suspend = false;
                        return;
                    }
                }

                entities[0].set('components.sound.slots.' + key + '.name', value);
            });

            // unbind events
            var evtChange = entities[0].on('components.sound.slots.' + key + '.name:set', function (value) {
                suspend = true;
                fieldSlotName.value = value;
                suspend = false;
            });

            var evtUnset = entities[0].on('components.sound.slots.' + key + ':unset', function () {
                if (evtChange) {
                    evtChange.unbind();
                    evtChange = null;
                }

                if (evtUnset) {
                    evtUnset.unbind();
                    evtUnset.unbind();
                }
            });

            panel.on('destroy', function () {
                if (evtChange) {
                    evtChange.unbind();
                    evtChange = null;
                }

                if (evtUnset) {
                    evtUnset.unbind();
                    evtUnset.unbind();
                }
            });

            var fieldSlotAsset = editor.call('attributes:addField', {
                parent: panelSlot,
                name: 'Asset',
                type: 'asset',
                kind: 'audio',
                link: entities,
                path: 'components.sound.slots.' + key + '.asset'
            });

            // reference
            editor.call('attributes:reference:attach', 'sound:slot:asset', fieldSlotAsset._label);

            // range
            var panelRange = editor.call('attributes:addField', {
                parent: panelSlot,
                name: 'Range'
            });
            var label = panelRange;
            panelRange = panelRange.parent;
            label.destroy();

            // startTime
            var fieldSlotStartTime = editor.call('attributes:addField', {
                panel: panelRange,
                placeholder: 'Start',
                type: 'number',
                precision: 2,
                step: 0.01,
                min: 0,
                link: entities,
                path: 'components.sound.slots.' + key + '.startTime'
            });
            fieldSlotStartTime.style.width = '32px';
            fieldSlotStartTime.flexGrow = 1;

            // reference
            editor.call('attributes:reference:attach', 'sound:slot:startTime', fieldSlotStartTime);

            // duration
            var fieldSlotDuration = editor.call('attributes:addField', {
                panel: panelRange,
                placeholder: 'Duration',
                type: 'number',
                precision: 2,
                step: 0.01,
                min: 0,
                link: entities,
                path: 'components.sound.slots.' + key + '.duration'
            });
            fieldSlotDuration.style.width = '32px';
            fieldSlotDuration.flexGrow = 1;

            // reference
            editor.call('attributes:reference:attach', 'sound:slot:duration', fieldSlotDuration);

            // playback
            var panelPlayback = editor.call('attributes:addField', {
                parent: panelSlot,
                name: 'Playback'
            });
            label = panelPlayback;
            panelPlayback = panelPlayback.parent;
            label.destroy();

            var fieldSlotAutoPlay = editor.call('attributes:addField', {
                panel: panelPlayback,
                type: 'checkbox',
                link: entities,
                path: 'components.sound.slots.' + key + '.autoPlay'
            });
            // label
            label = new ui.Label({ text: 'Auto Play' });
            label.class.add('label-infield');
            panelPlayback.append(label);

            // reference
            editor.call('attributes:reference:attach', 'sound:slot:autoPlay', label);

            var fieldSlotOverlap = editor.call('attributes:addField', {
                panel: panelPlayback,
                type: 'checkbox',
                link: entities,
                path: 'components.sound.slots.' + key + '.overlap'
            });
            // label
            label = new ui.Label({ text: 'Overlap' });
            label.class.add('label-infield');
            panelPlayback.append(label);

            // reference
            editor.call('attributes:reference:attach', 'sound:slot:overlap', label);

            var fieldSlotLoop = editor.call('attributes:addField', {
                panel: panelPlayback,
                type: 'checkbox',
                link: entities,
                path: 'components.sound.slots.' + key + '.loop'
            });
            // label
            label = new ui.Label({ text: 'Loop' });
            label.class.add('label-infield');
            panelPlayback.append(label);

            // reference
            editor.call('attributes:reference:attach', 'sound:slot:loop', label);

            // slot volume
            var fieldSlotVolume = editor.call('attributes:addField', {
                parent: panelSlot,
                name: 'Volume',
                type: 'number',
                precision: 2,
                step: 0.01,
                min: 0,
                max: 1,
                link: entities,
                path: 'components.sound.slots.' + key + '.volume'
            });

            // reference
            editor.call('attributes:reference:attach', 'sound:slot:volume', fieldSlotVolume.parent.innerElement.firstChild.ui);

            // volume slider
            var fieldSlotVolumeSlider = editor.call('attributes:addField', {
                panel: fieldSlotVolume.parent,
                precision: 2,
                step: 0.01,
                min: 0,
                max: 1,
                type: 'number',
                slider: true,
                link: entities,
                path: 'components.sound.slots.' + key + '.volume'
            });
            fieldSlotVolume.style.width = '32px';
            fieldSlotVolumeSlider.flexGrow = 4;

            // slot pitch
            var fieldSlotPitch = editor.call('attributes:addField', {
                parent: panelSlot,
                name: 'Pitch',
                type: 'number',
                precision: 2,
                step: 0.1,
                min: 0,
                link: entities,
                path: 'components.sound.slots.' + key + '.pitch'
            });

            // reference
            editor.call('attributes:reference:attach', 'sound:slot:pitch', fieldSlotPitch.parent.innerElement.firstChild.ui);

            if (focus) {
                fieldSlotName.elementInput.focus();
                fieldSlotName.elementInput.select();
            }
        };

        // create slot button
        var btnCreateSlot = new ui.Button({
            text: 'Add Slot'
        });
        btnCreateSlot.class.add('add-sound-slot');
        btnCreateSlot.hidden = entities.length > 1;
        panel.append(btnCreateSlot);

        btnCreateSlot.on('click', function () {
            var keyName = 1;
            var count = 0;
            var idx = {};
            slots = entities[0].get('components.sound.slots');
            for (var key in slots) {
                keyName = parseInt(key, 10);
                idx[slots[key].name] = true;
                count++;
            }

            keyName = keyName + 1;
            name = 'Slot ' + (count + 1);
            while (idx[name]) {
                count++;
                name = 'Slot ' + (count + 1);
            }

            entities[0].set('components.sound.slots.' + (keyName), {
                name: name,
                loop: false,
                autoPlay: false,
                overlap: false,
                asset: null,
                startTime: 0,
                duration: null,
                volume: 1,
                pitch: 1
            });
        });

        // create slots for first entity only
        var slots = entities[0].get('components.sound.slots');
        for (var key in slots) {
            createSlot(key, slots[key]);
        }

        // add event for new slots
        var evtAddSlot = entities[0].on('*:set', function (path, value) {
            var matches = path.match(/^components.sound.slots.(\d+)$/);
            if (! matches) return;

            createSlot(matches[1], value, true);
        });

        // add event for deletings slots
        var evtRemoveSlot = entities[0].on('*:unset', function (path, value) {
            var matches = path.match(/^components.sound.slots.(\d+)$/);
            if (! matches) return;

            var slotPanel = document.getElementById('sound-slot-' + matches[1]);
            if (slotPanel) {
                slotPanel.parentElement.removeChild(slotPanel);
            }
        });

        panel.on('destroy', function () {
            if (evtAddSlot)
                evtAddSlot.unbind();

            if (evtRemoveSlot)
                evtRemoveSlot.unbind();
        });
    });
});


/* editor/attributes/components/attributes-components-camera.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Camera',
            name: 'camera',
            entities: entities
        });


        // clearColorBuffer
        var fieldClearColorBuffer = editor.call('attributes:addField', {
            parent: panel,
            type: 'checkbox',
            name: 'Clear Buffers',
            link: entities,
            path: 'components.camera.clearColorBuffer'
        });
        // label
        var label = new ui.Label({ text: 'Color' });
        label.class.add('label-infield');
        label.style.paddingRight = '12px';
        fieldClearColorBuffer.parent.append(label);
        // reference
        editor.call('attributes:reference:attach', 'camera:clearColorBuffer', label);


        // clearDepthBuffer
        var fieldCastShadows = editor.call('attributes:addField', {
            panel: fieldClearColorBuffer.parent,
            type: 'checkbox',
            link: entities,
            path: 'components.camera.clearDepthBuffer'
        });
        // label
        var label = new ui.Label({ text: 'Depth' });
        label.class.add('label-infield');
        fieldClearColorBuffer.parent.append(label);
        // reference
        editor.call('attributes:reference:attach', 'camera:clearDepthBuffer', label);


        // camera.clearColor
        var fieldClearColor = editor.call('attributes:addField', {
            parent: panel,
            name: 'Clear Color',
            type: 'rgb',
            link: entities,
            path: 'components.camera.clearColor'
        });
        fieldClearColor.parent.hidden = ! (fieldClearColorBuffer.value || fieldClearColorBuffer.class.contains('null'));
        fieldClearColorBuffer.on('change', function(value) {
            fieldClearColor.parent.hidden = ! (value || this.class.contains('null'));
        });
        // reference
        editor.call('attributes:reference:attach', 'camera:clearColor', fieldClearColor.parent.innerElement.firstChild.ui);


        // camera.projection
        var fieldProjection = editor.call('attributes:addField', {
            parent: panel,
            name: 'Projection',
            type: 'number',
            enum: [
                { v: '', t: '...' },
                { v: 0, t: 'Perspective' }, // pc.PROJECTION_PERSPECTIVE
                { v: 1, t: 'Orthographic' } // pc.PROJECTION_ORTHOGRAPHIC
            ],
            link: entities,
            path: 'components.camera.projection'
        });
        // reference
        editor.call('attributes:reference:attach', 'camera:projection', fieldProjection.parent.innerElement.firstChild.ui);

        // frustumCulling
        var fieldFrustumCulling = editor.call('attributes:addField', {
            parent: panel,
            type: 'checkbox',
            name: 'Frustum Culling',
            link: entities,
            path: 'components.camera.frustumCulling'
        });
        // reference
        editor.call('attributes:reference:attach', 'camera:frustumCulling', fieldFrustumCulling.parent.innerElement.firstChild.ui);

        // camera.fov
        var fieldFov = editor.call('attributes:addField', {
            parent: panel,
            name: 'Field of View',
            placeholder: '\u00B0',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            link: entities,
            path: 'components.camera.fov'
        });
        fieldFov.style.width = '32px';
        fieldFov.parent.hidden = fieldProjection.value !== 0 && fieldProjection.value !== '';
        fieldProjection.on('change', function(value) {
            fieldFov.parent.hidden = value !== 0 && value !== '';
        });
        // reference
        editor.call('attributes:reference:attach', 'camera:fov', fieldFov.parent.innerElement.firstChild.ui);

        // fov slider
        var fieldFovSlider = editor.call('attributes:addField', {
            panel: fieldFov.parent,
            precision: 2,
            step: 1,
            min: 0,
            max: 90,
            type: 'number',
            slider: true,
            link: entities,
            path: 'components.camera.fov'
        });
        fieldFovSlider.flexGrow = 4;

        // camera.orthoHeight
        var fieldOrthoHeight = editor.call('attributes:addField', {
            parent: panel,
            name: 'Ortho Height',
            type: 'number',
            link: entities,
            path: 'components.camera.orthoHeight'
        });
        fieldOrthoHeight.parent.hidden = fieldProjection.value !== 1 && fieldProjection.value !== '';
        fieldProjection.on('change', function(value) {
            fieldOrthoHeight.parent.hidden = value !== 1 && value !== '';
        });
        // reference
        editor.call('attributes:reference:attach', 'camera:orthoHeight', fieldOrthoHeight.parent.innerElement.firstChild.ui);


        // nearClip
        var fieldNearClip = editor.call('attributes:addField', {
            parent: panel,
            name: 'Clip',
            placeholder: 'Near',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            link: entities,
            path: 'components.camera.nearClip'
        });
        fieldNearClip.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'camera:clip', fieldNearClip.parent.innerElement.firstChild.ui);


        // farClip
        var fieldFarClip = editor.call('attributes:addField', {
            panel: fieldNearClip.parent,
            placeholder: 'Far',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            link: entities,
            path: 'components.camera.farClip'
        });
        fieldFarClip.style.width = '32px';


        // camera.priority
        var fieldPriority = editor.call('attributes:addField', {
            parent: panel,
            name: 'Priority',
            type: 'number',
            precision: 1,
            step: 1,
            min: 0,
            link: entities,
            path: 'components.camera.priority'
        });
        // reference
        editor.call('attributes:reference:attach', 'camera:priority', fieldPriority.parent.innerElement.firstChild.ui);


        // camera.rect
        var fieldRect = editor.call('attributes:addField', {
            parent: panel,
            name: 'Viewport',
            placeholder: [ 'X', 'Y', 'W', 'H' ],
            type: 'vec4',
            precision: 3,
            step: 0.01,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.camera.rect'
        });
        // reference
        editor.call('attributes:reference:attach', 'camera:rect', fieldRect[0].parent.innerElement.firstChild.ui);
    });
});


/* editor/attributes/components/attributes-components-collision.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var events = [ ];

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Collision',
            name: 'collision',
            entities: entities
        });


        // type
        var fieldType = editor.call('attributes:addField', {
            parent: panel,
            name: 'Type',
            type: 'string',
            enum: {
                '': '...',
                'box': 'Box',
                'sphere': 'Sphere',
                'capsule': 'Capsule',
                'cylinder': 'Cylinder',
                'mesh': 'Mesh'
            },
            link: entities,
            path: 'components.collision.type'
        });
        // reference
        editor.call('attributes:reference:attach', 'collision:type', fieldType.parent.innerElement.firstChild.ui);


        // halfExtents
        var fieldHalfExtents = editor.call('attributes:addField', {
            parent: panel,
            name: 'Half Extents',
            placeholder: [ 'X', 'Y', 'Z' ],
            precision: 3,
            step: 0.1,
            min: 0,
            type: 'vec3',
            link: entities,
            path: 'components.collision.halfExtents'
        });
        fieldHalfExtents[0].parent.hidden = fieldType.value !== 'box' && fieldType.value !== '';
        fieldType.on('change', function(value) {
            fieldHalfExtents[0].parent.hidden = value !== 'box' && value !== '';
        });
        // reference
        editor.call('attributes:reference:attach', 'collision:halfExtents', fieldHalfExtents[0].parent.innerElement.firstChild.ui);


        // radius
        var fieldRadius = editor.call('attributes:addField', {
            parent: panel,
            name: 'Radius',
            type: 'number',
            precision: 2,
            step: 0.1,
            min: 0,
            link: entities,
            path: 'components.collision.radius'
        });
        fieldRadius.parent.hidden = fieldType.value !== '' && [ 'sphere', 'capsule', 'cylinder' ].indexOf(fieldType.value) === -1;
        fieldType.on('change', function(value) {
            fieldRadius.parent.hidden = value !== '' && [ 'sphere', 'capsule', 'cylinder' ].indexOf(value) === -1;
        });
        // reference
        editor.call('attributes:reference:attach', 'collision:radius', fieldRadius.parent.innerElement.firstChild.ui);


        // height
        var fieldHeight = editor.call('attributes:addField', {
            parent: panel,
            name: 'Height',
            type: 'number',
            precision: 2,
            step: 0.1,
            min: 0,
            link: entities,
            path: 'components.collision.height'
        });
        // show/hide
        fieldHeight.parent.hidden = fieldType.value !== '' && [ 'capsule', 'cylinder' ].indexOf(fieldType.value) === -1;
        fieldType.on('change', function(value) {
            fieldHeight.parent.hidden = value !== '' && [ 'capsule', 'cylinder' ].indexOf(value) === -1;
        });
        // reference
        editor.call('attributes:reference:attach', 'collision:height', fieldHeight.parent.innerElement.firstChild.ui);


        // axis
        var fieldAxis = editor.call('attributes:addField', {
            parent: panel,
            name: 'Axis',
            type: 'number',
            enum: [
                { v: '', t: '...' },
                { v: 0, t: 'X' },
                { v: 1, t: 'Y' },
                { v: 2, t: 'Z' }
            ],
            link: entities,
            path: 'components.collision.axis'
        });
        fieldAxis.parent.hidden = fieldType.value !== '' && [ 'capsule', 'cylinder' ].indexOf(fieldType.value) === -1;
        fieldType.on('change', function(value) {
            fieldAxis.parent.hidden = value !== '' && [ 'capsule', 'cylinder' ].indexOf(value) === -1;
        });
        // reference
        editor.call('attributes:reference:attach', 'collision:axis', fieldAxis.parent.innerElement.firstChild.ui);


        // asset
        var fieldAsset = editor.call('attributes:addField', {
            parent: panel,
            name: 'Asset',
            type: 'asset',
            kind: 'model',
            link: entities,
            path: 'components.collision.asset'
        });
        fieldAsset.parent.hidden = fieldType.value !== '' && fieldType.value !== 'mesh';
        fieldType.on('change', function(value) {
            fieldAsset.parent.hidden = value !== '' && value !== 'mesh';
        });
        // reference
        editor.call('attributes:reference:attach', 'collision:asset', fieldAsset._label);
    });
});


/* editor/attributes/components/attributes-components-light.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        // if (entities.length !== 1)
        //     return;

        // var entity = entities[0];

        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var events = [ ];

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Light',
            name: 'light',
            entities: entities
        });


        // type
        var fieldType = editor.call('attributes:addField', {
            parent: panel,
            name: 'Type',
            type: 'string',
            enum: {
                '': '...',
                'directional': 'Directional',
                'spot': 'Spot',
                'point': 'Point'
            },
            link: entities,
            path: 'components.light.type'
        });
        // reference
        editor.call('attributes:reference:attach', 'light:type', fieldType.parent.innerElement.firstChild.ui);


        // color
        var fieldColor = editor.call('attributes:addField', {
            parent: panel,
            name: 'Color',
            type: 'rgb',
            link: entities,
            path: 'components.light.color'
        });
        // reference
        editor.call('attributes:reference:attach', 'light:color', fieldColor.parent.innerElement.firstChild.ui);


        // intensity
        var fieldIntensity = editor.call('attributes:addField', {
            parent: panel,
            name: 'Intensity',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            max: 32,
            link: entities,
            path: 'components.light.intensity'
        });
        fieldIntensity.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'light:intensity', fieldIntensity.parent.innerElement.firstChild.ui);

        // intensity slider
        var fieldIntensitySlider = editor.call('attributes:addField', {
            panel: fieldIntensity.parent,
            precision: 2,
            step: .1,
            min: 0,
            max: 32,
            type: 'number',
            slider: true,
            link: entities,
            path: 'components.light.intensity'
        });
        fieldIntensitySlider.flexGrow = 4;


        // range
        var fieldRange = editor.call('attributes:addField', {
            parent: panel,
            name: 'Range',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            link: entities,
            path: 'components.light.range'
        });
        fieldRange.parent.hidden = ! (fieldType.value === '' || fieldType.value !== 'directional');
        fieldType.on('change', function(value) {
            fieldRange.parent.hidden = ! (value === '' || value !== 'directional');
        });
        // reference
        editor.call('attributes:reference:attach', 'light:range', fieldRange.parent.innerElement.firstChild.ui);


        // falloffMode
        var fieldFalloffMode = editor.call('attributes:addField', {
            parent: panel,
            name: 'Falloff Mode',
            type: 'number',
            enum: {
                0: 'Linear',
                1: 'Inverse Squared'
            },
            link: entities,
            path: 'components.light.falloffMode'
        });
        fieldFalloffMode.parent.hidden = ! (fieldType.value === '' || fieldType.value !== 'directional');
        fieldType.on('change', function(value) {
            fieldFalloffMode.parent.hidden = ! (value === '' || value !== 'directional');
        });
        // reference
        editor.call('attributes:reference:attach', 'light:falloffMode', fieldFalloffMode.parent.innerElement.firstChild.ui);


        // innerConeAngle
        var fieldInnerConeAngle = editor.call('attributes:addField', {
            parent: panel,
            name: 'Cone Angles',
            placeholder: 'Inner',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            max: 90,
            link: entities,
            path: 'components.light.innerConeAngle'
        });
        fieldInnerConeAngle.style.width = '32px';
        fieldInnerConeAngle.parent.hidden = ! (fieldType.value === '' || fieldType.value === 'spot');
        fieldType.on('change', function(value) {
            fieldInnerConeAngle.parent.hidden = ! (value === '' || value === 'spot');
        });
        // reference
        editor.call('attributes:reference:attach', 'light:coneAngles', fieldInnerConeAngle.parent.innerElement.firstChild.ui);


        // outerConeAngle
        var fieldOuterConeAngle = editor.call('attributes:addField', {
            panel: fieldInnerConeAngle.parent,
            placeholder: 'Outer',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            max: 90,
            link: entities,
            path: 'components.light.outerConeAngle'
        });
        fieldOuterConeAngle.style.width = '32px';


        // divider
        var divider = document.createElement('div');
        divider.classList.add('fields-divider');
        panel.append(divider);


        // isStatic
        var fieldIsStatic = editor.call('attributes:addField', {
            parent: panel,
            name: 'States',
            type: 'checkbox',
            link: entities,
            path: 'components.light.isStatic'
        });
        // label
        var label = new ui.Label({ text: 'Static' });
        label.class.add('label-infield');
        label.style.paddingRight = '12px';
        fieldIsStatic.parent.append(label);
        // reference
        editor.call('attributes:reference:attach', 'light:isStatic', label);


        // bake
        var fieldLightMap = editor.call('attributes:addField', {
            parent: panel,
            name: 'Lightmap',
            type: 'checkbox',
            link: entities,
            path: 'components.light.bake'
        });
        // label
        var label = new ui.Label({ text: 'Bake' });
        label.class.add('label-infield');
        fieldLightMap.parent.append(label);
        // reference
        editor.call('attributes:reference:attach', 'light:bake', label);


        // bakeDir
        var fieldLightMapDirection = editor.call('attributes:addField', {
            parent: fieldLightMap.parent,
            type: 'checkbox',
            link: entities,
            path: 'components.light.bakeDir'
        });
        // label
        var labelLightMapDirection = new ui.Label({ text: 'Direction' });
        labelLightMapDirection.class.add('label-infield');
        fieldLightMapDirection.parent.append(labelLightMapDirection);
        // reference
        editor.call('attributes:reference:attach', 'light:bakeDir', labelLightMapDirection);
        var checkLightMapDir = function() {
            fieldLightMapDirection.disabled = labelLightMapDirection.disabled = ! fieldLightMap.value;
        };
        fieldLightMap.on('change', checkLightMapDir);
        checkLightMapDir();


        // affectDynamic
        var fieldAffectDynamic = editor.call('attributes:addField', {
            parent: panel,
            name: 'Affect',
            type: 'checkbox',
            link: entities,
            path: 'components.light.affectDynamic'
        });
        // label
        var label = new ui.Label({ text: 'Non-Baked' });
        label.class.add('label-infield');
        label.style.paddingRight = '12px';
        fieldAffectDynamic.parent.append(label);
        // reference
        editor.call('attributes:reference:attach', 'light:affectDynamic', label);


        // affectLightmapped
        var fieldAffectLightmapped = editor.call('attributes:addField', {
            panel: fieldAffectDynamic.parent,
            type: 'checkbox',
            link: entities,
            path: 'components.light.affectLightmapped'
        });
        // label
        var labelBaked = new ui.Label({ text: 'Baked' });
        labelBaked.class.add('label-infield');
        fieldAffectDynamic.parent.append(labelBaked);
        // reference
        editor.call('attributes:reference:attach', 'light:affectLightmapped', labelBaked);
        // disable/enable affectLightmapped flag
        fieldAffectLightmapped.disabled = labelBaked.disabled = !! fieldLightMap.value;
        fieldLightMap.on('change', function() {
            fieldAffectLightmapped.disabled = labelBaked.disabled = !! fieldLightMap.value;
        });


        // divider
        var divider = document.createElement('div');
        divider.classList.add('fields-divider');
        panel.append(divider);


        // castShadows
        var fieldCastShadows = editor.call('attributes:addField', {
            parent: panel,
            name: 'Shadows',
            type: 'checkbox',
            link: entities,
            path: 'components.light.castShadows'
        });
        // reference
        editor.call('attributes:reference:attach', 'light:castShadows', fieldCastShadows.parent.innerElement.firstChild.ui);


        // shadows panel
        var panelShadows = editor.call('attributes:addPanel', {
            parent: panel
        });
        panelShadows.hidden = ! fieldCastShadows.value && ! fieldCastShadows.class.contains('null');
        fieldCastShadows.on('change', function(value) {
            panelShadows.hidden = ! value && ! this.class.contains('null');
        });


        // shadowUpdateMode
        var fieldShadowUpdateMode = editor.call('attributes:addField', {
            parent: panelShadows,
            name: 'Update Mode',
            type: 'number',
            enum: [
                { v: '', t: '...' },
                { v: pc.SHADOWUPDATE_THISFRAME, t: 'Once' },
                { v: pc.SHADOWUPDATE_REALTIME, t: 'Realtime' }
            ],
            link: entities,
            path: 'components.light.shadowUpdateMode'
        });
        // reference
        editor.call('attributes:reference:attach', 'light:shadowUpdateMode', fieldShadowUpdateMode.parent.innerElement.firstChild.ui);

        var updateFieldShadowUpdateMode = function() {
            fieldShadowUpdateMode.parent.hidden = fieldLightMap.value && ! fieldAffectDynamic.value && ! fieldLightMap.class.contains('null') && ! fieldAffectDynamic.class.contains('null');
        };
        fieldLightMap.on('change', updateFieldShadowUpdateMode);
        fieldAffectDynamic.on('change', updateFieldShadowUpdateMode);


        // updateShadow button
        var btnUpdateShadow = new ui.Button({
            text: '&#57640;'
        });
        btnUpdateShadow.class.add('shadowUpdate');
        btnUpdateShadow.hidden = fieldShadowUpdateMode.value !== pc.SHADOWUPDATE_THISFRAME && !! fieldShadowUpdateMode.value;
        fieldShadowUpdateMode.parent.append(btnUpdateShadow);
        fieldShadowUpdateMode.on('change', function() {
            btnUpdateShadow.hidden = fieldShadowUpdateMode.value !== pc.SHADOWUPDATE_THISFRAME && !! fieldShadowUpdateMode.value;
        });
        btnUpdateShadow.on('click', function() {
            for(var i = 0; i < entities.length; i++) {
                if (entities[i].entity && entities[i].entity.light && entities[i].entity.light.shadowUpdateMode === pc.SHADOWUPDATE_THISFRAME)
                    entities[i].entity.light.light.shadowUpdateMode = pc.SHADOWUPDATE_THISFRAME;
            }
            editor.call('viewport:render');
        });
        var updateShadowTooltip = Tooltip.attach({
            target: btnUpdateShadow.element,
            text: 'Update',
            align: 'bottom',
            root: editor.call('layout.root')
        });
        btnUpdateShadow.once('destroy', function() {
            updateShadowTooltip.destroy();
        });


        // shadowResolution
        var fieldShadowResolution = editor.call('attributes:addField', {
            parent: panelShadows,
            name: 'Resolution',
            type: 'number',
            enum: [
                { v: '', t: '...' },
                { v: 16, t: '16 x 16' },
                { v: 32, t: '32 x 32' },
                { v: 64, t: '64 x 64' },
                { v: 128, t: '128 x 128' },
                { v: 256, t: '256 x 256' },
                { v: 512, t: '512 x 512' },
                { v: 1024, t: '1024 x 1024' },
                { v: 2048, t: '2048 x 2048' },
                { v: 4096, t: '4096 x 4096' }
            ],
            link: entities,
            path: 'components.light.shadowResolution'
        });
        // reference
        editor.call('attributes:reference:attach', 'light:shadowResolution', fieldShadowResolution.parent.innerElement.firstChild.ui);


        // shadowDistance
        var fieldShadowDistance = editor.call('attributes:addField', {
            parent: panelShadows,
            name: 'Distance',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            link: entities,
            path: 'components.light.shadowDistance'
        });
        fieldShadowDistance.parent.hidden = ! (fieldType.value === '' || fieldType.value === 'directional');
        fieldType.on('change', function(value) {
            fieldShadowDistance.parent.hidden = ! (value === '' || value === 'directional');
        });
        // reference
        editor.call('attributes:reference:attach', 'light:shadowDistance', fieldShadowDistance.parent.innerElement.firstChild.ui);


        // shadowType
        var fieldShadowType = editor.call('attributes:addField', {
            parent: panelShadows,
            name: 'Shadow Type',
            type: 'number',
            enum: [
                { v: '', t: '...' },
                { v: 0, t: 'Shadow Map PCF 3x3' },
                { v: 4, t: 'Shadow Map PCF 5x5' },
                { v: 1, t: 'Variance Shadow Map (8bit)' },
                { v: 2, t: 'Variance Shadow Map (16bit)' },
                { v: 3, t: 'Variance Shadow Map (32bit)' }
            ],
            link: entities,
            path: 'components.light.shadowType'
        });
        // reference
        editor.call('attributes:reference:attach', 'light:shadowType', fieldShadowType.parent.innerElement.firstChild.ui);

        // vsmBlurMode
        var fieldShadowVsmBlurMode = editor.call('attributes:addField', {
            parent: panelShadows,
            name: 'VSM Blur Mode',
            type: 'number',
            enum: [
                { v: '', t: '...' },
                { v: 0, t: 'Box' },
                { v: 1, t: 'Gaussian' }
            ],
            link: entities,
            path: 'components.light.vsmBlurMode'
        });
        // reference
        editor.call('attributes:reference:attach', 'light:vsmBlurMode', fieldShadowVsmBlurMode.parent.innerElement.firstChild.ui);
        //
        fieldShadowVsmBlurMode.parent.hidden = fieldShadowType.value === 0 || fieldShadowType.value === 4;
        fieldShadowType.on('change', function() {
            fieldShadowVsmBlurMode.parent.hidden = fieldShadowType.value === 0 || fieldShadowType.value === 4;
        });

        // vsmBlurSize
        var fieldShadowVsmBlurSize = editor.call('attributes:addField', {
            parent: panelShadows,
            name: 'VSM Blur Size',
            type: 'number',
            min: 1,
            max: 25,
            link: entities,
            path: 'components.light.vsmBlurSize'
        });
        fieldShadowVsmBlurSize.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'light:vsmBlurSize', fieldShadowVsmBlurSize.parent.innerElement.firstChild.ui);
        //
        fieldShadowVsmBlurSize.parent.hidden = fieldShadowType.value === 0 || fieldShadowType.value === 4;
        fieldShadowType.on('change', function() {
            fieldShadowVsmBlurSize.parent.hidden = fieldShadowType.value === 0 || fieldShadowType.value === 4;
        });
        // vsmBlurSize slider
        var fieldShadowVsmBlurSizeSlider = editor.call('attributes:addField', {
            panel: fieldShadowVsmBlurSize.parent,
            precision: 0,
            step: 1,
            min: 1,
            max: 25,
            type: 'number',
            slider: true,
            link: entities,
            path: 'components.light.vsmBlurSize'
        });
        fieldShadowVsmBlurSizeSlider.flexGrow = 4;


        // vsmBias
        var fieldVsmBias = editor.call('attributes:addField', {
            parent: panelShadows,
            name: 'VSM Bias',
            type: 'number',
            precision: 4,
            step: .001,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.light.vsmBias'
        });
        // reference
        editor.call('attributes:reference:attach', 'light:vsmBias', fieldVsmBias.parent.innerElement.firstChild.ui);
        //
        fieldVsmBias.parent.hidden = fieldShadowType.value === 0 || fieldShadowType.value === 4;
        fieldShadowType.on('change', function() {
            fieldVsmBias.parent.hidden = fieldShadowType.value === 0 || fieldShadowType.value === 4;
        });


        // shadowBias
        var fieldShadowBias = editor.call('attributes:addField', {
            parent: panelShadows,
            name: 'Bias',
            type: 'number',
            precision: 4,
            step: .001,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.light.shadowBias'
        });
        fieldShadowBias.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'light:shadowBias', fieldShadowBias.parent.innerElement.firstChild.ui);
        //
        fieldShadowBias.parent.hidden = fieldShadowType.value !== 0 && fieldShadowType.value !== 4;
        fieldShadowType.on('change', function() {
            fieldShadowBias.parent.hidden = fieldShadowType.value !== 0 && fieldShadowType.value !== 4;
        });


        // normalOffsetBias
        var fieldShadowBiasNormalOffset = editor.call('attributes:addField', {
            panel: fieldShadowBias.parent,
            type: 'number',
            placeholder: 'Normal Offset',
            precision: 3,
            step: .001,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.light.normalOffsetBias'
        });
        fieldShadowBiasNormalOffset.style.width = '32px';
        fieldShadowBiasNormalOffset.flexGrow = 2;
        // reference
        editor.call('attributes:reference:attach', 'light:normalOffsetBias', fieldShadowBiasNormalOffset);


        // divider
        var dividerCookie = document.createElement('div');
        dividerCookie.classList.add('fields-divider');
        panel.append(dividerCookie);
        if (fieldType.value === 'directional')
            dividerCookie.classList.add('hidden');


        // asset
        var argsCookie = {
            parent: panel,
            name: 'Cookie',
            type: 'asset',
            kind: fieldType.value === 'point' ? 'cubemap' : 'texture',
            link: entities,
            path: 'components.light.cookieAsset'
        };
        var fieldCookie = editor.call('attributes:addField', argsCookie);
        fieldCookie.parent.hidden = fieldType.value === 'directional';
        fieldCookie.parent.class.add('channel');
        fieldType.on('change', function(value) {
            fieldCookie.parent.hidden = fieldType.value === 'directional';
            argsCookie.kind = fieldType.value === 'point' ? 'cubemap' : 'texture';
            if (fieldCookie.parent.hidden) {
                dividerCookie.classList.add('hidden');
            } else {
                dividerCookie.classList.remove('hidden');
            }
        });
        // reference
        editor.call('attributes:reference:attach', 'light:cookieAsset', fieldCookie.parent.innerElement.firstChild.ui);


        // cookies panel
        var panelCookie = editor.call('attributes:addPanel', {
            parent: panel
        });
        var updatePanelCookie = function() {
            panelCookie.hidden = (! fieldCookie.value && ! fieldCookie.class.contains('null')) || fieldType.value === 'directional';
        };
        updatePanelCookie();
        fieldCookie.on('change', updatePanelCookie);
        fieldType.on('change', updatePanelCookie);


        // cookieIntensity
        var fieldCookieIntensity = editor.call('attributes:addField', {
            parent: panelCookie,
            name: 'Intensity',
            type: 'number',
            min: 0,
            max: 1,
            link: entities,
            path: 'components.light.cookieIntensity'
        });
        fieldCookieIntensity.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'light:cookieIntensity', fieldCookieIntensity.parent.innerElement.firstChild.ui);

        // cookieIntensity slider
        var fieldCookieIntensitySlider = editor.call('attributes:addField', {
            panel: fieldCookieIntensity.parent,
            precision: 3,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: entities,
            path: 'components.light.cookieIntensity'
        });
        fieldCookieIntensitySlider.flexGrow = 4;


        // cookieAngle
        var fieldCookieAngle = editor.call('attributes:addField', {
            parent: panelCookie,
            name: 'Angle',
            type: 'number',
            placeholder: '',
            min: 0,
            max: 360.0,
            link: entities,
            path: 'components.light.cookieAngle'
        });
        fieldCookieAngle.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'light:cookieAngle', fieldCookieAngle.parent.innerElement.firstChild.ui);

        // cookieAngle slider
        var fieldCookieAngleSlider = editor.call('attributes:addField', {
            panel: fieldCookieAngle.parent,
            precision: 1,
            min: 0,
            max: 360.0,
            type: 'number',
            slider: true,
            link: entities,
            path: 'components.light.cookieAngle'
        });
        fieldCookieAngleSlider.flexGrow = 4;

        // cookieOffset
        var fieldCookieOffset = editor.call('attributes:addField', {
            parent: panelCookie,
            name: 'Offset',
            type: 'vec2',
            step: 0.01,
            precision: 3,
            placeholder: [ 'U', 'V' ],
            link: entities,
            path: 'components.light.cookieOffset'
        });
        // reference
        editor.call('attributes:reference:attach', 'light:cookieOffset', fieldCookieOffset[0].parent.innerElement.firstChild.ui);


        // cookieScale
        var fieldCookieScale = editor.call('attributes:addField', {
            parent: panelCookie,
            name: 'Scale',
            type: 'vec2',
            step: 0.01,
            precision: 3,
            placeholder: [ 'U', 'V' ],
            link: entities,
            path: 'components.light.cookieScale'
        });
        // reference
        editor.call('attributes:reference:attach', 'light:cookieScale', fieldCookieScale[0].parent.innerElement.firstChild.ui);

        var updateCookieParams = function() {
            var hidden = panelCookie.hidden || fieldType.value === 'point';
            fieldCookieAngle.parent.hidden = hidden;
            fieldCookieOffset[0].parent.hidden = hidden;
            fieldCookieScale[0].parent.hidden = hidden;
        };
        updateCookieParams();
        fieldType.on('change', updateCookieParams);


        // cookieFalloff
        var fieldCookieFalloff = editor.call('attributes:addField', {
            parent: panelCookie,
            name: 'Falloff',
            type: 'checkbox',
            link: entities,
            path: 'components.light.cookieFalloff'
        });
        fieldCookieFalloff.parent.hidden = fieldType.value !== 'spot';
        fieldType.on('change', function() {
            fieldCookieFalloff.parent.hidden = fieldType.value !== 'spot';
        });
        // reference
        editor.call('attributes:reference:attach', 'light:cookieFalloff', fieldCookieFalloff.parent.innerElement.firstChild.ui);


        // map channel
        var fieldCookieChannel = editor.call('attributes:addField', {
            panel: fieldCookie.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A',
                'rgb': 'RGB'
            },
            link: entities,
            path: 'components.light.cookieChannel'
        });
        fieldCookieChannel.element.parentNode.removeChild(fieldCookieChannel.element);
        fieldCookie.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldCookieChannel.element);
        // reference
        editor.call('attributes:reference:attach', 'light:cookieChannel', fieldCookieChannel);

    });
});


/* editor/attributes/components/attributes-components-model.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var app = editor.call('viewport:app');
        if (! app) return; // webgl not available

        var events = [ ];

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Model',
            name: 'model',
            entities: entities
        });


        // type
        var fieldType = editor.call('attributes:addField', {
            parent: panel,
            name: 'Type',
            type: 'string',
            enum: {
                '': '...',
                'asset': 'Asset',
                'box': 'Box',
                'capsule': 'Capsule',
                'sphere': 'Sphere',
                'cylinder': 'Cylinder',
                'cone': 'Cone',
                'plane': 'Plane'
            },
            link: entities,
            path: 'components.model.type'
        });
        fieldType.on('change', function(value) {
            fieldAsset.parent.hidden = value !== 'asset';
            fieldMaterial.parent.hidden = value === 'asset';
            toggleMaterials();
        });
        // reference
        editor.call('attributes:reference:attach', 'model:type', fieldType.parent.innerElement.firstChild.ui);


        // asset
        var fieldAsset = editor.call('attributes:addField', {
            parent: panel,
            name: 'Model',
            type: 'asset',
            kind: 'model',
            link: entities,
            path: 'components.model.asset'
        });
        fieldAsset.parent.hidden = fieldType.value !== 'asset';
        // reference
        editor.call('attributes:reference:attach', 'model:asset', fieldAsset._label);

        var changingAsset = false;

        // if the assets changes then remove material overrides
        fieldAsset.on('beforechange', function (value) {
            var resourceIds = [];
            var mappings = {};

            entities.forEach(function (entity) {
                if (entity.has('components.model.mapping') && entity.get('components.model.asset') !== parseInt(value, 10)) {
                    resourceIds.push(entity.get('resource_id'));
                    mappings[entity.get('resource_id')] = entity.get('components.model.mapping');
                }
            });

            fieldAsset.once('change', function (value) {
                if (changingAsset) return;

                changingAsset = true;

                // modify last history action to include changing
                // the mapping
                var lastHistoryAction = editor.call('history:list')[editor.call('history:current')];
                var lastUndo = lastHistoryAction.undo;
                var lastRedo = lastHistoryAction.redo;

                resourceIds.forEach(function (id) {
                    var entity = editor.call('entities:get', id);
                    if (! entity) return;
                    var history = entity.history.enabled;
                    entity.history.enabled = false;
                    entity.unset('components.model.mapping');
                    entity.history.enabled = history;
                });

                lastHistoryAction.undo = function () {
                    changingAsset = true;

                    // execute last actions undo first
                    lastUndo();

                    // do this in a timeout so that the
                    // 'change' event of fieldAsset is fired first
                    setTimeout(function () {
                        resourceIds.forEach(function (id) {
                            var entity = editor.call('entities:get', id);
                            if (! entity) return;

                            var history = entity.history.enabled;
                            entity.history.enabled = false;
                            entity.set('components.model.mapping', mappings[id]);
                            entity.history.enabled = history;
                        });

                        changingAsset = false;
                    });
                };

                lastHistoryAction.redo = function () {
                    changingAsset = true;

                    // execute last actions redo first
                    lastRedo();

                    // do this in a timeout so that the
                    // 'change' event of fieldAsset is fired first
                    setTimeout(function () {
                        resourceIds.forEach(function (id) {
                            var entity = editor.call('entities:get', id);
                            if (! entity) return;

                            var history = entity.history.enabled;
                            entity.history.enabled = false;
                            entity.unset('components.model.mapping');
                            entity.history.enabled = history;
                        });

                        changingAsset = false;
                    });
                };

                changingAsset = false;
            });
        });

        // material
        var fieldMaterial = editor.call('attributes:addField', {
            parent: panel,
            name: 'Material',
            type: 'asset',
            kind: 'material',
            link: entities,
            path: 'components.model.materialAsset'
        });
        fieldMaterial.class.add('material-asset');
        fieldMaterial.parent.hidden = fieldType.value === 'asset';
        // reference
        editor.call('attributes:reference:attach', 'model:materialAsset', fieldMaterial._label);


        // castShadows
        var fieldCastShadows = editor.call('attributes:addField', {
            parent: panel,
            type: 'checkbox',
            name: 'Shadows',
            link: entities,
            path: 'components.model.castShadows'
        });
        // label
        var label = new ui.Label({ text: 'Cast' });
        label.class.add('label-infield');
        label.style.paddingRight = '8px';
        fieldCastShadows.parent.append(label);
        // reference
        editor.call('attributes:reference:attach', 'model:castShadows', label);


        // castShadowsLightmap
        var fieldCastShadowsLightmap = editor.call('attributes:addField', {
            panel: fieldCastShadows.parent,
            type: 'checkbox',
            link: entities,
            path: 'components.model.castShadowsLightmap'
        });
        // label
        var labelCastShadowsLightmap = new ui.Label({ text: 'Cast Lightmap' });
        labelCastShadowsLightmap.class.add('label-infield');
        labelCastShadowsLightmap.style.paddingRight = '8px';
        labelCastShadowsLightmap.style.whiteSpace = 'nowrap';
        fieldCastShadows.parent.append(labelCastShadowsLightmap);
        // reference
        editor.call('attributes:reference:attach', 'model:castShadowsLightmap', labelCastShadowsLightmap);


        // receiveShadows
        var fieldReceiveShadows = editor.call('attributes:addField', {
            panel: fieldCastShadows.parent,
            type: 'checkbox',
            link: entities,
            path: 'components.model.receiveShadows'
        });
        // label
        var label = new ui.Label({ text: 'Receive' });
        label.class.add('label-infield');
        fieldCastShadows.parent.append(label);
        // reference
        editor.call('attributes:reference:attach', 'model:receiveShadows', label);


        // lightmapped
        var fieldIsStatic = editor.call('attributes:addField', {
            parent: panel,
            name: 'States',
            type: 'checkbox',
            link: entities,
            path: 'components.model.isStatic'
        });
        // label
        var label = new ui.Label({ text: 'Static' });
        label.class.add('label-infield');
        fieldIsStatic.parent.append(label);
        label.style.paddingRight = '12px';
        // reference
        editor.call('attributes:reference:attach', 'model:isStatic', label);


        // lightmapped
        var fieldLightmapped = editor.call('attributes:addField', {
            parent: fieldIsStatic.parent,
            type: 'checkbox',
            link: entities,
            path: 'components.model.lightmapped'
        });
        // label
        var label = new ui.Label({ text: 'Lightmapped' });
        label.class.add('label-infield');
        fieldIsStatic.parent.append(label);
        // reference
        editor.call('attributes:reference:attach', 'model:lightmapped', label);
        // uv1 is missing
        var label = new ui.Label({ text: 'UV1 is missing' });
        label.class.add('label-infield');
        label.style.color = '#f66';
        fieldIsStatic.parent.append(label);

        var checkUV1Missing = function() {
            var missing = false;
            for(var i = 0; i < entities.length; i++) {
                var e = entities[i];
                if (! e.has('components.model') || ! e.get('components.model.lightmapped') || e.get('components.model.type') !== 'asset' || ! e.get('components.model.asset'))
                    continue;

                var assetId = e.get('components.model.asset');
                var asset = editor.call('assets:get', assetId);
                if (! asset)
                    continue;

                if (! asset.has('meta.attributes.texCoord1')) {
                    missing = true;
                    break;
                }
            }

            label.hidden = ! missing;
        };
        checkUV1Missing();
        fieldLightmapped.on('change', function() {
            checkUV1Missing();
            collectResolutions();
        });


        // resolution
        var fieldResolution = editor.call('attributes:addField', {
            parent: panel,
            name: 'Lightmap Size',
            value: '?'
        });
        fieldResolution.style.marginBottom = '5px';
        fieldResolution.style.paddingLeft = '0px';
        fieldResolution.style.minWidth = '32px';
        fieldResolution.flexGrow = 0;
        fieldResolution.flexShrink = 0;
        // show/hide
        fieldResolution.parent.hidden = ! fieldLightmapped.value && ! fieldLightmapped.class.contains('null');
        fieldLightmapped.on('change', function() {
            fieldResolution.parent.hidden = ! fieldLightmapped.value && ! fieldLightmapped.class.contains('null');
        });
        // reference
        editor.call('attributes:reference:attach', 'model:resolution', fieldResolution.parent.innerElement.firstChild.ui);

        // calculate resolutions for lightmap
        var collectResolutions = function() {
            var lightmapper = app.lightmapper;
            var min = Infinity;
            var max = -Infinity;

            for(var i = 0; i < entities.length; i++) {
                if (! entities[i].get('components.model.lightmapped') || ! entities[i].entity.model || (! entities[i].entity.model.asset && entities[i].entity.type === 'asset') || (entities[i].entity.model.asset && ! app.assets.get(entities[i].entity.model.asset)))
                    continue;

                var size = lightmapper.calculateLightmapSize(entities[i].entity);

                if (size > max)
                    max = size;

                if (size < min)
                    min = size;
            }

            if (min) {
                fieldResolution.value = (min !== max) ? (min + ' - ' + max) : min;
            } else {
                fieldResolution.value = '?';
            }
        };
        collectResolutions();


        // lightmapSizeMultiplier
        var fieldLightmapSizeMultiplier = editor.call('attributes:addField', {
            panel: fieldResolution.parent,
            placeholder: 'Size Multiplier',
            type: 'number',
            min: 0,
            link: entities,
            path: 'components.model.lightmapSizeMultiplier'
        });
        fieldLightmapSizeMultiplier.on('change', function() {
            collectResolutions();
        });
        // reference
        editor.call('attributes:reference:attach', 'model:lightmapSizeMultiplier', fieldLightmapSizeMultiplier);


        panel.on('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();
        });


        // gather all mappings for all selected entities
        var allMappings = {};
        for (var i = 0, len = entities.length; i < len; i++) {
            var mapping = entities[i].get('components.model.mapping');
            if (mapping) {
                for (var key in mapping) {
                    if (!allMappings[key])
                        allMappings[key] = [entities[i].get('resource_id')];
                    else
                        allMappings[key].push(entities[i].get('resource_id'));
                }
            }
        }

        var panelMaterialButtons = editor.call('attributes:addPanel');
        panelMaterialButtons.class.add('flex', 'component', 'override-material');
        panel.append(panelMaterialButtons);

        var panelMaterials = editor.call('attributes:addPanel');
        panelMaterials.class.add('component', 'override-material');
        panel.append(panelMaterials);

        // check if we should show the override button
        // mainly if all entities have a model component
        // and are referencing an asset
        var toggleMaterials = function ()  {
            var referencedModelAsset = entities[0].get('components.model.asset');
            for (var i = 0, len = entities.length; i < len; i++) {
                if (entities[i].get('components.model.type') !== 'asset' ||
                    entities[i].get('components.model.asset') !== referencedModelAsset) {
                    panelMaterials.hidden = true;
                    panelMaterialButtons.hidden = true;
                    return;
                }
            }

            panelMaterials.hidden = false;
            panelMaterialButtons.hidden = false;
        };

        // turn override panel off / on
        toggleMaterials();

        var assetMaterials = new ui.Button({
            text: 'Asset Materials'
        });
        assetMaterials.disabled = ! editor.call('assets:get', entities[0].get('components.model.asset'));
        events.push(entities[0].on('components.model.asset:set', function(value) {
            assetMaterials.disabled = entityMaterials.disabled = ! value || ! editor.call('assets:get', value);
        }));

        assetMaterials.class.add('override-material');
        panelMaterialButtons.append(assetMaterials);
        assetMaterials.on('click', function () {
            var modelAsset = editor.call('assets:get', entities[0].get('components.model.asset'));
            editor.call('selector:set', 'asset', [modelAsset]);
        });

        // add button to add material override
        var entityMaterials = new ui.Button({
            text: 'Entity Materials'
        });
        entityMaterials.disabled = assetMaterials.disabled;
        entityMaterials.class.add('override-material');
        panelMaterialButtons.append(entityMaterials);

        entityMaterials.on('click', function () {
            editor.call('picker:node', entities);
        });

        // get one of the Entities to use for finding the mesh instances names
        var engineEntity = app.root.findByGuid(entities[0].get('resource_id'));

        var removeOverride = function (index) {
            var resourceIds = [];
            var previous = [];

            entities.forEach(function (entity) {
                resourceIds.push(entity.get('resource_id'));
                var history = entity.history.enabled;
                entity.history.enabled = false;
                previous.push(entity.has('components.model.mapping.' + index) ? entity.get('components.model.mapping.' + index) : undefined);
                entity.unset('components.model.mapping.' + index);
                entity.history.enabled = history;
            });

            editor.call('history:add', {
                name: 'entities.' + (resourceIds.length > 1 ? '*' : resourceIds[0]) + '.components.model.mapping',
                undo: function() {
                    for(var i = 0; i < resourceIds.length; i++) {
                        var item = editor.call('entities:get', resourceIds[i]);
                        if (! item)
                            continue;

                        var history = item.history.enabled;
                        item.history.enabled = false;
                        if (previous[i] === undefined)
                            item.unset('components.model.mapping.' + index);
                        else
                            item.set('components.model.mapping.' + index, previous[i]);

                        item.history.enabled = history;
                    }
                },
                redo: function() {
                    for(var i = 0; i < resourceIds.length; i++) {
                        var item = editor.call('entities:get', resourceIds[i]);
                        if (! item)
                            continue;

                        var history = item.history.enabled;
                        item.history.enabled = false;
                        item.unset('components.model.mapping.' + index);
                        item.history.enabled = history;
                    }
                }
            });
        };

        var addOverride = function (index) {
            var valuesBefore;

            if (! engineEntity.model)
                return;

            var meshInstances = engineEntity.model.meshInstances || [ ];

            var field = editor.call('attributes:addField', {
                parent: panelMaterials,
                type: 'asset',
                kind: 'material',
                name: meshInstances[index] ? meshInstances[index].node.name : 'node ' + index,
                link: entities,
                path: 'components.model.mapping.' + index,
                over: function(type, data) {
                    valuesBefore = entities.map(function (entity) {
                        var path = 'components.model.mapping.' + index;
                        return entity.has(path) ? entity.get(path) : undefined;
                    });

                    entities.forEach(function (entity) {
                        var engineEntity = app.root.findByGuid(entity.get('resource_id'));
                        if (engineEntity) {
                            var mapping = engineEntity.model.mapping;
                            if (engineEntity.model.mapping && engineEntity.model.mapping[index] !== undefined) {
                                mapping[index] = parseInt(data.id, 10);
                                engineEntity.model.mapping = mapping;
                            }
                        }
                    });

                    editor.call('viewport:render');
                },
                leave: function() {
                    if (!valuesBefore) return;

                    entities.forEach(function (entity, i) {
                        var engineEntity = app.root.findByGuid(entity.get('resource_id'));
                        if (engineEntity) {
                            var mapping = engineEntity.model.mapping;
                            if (! mapping) return;

                            if (valuesBefore[i] === undefined) {
                                delete mapping[index];
                            } else {
                                mapping[index] = valuesBefore[i] === null ? null : parseInt(valuesBefore[i], 10);
                            }

                            engineEntity.model.mapping = mapping;
                        }
                    });

                    editor.call('viewport:render');
                }
            });

            field.parent.class.add('node-' + index);

            field.parent.on('click', function () {
                field.parent.class.remove('active');
            });

            // button to remove mapping entry
            var removeButton = new ui.Button({
                text: '&#57636;'
            });
            removeButton.style.fontWeight = 200;
            removeButton.class.add('remove');
            field.parent.append(removeButton);

            removeButton.on('click', function () {
                removeOverride(index);
            });
        };

        // add field for each mapping
        for (var key in allMappings) {
            addOverride(key);
        }

        // subscribe to mapping change events
        entities.forEach(function (entity) {
            events.push(entity.on('*:set', function (path) {
                if (! /^components.model.mapping/.test(path)) return;

                var value = entity.get('components.model.mapping');

                if (! value) value = {};

                var resourceId = entity.get('resource_id');

                // remove deleted overrides
                for (var key in allMappings) {
                    if (value[key] === undefined) {
                        var ind = allMappings[key].indexOf(resourceId);
                        if (ind !== -1) {
                            allMappings[key].splice(ind, 1);
                            if (allMappings[key].length === 0) {
                                var field = panelMaterials.element.querySelector('.field-asset.node-' + key);
                                if (field)
                                    field.parentElement.removeChild(field);

                                delete allMappings[key];
                            }
                        }
                    }
                }


                // add new
                for (var key in value) {
                    if (!allMappings[key]) {
                        allMappings[key] = [resourceId];
                        addOverride(key);
                    }
                    else {
                        if (allMappings[key].indexOf(resourceId) === -1)
                            allMappings[key].push(resourceId);
                    }
                }

            }));

            events.push(entity.on('*:unset', function (path, value) {
                if (! /^components.model.mapping/.test(path)) return;

                var parts = path.split('.');
                var index = parts[parts.length-1];
                if (!allMappings[index]) return;

                var resourceId = entity.get('resource_id');

                var ind = allMappings[index].indexOf(resourceId);
                if (ind === -1) return;

                allMappings[index].splice(ind, 1);
                if (allMappings[index].length) return;

                delete allMappings[index];

                var field = panelMaterials.element.querySelector('.field-asset.node-' + index);
                if (field)
                    field.parentElement.removeChild(field);

            }));
        });
    });
});


/* editor/attributes/components/attributes-components-particlesystem.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;


        // particlesystem
        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Particles',
            name: 'particlesystem',
            entities: entities
        });


        // controls
        var fieldControls = editor.call('attributes:addField', {
            parent: panel,
            name: 'Controls',
        });
        var label = fieldControls;
        fieldControls = fieldControls.parent;
        label.destroy();
        fieldControls.class.add('controls');

        var btnPlay = new ui.Button({
            text: '&#57649;'
        });
        btnPlay.on('click', function() {
            for(var i = 0; i < entities.length; i++) {
                if (! entities[i].entity || ! entities[i].entity.particlesystem)
                    continue;

                if (playingState === 1) {
                    entities[i].entity.particlesystem.pause();
                } else if (entities[i].entity.particlesystem.data.paused) {
                    entities[i].entity.particlesystem.unpause();
                } else {
                    entities[i].entity.particlesystem.stop();
                    entities[i].entity.particlesystem.reset();
                    entities[i].entity.particlesystem.play();
                }
            }
            checkPlayingState();
        });
        fieldControls.append(btnPlay);

        var playingState = -1;
        var loopingState = -1;

        var checkPlayingState = function() {
            var playing = -1;
            var looping = -1;

            for(var i = 0; i < entities.length; i++) {
                if (! entities[i].entity || ! entities[i].entity.particlesystem)
                    continue;

                if (entities[i].entity.particlesystem.emitter && entities[i].entity.particlesystem.isPlaying()) {
                    if (playing === -1) {
                        playing = 1;
                    } else if (playing === 0) {
                        playing = 2;
                    }
                } else {
                    if (playing === -1) {
                        playing = 0;
                    } else if (playing === 1) {
                        playing = 2;
                    }
                }

                if (entities[i].entity.particlesystem.emitter && entities[i].entity.particlesystem.emitter.loop) {
                    if (looping === -1) {
                        looping = 1;
                    } else if (looping === 0) {
                        looping = 2;
                    }
                } else {
                    if (looping === -1) {
                        looping = 0;
                    } else if (looping === 1) {
                        looping = 2;
                    }
                }
            }

            if (playingState !== playing) {
                playingState = playing;

                if (playingState === 1) {
                    btnPlay.text = '&#10074;&#10074;'; // pause
                    btnPlay.class.add('pause');
                } else {
                    btnPlay.text = '&#57649;'; // play
                    btnPlay.class.remove('pause');
                }
            }

            if (loopingState !== looping) {
                loopingState = looping;

                if (loopingState === 0) {
                    btnStop.disabled = true;
                } else {
                    btnStop.disabled = false;
                }
            }
        };

        var evtCheckPlayingState = setInterval(checkPlayingState, 100);
        btnPlay.once('destroy', function() {
            clearInterval(evtCheckPlayingState);
        });


        var btnStop = new ui.Button({
            text: '	&#57653;'
        });
        btnStop.on('click', function() {
            for(var i = 0; i < entities.length; i++) {
                if (! entities[i].entity || ! entities[i].entity.particlesystem)
                    continue;

                if (playingState === 1) {
                    entities[i].entity.particlesystem.stop();
                } else {
                    entities[i].entity.particlesystem.stop();
                    entities[i].entity.particlesystem.reset();
                }
            }

            checkPlayingState();
        });
        fieldControls.append(btnStop);

        var btnReset = new ui.Button({
            text: '&#57619;'
        });
        btnReset.on('click', function() {
            for(var i = 0; i < entities.length; i++) {
                if (! entities[i].entity || ! entities[i].entity.particlesystem)
                    continue;

                entities[i].entity.particlesystem.rebuild();
                entities[i].entity.particlesystem.reset();
                entities[i].entity.particlesystem.play();
            }

            checkPlayingState();
        });
        fieldControls.append(btnReset);

        checkPlayingState();

        editor.once('viewport:update', function() {
            for(var i = 0; i < entities.length; i++) {
                if (! entities[i].entity || ! entities[i].entity.particlesystem)
                    continue;

                entities[i].entity.particlesystem.rebuild();
                entities[i].entity.particlesystem.reset();
                entities[i].entity.particlesystem.play();
            }
        });
        editor.call('viewport:render');


        // autoPlay
        var fieldAutoPlay = editor.call('attributes:addField', {
            parent: panel,
            name: 'Auto Play',
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.autoPlay'
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:autoPlay', fieldAutoPlay.parent.innerElement.firstChild.ui);


        // numParticles
        var fieldNumParticles = editor.call('attributes:addField', {
            parent: panel,
            name: 'Particle Count',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.numParticles'
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:numParticles', fieldNumParticles.parent.innerElement.firstChild.ui);


        // lifetime
        var fieldLifetime = editor.call('attributes:addField', {
            parent: panel,
            name: 'Lifetime',
            placeholder: 'Seconds',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.lifetime'
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:lifetime', fieldLifetime.parent.innerElement.firstChild.ui);


        // emission rate
        var panelEmissionRate = editor.call('attributes:addField', {
            parent: panel,
            name: 'Emission Rate'
        });
        var label = panelEmissionRate;
        panelEmissionRate = panelEmissionRate.parent;
        label.destroy();
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:rate', panelEmissionRate.innerElement.firstChild.ui);

        // emission rate from
        var fieldEmissionRateFrom = editor.call('attributes:addField', {
            panel: panelEmissionRate,
            placeholder: 'From',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.rate'
        });
        fieldEmissionRateFrom.style.width = '32px';

        // emission rate to
        var fieldEmissionRateTo = editor.call('attributes:addField', {
            panel: panelEmissionRate,
            placeholder: 'To',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.rate2'
        });
        fieldEmissionRateTo.style.width = '32px';


        // start angle
        var panelStartAngle = editor.call('attributes:addField', {
            parent: panel,
            name: 'Start Angle'
        });
        var label = panelStartAngle;
        panelStartAngle = panelStartAngle.parent;
        label.destroy();
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:startAngle', panelStartAngle.innerElement.firstChild.ui);

        // start angle from
        var fieldStartAngleFrom = editor.call('attributes:addField', {
            panel: panelStartAngle,
            placeholder: 'From',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.startAngle'
        });
        fieldStartAngleFrom.style.width = '32px';

        // start angle to
        var fieldStartAngleTo = editor.call('attributes:addField', {
            panel: panelStartAngle,
            placeholder: 'To',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.startAngle2'
        });
        fieldStartAngleTo.style.width = '32px';


        // playback
        var panelPlayback = editor.call('attributes:addField', {
            parent: panel,
            name: 'Playback'
        });
        var label = panelPlayback;
        panelPlayback = panelPlayback.parent;
        label.destroy();

        // loop
        var fieldLoop = editor.call('attributes:addField', {
            panel: panelPlayback,
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.loop'
        });
        // label
        var label = new ui.Label({ text: 'Loop' });
        label.class.add('label-infield');
        label.style.paddingRight = '12px';
        panelPlayback.append(label);
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:loop', label);


        // preWarm
        var fieldPreWarm = editor.call('attributes:addField', {
            panel: panelPlayback,
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.preWarm'
        });
        // label
        var labelPreWarm = new ui.Label({ text: 'Pre Warm' });
        labelPreWarm.class.add('label-infield');
        labelPreWarm.style.paddingRight = '12px';
        panelPlayback.append(labelPreWarm);
        // states
        fieldPreWarm.hidden = labelPreWarm.hidden = ! fieldLoop.value && ! fieldLoop.class.contains('null');
        fieldLoop.on('change', function(value) {
            fieldPreWarm.hidden = labelPreWarm.hidden = ! value && ! this.class.contains('null');
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:preWarm', labelPreWarm);



        // lighting
        var panelLighting = editor.call('attributes:addField', {
            parent: panel,
            name: 'Lighting'
        });
        var label = panelLighting;
        panelLighting = panelLighting.parent;
        label.destroy();

        // lighting
        var fieldLighting = editor.call('attributes:addField', {
            panel: panelLighting,
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.lighting'
        });
        // label
        var label = new ui.Label({ text: 'Enabled' });
        label.class.add('label-infield');
        label.style.paddingRight = '12px';
        label.class.add('label-infield');
        panelLighting.append(label);
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:lighting', label);


        // halfLambert
        var fieldHalfLambert = editor.call('attributes:addField', {
            panel: panelLighting,
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.halfLambert'
        });
        // label
        var labelHalfLambert = new ui.Label({ text: 'Half Lambert' });
        labelHalfLambert.class.add('label-infield');
        labelHalfLambert.style.paddingRight = '12px';
        panelLighting.append(labelHalfLambert);
        // state
        fieldHalfLambert.hidden = labelHalfLambert.hidden = ! fieldLighting.value && ! fieldLighting.class.contains('null');
        fieldLighting.on('change', function(value) {
            fieldHalfLambert.hidden = labelHalfLambert.hidden = ! value && ! this.class.contains('null');
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:halfLambert', labelHalfLambert);


        // intensity
        var fieldIntensity = editor.call('attributes:addField', {
            parent: panel,
            name: 'Intensity',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.intensity'
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:intensity', fieldIntensity.parent.innerElement.firstChild.ui);


        // depth
        var panelDepth = editor.call('attributes:addField', {
            parent: panel,
            name: 'Depth'
        });
        var label = panelDepth;
        panelDepth = panelDepth.parent;
        label.destroy();

        // depthWrite
        var fieldDepthWrite = editor.call('attributes:addField', {
            panel: panelDepth,
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.depthWrite'
        });
        // label
        var label = new ui.Label({ text: 'Write' });
        label.class.add('label-infield');
        label.style.paddingRight = '12px';
        panelDepth.append(label);
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:depthWrite', label);

        // depthSoftening
        var fieldDepthSoftening = editor.call('attributes:addField', {
            panel: panelDepth,
            placeholder: 'Softening',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.depthSoftening'
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:depthSoftening', fieldDepthSoftening);


        // sort
        var fieldSort = editor.call('attributes:addField', {
            parent: panel,
            name: 'Sort',
            type: 'number',
            enum: [
                { v: '', t: '...' },
                { v: 0, t: 'None' },
                { v: 1, t: 'Camera Distance' },
                { v: 2, t: 'Newest First' },
                { v: 3, t: 'Oldest First' }
            ],
            link: entities,
            path: 'components.particlesystem.sort'
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:sort', fieldSort.parent.innerElement.firstChild.ui);


        // blendType
        var fieldBlendType = editor.call('attributes:addField', {
            parent: panel,
            name: 'Blend Type',
            type: 'number',
            enum: [
                { v: '', t: '...' },
                { v: 2, t: 'Alpha' },
                { v: 1, t: 'Additive' },
                { v: 5, t: 'Multiply' }
            ],
            link: entities,
            path: 'components.particlesystem.blendType'
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:blend', fieldBlendType.parent.innerElement.firstChild.ui);


        // stretch
        var fieldStretch = editor.call('attributes:addField', {
            parent: panel,
            name: 'Stretch',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.stretch'
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:stretch', fieldStretch.parent.innerElement.firstChild.ui);


        // alignToMotion
        var fieldAlignToMotion = editor.call('attributes:addField', {
            parent: panel,
            name: 'Align To Motion',
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.alignToMotion'
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:alignToMotion', fieldAlignToMotion.parent.innerElement.firstChild.ui);


        // emitterShape
        var fieldEmitterShape = editor.call('attributes:addField', {
            parent: panel,
            name: 'Emmiter Shape',
            type: 'number',
            enum: [
                { v: '', t: '...' },
                { v: 0, t: 'Box' },
                { v: 1, t: 'Sphere' }
            ],
            link: entities,
            path: 'components.particlesystem.emitterShape'
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:emitterShape', fieldEmitterShape.parent.innerElement.firstChild.ui);


        // emitterExtents
        var fieldSpawnBounds = editor.call('attributes:addField', {
            parent: panel,
            name: 'Emmiter Extents',
            placeholder: [ 'X', 'Y', 'Z' ],
            type: 'vec3',
            link: entities,
            path: 'components.particlesystem.emitterExtents'
        });
        fieldSpawnBounds[0].parent.hidden = fieldEmitterShape.value !== 0 || fieldEmitterShape.class.contains('null');
        fieldEmitterShape.on('change', function(value) {
            fieldSpawnBounds[0].parent.hidden = value !== 0 || this.class.contains('null');
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:emitterExtents', fieldSpawnBounds[0].parent.innerElement.firstChild.ui);


        // emitterRadius
        var fieldSpawnRadius = editor.call('attributes:addField', {
            parent: panel,
            name: 'Emmiter Radius',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.emitterRadius'
        });
        fieldSpawnRadius.parent.hidden = fieldEmitterShape.value !== 1 || fieldEmitterShape.class.contains('null');
        fieldEmitterShape.on('change', function(value) {
            fieldSpawnRadius.parent.hidden = value !== 1 || this.class.contains('null');
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:emitterRadius', fieldSpawnRadius.parent.innerElement.firstChild.ui);


        // wrap
        var fieldWrap = editor.call('attributes:addField', {
            parent: panel,
            name: 'Wrap',
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.wrap'
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:wrap', fieldWrap.parent.innerElement.firstChild.ui);


        // wrapBounds
        var fieldWrapBounds = editor.call('attributes:addField', {
            parent: panel,
            name: 'Wrap Bounds',
            placeholder: [ 'X', 'Y', 'Z' ],
            type: 'vec3',
            link: entities,
            path: 'components.particlesystem.wrapBounds'
        });
        fieldWrapBounds[0].parent.hidden = ! fieldWrap.value && ! fieldWrap.class.contains('null');
        fieldWrap.on('change', function(value) {
            fieldWrapBounds[0].parent.hidden = ! value && ! this.class.contains('null');
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:wrapBounds', fieldWrapBounds[0].parent.innerElement.firstChild.ui);


        // colorMapAsset
        var fieldColorMap = editor.call('attributes:addField', {
            parent: panel,
            name: 'Color Map',
            type: 'asset',
            kind: 'texture',
            link: entities,
            path: 'components.particlesystem.colorMapAsset'
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:colorMap', fieldColorMap._label);

        fieldColorMap.on('change', function (value) {
            panelFrames.hidden = !value && !fieldNormalMap.value;
            fieldAnimatedTextureNumFrames.parent.hidden = panelFrames.hidden;
            panelAnimationPlayback.hidden = panelFrames.hidden;
        });

        // normalMapAsset
        var fieldNormalMap = editor.call('attributes:addField', {
            parent: panel,
            name: 'Normal Map',
            type: 'asset',
            kind: 'texture',
            link: entities,
            path: 'components.particlesystem.normalMapAsset'
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:normalMap', fieldNormalMap._label);

        fieldNormalMap.on('change', function (value) {
            panelFrames.hidden = !value && !fieldColorMap.value;
            fieldAnimatedTextureNumFrames.hidden = panelFrames.hidden;
            panelAnimationPlayback.hidden = panelFrames.hidden;
        });

        // frames
        var panelFrames = editor.call('attributes:addField', {
            parent: panel,
            name: 'Map Tiles'
        });

        var label = panelFrames;
        panelFrames = panelFrames.parent;
        label.destroy();

        // number of x tiles
        var fieldAnimatedTextureTilesX = editor.call('attributes:addField', {
            parent: panelFrames,
            type: 'number',
            placeholder: 'X',
            min: 1,
            link: entities,
            path: 'components.particlesystem.animTilesX'
        });
        fieldAnimatedTextureTilesX.style.width = '50%';
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:animTilesX', fieldAnimatedTextureTilesX.parent.innerElement.firstChild.ui);

        // number of y tiles
        var fieldAnimatedTextureTilesY = editor.call('attributes:addField', {
            parent: panelFrames,
            type: 'number',
            placeholder: 'Y',
            min: 1,
            link: entities,
            path: 'components.particlesystem.animTilesY'
        });
        fieldAnimatedTextureTilesY.style.width = '50%';
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:animTilesY', fieldAnimatedTextureTilesY.parent.innerElement.firstChild.ui);

        panelFrames.hidden = !fieldColorMap.value && !fieldNormalMap.value;

        // frames to play
        var fieldAnimatedTextureNumFrames = editor.call('attributes:addField', {
            parent: panel,
            type: 'number',
            name: 'Frame Count',
            min: 1,
            link: entities,
            path: 'components.particlesystem.animNumFrames'
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:animNumFrames', fieldAnimatedTextureNumFrames.parent.innerElement.firstChild.nextSibling.ui);

        fieldAnimatedTextureNumFrames.parent.hidden = !fieldColorMap.value && !fieldNormalMap.value;

        var panelAnimationPlayback = editor.call('attributes:addField', {
            parent: panel,
            name: 'Animation'
        });

        var label = panelAnimationPlayback;
        panelAnimationPlayback = panelAnimationPlayback.parent;
        label.destroy();

        // animation speed
        var fieldAnimatedTextureSpeed = editor.call('attributes:addField', {
            parent: panelAnimationPlayback,
            placeholder: 'Speed',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.animSpeed'
        });
        fieldAnimatedTextureSpeed.style.width = '50%';
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:animSpeed', fieldAnimatedTextureSpeed.parent.innerElement.firstChild.ui);


        // animation loop
        var fieldAnimatedTextureLoop = editor.call('attributes:addField', {
            parent: panelAnimationPlayback,
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.animLoop'
        });

        // label
        var label = new ui.Label({ text: 'Loop' });
        label.class.add('label-infield');
        label.style.paddingRight = '12px';
        panelAnimationPlayback.append(label);

        // reference
        editor.call('attributes:reference:attach', 'particlesystem:animLoop', label);

        panelAnimationPlayback.hidden = !fieldColorMap.value && !fieldNormalMap.value;

        // mesh
        var fieldMesh = editor.call('attributes:addField', {
            parent: panel,
            name: 'Mesh',
            type: 'asset',
            kind: 'model',
            link: entities,
            path: 'components.particlesystem.mesh'
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:mesh', fieldMesh._label);


        // localVelocityGraph
        var fieldLocalVelocity = editor.call('attributes:addField', {
            parent: panel,
            name: 'Local Velocity',
            type: 'curveset',
            link: entities[0],
            paths: [ 'components.particlesystem.localVelocityGraph', 'components.particlesystem.localVelocityGraph2' ],
            curves: [ 'X', 'Y', 'Z' ]
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:localVelocityGraph', fieldLocalVelocity.parent.innerElement.firstChild.ui);


        // velocityGraph
        var fieldVelocity = editor.call('attributes:addField', {
            parent: panel,
            name: 'Velocity',
            type: 'curveset',
            link: entities[0],
            paths: [ 'components.particlesystem.velocityGraph', 'components.particlesystem.velocityGraph2' ],
            curves: [ 'X', 'Y', 'Z' ]
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:velocityGraph', fieldVelocity.parent.innerElement.firstChild.ui);


        // rotationSpeedGraph
        var fieldRotationSpeed = editor.call('attributes:addField', {
            parent: panel,
            name: 'Rotation Speed',
            type: 'curveset',
            link: entities[0],
            paths: [ 'components.particlesystem.rotationSpeedGraph', 'components.particlesystem.rotationSpeedGraph2' ],
            curves: [ 'Angle' ],
            verticalValue: 180
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:rotationSpeedGraph', fieldRotationSpeed.parent.innerElement.firstChild.ui);


        // scaleGraph
        var fieldScale = editor.call('attributes:addField', {
            parent: panel,
            name: 'Scale',
            type: 'curveset',
            link: entities[0],
            paths: [ 'components.particlesystem.scaleGraph', 'components.particlesystem.scaleGraph2' ],
            curves: [ 'Scale' ],
            verticalValue: 1,
            min: 0
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:scaleGraph', fieldScale.parent.innerElement.firstChild.ui);


        // colorGraph
        var fieldColor = editor.call('attributes:addField', {
            parent: panel,
            name: 'Color',
            type: 'curveset',
            link: entities[0],
            path: 'components.particlesystem.colorGraph',
            gradient: true,
            curves: [ 'R', 'G', 'B' ],
            max: 1,
            min: 0
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:colorGraph', fieldColor.parent.innerElement.firstChild.ui);


        // alphaGraph
        var fieldAlpha = editor.call('attributes:addField', {
            parent: panel,
            name: 'Opacity',
            type: 'curveset',
            link: entities[0],
            paths: [ 'components.particlesystem.alphaGraph', 'components.particlesystem.alphaGraph2' ],
            curves: ['Opacity' ],
            min: 0,
            max: 1
        });
        // reference
        editor.call('attributes:reference:attach', 'particlesystem:alphaGraph', fieldAlpha.parent.innerElement.firstChild.ui);

        if (entities.length > 1) {
            fieldLocalVelocity.disabled = true;
            fieldVelocity.disabled = true;
            fieldRotationSpeed.disabled = true;
            fieldScale.disabled = true;
            fieldColor.disabled = true;
            fieldAlpha.disabled = true;
        }
    });
});


/* editor/attributes/components/attributes-components-rigidbody.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var events = [ ];

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Rigid Body',
            name: 'rigidbody',
            entities: entities
        });

        // type
        var fieldType = editor.call('attributes:addField', {
            parent: panel,
            name: 'Type',
            type: 'string',
            enum: {
                '': '...',
                'static': 'Static',
                'dynamic': 'Dynamic',
                'kinematic': 'Kinematic'
            },
            link: entities,
            path: 'components.rigidbody.type'
        });
        // reference
        editor.call('attributes:reference:attach', 'rigidbody:type', fieldType.parent.innerElement.firstChild.ui);


        // dynamic/kinematic fields
        var panelDynamic = editor.call('attributes:addPanel', {
            parent: panel
        });
        panelDynamic.hidden = fieldType.value !== '' && fieldType.value !== 'dynamic';
        fieldType.on('change', function(value) {
            panelDynamic.hidden = value !== '' && value !== 'dynamic';
        });

        // mass
        var fieldMass = editor.call('attributes:addField', {
            parent: panelDynamic,
            name: 'Mass',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            link: entities,
            path: 'components.rigidbody.mass'
        });
        fieldMass.placeholder = 'Kg';
        // reference
        editor.call('attributes:reference:attach', 'rigidbody:mass', fieldMass.parent.innerElement.firstChild.ui);


        // linearDamping
        var fieldLinearDamping = editor.call('attributes:addField', {
            parent: panelDynamic,
            name: 'Damping',
            placeholder: 'Linear',
            type: 'number',
            precision: 6,
            step: .01,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.rigidbody.linearDamping'
        });
        fieldLinearDamping.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'rigidbody:damping', fieldLinearDamping.parent.innerElement.firstChild.ui);


        // angularDamping
        var fieldAngularDamping = editor.call('attributes:addField', {
            panel: fieldLinearDamping.parent,
            placeholder: 'Angular',
            type: 'number',
            precision: 6,
            step: .01,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.rigidbody.angularDamping'
        });
        fieldAngularDamping.style.width = '32px';


        // linearFactor
        var fieldLinearFactor = editor.call('attributes:addField', {
            parent: panelDynamic,
            name: 'Linear Factor',
            placeholder: [ 'X', 'Y', 'Z' ],
            precision: 4,
            step: .01,
            min: 0,
            max: 1,
            type: 'vec3',
            link: entities,
            path: 'components.rigidbody.linearFactor'
        });
        // reference
        editor.call('attributes:reference:attach', 'rigidbody:linearFactor', fieldLinearFactor[0].parent.innerElement.firstChild.ui);


        // angularFactor
        var fieldAngularFactor = editor.call('attributes:addField', {
            parent: panelDynamic,
            name: 'Angular Factor',
            placeholder: [ 'X', 'Y', 'Z' ],
            precision: 4,
            step: .01,
            min: 0,
            max: 1,
            type: 'vec3',
            link: entities,
            path: 'components.rigidbody.angularFactor'
        });
        // reference
        editor.call('attributes:reference:attach', 'rigidbody:angularFactor', fieldAngularFactor[0].parent.innerElement.firstChild.ui);


        // friction
        var fieldFriction = editor.call('attributes:addField', {
            parent: panel,
            name: 'Friction',
            type: 'number',
            precision: 4,
            step: .01,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.rigidbody.friction'
        });
        fieldFriction.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'rigidbody:friction', fieldFriction.parent.innerElement.firstChild.ui);


        // friction slider
        var fieldFrictionSlider = editor.call('attributes:addField', {
            panel: fieldFriction.parent,
            precision: 4,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: entities,
            path: 'components.rigidbody.friction'
        });
        fieldFrictionSlider.flexGrow = 4;


        // restitution
        var fieldRestitution = editor.call('attributes:addField', {
            parent: panel,
            name: 'Restitution',
            type: 'number',
            precision: 4,
            step: .01,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.rigidbody.restitution'
        });
        fieldRestitution.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'rigidbody:restitution', fieldRestitution.parent.innerElement.firstChild.ui);


        // restitution slider
        var fieldRestitutionSlider = editor.call('attributes:addField', {
            panel: fieldRestitution.parent,
            precision: 3,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: entities,
            path: 'components.rigidbody.restitution'
        });
        fieldRestitutionSlider.flexGrow = 4;
    });
});


/* editor/attributes/components/attributes-components-script-2.js */
editor.once('load', function() {
    'use strict';

    if (editor.call('settings:project').get('useLegacyScripts'))
        return;

    var attributeTypeToUi = {
        boolean: 'checkbox',
        number: 'number',
        string: 'string',
        json: 'string',
        asset: 'asset',
        entity: 'entity',
        rgb: 'rgb',
        rgba: 'rgb',
        vec2: 'vec2',
        vec3: 'vec3',
        vec4: 'vec4',
        curve: 'curveset'
    };

    var attributeSubTitles = {
        boolean: '{Boolean}',
        number: '{Number}',
        string: '{String}',
        json: '{Object}',
        asset: '{pc.Asset}',
        entity: '{pc.Entity}',
        rgb: '{pc.Color}',
        rgba: '{pc.Color}',
        vec2: '{pc.Vec2}',
        vec3: '{pc.Vec3}',
        vec4: '{pc.Vec4}',
        curve: '{pc.Curve}'
    };

    editor.method('assets:scripts:typeToSubTitle', function(attribute) {
        var subTitle = attributeSubTitles[attribute.type];

        if (attribute.type === 'curve') {
            if (attribute.color) {
                if (attribute.color.length > 1)
                    subTitle = '{pc.CurveSet}';
            } else if (attribute.curves && attribute.curves.length > 1) {
                subTitle = '{pc.CurveSet}';
            }
        } else if (attribute.array) {
            subTitle = '[ ' + subTitle + ' ]';
        }

        return subTitle;
    });


    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Scripts',
            name: 'script',
            entities: entities
        });

        var events = [ ];
        var currentFocus = null;
        var lastValue = '';


        var excludeScripts = { };
        var calculateExcludeScripts = function() {
            excludeScripts = { };
            var excludeScriptsIndex = { };
            for(var i = 0; i < entities.length; i++) {
                var scripts = entities[i].get('components.script.order');
                if (! scripts)
                    continue;

                for(var s = 0; s < scripts.length; s++) {
                    excludeScriptsIndex[scripts[s]] = (excludeScriptsIndex[scripts[s]] || 0) + 1;
                    if (excludeScriptsIndex[scripts[s]] === entities.length)
                        excludeScripts[scripts[s]] = true;
                }
            }
        };

        var focusFirstAutocomplete = function() {
            var first = autoComplete.innerElement.firstChild;
            var found = false;
            while(! found && first) {
                if (first.ui && ! first.ui.hidden) {
                    found = true;
                    break;
                }
                first = first.nextSibling;
            }

            if (found && first && first.ui) {
                currentFocus = first.ui;
                currentFocus.class.add('active');
            } else {
                currentFocus = null;
            }
        };


        var createNewScript = function() {
            var filename = editor.call('picker:script-create:validate', inputAddScript.value);

            var onFilename = function(filename) {
                editor.call('assets:create:script', {
                    filename: filename,
                    boilerplate: true,
                    noSelect: true,
                    callback: function(err, asset, result) {
                        if (result && result.scripts) {
                            var keys = Object.keys(result.scripts);
                            if (keys.length === 1)
                                onScriptAdd(keys[0]);
                        }
                    }
                });
            };

            if (filename) {
                onFilename(filename);
            } else {
                editor.call('picker:script-create', onFilename, inputAddScript.value);
            }
        };


        var inputAddScript = new ui.TextField();
        inputAddScript.blurOnEnter = false;
        inputAddScript.renderChanges = false;
        inputAddScript.keyChange = true;
        inputAddScript.class.add('add-script');
        inputAddScript.on('change', function(value) {
            if (lastValue === value)
                return;

            lastValue = value;

            if (value) {
                inputAddScript.class.add('not-empty');

                var items = [ ];
                for(var key in autoComplete.index) {
                    if (! autoComplete.index.hasOwnProperty(key))
                        continue;

                    items.push([ key, key ]);
                }

                var search = editor.call('search:items', items, value);
                var searchIndex = { };
                for(var i = 0; i < search.length; i++)
                    searchIndex[search[i]] = true;

                itemAutoCompleteNew.hidden = !! excludeScripts[value] || !! searchIndex[value];
                itemAutoCompleteNew.class.remove('active');

                for(var key in autoComplete.index) {
                    if (! autoComplete.index.hasOwnProperty(key))
                        continue;

                    autoComplete.index[key].class.remove('active');

                    if (searchIndex[key] && ! excludeScripts[key]) {
                        autoComplete.index[key].hidden = false;
                    } else {
                        autoComplete.index[key].hidden = true;
                    }
                }
            } else {
                inputAddScript.class.remove('not-empty');
                itemAutoCompleteNew.hidden = false;
                itemAutoCompleteNew.class.remove('active');

                for(var key in autoComplete.index) {
                    if (! autoComplete.index.hasOwnProperty(key))
                        continue;

                    autoComplete.index[key].class.remove('active');
                    autoComplete.index[key].hidden = !! excludeScripts[key];
                }
            }

            focusFirstAutocomplete();
        });
        inputAddScript.on('input:focus', function() {
            calculateExcludeScripts();

            if (autoComplete.empty) {
                currentFocus = null;
                autoComplete.empty = false;

                var scripts = editor.call('assets:scripts:list');

                // sort list
                scripts.sort(function(a, b) {
                    if (a.toLowerCase() > b.toLowerCase()) {
                        return 1;
                    } else if (a.toLowerCase() < b.toLowerCase()) {
                        return -1;
                    } else {
                        return 0;
                    }
                });

                itemAutoCompleteNew = new ui.ListItem({ text: 'New Script' });
                itemAutoCompleteNew.class.add('new');
                itemAutoCompleteNew.element.addEventListener('mousedown', createNewScript, false);
                autoComplete.append(itemAutoCompleteNew);

                for(var i = 0; i < scripts.length; i++) {
                    var item = addScriptAutocompleteItem(scripts[i]);
                    if (excludeScripts[scripts[i]])
                        item.hidden = true;
                }

                // TODO scritps2
                // resort might be required if new scripts were added before templated
            } else {
                // show all items as search is empty
                for(var key in autoComplete.index) {
                    if (! autoComplete.index.hasOwnProperty(key))
                        continue;

                    autoComplete.index[key].class.remove('active');
                    autoComplete.index[key].hidden = !! excludeScripts[key];
                }
            }

            autoComplete.hidden = false;
            focusFirstAutocomplete();

            if (currentFocus)
                currentFocus.class.add('active');
        });

        var addScriptAutocompleteItem = function(script) {
            var item = new ui.ListItem({ text: script });
            item.element.script = script;
            item.element.addEventListener('mousedown', function() {
                onScriptAdd(this.script);
            }, false);
            autoComplete.index[script] = item;
            autoComplete.appendBefore(item, itemAutoCompleteNew);
            return item;
        };

        var removeScriptAutocompleteItem = function(script) {
            var item = autoComplete.index[script];
            if (! item) return;

            if (item === currentFocus) {
                var prev = item.element.previousSibling;
                if (! prev) prev = item.element.nextSibling;

                if (prev && prev.ui) {
                    currentFocus = prev.ui;
                    currentFocus.class.add('active');
                } else {
                    currentFocus = null;
                }
            }

            item.destroy();
            delete autoComplete.index[script];
        };

        var onScriptAdd = function(script) {
            var records = [ ];

            for(var i = 0; i < entities.length; i++) {
                if (entities[i].has('components.script.scripts.' + script))
                    continue;

                var record = {
                    get: entities[i].history._getItemFn,
                    data: {
                        enabled: true,
                        attributes: { }
                    }
                };
                records.push(record);

                entities[i].history.enabled = false;
                entities[i].set('components.script.scripts.' + script, record.data);
                entities[i].insert('components.script.order', script);
                entities[i].history.enabled = true;
            }

            editor.call('history:add', {
                name: 'entities.components.script.scripts',
                undo: function() {
                    for(var i = 0; i < records.length; i++) {
                        var item = records[i].get();
                        if (! item) continue;

                        item.history.enabled = false;
                        item.unset('components.script.scripts.' + script);
                        item.removeValue('components.script.order', script);
                        item.history.enabled = true;
                    }
                },
                redo: function() {
                    for(var i = 0; i < records.length; i++) {
                        var item = records[i].get();
                        if (! item) continue;

                        item.history.enabled = false;
                        item.set('components.script.scripts.' + script, records[i].data);
                        item.insert('components.script.order', script);
                        item.history.enabled = true;
                    }
                }
            });
        };

        var onAddScriptKeyDown = function(evt) {
            var candidate, found;
            var findFirst = false;
            var direction = '';

            if (evt.keyCode === 40 || (evt.keyCode === 9 && ! evt.shiftKey)) {
                // down
                if (currentFocus) {
                    direction = 'nextSibling';
                } else {
                    findFirst = true;
                }

                evt.preventDefault();
            } else if (evt.keyCode === 38 || (evt.keyCode === 9 && evt.shiftKey)) {
                // up
                if (currentFocus) {
                    direction = 'previousSibling';
                } else {
                    findFirst = true;
                }

                evt.preventDefault();
            } else if (evt.keyCode === 13) {
                // enter
                if (currentFocus) {
                    if (currentFocus === itemAutoCompleteNew) {
                        createNewScript();
                    } else {
                        onScriptAdd(currentFocus.element.script);
                    }

                    inputAddScript.elementInput.blur();
                } else {
                    findFirst = true;
                }
            }

            if (findFirst) {
                // try finding first available option
                candidate = autoComplete.innerElement.firstChild;
                found = false;

                while(! found && candidate) {
                    if (candidate.ui && ! candidate.ui.hidden) {
                        found = true;
                        break;
                    }
                    candidate = candidate.nextSibling;
                }

                if (found && candidate && candidate.ui) {
                    currentFocus = candidate.ui;
                    currentFocus.class.add('active');
                }

                if (evt.keyCode === 13) {
                    if (currentFocus) {
                        if (currentFocus === itemAutoCompleteNew) {
                            createNewScript();
                        } else {
                            onScriptAdd(currentFocus.ui.element.script);
                        }
                    }

                    inputAddScript.elementInput.blur();
                }
            } else if (direction) {
                // try finding next or previous available option
                candidate = currentFocus.element[direction];
                found = false;

                while(! found && candidate) {
                    if (candidate.ui && ! candidate.ui.hidden) {
                        found = true;
                        break;
                    }
                    candidate = candidate[direction];
                }
                if (candidate && candidate.ui) {
                    currentFocus.class.remove('active');
                    currentFocus = candidate.ui;
                    currentFocus.class.add('active');
                }
            }
        };
        inputAddScript.elementInput.addEventListener('keydown', onAddScriptKeyDown);

        inputAddScript.on('input:blur', function() {
            if (currentFocus) {
                currentFocus.class.remove('active');
                currentFocus = null;
            }
            autoComplete.hidden = true;
            this.value = '';
        });
        panel.append(inputAddScript);

        inputAddScript.once('destroy', function() {
            inputAddScript.elementInput.removeEventListener('keydown', onAddScriptKeyDown);
        });


        // autocomplete
        var autoComplete = new ui.List();
        autoComplete.empty = true;
        autoComplete.index = { };
        autoComplete.class.add('scripts-autocomplete');
        autoComplete.hidden = true;
        panel.append(autoComplete);

        var itemAutoCompleteNew;

        // script added
        events.push(editor.on('assets:scripts:add', function(asset, script) {
            if (autoComplete.empty || autoComplete.index[script])
                return;

            addScriptAutocompleteItem(script);
        }));

        // script removed
        events.push(editor.on('assets:scripts:remove', function(asset, script) {
            if (autoComplete.empty)
                return;

            if (editor.call('assets:scripts:assetByScript', script))
                return;

            removeScriptAutocompleteItem(script);
        }));


        var panelScripts = editor.call('attributes:addPanel', {
            parent: panel
        });
        panelScripts.hidden = true;
        panelScripts.class.add('scripts');


        var scriptPanelsIndex = { };

        // drag is only allowed for single selected entities
        if (entities.length === 1) {
            var dragScript = null;
            var dragScriptInd = null;
            var dragPlaceholder = null;
            var dragInd = null;
            var dragOut = true;
            var dragScripts = [ ];

            // drop area
            var target = editor.call('drop:target', {
                ref: panelScripts.innerElement,
                type: 'component-script-order',
                hole: true,
                passThrough: true
            });
            target.element.style.outline = '1px dotted #f60';
            panelScripts.once('drestroy', function() {
                target.unregister();
            });

            var dragCalculateSizes = function() {
                dragScripts = [ ];
                var children = panelScripts.innerElement.children;

                for(var i = 0; i < children.length; i++) {
                    var script = children[i].ui ? children[i].ui.script : children[i].script;

                    dragScripts.push({
                        script: script,
                        ind: entities[0].get('components.script.order').indexOf(script),
                        y: children[i].offsetTop,
                        height: children[i].clientHeight
                    });
                }
            };
            var onScriptDragStart = function(evt) {
                // dragend
                window.addEventListener('blur', onScriptDragEnd, false);
                window.addEventListener('mouseup', onScriptDragEnd, false);
                window.addEventListener('mouseleave', onScriptDragEnd, false);
                document.body.addEventListener('mouseleave', onScriptDragEnd, false);
                // dragmove
                window.addEventListener('mousemove', onScriptDragMove, false);

                scriptPanelsIndex[dragScript].class.add('dragged');

                dragCalculateSizes();
                for(var i = 0; i < dragScripts.length; i++) {
                    if (dragScripts[i].script === dragScript)
                        dragScriptInd = i;
                }

                var panel = scriptPanelsIndex[dragScript];
                var parent = panel.element.parentNode;
                dragPlaceholder = document.createElement('div');
                dragPlaceholder.script = dragScript;
                dragPlaceholder.classList.add('dragPlaceholder');
                dragPlaceholder.style.height = (dragScripts[dragScriptInd].height - 8) + 'px';
                parent.insertBefore(dragPlaceholder, panel.element);
                parent.removeChild(panel.element);

                onScriptDragMove(evt);

                editor.call('drop:set', 'component-script-order', { script: dragScript });
                editor.call('drop:activate', true);
            };
            var onScriptDragMove = function(evt) {
                if (! dragScript) return;

                var rect = panelScripts.innerElement.getBoundingClientRect();

                dragOut = (evt.clientX < rect.left || evt.clientX > rect.right || evt.clientY < rect.top || evt.clientY > rect.bottom);

                if (! dragOut) {
                    var y = evt.clientY - rect.top;
                    var ind = null;
                    var height = dragPlaceholder.clientHeight;

                    var c = 0;
                    for(var i = 0; i < dragScripts.length; i++) {
                        if (dragScripts[i].script === dragScript) {
                            c = i;
                            break;
                        }
                    }

                    // hovered script
                    for(var i = 0; i < dragScripts.length; i++) {
                        var off = Math.max(0, dragScripts[i].height - height);
                        if (c < i) {
                            if (y >= (dragScripts[i].y + off) && y <= (dragScripts[i].y + dragScripts[i].height)) {
                                ind = i;
                                if (ind > dragScriptInd) ind++;
                                break;
                            }
                        } else {
                            if (y >= dragScripts[i].y && y <= (dragScripts[i].y + dragScripts[i].height - off)) {
                                ind = i;
                                if (ind > dragScriptInd) ind++;
                                break;
                            }
                        }
                    }

                    if (ind !== null && dragInd !== ind) {
                        dragInd = ind;

                        var parent = dragPlaceholder.parentNode;
                        parent.removeChild(dragPlaceholder);

                        var ind = dragInd;
                        if (ind > dragScriptInd) ind--;
                        var next = parent.children[ind];

                        if (next) {
                            parent.insertBefore(dragPlaceholder, next);
                        } else {
                            parent.appendChild(dragPlaceholder);
                        }

                        dragCalculateSizes();
                    }
                } else {
                    dragInd = dragScriptInd;
                    var parent = dragPlaceholder.parentNode;
                    parent.removeChild(dragPlaceholder);
                    var next = parent.children[dragScriptInd];
                    if (next) {
                        parent.insertBefore(dragPlaceholder, next);
                    } else {
                        parent.appendChild(dragPlaceholder);
                    }
                    dragCalculateSizes();
                }
            };
            var onScriptDragEnd = function() {
                // dragend
                window.removeEventListener('blur', onScriptDragEnd);
                window.removeEventListener('mouseup', onScriptDragEnd);
                window.removeEventListener('mouseleave', onScriptDragEnd);
                document.body.removeEventListener('mouseleave', onScriptDragEnd);
                // dragmove
                window.removeEventListener('mousemove', onScriptDragMove);

                if (dragScript) {
                    scriptPanelsIndex[dragScript].class.remove('dragged');

                    var panel = scriptPanelsIndex[dragScript];
                    panelScripts.innerElement.removeChild(dragPlaceholder);
                    var next = panelScripts.innerElement.children[dragScriptInd];
                    if (next) {
                        panelScripts.innerElement.insertBefore(panel.element, next);
                    } else {
                        panelScripts.innerElement.appendChild(panel.element);
                    }

                    if (! dragOut && dragInd !== null && dragInd !== dragScriptInd && dragInd !== (dragScriptInd + 1)) {
                        var ind = dragInd;
                        if (ind > dragScriptInd) ind--;
                        entities[0].move('components.script.order', dragScriptInd, ind);
                    }
                }

                dragScript = null;
                dragScripts = [ ];
                dragInd = null;

                editor.call('drop:activate', false);
                editor.call('drop:set');
            };
        }

        var addScript = function(script, ind) {
            var panel = scriptPanelsIndex[script];
            var events = [ ];

            if (panel) {
                // check if script is still present in all entities
                var complete = true;
                for(var i = 0; i < entities.length; i++) {
                    if (! entities[i].has('components.script.scripts.' + script)) {
                        complete = false;
                        break;
                    }
                }
                panel.header = script + (complete ? '' : ' *');
                return;
            }

            panel = scriptPanelsIndex[script] = new ui.Panel();
            panel.script = script;
            panel.header = script;
            panel.attributesIndex = { };

            var next = null;
            if (typeof(ind) === 'number')
                next = panelScripts.innerElement.children[ind];

            if (next) {
                panelScripts.appendBefore(panel, next);
            } else {
                panelScripts.append(panel);
            }

            // clean events
            panel.once('destroy', function() {
                for(var i = 0; i < events.length; i++)
                    events[i].unbind();
                events = null;
            });

            // drag handle
            if (entities.length === 1) {
                panel.handle = document.createElement('div');
                panel.handle.classList.add('handle');
                panel.handle.addEventListener('mousedown', function(evt) {
                    evt.stopPropagation();
                    evt.preventDefault();

                    dragScript = script;
                    onScriptDragStart(evt);
                    tooltipHandle.hidden = true;
                }, false);
                panel.headerAppend(panel.handle);

                // tooltip
                var tooltipHandle = Tooltip.attach({
                    target: panel.handle,
                    text: 'Drag',
                    align: 'right',
                    root: editor.call('layout.root')
                });
                panel.once('destroy', function() {
                    tooltipHandle.destroy();
                });
            }

            // check if script is present in all entities
            for(var i = 0; i < entities.length; i++) {
                if (! entities[i].has('components.script.scripts.' + script)) {
                    panel.header += ' *';
                    break;
                }
            }

            panel.headerElementTitle.addEventListener('click', function() {
                if (! panel.headerElementTitle.classList.contains('link'))
                    return;

                editor.call('selector:set', 'asset', [ scriptAsset ]);
            });

            // edit
            var btnEdit = new ui.Button({
                text: '&#57648;'
            });
            btnEdit.class.add('edit');
            panel.headerAppend(btnEdit);
            btnEdit.on('click', function() {
                editor.call('assets:edit', scriptAsset);
            });
            btnEdit.hidden = editor.call('assets:scripts:collide', script) || ! editor.call('assets:scripts:assetByScript', script);
            // tooltip
            var tooltipEdit = Tooltip.attach({
                target: btnEdit.element,
                text: 'Edit',
                align: 'bottom',
                root: editor.call('layout.root')
            });
            btnEdit.once('destroy', function() {
                tooltipEdit.destroy();
            });

            // edit
            var btnParse = new ui.Button({
                text: '&#57640;'
            });
            btnParse.class.add('parse');
            panel.headerAppend(btnParse);
            btnParse.on('click', function() {
                btnParse.disabled = true;
                editor.call('scripts:parse', scriptAsset, function(err, result) {
                    btnParse.disabled = false;
                    if (err) {
                        btnParse.class.add('error');
                    } else {
                        btnParse.class.remove('error');
                    }
                });
            });
            btnParse.hidden = editor.call('assets:scripts:collide', script) || ! editor.call('assets:scripts:assetByScript', script);
            // tooltip
            var tooltipParse = Tooltip.attach({
                target: btnParse.element,
                text: 'Parse',
                align: 'bottom',
                root: editor.call('layout.root')
            });
            btnParse.once('destroy', function() {
                tooltipParse.destroy();
            });

            // remove
            var btnRemove = new ui.Button();
            btnRemove.class.add('remove');
            panel.headerAppend(btnRemove);
            btnRemove.on('click', function() {
                var records = [ ];

                for(var i = 0; i < entities.length; i++) {
                    if (! entities[i].has('components.script.scripts.' + script))
                        continue;

                    records.push({
                        get: entities[i].history._getItemFn,
                        ind: entities[i].get('components.script.order').indexOf(script),
                        data: entities[i].get('components.script.scripts.' + script)
                    });
                }

                for(var i = 0; i < records.length; i++) {
                    var entity = records[i].get();
                    entity.history.enabled = false;
                    entity.unset('components.script.scripts.' + script);
                    entity.removeValue('components.script.order', script);
                    entity.history.enabled = true;
                }

                editor.call('history:add', {
                    name: 'entities.components.script.scripts',
                    undo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item = records[i].get();
                            if (! item) continue;

                            item.history.enabled = false;
                            item.set('components.script.scripts.' + script, records[i].data);
                            item.insert('components.script.order', script, records[i].ind);
                            item.history.enabled = true;
                        }
                    },
                    redo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item = records[i].get();
                            if (! item) continue;

                            item.history.enabled = false;
                            item.unset('components.script.scripts.' + script);
                            item.removeValue('components.script.order', script);
                            item.history.enabled = true;
                        }
                    }
                });

                removeScript(script);
            });
            // tooltip
            var tooltipRemove = Tooltip.attach({
                target: btnRemove.element,
                text: 'Remove',
                align: 'bottom',
                root: editor.call('layout.root')
            });
            btnRemove.once('destroy', function() {
                tooltipRemove.destroy();
            });

            // enable/disable
            var fieldEnabled = editor.call('attributes:addField', {
                panel: panel,
                type: 'checkbox',
                link: entities,
                path: 'components.script.scripts.' + script + '.enabled'
            });
            fieldEnabled.class.remove('tick');
            fieldEnabled.class.add('component-toggle');
            fieldEnabled.element.parentNode.removeChild(fieldEnabled.element);
            panel.headerAppend(fieldEnabled);

            // toggle-label
            var labelEnabled = new ui.Label();
            labelEnabled.renderChanges = false;
            labelEnabled.class.add('component-toggle-label');
            panel.headerAppend(labelEnabled);
            labelEnabled.text = fieldEnabled.class.contains('null') ? '?' : (fieldEnabled.value ? 'On' : 'Off');
            fieldEnabled.on('change', function(value) {
                labelEnabled.text = fieldEnabled.class.contains('null') ? '?' : (value ? 'On' : 'Off');
            });

            var scriptAsset = editor.call('assets:scripts:assetByScript', script);

            if (scriptAsset)
                panel.headerElementTitle.classList.add('link');

            // invalid sign
            var labelInvalid = new ui.Label({ text: '!' });
            labelInvalid.renderChanges = false;
            labelInvalid.class.add('invalid-script');
            panel.headerAppend(labelInvalid);
            labelInvalid.hidden = !! scriptAsset;

            // invalid tooltip
            var tooltipInvalid = editor.call('attributes:reference', {
                title: 'Invalid',
                description: 'test'
            });
            tooltipInvalid.attach({
                target: panel,
                element: labelInvalid.element
            });

            var updateInvalidTooltip = function() {
                var asset = editor.call('assets:scripts:assetByScript', script);
                var description = '';

                if (editor.call('assets:scripts:collide', script)) {
                    // collision
                    description = '\'' + script + '\' Script Object is defined in multiple preloaded assets. Please uncheck preloading for undesirable script assets.';
                } else {
                    // no script
                    description = '\'' + script + '\' Script Object is not defined in any of preloaded script assets.';
                }

                tooltipInvalid.html = editor.call('attributes:reference:template', {
                    title: 'Invalid',
                    description: description
                });
            };
            if (! scriptAsset)
                updateInvalidTooltip();

            panelScripts.hidden = false;

            // primary script changed
            events.push(editor.on('assets:scripts[' + script + ']:primary:set', function(asset) {
                scriptAsset = asset;
                labelInvalid.hidden = true;
                btnEdit.hidden = btnParse.hidden = false;
                panel.headerElementTitle.classList.add('link');
            }));
            events.push(editor.on('assets:scripts[' + script + ']:primary:unset', function(asset) {
                scriptAsset = null;
                labelInvalid.hidden = false;
                btnEdit.hidden = btnParse.hidden = true;
                panel.headerElementTitle.classList.remove('link');
                updateInvalidTooltip();
            }));

            // attribute added
            events.push(editor.on('assets:scripts[' + script + ']:attribute:set', function(asset, name, ind) {
                if (asset !== scriptAsset)
                    return;

                var attribute = scriptAsset.get('data.scripts.' + script + '.attributes.' + name);
                addScriptAttribute(script, name, attribute, ind);
            }));
            // attribute change
            events.push(editor.on('assets:scripts[' + script + ']:attribute:change', function(asset, name, attribute, old) {
                if (asset !== scriptAsset)
                    return;

                updateScriptAttribute(script, name, attribute, old);
            }));
            // attribute move
            events.push(editor.on('assets:scripts[' + script + ']:attribute:move', function(asset, name, ind, indOld) {
                if (asset !== scriptAsset)
                    return;

                moveScriptAttribute(script, name, ind, indOld);
            }));
            // attribute removed
            events.push(editor.on('assets:scripts[' + script + ']:attribute:unset', function(asset, name) {
                if (asset !== scriptAsset)
                    return;

                removeScriptAttribute(script, name);
            }));

            if (scriptAsset) {
                var attributesOrder = scriptAsset.get('data.scripts.' + script + '.attributesOrder');
                if (attributesOrder) {
                    for(var i = 0; i < attributesOrder.length; i++) {
                        var attribute = scriptAsset.get('data.scripts.' + script + '.attributes.' + attributesOrder[i]);
                        addScriptAttribute(script, attributesOrder[i], attribute);
                    }
                }
            }
        };
        var removeScript = function(script) {
            if (! scriptPanelsIndex[script])
                return;

            var complete = true;
            for(var i = 0; i < entities.length; i++) {
                if (entities[i].has('components.script.scripts.' + script)) {
                    complete = false;
                    break;
                }
            }

            var panel = scriptPanelsIndex[script];

            if (! complete) {
                if (panel) panel.header = script + ' *';
                return;
            }

            if (panel) {
                delete scriptPanelsIndex[script];
                panel.destroy();
            }

            if (! panelScripts.innerElement.firstChild)
                panelScripts.hidden = true;
        };
        var addScriptAttribute = function(script, name, attribute, ind) {
            var panelScripts = scriptPanelsIndex[script];
            if (! panelScripts || panelScripts.attributesIndex[name])
                return;

            var panel = new ui.Panel();
            panel.field = null;
            panel.args = null;
            panelScripts.attributesIndex[name] = panel;

            var next = null;
            if (typeof(ind) === 'number')
                next = panelScripts.innerElement.children[ind];

            if (next) {
                panelScripts.appendBefore(panel, next);
            } else {
                panelScripts.append(panel);
            }

            var type = attributeTypeToUi[attribute.type];

            var reference = {
                title: name,
                subTitle: editor.call('assets:scripts:typeToSubTitle', attribute),
                description: attribute.description || ''
            };

            if (attribute.array) {
                if (attribute.type === 'string') {
                    type = 'strings';
                } else {
                    type = null;
                }
            }

            if (attribute.array && attribute.type === 'asset') {
                panel.args = {
                    panel: panel,
                    title: attribute.title || name,
                    name: attribute.title || name,
                    reference: reference,
                    type: attribute.assetType || '*',
                    link: entities,
                    path: 'components.script.scripts.' + script + '.attributes.' + name
                };
                panel.field = editor.call('attributes:addAssetsList', panel.args);
            } else {
                var min = typeof(attribute.min) === 'number' ? attribute.min : undefined;
                var max = typeof(attribute.max) === 'number' ? attribute.max : undefined;
                var curves = null;
                var choices = null;
                if (attribute.type === 'curve') {
                    if (attribute.color) {
                        curves = attribute.color.split('');
                        min = 0;
                        max = 1;
                    } else if (attribute.curves) {
                        curves = attribute.curves;
                    } else {
                        curves = [ 'Value' ];
                    }
                }

                if (attribute.enum) {
                    choices = [ { v: '', t: '...' } ];
                    for(var i = 0; i < attribute.enum.order.length; i++) {
                        var key = attribute.enum.order[i];
                        choices.push({
                            v: attribute.enum.options[key],
                            t: key
                        });
                    }
                }

                panel.args = {
                    parent: panel,
                    name: attribute.title || name,
                    placeholder: attribute.placeholder || null,
                    reference: reference,
                    type: type,
                    kind: attribute.assetType || '*',
                    link: entities,
                    enum: choices,
                    curves: curves,
                    gradient: !! attribute.color,
                    min: min,
                    max: max,
                    hideRandomize: true,
                    path: 'components.script.scripts.' + script + '.attributes.' + name
                };
                panel.field = editor.call('attributes:addField', panel.args);

                if (type === 'number') {
                    panel.slider = editor.call('attributes:addField', {
                        panel: panel.field.parent,
                        type: 'number',
                        slider: true,
                        link: entities,
                        min: min,
                        max: max,
                        path: 'components.script.scripts.' + script + '.attributes.' + name
                    });
                    panel.field.flexGrow = 1;
                    panel.field.style.width = '32px';
                    panel.slider.style.width = '32px';
                    panel.slider.flexGrow = 4;

                    panel.slider.update = function() {
                        panel.slider.hidden = (typeof(panel.args.max) !== 'number' || typeof(panel.args.min) !== 'number');
                        if (! panel.slider.hidden) {
                            panel.slider.max = panel.args.max;
                            panel.slider.min = panel.args.min;
                        }
                    };
                    panel.slider.update();
                }
            }

            return panel;
        };
        var removeScriptAttribute = function(script, name) {
            var panelScripts = scriptPanelsIndex[script];
            if (! panelScripts || ! panelScripts.attributesIndex[name])
                return;

            panelScripts.attributesIndex[name].destroy();
            delete panelScripts.attributesIndex[name];
        };
        var updateScriptAttribute = function(script, name, value, old) {
            var panelScripts = scriptPanelsIndex[script];
            if (! panelScripts) return;

            var panel = panelScripts.attributesIndex[name];
            if (! panel) return;

            var changed = false;
            if (value.type !== old.type)
                changed = true;

            if (! changed && !! value.array !== !! old.array)
                changed = true;

            if (! changed && typeof(value.enum) !== typeof(old.enum))
                changed = true;

            if (! changed && typeof(value.enum) === 'object' && ! value.enum.order.equals(old.enum.order))
                changed = true;

            if (! changed && typeof(value.enum) === 'object') {
                for(var i = 0; i < value.enum.order.length; i++) {
                    if (value.enum.options[value.enum.order[i]] !== old.enum.options[value.enum.order[i]]) {
                        changed = true;
                        break;
                    }
                }
            }

            if (! changed && value.type === 'curve' && typeof(value.color) !== typeof(old.color))
                changed = true;

            if (! changed && value.type === 'curve' && typeof(value.color) !== 'string' && typeof(value.curves) !== typeof(old.curves))
                changed = true;

            if (! changed) {
                var changeTooltip = false;

                var label = null;
                if (panel.field instanceof Array) {
                    label = panel.field[0].parent._label;
                } else {
                    label = panel.field.parent._label;
                }

                if (value.title !== old.title) {
                    changeTooltip = true;
                    label.text = value.title || name;
                }
                if (value.description !== old.description) {
                    changeTooltip = true;
                }
                if (value.placeholder !== old.placeholder) {
                    if (panel.field instanceof Array) {
                        if (value.placeholder instanceof Array && value.placeholder.length === panel.field.length) {
                            for(var i = 0; i < panel.field.length; i++) {
                                panel.field[i].placeholder = value.placeholder[i];
                            }
                        } else {
                            for(var i = 0; i < panel.field.length; i++) {
                                panel.field[i].placeholder = null;
                            }
                        }
                    } else {
                        panel.field.placeholder = value.placeholder;
                    }
                }
                if (value.min !== old.min) {
                    panel.args.min = value.min;
                    if (value.type === 'number') {
                        panel.field.min = value.min;
                        panel.slider.update();
                    }
                }
                if (value.max !== old.max) {
                    panel.args.max = value.max;
                    if (value.type === 'number') {
                        panel.field.max = value.max;
                        panel.slider.update();
                    }
                }
                if (value.assetType !== old.assetType)
                    panel.args.kind = value.assetType;

                if (changeTooltip) {
                    label._tooltip.html = editor.call('attributes:reference:template', {
                        title: name,
                        subTitle: editor.call('assets:scripts:typeToSubTitle', value),
                        description: value.description
                    });
                }
            }

            if (changed) {
                var next = panelScripts.element.nextSibling;
                removeScriptAttribute(script, name);
                var panel = addScriptAttribute(script, name, value);

                // insert at same location
                if (next) {
                    var parent = panel.element.parentNode;
                    parent.removeChild(panel.element);
                    parent.insertBefore(panel.element, next);
                }
            }
        };

        var moveScriptAttribute = function(script, name, ind, indOld) {
            var panelScripts = scriptPanelsIndex[script];
            if (! panelScripts) return;

            var panel = panelScripts.attributesIndex[name];
            if (! panel) return;

            var parent = panel.element.parentNode;
            parent.removeChild(panel.element);

            var next = parent.children[ind];
            if (next) {
                parent.insertBefore(panel.element, next);
            } else {
                parent.appendChild(panel.element);
            }
        };

        var scripts = { };
        for(var i = 0; i < entities.length; i++) {
            // on script add
            events.push(entities[i].on('components.script.order:insert', function(value, ind) {
                addScript(value, ind);
                calculateExcludeScripts();
            }));

            // on script remove
            events.push(entities[i].on('components.script.order:remove', function(value) {
                removeScript(value);
                calculateExcludeScripts();
            }));

            // on script component set
            events.push(entities[i].on('components.script:set', function(value) {
                if (! value || ! value.order || ! value.order.length)
                    return;

                for(var i = 0; i < value.order.length; i++) {
                    addScript(value.order[i], i);
                    calculateExcludeScripts();
                }
            }));

            // on script component unset
            events.push(entities[i].on('components.script:unset', function(value) {
                if (! value || ! value.order || ! value.order.length)
                    return;

                for(var i = 0; i < value.order.length; i++) {
                    removeScript(value.order[i]);
                    calculateExcludeScripts();
                }
            }));

            // on script move
            if (entities.length === 1) {
                events.push(entities[i].on('components.script.order:move', function(value, ind, indOld) {
                    var panel = scriptPanelsIndex[value];
                    if (! panel) return;

                    var parent = panel.element.parentNode;
                    parent.removeChild(panel.element);

                    var next = parent.children[ind];
                    if (next) {
                        parent.insertBefore(panel.element, next);
                    } else {
                        parent.appendChild(panel.element);
                    }
                }));
            }

            var items = entities[i].get('components.script.order');
            if (! items || items.length === 0)
                continue;

            for(var s = 0; s < items.length; s++)
                scripts[items[s]] = true;
        }

        for(var key in scripts) {
            if (! scripts.hasOwnProperty(key))
                continue;

            addScript(key);
        }

        panel.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();

            events = null;
        });
    });
});


/* editor/attributes/components/attributes-components-script.js */
editor.once('load', function() {
    'use strict';

    if (! editor.call('settings:project').get('useLegacyScripts'))
        return;

    var scriptAttributeTypes = {
        'number': 'number',
        'string': 'string',
        'boolean': 'checkbox',
        'asset': 'assets', // TEMP
        'rgb': 'rgb',
        'rgba': 'rgb', // TEMP
        'vector': 'vec3',
        'vec2': 'vec2',
        'vec3': 'vec3',
        'vec4': 'vec4',
        'enumeration': 'number',
        'entity': 'entity',
        'curve': 'curveset',
        'colorcurve': 'curveset'
    };

    var scriptAttributeRuntimeTypes = {
        'number': '{Number}',
        'string': '{String}',
        'boolean': '{Boolean}',
        'rgb': '{pc.Color}',
        'rgba': '{pc.Color}',
        'vector': '{pc.Vec3}',
        'vec2': '{pc.Vec2}',
        'vec3': '{pc.Vec3}',
        'vec4': '{pc.Vec4}',
        'enumeration': '{Number}',
        'entity': '{pc.Entity}'
    };

    // index entities with script components
    // so we can easily find them when we need
    // to refresh script attributes
    var entitiesWithScripts = { };

    editor.on('entities:add', function (entity) {
        if (entity.get('components.script'))
            entitiesWithScripts[entity.get('resource_id')] = entity;

        entity.on('components.script:set', function (value) {
            if (! value)
                return;

            entitiesWithScripts[entity.get('resource_id')] = entity;
        });

        entity.on('components.script:unset', function () {
            delete entitiesWithScripts[entity.get('resource_id')];
        });
    });

    editor.on('entities:remove', function (entity) {
        delete entitiesWithScripts[entity.get('resource_id')];
    });

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Scripts',
            name: 'script',
            entities: entities
        });

        // holds each script panel
        var events = [ ];
        var scriptsIndex = { };

        for(var i = 0; i < entities.length; i++) {
            events.push(entities[i].on('components.script:unset', function(valueOld) {
                if (! valueOld)
                    return;

                for(var i = 0; i < valueOld.scripts.length; i++) {
                    var scriptPanel = scriptsIndex[valueOld.scripts[i].url];
                    if (! scriptPanel)
                        continue;

                    scriptPanel.count--;
                    scriptPanel._link.textContent = (scriptPanel.count === entities.length ? '' : '* ') + scriptPanel._originalTitle;

                    if (scriptPanel.count === 0) {
                        scriptPanel.destroy();
                        delete scriptsIndex[valueOld.scripts[i].url];
                    }
                }
            }));
        }

        var urlRegex = /^http(s)?:/;
        var jsRegex = /\.js$/;
        var scriptNameRegex = /^(?:[\w\d\.-]+\/)*[\w\d\.-]+(?:\.[j|J][s|S](?:[o|O][n|N])?)?$/;

        // scripts.add
        var btnAddScript = new ui.Button({
            text: 'Add Script'
        });
        btnAddScript.class.add('add-script');
        panel.append(btnAddScript);

        btnAddScript.on('click', function () {
            var evtPick = editor.once("picker:asset", function (asset) {
                addScript(asset.get('filename'));
                evtPick = null;
            });

            // show asset picker
            editor.call("picker:asset", "script", null);

            editor.once('picker:asset:close', function () {
                if (evtPick) {
                    evtPick.unbind();
                    evtPick = null;
                }
            });
        });

        var panelScripts = new ui.Panel();
        panelScripts.class.add('components-scripts');
        panel.append(panelScripts);

        var addScript = function(url) {
            var scriptAdded = false;
            var records = [ ];
            var requestScript = false;

            if (! urlRegex.test(url)) {
                if (! jsRegex.test(url))
                    url += '.js';

                if (! scriptNameRegex.test(url) || url.indexOf('..') >= 0)
                    return false;

                requestScript = true;
            }

            for(var i = 0; i < entities.length; i++) {
                var addScript = true;
                var scripts = entities[i].getRaw('components.script.scripts');
                for(var s = 0; s < scripts.length; s++) {
                    if (scripts[s].get('url') === url) {
                        addScript = false;
                        break;
                    }
                }

                if (addScript) {
                    var script = new Observer({
                        url: url
                    });

                    records.push({
                        get: entities[i].history._getItemFn
                    });

                    entities[i].history.enabled = false;
                    entities[i].insert('components.script.scripts', script);
                    entities[i].history.enabled = true;

                    scriptAdded = true;
                }
            }

            if (requestScript) {
                // try to get the script and if it doesn't exist create it
                editor.call('sourcefiles:content', url, function (err) {
                    // script does not exist so create it
                    if (err === 404) {
                        editor.call('sourcefiles:create', editor.call('sourcefiles:skeleton', url), url);
                    } else if (!err) {
                        refreshScriptAttributes(url);
                    }
                });
            } else {
                refreshScriptAttributes(url);
            }

            editor.call('history:add', {
                name: 'entities.components.script.scripts',
                undo: function() {
                    for(var i = 0; i < records.length; i++) {
                        var item = records[i].get();
                        if (! item)
                            continue;

                        var scripts = item.getRaw('components.script.scripts');
                        if (! scripts)
                            continue;

                        for(var s = 0; s < scripts.length; s++) {
                            if (scripts[s].get('url') !== url)
                                continue;

                            item.history.enabled = false;
                            item.removeValue('components.script.scripts', scripts[s]);
                            item.history.enabled = true;
                            break;
                        }
                    }
                },
                redo: function() {
                    for(var i = 0; i < records.length; i++) {
                        var item = records[i].get();
                        if (! item)
                            continue;

                        var addScript = true;
                        var scripts = item.getRaw('components.script.scripts');
                        for(var s = 0; s < scripts.length; s++) {
                            if (scripts[s].get('url') !== url)
                                continue;
                            addScript = false;
                            break;
                        }

                        if (! addScript)
                            continue;

                        var script = new Observer({
                            url: url
                        });

                        item.history.enabled = false;
                        item.insert('components.script.scripts', script);
                        item.history.enabled = true;
                    }

                    refreshScriptAttributes(url);
                }
            });

            return scriptAdded;
        };

        var refreshScriptAttributes = function(url) {
            if (! editor.call('permissions:write'))
                return;

            var fullUrl = urlRegex.test(url) ? url : editor.call('sourcefiles:url', url) + '?access_token=' + config.accessToken;

            editor.call('sourcefiles:scan', fullUrl, function (data) {
                data.url = url;

                // merge old attributes with new attributes for all script components with this script
                for (var key in entitiesWithScripts) {
                    var entity = entitiesWithScripts[key];
                    var scripts = entity.getRaw('components.script.scripts');
                    if (! scripts)
                        continue;

                    for (var i = 0; i < scripts.length; i++) {
                        var scriptInstance = scripts[i];
                        if (scriptInstance.get('url') !== url)
                            continue;

                        var oldAttributes = scriptInstance.get('attributes') || { };
                        for (var attributeName in data.attributes) {
                            if (! data.attributes.hasOwnProperty(attributeName))
                                continue;

                            var value = data.attributes[attributeName].defaultValue;
                            if (attributeName in oldAttributes) {
                                var attributeOld = oldAttributes[attributeName];
                                var attributeNew = data.attributes[attributeName];

                                if (attributeOld.type === 'asset') {
                                    if (attributeOld.options.type !== attributeNew.options.type) {
                                        // different asset.type
                                        if (attributeNew.options.max === 1) {
                                            if (typeof(attributeNew.defaultValue) === 'number') {
                                                value = attributeNew.defaultValue;
                                            } else {
                                                value = null;
                                            }
                                        } else {
                                            if (attributeNew.defaultValue instanceof Array) {
                                                value = attributeNew.defaultValue;
                                            } else {
                                                value = [ ];
                                            }
                                        }
                                    } else if (attributeOld.options.max === 1 && attributeNew.options.max !== 1) {
                                        // now multiple assets
                                        if (attributeOld.value && typeof(attributeOld.value) === 'number') {
                                            value = [ attributeOld.value ];
                                        } else if (attributeNew.defaultValue instanceof Array) {
                                            value = attributeNew.defaultValue;
                                        } else {
                                            value = [ ];
                                        }
                                    } else if (attributeOld.options.max !== 1 && attributeNew.options.max === 1) {
                                        // now single asset
                                        if ((attributeOld.value instanceof Array) && attributeOld.value.length && attributeOld.value[0] && typeof(attributeOld.value[0]) === 'number') {
                                            value = attributeOld.value[0];
                                        } else if (typeof(attributeNew.defaultValue) === 'number') {
                                            value = attributeNew.defaultValue;
                                        } else {
                                            value = null;
                                        }
                                    } else {
                                        // old value
                                        value = attributeOld.value !== attributeOld.defaultValue ? attributeOld.value : value;
                                    }
                                } else if (attributeOld.type === data.attributes[attributeName].type) {
                                    // old value
                                    value = attributeOld.value !== attributeOld.defaultValue ? attributeOld.value : value;
                                }
                            }

                            data.attributes[attributeName].value = value;
                        }

                        // this is not undoable
                        var history = entity.history.enabled;
                        entity.history.enabled = false;
                        entity.getRaw('components.script.scripts.' + i).patch(data);
                        entity.history.enabled = history;
                    }
                }
            });
        };

        var updateAttributeFields = function(script, parent) {
            var attributes = script.get('attributesOrder');
            var children = parent.innerElement.childNodes;
            var list = [ ];
            var index = { };
            var toDestroy = [ ];
            var toCreate = [ ];

            for(var i = 0; i < children.length; i++) {
                var attribute = children[i].ui.attribute;
                var attributeType = children[i].ui.attributeType;
                var attributeUiType = children[i].ui.attributeUiType;

                if (attributes.indexOf(attribute) === -1 || attributeUiType !== script.get('attributes.' + attribute + '.type')) {
                    toDestroy.push(children[i].ui);
                } else {
                    list.push(attribute);
                    index[attribute] = children[i].ui;
                }
            }

            var i = toDestroy.length;
            while(i--) {
                toDestroy[i].destroy();
            }

            if (attributes) {
                for(var i = 0; i < attributes.length; i++) {
                    var ind = list.indexOf(attributes[i]);
                    var panelAttribute = null;

                    if (ind === -1) {
                        // new attibute
                        panelAttribute = createAttributeField(script, attributes[i], parent);
                        list.splice(i, 0, attributes[i]);
                        index[attributes[i]] = panelAttribute;
                    } else if (ind !== i) {
                        // moved attribute
                        panelAttribute = index[attributes[i]];
                        list.splice(ind, 1);
                        list.splice(i, 0, attributes[i]);
                    }

                    if (! panelAttribute)
                        continue;

                    parent.innerElement.removeChild(panelAttribute.element);

                    var ref = null;
                    if (i === 0) {
                        ref = parent.innerElement.firstChild;
                    } else {
                        ref = index[list[i - 1]].element.nextSibling;
                    }

                    if (ref) {
                        parent.innerElement.insertBefore(panelAttribute.element, ref);
                    } else {
                        parent.innerElement.appendChild(panelAttribute.element);
                    }
                }
            }
        };

        var createAttributeField = function(script, attribute, parent) {
            var choices = null;
            attribute = script.get('attributes.' + attribute);

            if (attribute.type === 'enumeration') {
                choices = [ { v: '', t: '...' } ];

                try {
                    for(var e = 0; e < attribute.options.enumerations.length; e++) {
                        choices.push({
                            v: attribute.options.enumerations[e].value,
                            t: attribute.options.enumerations[e].name
                        });
                    }
                } catch(ex) {
                    console.log(ex)
                    console.log('could not recreate enumeration for script attribute, ' + script.get('url'));
                }
            }

            var url = script.get('url');
            var scripts = [ ];
            for(var i = 0; i < entities.length; i++) {
                var items = entities[i].getRaw('components.script.scripts');
                if (! items)
                    continue;

                for(var s = 0; s < items.length; s++) {
                    if (items[s].get('url') === url) {
                        scripts.push(items[s]);
                        break;
                    }
                }
            }

            var field;

            var reference = {
                title: attribute.name,
                subTitle: scriptAttributeRuntimeTypes[attribute.type]
            };

            if (attribute.description)
                reference.description = attribute.description;
            else if (attribute.displayName !== attribute.name)
                reference.description = attribute.displayName;

            var type = scriptAttributeTypes[attribute.type];
            if (attribute.type === 'enumeration' && choices.length >= 2 && typeof(choices[1].v) === 'string') {
                type = 'string';
                reference.subTitle = scriptAttributeRuntimeTypes[type];
            } else if (attribute.type === 'asset') {
                if (attribute.options.max === 1) {
                    reference.subTitle = '{Number}';
                } else {
                    reference.subTitle = '[Number]';
                }
            } else if (attribute.type === 'curve') {
                if (attribute.options.curves.length > 1) {
                    reference.subTitle = '{pc.CurveSet}';
                } else {
                    reference.subTitle = '{pc.Curve}';
                }
            } else if (attribute.type === 'colorcurve') {
                if (attribute.options.type.length === 1) {
                    reference.subTitle = '{pc.Curve}';
                } else {
                    reference.subTitle = '{pc.CurveSet}';
                }
            }

            if (scriptAttributeTypes[attribute.type] !== 'assets') {
                var type = scriptAttributeTypes[attribute.type];
                if (attribute.type === 'enumeration' && choices.length >= 2 && typeof(choices[1].v) === 'string')
                    type = 'string';

                var args = {
                    parent: parent,
                    name: attribute.displayName || attribute.name,
                    type: type,
                    enum: choices,
                    link: scripts,
                    path: 'attributes.' + attribute.name + '.value',
                    reference: reference
                };

                if (attribute.type === 'number') {
                    if (attribute.options && attribute.options.step) {
                        args.step = attribute.options.step;
                        console.log('step yes')
                    }
                } else if (attribute.type === 'curve' || attribute.type === 'colorcurve') {
                    // find entity of first script
                    var firstEntity = scripts[0]._parent;
                    while (firstEntity._parent) {
                        firstEntity = firstEntity._parent;
                    }

                    var scriptIndex = firstEntity.getRaw('components.script.scripts').indexOf(scripts[0]);

                    var setCurvePickerArgs = function (options) {
                        if (attribute.type === 'curve') {
                            args.curves = options.curves;
                            args.min = options.min;
                            args.max = options.max;
                            args.gradient = false;
                        } else {
                            args.curves = options.type.split('');
                            args.min = 0;
                            args.max = 1;
                            args.gradient = true;
                        }
                    };

                    setCurvePickerArgs(attribute.options);

                    // use entity as the link for the curve so that history will work as expected
                    args.link = firstEntity;
                    args.path = 'components.script.scripts.' + scriptIndex + '.attributes.' + attribute.name + '.value';
                    args.hideRandomize = true;

                    var curveType = attribute.type;

                    // when argument options change make sure we refresh the curve pickers
                    var evtOptionsChanged = scripts[0].on('attributes.' + attribute.name + '.options:set', function (value, oldValue) {
                        // do this in a timeout to make sure it's done after all of the
                        // attribute fields have been updated like the 'defaultValue' field
                        setTimeout(function () {
                            // argument options changed so get new options and set args
                            var options = value;

                            var prevNumCurves = args.curves.length;

                            setCurvePickerArgs(options);

                            // reset field value which will trigger a refresh of the curve picker as well
                            var attributeValue = scripts[0].get('attributes.' + attribute.name + '.value');
                            if (prevNumCurves !== args.curves.length) {
                                attributeValue = scripts[0].get('attributes.' + attribute.name + '.defaultValue');
                                scripts[0].set('attributes.' + attribute.name + '.value', attributeValue);
                            }

                            field.curveNames = args.curves;
                            field.value = [attributeValue];
                        });
                    });
                    events.push(evtOptionsChanged);

                    // if we change the attribute type then don't listen to options changes
                    var evtTypeChanged = scripts[0].on('attributes.' + attribute.name + '.type:set', function (value) {
                        if (value !== curveType) {
                            evtOptionsChanged.unbind();
                            evtTypeChanged.unbind();
                        }
                    });
                    events.push(evtTypeChanged);
                }

                field = editor.call('attributes:addField', args);

                if (attribute.type === 'curve' || attribute.type === 'colorcurve') {
                    if (entities.length > 1)
                        field.disabled = true;
                }
            }

            if (attribute.type !== 'enumeration' && scriptAttributeTypes[attribute.type] === 'number') {
                field.flexGrow = 1;
                field.style.width = '32px';

                // slider
                var slider = editor.call('attributes:addField', {
                    panel: field.parent,
                    min: isNaN(attribute.options.min) ? 0 : attribute.options.min,
                    max: isNaN(attribute.options.max) ? 1 : attribute.options.max,
                    type: 'number',
                    slider: true,
                    link: scripts,
                    path: 'attributes.' + attribute.name + '.value'
                });
                slider.style.width = '32px';
                slider.flexGrow = 4;

                var sliderHidden = function() {
                    var min = script.get('attributes.' + attribute.name + '.options.min');
                    var max = script.get('attributes.' + attribute.name + '.options.max');
                    slider.hidden = min == null || max == null || isNaN(min) || isNaN(max);
                };
                sliderHidden();

                var evtMin = script.on('attributes.' + attribute.name + '.options.min:set', function(value) {
                    slider.min = value;
                    sliderHidden();
                });
                events.push(evtMin)

                var evtMax = script.on('attributes.' + attribute.name + '.options.max:set', function(value) {
                    slider.max = value;
                    sliderHidden();
                });
                events.push(evtMax);

                var evtMinUnset = script.on('attributes.' + attribute.name + '.options.min:unset', function() {
                    slider.hidden = true;
                });
                events.push(evtMinUnset);

                var evtMaxUnset = script.on('attributes.' + attribute.name + '.options.max:unset', function() {
                    slider.hidden = true;
                });
                events.push(evtMaxUnset);

                events.push(field.once('destroy', function() {
                    evtMin.unbind();
                    evtMax.unbind();
                    evtMinUnset.unbind();
                    evtMaxUnset.unbind();
                }));
            } else if (scriptAttributeTypes[attribute.type] === 'assets') {
                var options;

                if (attribute.options.max === 1) {
                    // asset
                    options = {
                        parent: parent,
                        name: attribute.displayName || attribute.name,
                        type: 'asset',
                        kind: attribute.options.type || '*',
                        link: scripts,
                        path: 'attributes.' + attribute.name + '.value',
                        single: true,
                        reference: reference
                    };
                    field = editor.call('attributes:addField', options);
                } else {
                    // assets
                    options = {
                        panel: parent,
                        title: 'Asset',
                        type: attribute.options.type || '*',
                        link: scripts,
                        path: 'attributes.' + attribute.name + '.value',
                        reference: reference
                    };
                    field = editor.call('attributes:addAssetsList', options);
                    field.parent._label.text = attribute.displayName || attribute.name;
                }

                field.options = options;

                // if we change asset `type`
                var evtAssetTypeChanged = scripts[0].on('attributes.' + attribute.name + '.options.type:set', function (value) {
                    options.kind = value || '*';
                });
                events.push(evtAssetTypeChanged);

                // if we change `max` to change between single/multiple
                var evtMaxAssetChanged = script.on('attributes.' + attribute.name + '.options.max:set', function(value) {
                    if ((options.single && value === 1) || (! options.single && value !== 1))
                        return;

                    setTimeout(function() {
                        updateAttributeFields(script, parent);
                    }, 0);
                });
                events.push(evtMaxAssetChanged);

                field.once('destroy', function() {
                    evtAssetTypeChanged.unbind();
                    evtMaxAssetChanged.unbind();
                });
            }

            var fieldParent;
            if (field instanceof Array) {
                fieldParent = field[0].parent;
            } else {
                fieldParent = field.parent;
            }

            var evtType = script.on('attributes.' + attribute.name + '.type:set', function(value) {
                setTimeout(function() {
                    updateAttributeFields(script, parent);
                }, 0);
            });
            events.push(evtType);

            events.push(fieldParent.once('destroy', function() {
                evtType.unbind();
            }));

            fieldParent.attribute = attribute.name;
            fieldParent.attributeUiType = scriptAttributeTypes[attribute.type];
            fieldParent.attributeType = attribute.type;

            return fieldParent;
        };

        var createScriptPanel = function(script) {
            var panelScript = scriptsIndex[script.get('url')];
            if (panelScript) {
                panelScript.count++;
                panelScript._link.textContent = (panelScript.count === entities.length ? '' : '* ') + panelScript._originalTitle;
                return;
            }

            panelScript = new ui.Panel(script.get('url'));
            panelScript.class.add('component-script');
            panelScript.count = 1;

            var href = document.createElement('div');
            href.classList.add('link');

            var url = script.get('url');
            var lowerUrl = url.toLowerCase();
            var isExternalUrl = urlRegex.test(lowerUrl);
            if (! isExternalUrl && ! jsRegex.test(url))
                url += '.js';

            panelScript._originalTitle = script.get('name') || getFilenameFromUrl(url);
            panelScript._link = href;
            href.textContent = (panelScript.count === entities.length ? '' : '* ') + panelScript._originalTitle;
            href.url = isExternalUrl ? url : 'https://' + window.location.host + '/editor/code/' + config.project.id + '/' + url;
            href.addEventListener('click', function() {
                window.open(this.url, this.url);
            });
            panelScript.headerElementTitle.textContent = '';
            panelScript.headerElementTitle.appendChild(href);

            // name change
            events.push(script.on('name:set', function(value) {
                panelScript._originalTitle = value;
                href.textContent = (panelScript.count === entities.length ? '' : '* ') + panelScript._originalTitle;
            }));

            // remove
            var fieldRemoveScript = new ui.Button();
            fieldRemoveScript.parent = panelScript;
            fieldRemoveScript.class.add('remove');
            fieldRemoveScript.on('click', function (value) {
                var records = [ ];

                for(var i = 0; i < entities.length; i++) {
                    entities[i].history.enabled = false;
                    var scripts = entities[i].getRaw('components.script.scripts');
                    for(var s = 0; s < scripts.length; s++) {
                        if (scripts[s].get('url') === script.get('url')) {
                            var data = scripts[s].json();

                            records.push({
                                get: entities[i].history._getItemFn,
                                value: data,
                                ind: s
                            });

                            entities[i].remove('components.script.scripts', s);
                            break;
                        }
                    }
                    entities[i].history.enabled = true;
                }

                delete scriptsIndex[script.get('url')];

                if (! records.length)
                    return;

                editor.call('history:add', {
                    name: 'entities.components.script.scripts',
                    undo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item = records[i].get();
                            if (! item)
                                continue;

                            var scripts = item.getRaw('components.script.scripts');
                            if (! scripts)
                                continue;

                            var addScript = true;

                            for(var s = 0; s < scripts.length; s++) {
                                if (scripts[s].get('url') === records[i].value.url) {
                                    addScript = false;
                                    break;
                                }
                            }

                            if (! addScript)
                                continue;

                            var script = new Observer(records[i].value);

                            item.history.enabled = false;
                            item.insert('components.script.scripts', script, records[i].ind);
                            item.history.enabled = true;
                        }

                        refreshScriptAttributes(records[0].value.url);
                    },
                    redo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item = records[i].get();
                            if (! item)
                                continue;

                            var scripts = item.getRaw('components.script.scripts');

                            for(var s = 0; s < scripts.length; s++) {
                                if (scripts[s].get('url') !== records[i].value.url)
                                    continue;

                                item.history.enabled = false;
                                item.removeValue('components.script.scripts', scripts[s]);
                                item.history.enabled = true;
                                break;
                            }
                        }

                        delete scriptsIndex[records[0].value.url];
                    }
                });
            });
            panelScript.headerElement.appendChild(fieldRemoveScript.element);

            // TODO
            // allow reordering scripts if all entities scripts components are identical

            // move down
            var fieldMoveDown = new ui.Button();
            fieldMoveDown.class.add('move-down');
            fieldMoveDown.element.title = 'Move script down';
            fieldMoveDown.on('click', function () {
                var scripts = entities[0].getRaw('components.script.scripts');
                var ind = scripts.indexOf(script);
                if (ind < scripts.length - 1)
                    entities[0].move('components.script.scripts', ind, ind + 1);
            });
            panelScript.headerElement.appendChild(fieldMoveDown.element);
            if (entities.length > 1)
                fieldMoveDown.style.visibility = 'hidden';

            // move up
            var fieldMoveUp = new ui.Button();
            fieldMoveUp.class.add('move-up');
            fieldMoveUp.element.title = 'Move script up';
            fieldMoveUp.on('click', function () {
                var ind = entities[0].getRaw('components.script.scripts').indexOf(script);
                if (ind > 0)
                    entities[0].move('components.script.scripts', ind, ind - 1);
            });
            panelScript.headerElement.appendChild(fieldMoveUp.element);
            if (entities.length > 1)
                fieldMoveUp.style.visibility = 'hidden';

            // refresh attributes
            var fieldRefreshAttributes = new ui.Button();
            fieldRefreshAttributes.class.add('refresh');
            fieldRefreshAttributes.element.title = "Refresh script attributes";
            panelScript.headerElement.appendChild(fieldRefreshAttributes.element);

            fieldRefreshAttributes.on('click', function () {
                refreshScriptAttributes(script.get('url'));
            });

            // attributes panel
            var attributes = new ui.Panel();
            panelScript.append(attributes);

            if (script.has('attributesOrder')) {
                // add attributes if has any
                var order = script.get('attributesOrder');
                if (order) {
                    for(var i = 0; i < order.length; i++) {
                        createAttributeField(script, order[i], attributes);
                    }
                }
            }

            var timerUpdateAttributes = null;
            // when attributes order changed, schedule update
            events.push(script.on('attributesOrder:set', function() {
                if (timerUpdateAttributes)
                    return;

                timerUpdateAttributes = setTimeout(function() {
                    timerUpdateAttributes = null;
                    updateAttributeFields(script, attributes);
                }, 0);
            }));

            return panelScript;
        };

        // Converts URL to script name
        var getFilenameFromUrl = function(url) {
            var filename = url;

            if (jsRegex.test(filename))
                filename = filename.substring(0, filename.length - 3);

            var lastIndexOfSlash = filename.lastIndexOf('/');
            if (lastIndexOfSlash >= 0)
                filename = filename.substring(lastIndexOfSlash + 1, filename.length);

            return filename;
        };

        var addScriptPanel = function(script, ind) {
            var panelScript = createScriptPanel(script);
            if (! panelScript)
                return;

            scriptsIndex[script.get('url')] = panelScript;

            var panels = panelScripts.innerElement.childNodes;

            if (ind === undefined || ind === panels.length) {
                // append at the end
                panelScripts.append(panelScript);
            } else {
                // append before panel at next index
                panelScripts.appendBefore(panelScript, panels[ind]);
            }
        };

        // add existing scripts and subscribe to scripts Observer list
        for(var i = 0; i < entities.length; i++) {
            var scripts = entities[i].getRaw('components.script.scripts');

            if (scripts) {
                for(var s = 0; s < scripts.length; s++)
                    addScriptPanel(scripts[s]);
            }

            // subscribe to scripts:set
            events.push(entities[i].on('components.script.scripts:set', function(value, valueOld) {
                for(var i = 0; i < value.length; i++)
                    addScriptPanel(value[i]);
            }));

            // subscribe to scripts:insert
            events.push(entities[i].on('components.script.scripts:insert', function (script, ind) {
                addScriptPanel(script, ind);
            }));

            events.push(entities[i].on('components.script.scripts:move', function (value, indNew, indOld) {
                var elementOld = scriptsIndex[this.get('components.script.scripts.' + indOld + '.url')];
                var elementNew = scriptsIndex[value.get('url')];

                panelScripts.innerElement.removeChild(elementNew.element);

                if (indNew > indOld) {
                    if (elementOld.element.nextSibling) {
                        panelScripts.innerElement.insertBefore(elementNew.element, elementOld.element.nextSibling);
                    } else {
                        panelScripts.innerElement.appendChild(elementNew.element);
                    }
                } else {
                    panelScripts.innerElement.insertBefore(elementNew.element, elementOld.element);
                }
            }));

            // subscribe to scripts:remove
            events.push(entities[i].on('components.script.scripts:remove', function (script, ind) {
                var scriptPanel = scriptsIndex[script.get('url')];
                if (! scriptPanel)
                    return;

                scriptPanel.count--;
                scriptPanel._link.textContent = (scriptPanel.count === entities.length ? '' : '* ') + scriptPanel._originalTitle;

                if (scriptPanel.count === 0) {
                    scriptsIndex[script.get('url')].destroy();
                    script.destroy();
                    delete scriptsIndex[script.get('url')];
                }
            }));
        }

        // drag drop
        var dropRef = editor.call('drop:target', {
            ref: panel.element,
            filter: function(type, data) {
                if (type !== 'asset.script') return false;

                var root = editor.call('layout.root');
                var rectA = root.innerElement.getBoundingClientRect();
                var rectB = panel.element.getBoundingClientRect();
                if (rectB.top > rectA.top && rectB.bottom < rectA.bottom) {
                    for(var i = 0; i < entities.length; i++) {
                        var addScript = true;
                        var scripts = entities[i].getRaw('components.script.scripts');
                        for(var s = 0; s < scripts.length; s++) {
                            if (scripts[s].get('url') === data.filename) {
                                return false;
                            }
                        }
                    }

                    return true;
                }

                return false;

            },
            drop: function(type, data) {
                if (type !== 'asset.script')
                    return;

                addScript(data.filename);
            }
        });

        // clean up events
        panel.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();

            events = null;
            dropRef.unregister();
        });
    });
});


/* editor/attributes/components/attributes-components-zone.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var events = [ ];

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Zone',
            name: 'zone',
            entities: entities
        });


        // size
        var fieldSize = editor.call('attributes:addField', {
            parent: panel,
            name: 'Size',
            placeholder: [ 'W', 'H', 'D' ],
            precision: 2,
            step: 0.1,
            min: 0,
            type: 'vec3',
            link: entities,
            path: 'components.zone.size'
        });
        // reference
        editor.call('attributes:reference:attach', 'zone:size', fieldSize[0].parent.innerElement.firstChild.ui);
    });
});


/* editor/attributes/components/attributes-components-screen.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var events = [ ];

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Screen',
            name: 'screen',
            entities: entities
        });

        // Screenspace
        var fieldScreenspace = editor.call('attributes:addField', {
            parent: panel,
            name: 'Screen Space',
            type: 'checkbox',
            link: entities,
            path: 'components.screen.screenSpace'
        });

        // reference
        editor.call('attributes:reference:attach', 'screen:screenSpace', fieldScreenspace.parent.innerElement.firstChild.ui);

        // Resolution
        var fieldResolution = editor.call('attributes:addField', {
            parent: panel,
            name: 'Resolution',
            placeholder: ['Width', 'Height'],
            type: 'vec2',
            link: entities,
            path: 'components.screen.resolution'
        });

        fieldResolution[0].parent.hidden = !!fieldScreenspace.value;

        // reference
        editor.call('attributes:reference:attach', 'screen:resolution', fieldResolution[0].parent.innerElement.firstChild.ui);

        // Reference Resolution
        var fieldRefResolution = editor.call('attributes:addField', {
            parent: panel,
            name: 'Ref Resolution',
            placeholder: ['Width', 'Height'],
            type: 'vec2',
            link: entities,
            path: 'components.screen.referenceResolution'
        });

        // reference
        editor.call('attributes:reference:attach', 'screen:referenceResolution', fieldRefResolution[0].parent.innerElement.firstChild.ui);

        // scale mode
        var fieldScaleMode = editor.call('attributes:addField', {
            parent: panel,
            name: 'Scale Mode',
            type: 'string',
            enum: [
                {v: '', t: '...'},
                {v: 'none', t: 'None'},
                {v: 'blend', t: 'Blend'},
            ],
            link: entities,
            path: 'components.screen.scaleMode'
        });

        fieldScaleMode.parent.hidden = !fieldScreenspace.value;

        // hide ref resolution if necessary
        fieldRefResolution[0].parent.hidden = fieldScaleMode.value === 'none' || !fieldScreenspace.value;

        // reference
        editor.call('attributes:reference:attach', 'screen:scaleMode', fieldScaleMode.parent.innerElement.firstChild.ui);

        // scale blend
        var fieldScaleBlend = editor.call('attributes:addField', {
            parent: panel,
            name: 'Scale Blend',
            type: 'number',
            min: 0,
            max: 1,
            precision: 2,
            step: 0.1,
            link: entities,
            path: 'components.screen.scaleBlend'
        });

        fieldScaleBlend.style.width = '32px';
        fieldScaleBlend.parent.hidden = fieldScaleMode.value !== 'blend' || ! fieldScreenspace.value;
        events.push(fieldScaleMode.on('change', function (value) {
            fieldScaleBlend.parent.hidden = value !== 'blend' || ! fieldScreenspace.value;
            fieldRefResolution[0].parent.hidden = value === 'none' || !fieldScreenspace.value;
        }));

        var fieldScaleBlendSlider = editor.call('attributes:addField', {
            panel: fieldScaleBlend.parent,
            precision: 2,
            step: 0.1,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: entities,
            path: 'components.screen.scaleBlend'
        });
        fieldScaleBlendSlider.flexGrow = 4;

        // reference
        editor.call('attributes:reference:attach', 'screen:scaleBlend', fieldScaleBlend.parent.innerElement.firstChild.ui);

        // on screenspace change
        events.push(fieldScreenspace.on('change', function (value) {
            fieldResolution[0].parent.hidden = !!value;
            fieldRefResolution[0].parent.hidden = fieldScaleMode.value === 'none' || !value;
            fieldScaleMode.parent.hidden = !value;
            fieldScaleBlend.parent.hidden = !value;
        }));

        panel.on('destroy', function () {
            events.forEach(function (e) {
                e.unbind();
            });
            events.length = 0;
        });

    });
});


/* editor/attributes/components/attributes-components-element.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var events = [ ];

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Element',
            name: 'element',
            entities: entities
        });

        var fieldType = editor.call('attributes:addField', {
            parent: panel,
            name: 'Type',
            type: 'string',
            enum: [
                {v: '', t: '...'},
                {v: 'text', t: 'Text'},
                {v: 'image', t: 'Image'},
                {v: 'group', t: 'Group'}
            ],
            link: entities,
            path: 'components.element.type'
        });

        // reference
        editor.call('attributes:reference:attach', 'element:type', fieldType.parent.innerElement.firstChild.ui);

        var presets = {
            '0,1,0,1/0,1': 'Top Left',
            '0.5,1,0.5,1/0.5,1': 'Top',
            '1,1,1,1/1,1': 'Top Right',
            '0,0.5,0,0.5/0,0.5': 'Left',
            '0.5,0.5,0.5,0.5/0.5,0.5': 'Center',
            '1,0.5,1,0.5/1,0.5': 'Right',
            '0,0,0,0/0,0': 'Bottom Left',
            '0.5,0,0.5,0/0.5,0': 'Bottom',
            '1,0,1,0/1,0': 'Bottom Right',
        };

        var presetsEnum = [];
        for (var key in presets) {
            presetsEnum.push({v: key, t: presets[key]});
        }

        presetsEnum.push({v: 'custom', t: 'Custom'});

        var fieldPreset = editor.call('attributes:addField', {
            parent: panel,
            name: 'Preset',
            type: 'string',
            enum: presetsEnum
        });

        editor.call('attributes:reference:attach', 'element:preset', fieldPreset.parent.innerElement.firstChild.ui);

        var fieldAnchor = editor.call('attributes:addField', {
            parent: panel,
            placeholder: ['', '', '', ''],
            name: 'Anchor',
            type: 'vec4',
            precision: 2,
            step: 0.1,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.element.anchor'
        });

        var onAnchorChange = function () {
            toggleSize();
            toggleMargin();
        };


        fieldAnchor.forEach(function (field, index) {
            field.on('change', onAnchorChange);

            // var changing = false;

            // var refreshValue = function () {
            //     var value = null;
            //     for (var i = 0, len = entities.length; i < len; i++) {
            //         var anchor = entities[i].get('components.element.anchor.' + index);
            //         if (value === null) {
            //             value = anchor;
            //         } else if (value !== anchor) {
            //             value = null;
            //             break;
            //         }
            //     }

            //     changing = true;
            //     field.value = value;
            //     changing = false;
            //     field.proxy = value !== null ? null : '...';
            // };

            // refreshValue();

            // field.on('change', function (value) {
            //     if (changing) return;

            //     changing = true;

            //     var prev = {};

            //     for (var i = 0, len = entities.length; i < len; i++) {
            //         if (entities[i].has('components.element')) {
            //             var prevData = {
            //                 anchor: entities[i].get('components.element.anchor.' + index)
            //             };

            //             prev[entities[i].get('resource_id')] = prevData;

            //             var history = entities[i].history.enabled;
            //             entities[i].history.enabled = false;
            //             entities[i].set('components.element.anchor.' + index, value);
            //             entities[i].history.enabled = history;
            //         }
            //     }

            //     editor.call('history:add', {
            //         name: 'components.element.anchor.' + index,
            //         undo: function () {
            //             for (var i = 0, len = entities.length; i < len; i++) {
            //                 var prevData = prev[entities[i].get('resource_id')];
            //                 if (! prevData) continue;

            //                 var obj = editor.call('entities:get', entities[i].get('resource_id'));
            //                 if (! obj) return;
            //                 var history = obj.history.enabled;
            //                 obj.history.enabled = false;
            //                 obj.set('components.element.anchor.' + index, prevData.anchor);
            //                 obj.history.enabled = history;
            //             }
            //         },
            //         redo: function () {
            //             for (var i = 0, len = entities.length; i < len; i++) {
            //                 var obj = editor.call('entities:get', entities[i].get('resource_id'));
            //                 if (! obj) return;

            //                 var history = obj.history.enabled;
            //                 obj.history.enabled = false;
            //                 obj.set('components.element.anchor.' + index, value);
            //                 obj.history.enabled = history;
            //             }

            //         }
            //     });

            //     changing = false;

            // });

            // for (var i = 0, len = entities.length; i < len; i++) {
            //     events.push(entities[i].on('components.element.anchor:set', refreshValue));
            //     events.push(entities[i].on('components.element.anchor.0:set', refreshValue));
            //     events.push(entities[i].on('components.element.anchor.1:set', refreshValue));
            //     events.push(entities[i].on('components.element.anchor.2:set', refreshValue));
            //     events.push(entities[i].on('components.element.anchor.3:set', refreshValue));
            // }
        });

        // reference
        editor.call('attributes:reference:attach', 'element:anchor', fieldAnchor[0].parent.innerElement.firstChild.ui);

        var fieldPivot = editor.call('attributes:addField', {
            parent: panel,
            placeholder: ['', ''],
            name: 'Pivot',
            type: 'vec2',
            precision: 2,
            step: 0.1,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.element.pivot'
        });

        // reference
        editor.call('attributes:reference:attach', 'element:pivot', fieldPivot[0].parent.innerElement.firstChild.ui);

        // auto size
        var panelAutoSize = editor.call('attributes:addField', {
            parent: panel,
            name: 'Auto-Size'
        });
        var label = panelAutoSize;
        panelAutoSize = panelAutoSize.parent;
        label.destroy();

        panelAutoSize.hidden = fieldType.value !== 'text';

        // autoWidth
        var fieldAutoWidth = editor.call('attributes:addField', {
            panel: panelAutoSize,
            type: 'checkbox',
            link: entities,
            path: 'components.element.autoWidth'
        });
        // label
        label = new ui.Label({ text: 'Width' });
        label.class.add('label-infield');
        label.style.paddingRight = '12px';
        panelAutoSize.append(label);
        // reference
        editor.call('attributes:reference:attach', 'element:autoWidth', label);

        fieldAutoWidth.on('change', function (value) {
            toggleSize();
            toggleMargin();
        });

        // autoHeight
        var fieldAutoHeight = editor.call('attributes:addField', {
            panel: panelAutoSize,
            type: 'checkbox',
            link: entities,
            path: 'components.element.autoHeight'
        });
        // label
        label = new ui.Label({ text: 'Height' });
        label.class.add('label-infield');
        label.style.paddingRight = '12px';
        panelAutoSize.append(label);

        // reference
        editor.call('attributes:reference:attach', 'element:autoHeight', label);

        fieldAutoHeight.on('change', function (value) {
            toggleSize();
            toggleMargin();
        });


        var setPresetValue = function () {
            var val = fieldAnchor.map(function (f) {return f.value}).join(',') + '/' + fieldPivot.map(function (f) {return f.value}).join(',');
            if (! presets[val])
                val = 'custom';

            fieldPreset.value = val;
        };

        setPresetValue();

        var changingPreset = false;

        for (var i = 0; i < 4; i++) {
            events.push(fieldAnchor[i].on('change', function (value) {
                if (changingPreset) return;
                changingPreset = true;
                setPresetValue();
                changingPreset = false;
            }));
        }

        for (var i = 0; i < 2; i++) {
            events.push(fieldPivot[i].on('change', function (value) {
                if (changingPreset) return;
                changingPreset = true;
                setPresetValue();
                changingPreset = false;
            }));
        }

        events.push(fieldPreset.on('change', function (value) {
            if (! value || value === 'custom' || changingPreset) return;

            changingPreset = true;
            var fields = value.split('/');
            var anchor = fields[0].split(',').map(function (v){ return parseFloat(v);} );
            var pivot = fields[1].split(',').map(function (v){ return parseFloat(v);} );

            var prev = {};

            var prevAnchors = [];
            var prevPivots = [];
            var prevPositions = [];

            for (var i = 0; i < entities.length; i++) {
                var history = entities[i].history.enabled;
                entities[i].history.enabled = false;
                var width = entities[i].get('components.element.width');
                var height = entities[i].get('components.element.height');
                prev[entities[i].get('resource_id')] = {
                    anchor: entities[i].get('components.element.anchor'),
                    pivot: entities[i].get('components.element.pivot'),
                    width: width,
                    height: height
                };
                entities[i].set('components.element.anchor', anchor);
                entities[i].set('components.element.pivot', pivot);
                if (entities[i].entity) {
                    entities[i].entity.element.width = width;
                    entities[i].entity.element.height = height;
                }
                entities[i].history.enabled = history;
            }

            editor.call('history:add', {
                name: 'entities.components.element.preset',
                undo: function() {
                    for(var i = 0; i < entities.length; i++) {
                        var entity = entities[i];
                        var history = entity.history.enabled;
                        entity.history.enabled = false;
                        var prevRecord = prev[entity.get('resource_id')];
                        entity.set('components.element.anchor', prevRecord.anchor);
                        entity.set('components.element.pivot', prevRecord.pivot);
                        if (entity.entity) {
                            entity.entity.element.width = prevRecord.width;
                            entity.entity.element.height = prevRecord.height;
                        }
                        entity.history.enabled = history;
                    }
                },
                redo: function() {
                    for(var i = 0; i < entities.length; i++) {
                        var entity = entities[i];
                        var history = entity.history.enabled;
                        entity.history.enabled = false;
                        entity.set('components.element.anchor', anchor);
                        entity.set('components.element.pivot', pivot);

                        var prevRecord = prev[entity.get('resource_id')];

                        if (entity.entity) {
                            entity.entity.element.width = prevRecord.width;
                            entity.entity.element.height = prevRecord.height;
                        }

                        entity.history.enabled = history;
                    }
                }
            });


            changingPreset = false;
        }));

        var hasSplitAnchors = function (horizontal) {
            for (var i = 0, len = entities.length; i < len; i++) {
                var e = entities[i];
                var anchor = e.get('components.element.anchor');
                if (! anchor) continue;
                if (horizontal) {
                    if (Math.abs(anchor[0] - anchor[2]) > 0.001) {
                        return true;
                    }
                } else {
                    if (Math.abs(anchor[1] - anchor[3]) > 0.001) {
                        return true;
                    }
                }
            }

            return false;
        };

        var fieldWidth = editor.call('attributes:addField', {
            parent: panel,
            name: 'Size',
            type: 'number',
            placeholder: 'Width',
            link: entities,
            path: 'components.element.width'
        });

        fieldWidth.style.width = '32px';

        // reference
        editor.call('attributes:reference:attach', 'element:size', fieldWidth.parent.innerElement.firstChild.ui);

        var fieldHeight = editor.call('attributes:addField', {
            panel: fieldWidth.parent,
            type: 'number',
            placeholder: 'Height',
            link: entities,
            path: 'components.element.height'
        });

        fieldHeight.style.width = '32px';

        var toggleSize = function () {
            fieldWidth.disabled = hasSplitAnchors(true) || (fieldAutoWidth.value && fieldType.value === 'text');
            fieldWidth.renderChanges = !fieldWidth.disabled;
            fieldHeight.disabled = hasSplitAnchors(false) || (fieldAutoHeight.value && fieldType.value === 'text');
            fieldHeight.renderChanges = !fieldHeight.disabled;
        };

        toggleSize();

        var fieldMargin = editor.call('attributes:addField', {
            parent: panel,
            name: 'Margin',
            type: 'vec4',
            placeholder: ['', '', '', ''],
            link: entities,
            path: 'components.element.margin'
        });

        // reference
        editor.call('attributes:reference:attach', 'element:margin', fieldMargin[0].parent.innerElement.firstChild.ui);

        var toggleMargin = function () {
            var horizontalSplit = hasSplitAnchors(true);
            var verticalSplit = hasSplitAnchors(false);
            fieldMargin[0].disabled = ! horizontalSplit || (fieldAutoWidth.value && fieldType.value === 'text');
            fieldMargin[2].disabled = fieldMargin[0].disabled;

            fieldMargin[1].disabled = ! verticalSplit || (fieldAutoHeight.value && fieldType.value === 'text');
            fieldMargin[3].disabled = fieldMargin[1].disabled;

            for (var i = 0; i < 4; i++)
                fieldMargin[i].renderChanges = !fieldMargin[i].disabled;
        };

        toggleMargin();

        var fieldAlignment = editor.call('attributes:addField', {
            parent: panel,
            name: 'Alignment',
            type: 'vec2',
            placeholder: ['', ''],
            precision: 2,
            step: 0.1,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.element.alignment'
        });

        // reference
        editor.call('attributes:reference:attach', 'element:alignment', fieldAlignment[0].parent.innerElement.firstChild.ui);

        fieldAlignment[0].parent.hidden = fieldType.value !== 'text';

        var fieldText = editor.call('attributes:addField', {
            parent: panel,
            name: 'Text',
            type: 'text',
            link: entities,
            path: 'components.element.text'
        });

        fieldText.parent.hidden = fieldType.value !== 'text';

        // reference
        editor.call('attributes:reference:attach', 'element:text', fieldText.parent.innerElement.firstChild.ui);

        var fieldFontSize = editor.call('attributes:addField', {
            parent: panel,
            name: 'Font Size',
            type: 'number',
            link: entities,
            path: 'components.element.fontSize'
        });

        fieldFontSize.parent.hidden = fieldType.value !== 'text';

        // reference
        editor.call('attributes:reference:attach', 'element:fontSize', fieldFontSize.parent.innerElement.firstChild.ui);

        var fieldLineHeight = editor.call('attributes:addField', {
            parent: panel,
            name: 'Line Height',
            type: 'number',
            link: entities,
            path: 'components.element.lineHeight'
        });

        fieldLineHeight.parent.hidden = fieldType.value !== 'text';

        // reference
        editor.call('attributes:reference:attach', 'element:lineHeight', fieldLineHeight.parent.innerElement.firstChild.ui);

        var fieldSpacing = editor.call('attributes:addField', {
            parent: panel,
            name: 'Spacing',
            type: 'number',
            link: entities,
            path: 'components.element.spacing'
        });

        fieldSpacing.parent.hidden = fieldType.value !== 'text';

        // reference
        editor.call('attributes:reference:attach', 'element:spacing', fieldSpacing.parent.innerElement.firstChild.ui);


        var fieldRect = editor.call('attributes:addField', {
            parent: panel,
            name: 'Rect',
            type: 'vec4',
            placeholder: ['u', 'v', 'w', 'h'],
            link: entities,
            path: 'components.element.rect'
        });

        fieldRect[0].parent.hidden = fieldType.value !== 'image';

        // reference
        editor.call('attributes:reference:attach', 'element:rect', fieldRect[0].parent.innerElement.firstChild.ui);

        var fieldTextureAsset = editor.call('attributes:addField', {
            parent: panel,
            name: 'Texture',
            type: 'asset',
            kind: 'texture',
            link: entities,
            path: 'components.element.textureAsset'
        });

        // reference
        editor.call('attributes:reference:attach', 'element:textureAsset', fieldTextureAsset.parent.innerElement.firstChild.ui);

        var fieldFontAsset = editor.call('attributes:addField', {
            parent: panel,
            name: 'Font',
            type: 'asset',
            kind: 'font',
            link: entities,
            path: 'components.element.fontAsset'
        });

        fieldFontAsset.parent.hidden = fieldType.value !== 'text';

        // reference
        editor.call('attributes:reference:attach', 'element:fontAsset', fieldFontAsset.parent.innerElement.firstChild.ui);

        var fieldColor = editor.call('attributes:addField', {
            parent: panel,
            name: 'Color',
            type: 'rgb',
            channels: 4,
            link: entities,
            path: 'components.element.color'
        });

        // reference
        editor.call('attributes:reference:attach', 'element:color', fieldColor.parent.innerElement.firstChild.ui);

        var fieldOpacity = editor.call('attributes:addField', {
            parent: panel,
            name: 'Opacity',
            type: 'number',
            min: 0,
            max: 1,
            link: entities,
            path: 'components.element.opacity'
        });

        fieldOpacity.style.width = '32px';

        // reference
        editor.call('attributes:reference:attach', 'element:opacity', fieldOpacity.parent.innerElement.firstChild.ui);

        var fieldOpacitySlider = editor.call('attributes:addField', {
            panel: fieldOpacity.parent,
            precision: 3,
            step: 1,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: entities,
            path: 'components.element.opacity'
        });
        fieldOpacitySlider.flexGrow = 4;

        var fieldMaterialAsset = editor.call('attributes:addField', {
            parent: panel,
            name: 'Material',
            type: 'asset',
            kind: 'material',
            link: entities,
            path: 'components.element.materialAsset'
        });

        // reference
        editor.call('attributes:reference:attach', 'element:materialAsset', fieldMaterialAsset.parent.innerElement.firstChild.ui);

        var fieldUseInput = editor.call('attributes:addField', {
            parent: panel,
            name: 'Use Input',
            type: 'checkbox',
            link: entities,
            path: 'components.element.useInput'
        });

        // reference
        editor.call('attributes:reference:attach', 'element:useInput', fieldUseInput.parent.innerElement.firstChild.ui);

        var toggleColorFields = function () {
            if (fieldMaterialAsset.value) {
                fieldTextureAsset.parent.hidden = true;
                fieldColor.parent.hidden = true;
                fieldOpacity.parent.hidden = true;
            } else {
                fieldTextureAsset.parent.hidden = fieldType.value !== 'image';
                fieldColor.parent.hidden = fieldType.value !== 'image' && fieldType.value !== 'text';
                fieldOpacity.parent.hidden = fieldType.value !== 'image' && fieldType.value !== 'text';
                fieldMaterialAsset.parent.hidden = fieldTextureAsset.value || fieldType.value !== 'image';
            }
        };

        toggleColorFields();

        events.push(fieldType.on('change', function (value) {
            fieldText.parent.hidden = value !== 'text';
            fieldFontAsset.parent.hidden = value !== 'text';
            fieldFontSize.parent.hidden = value !== 'text';
            fieldLineHeight.parent.hidden = value !== 'text';
            fieldSpacing.parent.hidden = value !== 'text';
            fieldRect[0].parent.hidden = value !== 'image';
            toggleSize();
            toggleMargin();
            toggleColorFields();
            panelAutoSize.hidden = value !== 'text';
            fieldAlignment[0].parent.hidden = value !== 'text';
        }));


        events.push(fieldMaterialAsset.on('change', function (value) {
            toggleColorFields();
        }));

        events.push(fieldTextureAsset.on('change', function (value) {
            fieldRect[0].parent.hidden = fieldType.value !== 'image';
            toggleSize();
            toggleColorFields();
        }));


        // handle local changes to texture field to
        // auto set width and height and combine all of them in the same
        // history action
        events.push(fieldTextureAsset.on('beforechange', function (value) {
            if (! value) return;
            var asset = editor.call('assets:get', value);
            if (! asset) return;

            if (! asset.has('meta.width') || ! asset.has('meta.height')) return;

            var width = asset.get('meta.width');
            var height = asset.get('meta.height');
            if (width === fieldWidth.value && height === fieldHeight.value)
                return;

            fieldTextureAsset.once('change', function (value) {
                var lastHistoryAction = editor.call('history:list')[editor.call('history:current')];
                var lastUndo = lastHistoryAction.undo;
                var lastRedo = lastHistoryAction.redo;

                var previous = {};
                for (var i = 0, len = entities.length; i < len; i++) {
                    var anchor = entities[i].get('components.element.anchor');
                    if (Math.abs(anchor[0] - anchor[2]) > 0.001 || Math.abs(anchor[1] - anchor[3]) > 0.001) {
                        continue;
                    }

                    var prevData = {
                        width: entities[i].get('components.element.width'),
                        height: entities[i].get('components.element.height'),
                        margin: entities[i].get('components.element.margin')
                    };


                    previous[entities[i].get('resource_id')] = prevData;
                }

                lastHistoryAction.undo = function () {
                    lastUndo();

                    for (var i = 0, len = entities.length; i < len; i++) {
                        var prev = previous[entities[i].get('resource_id')];
                        if (! prev) continue;

                        var entity = editor.call('entities:get', entities[i].get('resource_id'));
                        if (! entity) continue;

                        var history = entity.history.enabled;
                        entity.history.enabled = false;
                        if (entity.has('components.element')) {
                            entity.set('components.element.width', prev.width);
                            entity.set('components.element.height', prev.height);
                            entity.set('components.element.margin', prev.margin);
                        }
                        entity.history.enabled = history;
                    }
                };

                var redo = function () {
                    for (var i = 0, len = entities.length; i < len; i++) {
                        var prev = previous[entities[i].get('resource_id')];
                        if (! prev) continue;

                        var entity = editor.call('entities:get', entities[i].get('resource_id'));
                        if (! entity) continue;

                        var history = entity.history.enabled;
                        entity.history.enabled = false;
                        if (entity.has('components.element')) {
                            entity.set('components.element.width', width);
                            entity.set('components.element.height', height);

                            if (entity.entity) {
                                var margin = entity.entity.element.margin.data;
                                entity.set('components.element.margin', [margin[0], margin[1], margin[2], margin[3]]);
                            }
                        }
                        entity.history.enabled = history;
                    }
                };

                lastHistoryAction.redo = function () {
                    lastRedo();
                    redo();
                };

                redo();
            });

        }));


        panel.on('destroy', function () {
            events.forEach(function (e) {
                e.unbind();
            });
            events.length = 0;
        });

    });
});


/* editor/attributes/attributes-asset.js */
editor.once('load', function() {
    'use strict';

    var legacyScripts = editor.call('settings:project').get('useLegacyScripts');

    var sourceRuntimeOptions = {
        '-1': 'various',
        '0': 'yes',
        '1': 'no'
    };

    var editableTypes = {
        'script': 1,
        'css': 1,
        'html': 1,
        'shader': 1,
        'text': 1,
        'json': 1
    };

    var assetsPanel = null;

    editor.on('attributes:inspect[asset]', function(assets) {
        var events = [ ];

        // unfold panel
        var panel = editor.call('attributes.rootPanel');
        if (panel.folded)
            panel.folded = false;

        var multi = assets.length > 1;
        var type = ((assets[0].get('source') && assets[0].get('type') !== 'folder') ? 'source ' : '') + assets[0].get('type');

        if (multi) {
            editor.call('attributes:header', assets.length + ' assets');

            for(var i = 0; i < assets.length; i++) {
                if (type !== ((assets[0].get('source') && assets[0].get('type') !== 'folder') ? 'source ' : '') + assets[i].get('type')) {
                    type = null;
                    break;
                }
            }
        } else {
            editor.call('attributes:header', type);
        }

        // panel
        var panel = editor.call('attributes:addPanel');
        panel.class.add('component');
        assetsPanel = panel;
        panel.once('destroy', function () {
            assetsPanel = null;

            for(var i = 0; i < events.length; i++)
                events[i].unbind();

            events = null;
        });

        if (multi) {
            var fieldFilename = editor.call('attributes:addField', {
                parent: panel,
                name: 'Assets',
                value: assets.length
            });

            var scriptSelected = false;
            if (legacyScripts) {
                for(var i = 0; i < assets.length; i++) {
                    // scripts are not real assets, and have no preload option
                    if (! scriptSelected && assets[i].get('type') === 'script')
                        scriptSelected = true;
                }
            }

            var source = (assets[0].get('type') === 'folder') ? 1 : assets[0].get('source') + 0;

            for(var i = 1; i < assets.length; i++) {
                if ((assets[i].get('type') === 'folder' ? 1 : assets[i].get('source') + 0) !== source) {
                    source = -1;
                    break;
                }
            }

            if (! scriptSelected && source === 0) {
                // tags
                var fieldTags = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Tags',
                    placeholder: 'Add Tag',
                    type: 'strings',
                    link: assets,
                    path: 'tags'
                });
                // reference
                editor.call('attributes:reference:attach', 'asset:tags', fieldTags.parent.parent.innerElement.firstChild.ui);
            }

            if (! scriptSelected) {
                // runtime
                var fieldRuntime = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Runtime',
                    value: sourceRuntimeOptions[source]
                });
                // reference
                editor.call('attributes:reference:attach', 'asset:runtime', fieldRuntime.parent.innerElement.firstChild.ui);
            }

            // type
            var fieldType = editor.call('attributes:addField', {
                parent: panel,
                name: 'Type',
                value: type ? type : 'various'
            });
            // reference
            editor.call('attributes:reference:attach', 'asset:type', fieldType.parent.innerElement.firstChild.ui);
            if (type)
                editor.call('attributes:reference:asset:' + type + ':asset:attach', fieldType);

            // preload
            if (! scriptSelected && source === 0) {
                var fieldPreload = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Preload',
                    type: 'checkbox',
                    link: assets,
                    path: 'preload'
                });
                fieldPreload.parent.class.add('preload');
                editor.call('attributes:reference:attach', 'asset:preload', fieldPreload.parent.innerElement.firstChild.ui);
            }

            if (! scriptSelected) {
                // size
                var sizeCalculate = function() {
                    var size = 0;

                    for(var i = 0; i < assets.length; i++)
                        size += assets[i].get('file.size') || 0;

                    fieldSize.value = bytesToHuman(size);
                };
                var fieldSize = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Size'
                });
                sizeCalculate();

                var evtSize = [ ];
                for(var i = 0; i < assets.length; i++) {
                    evtSize.push(assets[i].on('file:set', sizeCalculate));
                    evtSize.push(assets[i].on('file:unset', sizeCalculate));
                    evtSize.push(assets[i].on('file.size:set', sizeCalculate));
                    evtSize.push(assets[i].on('file.size:unset', sizeCalculate));
                }

                panel.once('destroy', function () {
                    for(var i = 0; i < evtSize.length; i++) {
                        evtSize[i].unbind();
                    }
                });

                // reference
                editor.call('attributes:reference:attach', 'asset:size', fieldSize.parent.innerElement.firstChild.ui);
            }


            if (! scriptSelected && source === 0) {
                // source
                var fieldSource = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Source',
                    value: 'none'
                });
                // reference
                editor.call('attributes:reference:attach', 'asset:source', fieldSource.parent.innerElement.firstChild.ui);

                var sourceId = assets[0].get('source_asset_id');
                for(var i = 1; i < assets.length; i++) {
                    if (sourceId !== assets[i].get('source_asset_id')) {
                        sourceId = 0;
                        fieldSource.value = 'various';
                        break;
                    }
                }
                fieldSource.on('click', function() {
                    if (! sourceId)
                        return;

                    var asset = editor.call('assets:get', sourceId);

                    if (! asset)
                        return;

                    editor.call('selector:set', 'asset', [ asset ]);
                });
                if (sourceId) {
                    var source = editor.call('assets:get', sourceId);
                    if (source) {
                        fieldSource.value = source.get('name');
                        fieldSource.class.add('export-model-archive');

                        var evtSourceName = source.on('name:set', function(value) {
                            fieldSource.value = value;
                        });
                        fieldSource.once('destroy', function() {
                            evtSourceName.unbind();
                        });
                    }
                }
            }
        } else {
            if (legacyScripts && assets[0].get('type') === 'script') {
                // filename
                var fieldFilename = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Filename',
                    // type: 'string',
                    link: assets[0],
                    path: 'filename'
                });
                // reference
                editor.call('attributes:reference:attach', 'asset:script:filename', fieldFilename.parent.innerElement.firstChild.ui);
            } else {
                // id
                var fieldId = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'ID',
                    link: assets[0],
                    path: 'id'
                });
                // reference
                editor.call('attributes:reference:attach', 'asset:id', fieldId.parent.innerElement.firstChild.ui);

                // name
                var fieldName = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Name',
                    type: 'string',
                    link: assets[0],
                    path: 'name'
                });
                fieldName.class.add('asset-name');
                // reference
                editor.call('attributes:reference:attach', 'asset:name', fieldName.parent.innerElement.firstChild.ui);

                if (! assets[0].get('source') && assets[0].get('type') !== 'folder') {
                    // tags
                    var fieldTags = editor.call('attributes:addField', {
                        parent: panel,
                        name: 'Tags',
                        placeholder: 'Add Tag',
                        type: 'strings',
                        link: assets[0],
                        path: 'tags'
                    });
                    // reference
                    editor.call('attributes:reference:attach', 'asset:tags', fieldTags.parent.parent.innerElement.firstChild.ui);
                }

                // runtime
                var runtime = sourceRuntimeOptions[assets[0].get('source') + 0];
                if (assets[0].get('type') === 'folder')
                    runtime = sourceRuntimeOptions[1];

                var fieldRuntime = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Runtime',
                    value: runtime
                });
                // reference
                editor.call('attributes:reference:attach', 'asset:runtime', fieldRuntime.parent.innerElement.firstChild.ui);


                // taskInfo
                var fieldFailed = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Failed',
                    link: assets[0],
                    path: 'taskInfo'
                });
                fieldFailed.class.add('error');

                var checkFailed = function() {
                    fieldFailed.parent.hidden = assets[0].get('task') !== 'failed' || ! assets[0].get('taskInfo');
                };
                checkFailed();

                events.push(assets[0].on('task:set', checkFailed));
                events.push(assets[0].on('taskInfo:set', checkFailed));
                events.push(assets[0].on('taskInfo:unset', checkFailed));
            }


            // type
            var fieldType = editor.call('attributes:addField', {
                parent: panel,
                name: 'Type',
                value: type
            });
            // reference
            editor.call('attributes:reference:attach', 'asset:type', fieldType.parent.innerElement.firstChild.ui);
            // reference type
            if (! assets[0].get('source'))
                editor.call('attributes:reference:asset:' + assets[0].get('type') + ':asset:attach', fieldType);


            if (! (legacyScripts && assets[0].get('type') === 'script') && assets[0].get('type') !== 'folder' && ! assets[0].get('source')) {
                // preload
                var fieldPreload = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Preload',
                    type: 'checkbox',
                    link: assets[0],
                    path: 'preload'
                });
                fieldPreload.parent.class.add('preload');
                editor.call('attributes:reference:attach', 'asset:preload', fieldPreload.parent.innerElement.firstChild.ui);
            }

            // size
            if (assets[0].has('file')) {
                var fieldSize = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Size',
                    value: bytesToHuman(assets[0].get('file.size'))
                });

                var evtFileSet = assets[0].on('file:set', function (value) {
                    fieldSize.text = bytesToHuman(value ? value.size : 0);
                });

                var evtFileSizeSet = assets[0].on('file.size:set', function(value) {
                    fieldSize.text = bytesToHuman(value);
                });

                panel.once('destroy', function () {
                    evtFileSet.unbind();
                    evtFileSizeSet.unbind();
                });

                // reference
                editor.call('attributes:reference:attach', 'asset:size', fieldSize.parent.innerElement.firstChild.ui);
            }

            if (! (legacyScripts && assets[0].get('type') === 'script') && ! assets[0].get('source')) {
                // source
                var fieldSource = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Source',
                    value: 'none'
                });
                // reference
                editor.call('attributes:reference:attach', 'asset:source', fieldSource.parent.innerElement.firstChild.ui);

                var sourceId = assets[0].get('source_asset_id');
                fieldSource.on('click', function() {
                    if (! sourceId)
                        return;

                    var asset = editor.call('assets:get', sourceId);

                    if (! asset)
                        return;

                    editor.call('selector:set', 'asset', [ asset ]);
                });
                if (sourceId) {
                    var source = editor.call('assets:get', sourceId);
                    if (source) {
                        fieldSource.value = source.get('name');
                        fieldSource.class.add('export-model-archive');

                        var evtSourceName = source.on('name:set', function(value) {
                            fieldSource.value = value;
                        });
                        fieldSource.once('destroy', function() {
                            evtSourceName.unbind();
                        });
                    }
                }
            }

            var panelButtons = new ui.Panel();
            panelButtons.class.add('buttons');
            panel.append(panelButtons);

            // download
            if (assets[0].get('type') !== 'folder' && ! (legacyScripts && assets[0].get('type') === 'script')) {
                // download
                var btnDownload = new ui.Button();

                btnDownload.hidden = ! editor.call('permissions:read');
                var evtBtnDownloadPermissions = editor.on('permissions:set:' + config.self.id, function() {
                    btnDownload.hidden = ! editor.call('permissions:read');
                });

                btnDownload.text = 'Download';
                btnDownload.class.add('download-asset', 'large-with-icon');
                btnDownload.element.addEventListener('click', function(evt) {
                    if (btnDownload.prevent)
                        return;

                    if (assets[0].get('source') || assets[0].get('type') === 'texture' || assets[0].get('type') === 'audio') {
                        window.open(assets[0].get('file.url'));
                    } else {
                        window.open('/api/assets/' + assets[0].get('id') + '/download');
                    }
                });
                panelButtons.append(btnDownload);

                btnDownload.once('destroy', function() {
                    evtBtnDownloadPermissions.unbind();
                });
            }

            if (editableTypes[assets[0].get('type')]) {
                // edit
                var btnEdit = new ui.Button();

                btnEdit.text = editor.call('permissions:write') ? 'Edit' : 'View';
                var evtPermissions = editor.on('permissions:writeState', function(state) {
                    btnEdit.text = state ? 'Edit' : 'View';
                });

                btnEdit.class.add('edit-script', 'large-with-icon');
                btnEdit.hidden = ! assets[0].has('file.url');
                btnEdit.element.addEventListener('click', function(evt) {
                    editor.call('assets:edit', assets[0]);
                }, false);
                panelButtons.append(btnEdit);

                var evtFileUrl = assets[0].on('file.url:set', function() {
                    btnEdit.hidden = false;
                });
                var evtFileUrlUnset = assets[0].on('file.url:unset', function() {
                    btnEdit.hidden = true;
                });

                btnEdit.once('destroy', function() {
                    evtPermissions.unbind();
                    evtFileUrl.unbind();
                    evtFileUrlUnset.unbind();
                });
            }
        }
    });

    editor.on('attributes:assets:toggleInfo', function (enabled) {
        if (assetsPanel) {
            assetsPanel.hidden = !enabled;
        }
    });

    editor.method('attributes:assets:panel', function() {
        return assetsPanel;
    });
});


/* editor/attributes/assets/attributes-asset-animation.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'animation' || assets[0].get('source'))
            return;

        var asset = assets[0];

        // panel
        var panel = editor.call('attributes:addPanel', {
            name: 'Animation'
        });
        panel.class.add('component');
        // reference
        editor.call('attributes:reference:attach', 'asset:animation:asset', panel, panel.headerElement);


        // duration
        var fieldDuration = editor.call('attributes:addField', {
            parent: panel,
            name: 'Duration',
            placeholder: 'Seconds',
            link: asset,
            path: 'meta.duration'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:animation:duration', fieldDuration.parent.innerElement.firstChild.ui);


        // name
        var fieldName = editor.call('attributes:addField', {
            parent: panel,
            name: 'Name',
            link: asset,
            path: 'meta.name'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:animation:name', fieldName.parent.innerElement.firstChild.ui);
    });
});


/* editor/attributes/assets/attributes-asset-audio.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'audio' || assets[0].get('source'))
            return;

        var asset = assets[0];

        var panel = editor.call('attributes:addPanel', {
            name: 'Audio'
        });
        panel.class.add('component');
        // reference
        editor.call('attributes:reference:attach', 'asset:audio:asset', panel, panel.headerElement);


        // duration
        var fieldDuration = editor.call('attributes:addField', {
            parent: panel,
            name: 'Duration',
            value: '...'
        });
        fieldDuration.renderChanges = false;
        // reference
        editor.call('attributes:reference:attach', 'asset:audio:duration', fieldDuration.parent.innerElement.firstChild.ui);


        var playing = null;
        var updateTimeline = function() {
            timeline.progress = audio.currentTime / audio.duration;
        };


        // audio
        var audio = new Audio();
        audio.src = config.url.home + asset.get('file.url');
        panel.append(audio);


        // play
        var btnPlay = new ui.Button({
            text: '&#57649;'
        });
        btnPlay.disabled = true;
        btnPlay.class.add('audio-play');
        btnPlay.on('click', function() {
            if (audio.paused) {
                audio.play();
            } else {
                audio.pause();
                audio.currentTime = 0;
            }
        });
        panel.append(btnPlay);


        // timeline
        var timeline = new ui.Progress();
        timeline.class.add('audio-timeline');
        timeline.progress = 1;
        timeline.speed = .9;
        panel.append(timeline);


        // duration information available
        audio.addEventListener('durationchange', function(evt) {
            fieldDuration.text = audio.duration.toFixed(2) + 's';
        }, false);

        // can be played
        audio.addEventListener('canplay', function(evt) {
            btnPlay.enabled = true;
            timeline.progress = 0;
        }, false);

        // on play
        audio.addEventListener('play', function() {
            btnPlay.class.add('active');
            btnPlay.text = '&#57649;';

            if (playing)
                return;

            playing = setInterval(updateTimeline, 1000 / 60);
        }, false);

        // on stop
        audio.addEventListener('pause', function() {
            timeline.progress = 0;
            btnPlay.class.remove('active');
            btnPlay.text = '&#57649;';

            clearInterval(playing);
            playing = null;
        }, false);


        panel.once('destroy', function() {
            clearInterval(playing);
        });
    });
});


/* editor/attributes/assets/attributes-asset-css.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'css' || assets[0].get('source'))
            return;

        var asset = assets[0];

        // panel
        var panel = editor.call('attributes:assets:panel');

        var panelRaw = editor.call('attributes:addPanel', {
            name: 'CSS'
        });
        panelRaw.class.add('component');
        // reference
        editor.call('attributes:reference:attach', 'asset:css:asset', panelRaw, panelRaw.headerElement);

        // loading
        var loading = editor.call('attributes:addField', {
            type: 'progress'
        });
        loading.progress = 1;

        // code
        var fieldCode = editor.call('attributes:addField', {
            parent: panelRaw,
            type: 'code'
        });
        fieldCode.style.margin = '-8px -6px';

        var fieldError = new ui.Label({
            text: 'failed loading data'
        });
        fieldError.class.add('asset-loading-error');
        fieldError.hidden = true;
        editor.call('attributes.rootPanel').append(fieldError);

        var loadContent = function() {
            if (asset.get('file.size') > 128 * 1024) {
                panelRaw.hidden = true;
                loading.hidden = true;
                return;
            } else {
                panelRaw.hidden = false;
                loading.hidden = false;
            }
            // load data
            Ajax({
                url: '{{url.home}}' + asset.get('file.url') + '?t=' + asset.get('file.hash'),
                notJson: true
            })
                .on('load', function(status, data) {
                    fieldCode.text = data;
                    fieldCode.hidden = false;
                    fieldError.hidden = true;
                    loading.hidden = true;
                })
                .on('error', function() {
                    loading.hidden = false;
                    loading.failed = true;
                    fieldCode.hidden = true;
                    fieldError.hidden = false;
                });
        };
        if (asset.has('file.url'))
            loadContent();

        var evtReload = asset.on('file.hash:set', function() {
            loadContent();
        });
        panel.once('destroy', function() {
            evtReload.unbind();
        });
    });
});


/* editor/attributes/assets/attributes-asset-cubemap.js */
editor.once('load', function() {
    'use strict';


    editor.on('attributes:inspect[asset]', function(assets) {
        for(var i = 0; i < assets.length; i++) {
            if (assets[i].get('type') !== 'cubemap')
                return;
        }

        if (assets.length > 1)
            editor.call('attributes:header', assets.length + ' CubeMaps');

        var root = editor.call('attributes.rootPanel');

        if (assets.length === 1) {
            var previewContainer = document.createElement('div');
            previewContainer.classList.add('asset-preview-container');

            var preview = document.createElement('canvas');
            var ctx = preview.getContext('2d');
            preview.width = 256;
            preview.height = 256;
            preview.classList.add('asset-preview', 'flipY');
            previewContainer.appendChild(preview);

            var mipLevel = 0;

            var mipSelector = new ui.SelectField({
                type: 'number',
                options: [
                    { v: 0, t: '1' },
                    { v: 1, t: '2' },
                    { v: 2, t: '3' },
                    { v: 3, t: '4' },
                    { v: 4, t: '5' }
                ]
            });
            mipSelector.value = 0;
            mipSelector.class.add('cubeMapMipLevel');
            previewContainer.appendChild(mipSelector.element);
            mipSelector.parent = panelParams;
            mipSelector.hidden = ! assets[0].get('file');

            mipSelector.on('change', function(value) {
                mipLevel = value;
                queueRender();
            });

            var sx = 0, sy = 0, x = 0, y = 0, nx = 0, ny = 0;
            var dragging = false;
            var previewRotation = [ 0, 0 ];

            preview.addEventListener('mousedown', function(evt) {
                if (evt.button !== 0)
                    return;

                evt.preventDefault();
                evt.stopPropagation();

                sx = x = evt.clientX;
                sy = y = evt.clientY;

                dragging = true;
            }, false);

            var onMouseMove = function(evt) {
                if (! dragging)
                    return;

                nx = x - evt.clientX;
                ny = y - evt.clientY;
                x = evt.clientX;
                y = evt.clientY;

                queueRender();
            };

            var onMouseUp = function(evt) {
                if (! dragging)
                    return;

                if ((Math.abs(sx - x) + Math.abs(sy - y)) < 8) {
                    if (root.element.classList.contains('large')) {
                        root.element.classList.remove('large');
                    } else {
                        root.element.classList.add('large');
                    }
                }

                previewRotation[0] = Math.max(-90, Math.min(90, previewRotation[0] + ((sy - y) * 0.3)));
                previewRotation[1] += (sx - x) * 0.3;
                sx = sy = x = y = 0;

                dragging = false;

                queueRender();
            };

            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('mouseup', onMouseUp, false);


            root.class.add('asset-preview');
            root.element.insertBefore(previewContainer, root.innerElement);

            // rendering preview
            var renderQueued;

            var renderPreview = function () {
                if (renderQueued)
                    renderQueued = false;

                // render
                var imageData = editor.call('preview:render', assets[0], root.element.clientWidth, root.element.clientWidth, {
                    rotation: [ Math.max(-90, Math.min(90, previewRotation[0] + (sy - y) * 0.3)), previewRotation[1] + (sx - x) * 0.3 ],
                    mipLevel: mipLevel
                });

                if (! imageData)
                    return;

                preview.width = imageData.width;
                preview.height = imageData.height;

                ctx.putImageData(imageData, 0, 0);
            };
            renderPreview();

            // queue up the rendering to prevent too oftern renders
            var queueRender = function() {
                if (renderQueued) return;
                renderQueued = true;
                requestAnimationFrame(renderPreview);
            };

            // render on resize
            var evtPanelResize = root.on('resize', queueRender);
            var evtSceneSettings = editor.on('preview:scene:changed', queueRender);

            // cubemap textures loaded
            var cubemapWatch = editor.call('assets:cubemap:watch', {
                asset: assets[0],
                autoLoad: true,
                callback: queueRender
            });
        }


        // properties panel
        var panelParams = editor.call('attributes:addPanel', {
            name: 'CubeMap'
        });
        panelParams.class.add('component');
        // reference
        editor.call('attributes:reference:attach', 'asset:cubemap:asset', panelParams, panelParams.headerElement);

        if (assets.length === 1) {
            panelParams.on('destroy', function() {
                root.class.remove('asset-preview');

                editor.call('assets:cubemap:unwatch', assets[0], cubemapWatch);

                evtSceneSettings.unbind();
                evtPanelResize.unbind();
                previewContainer.parentNode.removeChild(previewContainer);

                window.removeEventListener('mousemove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);
            });
        }


        // filtering
        var fieldFiltering = editor.call('attributes:addField', {
            parent: panelParams,
            name: 'Filtering',
            type: 'string',
            enum: {
                '': '...',
                'nearest': 'Point',
                'linear': 'Linear'
            }
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:filtering', fieldFiltering.parent.innerElement.firstChild.ui);

        var isPrefiltered = false;
        for(var i = 0; i < assets.length; i++) {
            if (!! assets[i].get('file')) {
                isPrefiltered = true;
                break;
            }
        }

        var changingFiltering = false;

        var updateFiltering = function() {
            var value = '';
            var valueDifferent = false;
            var filter = assets[0].get('data.minFilter') + '_' + assets[0].get('data.magFilter');

            for(var i = 1; i < assets.length; i++) {
                if (filter !== (assets[i].get('data.minFilter') + '_' + assets[i].get('data.magFilter'))) {
                    valueDifferent = true;
                    break;
                }
            }

            if (! valueDifferent) {
                if (assets[0].get('data.minFilter') === 5 && assets[0].get('data.magFilter') === 1) {
                    value = 'linear';
                } else if (assets[0].get('data.minFilter') === 2 && assets[0].get('data.magFilter') === 0) {
                    value = 'nearest';
                }
            }

            if (! valueDifferent && value) {
                fieldFiltering.optionElements[''].style.display = 'none';
            } else {
                fieldFiltering.optionElements[''].style.display = '';
            }

            changingFiltering = true;
            fieldFiltering.value = value;
            changingFiltering = false;
        };
        updateFiltering();

        fieldFiltering.on('change', function(value) {
            if (changingFiltering)
                return;

            var values = [ ];
            var valueMin = value === 'nearest' ? 2 : 5;
            var valueMag = value === 'nearest' ? 0 : 1;

            changingFiltering = true;
            for(var i = 0; i < assets.length; i++) {
                values.push({
                    id: assets[i].get('id'),
                    valueMin: assets[i].get('data.minFilter'),
                    valueMag: assets[i].get('data.magFilter')
                });
                assets[i].history.enabled = false;
                assets[i].set('data.minFilter', valueMin);
                assets[i].set('data.magFilter', valueMag);
                assets[i].history.enabled = true;
            }
            changingFiltering = false;

            fieldFiltering.optionElements[''].style.display = 'none';

            // history
            editor.call('history:add', {
                name: 'assets.filtering',
                undo: function() {
                    for(var i = 0; i < values.length; i++) {
                        var asset = editor.call('assets:get', values[i].id);
                        if (! asset)
                            continue;

                        asset.history.enabled = false;
                        asset.set('data.minFilter', values[i].valueMin);
                        asset.set('data.magFilter', values[i].valueMag);
                        asset.history.enabled = true;
                    }
                },
                redo: function() {
                    for(var i = 0; i < values.length; i++) {
                        var asset = editor.call('assets:get', values[i].id);
                        if (! asset)
                            continue;

                        asset.history.enabled = false;
                        asset.set('data.minFilter', valueMin);
                        asset.set('data.magFilter', valueMag);
                        asset.history.enabled = true;
                    }
                }
            });
        });

        var eventsFiltering = [ ];
        var changingQueued = false;
        var changedFiltering = function() {
            if (changingQueued || changingFiltering)
                return;

            changingQueued = true;
            setTimeout(function() {
                changingQueued = false;
                updateFiltering();
            }, 0);
        };
        for(var i = 0; i < assets.length; i++) {
            eventsFiltering.push(assets[i].on('data.minFilter:set', changedFiltering));
            eventsFiltering.push(assets[i].on('data.magFilter:set', changedFiltering));
        }
        fieldFiltering.once('destroy', function() {
            for(var i = 0; i < eventsFiltering.length; i++) {
                eventsFiltering[i].unbind();
            }
        });



        // anisotropy
        var fieldAnisotropy = editor.call('attributes:addField', {
            parent: panelParams,
            name: 'Anisotropy',
            type: 'number',
            link: assets,
            path: 'data.anisotropy'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:cubemap:anisotropy', fieldAnisotropy.parent.innerElement.firstChild.ui);


        if (assets.length === 1) {
            // preview
            var previewPanel = editor.call('attributes:addPanel', {
                name: 'Faces'
            });
            previewPanel.class.add('cubemap-viewport', 'component');
            // reference
            editor.call('attributes:reference:attach', 'asset:cubemap:slots', previewPanel, previewPanel.headerElement);


            var downloadButton = previewPanel.parent.element.querySelector('.ui-panel.buttons > .content > .ui-button.download-asset');
            if (downloadButton)
                downloadButton = downloadButton.ui;

            // error
            var labelError = new ui.Label({
                text: 'error'
            });
            labelError.class.add('asset-loading-error');
            labelError.hidden = true;
            editor.call('attributes.rootPanel').append(labelError);


            // faces
            var sides = {
                2: 'top',
                1: 'left',
                4: 'front',
                0: 'right',
                5: 'back',
                3: 'bottom'
            };
            var side = [ 2, 1, 4, 0, 5, 3 ];
            var faces = [ ];

            var checkValid = function() {
                var invalid = invalidFaces();

                if (invalid)
                    labelError.text = invalid;

                labelError.hidden = ! invalid;

                if (downloadButton) {
                    downloadButton.disabled = !! invalid;
                    downloadButton.prevent = !! invalid;
                }
            };

            var invalidFaces = function() {
                var faces = assets[0].get('data.textures');

                if (! (faces instanceof Array))
                    return 'missing faces information';

                for(var i = 0; i < 6; i++) {
                    if (! faces[i])
                        return 'set face textures';
                }

                var width = 0;
                var height = 0;

                for(var i = 0; i < 6; i++) {
                    var asset = editor.call('assets:get', faces[i]);
                    if (! asset)
                        return 'missing face asset';

                    if (! asset.has('meta.width') || ! asset.has('meta.height'))
                        return 'no texture resolution data available';

                    var w = asset.get('meta.width');
                    var h = asset.get('meta.height');

                    if ((w & (w - 1)) !== 0 || (h & (h - 1)) !== 0)
                        return 'face textures should have power of two resolution';

                    if (w !== h)
                        return 'face textures should have square resolution';

                    if (i === 0) {
                        width = w;
                        height = h;
                    } else {
                        if (width !== w || height !== h)
                            return 'face textures should have same resolution';
                    }
                }

                return false;
            };

            var watchingAssets = [ null, null, null, null, null, null ];

            var makeThumbnailUrl = function(asset) {
                var url = config.url.home + '/' + (asset.get('thumbnails.l') || asset.get('file.url'));
                var separator = url.indexOf('?') !== -1 ? '&' : '?';
                url += separator + 't=' + asset.get('file.hash');
                return url;
            };

            // set face texture
            var setTexture = function(face, assetId) {
                if (watchingAssets[face.ind]) {
                    watchingAssets[face.ind].unbind();
                    watchingAssets[face.ind] = null;
                }

                if (! assetId) {
                    face.style.backgroundImage = '';
                    face.classList.add('empty');
                } else {
                    var texture = editor.call('assets:get', assetId);

                    if (texture && texture.get('type') === 'texture' && ! texture.get('source')) {
                        watchingAssets[face.ind] = texture.on('thumbnails:set', function() {
                            face.classList.remove('empty');
                            face.style.backgroundImage = 'url("' + makeThumbnailUrl(texture) + '")';
                        });
                    }

                    if (texture && texture.get('type') === 'texture' && (texture.get('thumbnails.l') || texture.get('file.url'))) {
                        face.classList.remove('empty');
                        face.style.backgroundImage = 'url("' + makeThumbnailUrl(texture) + '")';
                    } else {
                        face.classList.add('empty');
                        face.style.backgroundImage = '';
                    }
                }
            };

            var setAssetFace = function (face, texture) {
                var prevFace = assets[0].get('data.textures.' + face);
                var assetId = assets[0].get('id');
                var textureId = texture ? parseInt(texture.get('id'), 10) : null;

                var setRgbmIfNeeded = function (asset) {
                    var allHdr = true;
                    var textures = asset.get('data.textures');
                    for (var i = 0; i < textures.length; i++) {
                        if (textures[i] >= 0) {
                            var texture = editor.call('assets:get', textures[i]);
                            if (texture && !texture.get('data.rgbm')) {
                                allHdr = false;
                                break;
                            }
                        }
                    }

                    if (allHdr)  {
                        asset.set('data.rgbm', true);
                    } else {
                        asset.unset('data.rgbm');
                    }
                };

                var action = {
                    name: 'asset.' + assetId + '.face.' + face,
                    combine: false,
                    undo: function () {
                        var a = editor.call('assets:get', assetId);
                        if (!a) return;

                        var history = a.history.enabled;
                        a.history.enabled = false;
                        a.set('data.textures.' + face, prevFace);
                        setRgbmIfNeeded(a);
                        a.history.enabled = history;
                    },
                    redo: function () {
                        var a = editor.call('assets:get', assetId);
                        if (!a) return;

                        var history = a.history.enabled;
                        a.history.enabled = false;
                        a.set('data.textures.' + face, textureId);
                        // invalidate prefiltered data
                        // if (a.get('file')) a.set('file', null)
                        setRgbmIfNeeded(a);
                        a.history.enabled = history;
                    }
                };

                action.redo();

                assets[0].history.emit('record', 'add', action);
            };

            // create eface
            var createFace = function(ind) {
                // create face element
                var face = faces[ind] = document.createElement('div');
                face.ind = ind;
                face.classList.add('face', 'face-' + sides[ind]);
                previewPanel.append(face);

                var name = document.createElement('div');
                name.classList.add('face-name');
                name.innerHTML = sides[ind];
                face.appendChild(name);

                // on face click
                face.addEventListener('click', function() {
                    if (! editor.call('permissions:write'))
                        return;

                    var texture = editor.call('assets:get', assets[0].get('data.textures.' + ind));
                    editor.call('picker:asset', 'texture', texture);

                    var evtPick = editor.once('picker:asset', function(texture) {
                        // clear prefiltered data
                        setAssetFace(ind, texture);
                        evtPick = null;
                    });

                    editor.once('picker:asset:close', function() {
                        if (evtPick) {
                            evtPick.unbind();
                            evtPick = null;
                        }
                    });
                }, false);

                var dropRef = editor.call('drop:target', {
                    ref: face,
                    type: 'asset.texture',
                    drop: function(type, data) {
                        if (type !== 'asset.texture')
                            return;

                        var asset = editor.call('assets:get', parseInt(data.id, 10));

                        // try matching patterns of texture names
                        // to autoset  all 6 faces for empty cubemaps
                        try {
                            var empty = true;
                            var faces = assets[0].get('data.textures');
                            for(var i = 0; i < faces.length; i++) {
                                if (faces[i]) {
                                    empty = false;
                                    break;
                                }
                            }

                            if (empty) {
                                var name = asset.get('name');
                                var check = /((neg|pos)(x|y|z)|(right|left|top|up|bottom|down|front|forward|back|backward)|[0-6])(\.|$)/i;
                                var match = name.match(check);

                                if (match != null) {
                                    match = match.index;

                                    var part = '';
                                    if (match) part = name.slice(0, match).toLowerCase();
                                    var i = name.indexOf('.', match);
                                    if (i > 0) part += name.slice(i);

                                    var sort = {
                                        '0': 0,
                                        'posx': 0,
                                        'right': 0,

                                        '1': 1,
                                        'negx': 1,
                                        'left': 1,

                                        '2': 2,
                                        'posy': 2,
                                        'top': 2,
                                        'up': 2,

                                        '3': 3,
                                        'negy': 3,
                                        'bottom': 3,
                                        'down': 3,

                                        '4': 4,
                                        'posz': 4,
                                        'front': 4,
                                        'forward': 4,

                                        '5': 5,
                                        'negz': 5,
                                        'back': 5,
                                        'backward': 5,

                                        '6': 6,
                                    };
                                    var faceAssets = editor.call('assets:find', function(a) {
                                        if (a.get('source') || a.get('type') !== 'texture')
                                            return;

                                        if (! a.get('path').equals(asset.get('path')))
                                            return;

                                        if (a.get('meta.width') !== asset.get('meta.width') || a.get('meta.height') !== asset.get('meta.height'))
                                            return;

                                        var name = a.get('name').toLowerCase();
                                        var m = name.match(check);

                                        if (m === null)
                                            return;

                                        m = m.index;

                                        var p = '';
                                        if (m) p = name.slice(0, m).toLowerCase();
                                        var i = name.indexOf('.', m);
                                        if (i > 0) p += name.slice(i);

                                        return p === part;
                                    });

                                    if (faceAssets.length === 6) {
                                        var allFaces = [ ];

                                        for(var i = 0; i < faceAssets.length; i++) {
                                            var p = faceAssets[i][1].get('name').toLowerCase();
                                            if (match) p = p.slice(match);
                                            var m = p.indexOf('.');
                                            if (m > 0) p = p.slice(0, m);

                                            faceAssets[i] = {
                                                asset: faceAssets[i][1],
                                                face: sort[p]
                                            }
                                        }

                                        faceAssets.sort(function(a, b) {
                                            return a.face - b.face;
                                        });


                                        for(var i = 0; i < faceAssets.length; i++)
                                            setAssetFace(i, faceAssets[i].asset);

                                        return;
                                    }
                                }
                            }
                        } catch(ex) {
                            console.error(ex.message);
                            console.error(ex.stack);
                        }

                        setAssetFace(ind, asset);
                    }
                });
                previewPanel.on('destroy', function() {
                    for(var i = 0; i < watchingAssets.length; i++) {
                        if (! watchingAssets[i])
                            continue;

                        watchingAssets[i].unbind();
                        watchingAssets[i] = null;
                    }
                    dropRef.unregister();
                });

                // clear button
                var faceClear = document.createElement('div');
                faceClear.classList.add('clear');
                face.appendChild(faceClear);

                // on clear click
                faceClear.addEventListener('click', function(evt) {
                    if (! editor.call('permissions:write'))
                        return;

                    evt.stopPropagation();
                    setAssetFace(ind, null);
                    face.classList.add('empty');
                }, false);

                // load texture asset
                setTexture(face, assets[0].get('data.textures.' + ind));

                // bind to changes
                face.evt = assets[0].on('data.textures.' + ind + ':set', function(value) {
                    clearPrefiltered();
                    setTexture(face, value);
                    prefilterPanel.hidden = !! invalidFaces();
                    checkValid();
                });
            };

            // create all faces
            for(var i = 0; i < side.length; i++)
                createFace(side[i]);

            // on destroy
            previewPanel.on('destroy', function() {
                // unbind events
                for(var i = 0; i < faces.length; i++)
                    faces[i].evt.unbind();
            });


            // prefiltering
            var prefilterPanel = editor.call('attributes:addPanel', {
                name: 'Prefiltering'
            });
            prefilterPanel.class.add('component');
            // reference
            editor.call('attributes:reference:attach', 'asset:cubemap:prefilter', prefilterPanel, prefilterPanel.headerElement);

            // prefilter button
            var prefilterBtn = new ui.Button({
                text: 'Prefilter',
            });

            prefilterPanel.append(prefilterBtn);

            prefilterBtn.on('click', function () {
                // disable while prefiltering
                prefilterBtn.disabled = true;
                editor.call('assets:cubemaps:prefilter', assets[0], function (err) {
                    // re-enable button
                    if (err)
                        return editor.call('status:error', err);

                    prefilterBtn.disabled = true;
                });
            });

            // delete prefiltered data button
            var clearPrefilteredBtn = new ui.Button({
                text: 'Delete Prefiltered Data',
            });

            prefilterPanel.append(clearPrefilteredBtn);

            var clearPrefiltered = function () {
                editor.call('realtime:send', 'cubemap:clear:', parseInt(assets[0].get('id'), 10));
            };

            clearPrefilteredBtn.on('click', clearPrefiltered);

            var evtFileChange = assets[0].on('file:set', function (value) {
                prefilterBtn.disabled = false;

                if (mipSelector)
                    mipSelector.hidden = ! value;

                if (queueRender)
                    queueRender();

                togglePrefilterFields(!! value);
            });

            prefilterPanel.once('destroy', function () {
                evtFileChange.unbind();
            });


            // show prefilter button or clear prefiltering button depending
            // on current cubemap 'file' field
            var togglePrefilterFields = function (isPrefiltered) {
                prefilterPanel.hidden = !! invalidFaces();
                prefilterBtn.hidden = isPrefiltered;
                prefilterBtn.disabled = !! assets[0].get('task');
                clearPrefilteredBtn.hidden = ! isPrefiltered;
            };

            togglePrefilterFields(!!assets[0].get('file'));
            checkValid();
        }
    });
});


/* editor/attributes/assets/attributes-asset-html.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'html' || assets[0].get('source'))
            return;

        var asset = assets[0];

        // panel
        var panel = editor.call('attributes:assets:panel');

        var panelRaw = editor.call('attributes:addPanel', {
            name: 'HTML'
        });
        panelRaw.class.add('component');
        // reference
        editor.call('attributes:reference:attach', 'asset:html:asset', panelRaw, panelRaw.headerElement);

        // loading
        var loading = editor.call('attributes:addField', {
            type: 'progress'
        });
        loading.progress = 1;

        // code
        var fieldCode = editor.call('attributes:addField', {
            parent: panelRaw,
            type: 'code'
        });
        fieldCode.style.margin = '-8px -6px';

        var fieldError = new ui.Label({
            text: 'failed loading data'
        });
        fieldError.class.add('asset-loading-error');
        fieldError.hidden = true;
        editor.call('attributes.rootPanel').append(fieldError);

        var loadContent = function() {
            if (asset.get('file.size') > 128 * 1024) {
                panelRaw.hidden = true;
                loading.hidden = true;
                return;
            } else {
                panelRaw.hidden = false;
                loading.hidden = false;
            }
            // load data
            Ajax({
                url: '{{url.home}}' + asset.get('file.url') + '?t=' + asset.get('file.hash'),
                notJson: true
            })
                .on('load', function(status, data) {
                    fieldCode.text = data;
                    fieldCode.hidden = false;
                    fieldError.hidden = true;
                    loading.hidden = true;
                })
                .on('error', function() {
                    loading.hidden = false;
                    loading.failed = true;
                    fieldCode.hidden = true;
                    fieldError.hidden = false;
                });
        };
        if (asset.has('file.url'))
            loadContent();

        var evtReload = asset.on('file.hash:set', function() {
            loadContent();
        });
        panel.once('destroy', function() {
            evtReload.unbind();
        });
    });
});


/* editor/attributes/assets/attributes-asset-json.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'json' || assets[0].get('source'))
            return;

        var asset = assets[0];

        // panel
        var panel = editor.call('attributes:assets:panel');

        var panelRaw = editor.call('attributes:addPanel', {
            name: 'JSON'
        });
        panelRaw.class.add('component');
        // reference
        editor.call('attributes:reference:attach', 'asset:json:asset', panelRaw, panelRaw.headerElement);

        // loading
        var loading = editor.call('attributes:addField', {
            type: 'progress'
        });
        loading.progress = 1;

        // code
        var fieldCode = editor.call('attributes:addField', {
            parent: panelRaw,
            type: 'code'
        });
        fieldCode.style.margin = '-8px -6px';

        var fieldError = new ui.Label({
            text: 'failed loading data'
        });
        fieldError.class.add('asset-loading-error');
        fieldError.hidden = true;
        editor.call('attributes.rootPanel').append(fieldError);

        var loadContent = function() {
            if (asset.get('file.size') > 128 * 1024) {
                panelRaw.hidden = true;
                loading.hidden = true;
                return;
            } else {
                panelRaw.hidden = false;
                loading.hidden = false;
            }
            // load data
            Ajax
                .get('{{url.home}}' + asset.get('file.url') + '?t=' + asset.get('file.hash'))
                .on('load', function(status, data) {
                    fieldCode.text = JSON.stringify(data, null, 4);
                    fieldCode.hidden = false;
                    fieldError.hidden = true;
                    loading.hidden = true;
                })
                .on('error', function() {
                    loading.hidden = false;
                    loading.failed = true;
                    fieldCode.hidden = true;
                    fieldError.hidden = false;
                });
        };
        if (asset.has('file.url'))
            loadContent();

        var evtReload = asset.on('file.hash:set', function() {
            loadContent();
        });
        panel.once('destroy', function() {
            evtReload.unbind();
        });
    });
});


/* editor/attributes/assets/attributes-asset-material.js */
editor.once('load', function() {
    'use strict';

    var mappingTypes = {
        'int': 'float',
        'rgb': 'vec3'
    };

    var mapping = {
        ambient: {
            'default': [ 0, 0, 0 ],
            'type': 'rgb',
        },
        ambientTint: {
            'default': false,
            'type': 'boolean',
        },
        aoMap: {
            'default': 0,
            'type': 'texture',
        },
        aoMapVertexColor: {
            'default': false,
            'type': 'boolean',
        },
        aoMapChannel: {
            'default': 'r',
            'type': 'string'
        },
        aoMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        aoMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        aoMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        occludeSpecular: {
            'default': 1,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'Off' },
                { v: 1, t: 'Multiply' },
                { v: 2, t: 'Gloss Based' }
            ]
        },
        diffuse: {
            'default': [ 1, 1, 1 ],
            'type': 'rgb',
        },
        diffuseMap: {
            'default': 0,
            'type': 'texture',
        },
        diffuseMapVertexColor: {
            'default': false,
            'type': 'boolean',
        },
        diffuseMapChannel: {
            'default': 'rgb',
            'type': 'string'
        },
        diffuseMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        diffuseMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        diffuseMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        diffuseMapTint: {
            'default': false,
            'type': 'boolean',
        },
        specular: {
            'default': [ .23, .23, .23 ],
            'type': 'rgb',
        },
        specularMapVertexColor: {
            'default': false,
            'type': 'boolean',
        },
        specularMapChannel: {
            'default': 'rgb',
            'type': 'string'
        },
        specularMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        specularMap: {
            'default': 0,
            'type': 'texture',
        },
        specularMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        specularMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        specularMapTint: {
            'default': false,
            'type': 'boolean',
        },
        specularAntialias: {
            'default': true,
            'type': 'boolean',
        },
        useMetalness: {
            'default': false,
            'type': 'boolean',
        },
        metalnessMap: {
            'default': 0,
            'type': 'texture',
        },
        metalnessMapVertexColor: {
            'default': false,
            'type': 'boolean',
        },
        metalnessMapChannel: {
            'default': 'r',
            'type': 'string'
        },
        metalnessMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        metalnessMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        metalnessMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        metalnessMapTint: {
            'default': false,
            'type': 'boolean',
        },
        metalness: {
            'default': 1,
            'min': 0,
            'max': 1,
            'type': 'float',
        },
        conserveEnergy: {
            'default': true,
            'type': 'boolean',
        },
        shininess: {
            'default': 32,
            'min': 0,
            'max': 100,
            'type': 'float',
        },
        glossMap: {
            'default': 0,
            'type': 'texture',
        },
        glossMapVertexColor: {
            'default': false,
            'type': 'boolean',
        },
        glossMapChannel: {
            'default': 'r',
            'type': 'string'
        },
        glossMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        glossMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        glossMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        fresnelModel: {
            'default': 0,
            'type': 'float',
        },
        fresnelFactor: {
            'default': 0,
            'type': 'float',
        },
        emissive: {
            'default': [ 0, 0, 0 ],
            'type': 'rgb',
        },
        emissiveMap: {
            'default': 0,
            'type': 'texture',
        },
        emissiveMapVertexColor: {
            'default': false,
            'type': 'boolean',
        },
        emissiveMapChannel: {
            'default': 'rgb',
            'type': 'string'
        },
        emissiveMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        emissiveMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        emissiveMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        emissiveMapTint: {
            'default': false,
            'type': 'boolean',
        },
        emissiveIntensity: {
            'default': 1,
            'min': 0,
            'max': 10,
            'type': 'float'
        },
        normalMap: {
            'default': 0,
            'type': 'texture',
        },
        normalMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        normalMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        normalMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        bumpMapFactor: {
            'default': 1,
            'type': 'float',
        },
        heightMap: {
            'default': 0,
            'type': 'texture',
        },
        heightMapChannel: {
            'default': 'r',
            'type': 'string'
        },
        heightMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        heightMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        heightMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        heightMapFactor: {
            'default': 1,
            'min': 0,
            'max': 2,
            'type': 'float'
        },
        alphaTest: {
            'default': 0,
            'min': 0,
            'max': 1,
            'type': 'float'
        },
        alphaToCoverage: {
            'default': false,
            'type': 'boolean'
        },
        opacity: {
            'default': 1,
            'min': 0,
            'max': 1,
            'type': 'float',
        },
        opacityMap: {
            'default': 0,
            'type': 'texture',
        },
        opacityMapVertexColor: {
            'default': false,
            'type': 'boolean',
        },
        opacityMapChannel: {
            'default': 'r',
            'type': 'string'
        },
        opacityMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        opacityMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        opacityMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        reflectivity: {
            'default': 1,
            'min': 0,
            'max': 1,
            'type': 'float',
        },
        refraction: {
            'default': 0,
            'min': 0,
            'max': 1,
            'type': 'float'
        },
        refractionIndex: {
            'default': 1.0 / 1.5,
            'min': 0,
            'max': 1,
            'type': 'float'
        },
        sphereMap: {
            'default': 0,
            'type': 'texture',
        },
        cubeMap: {
            'default': 0,
            'type': 'cubemap',
        },
        cubeMapProjection: {
            'default': 0,
            'type': 'number',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'Normal' },
                { v: 1, t: 'Box' }
            ]
        },
        cubeMapProjectionBox: {
            'default': {
                'center': [ 0, 0, 0 ],
                'halfExtents': [ 0.5, 0.5, 0.5 ]
            },
            'type': 'object'
        },
        lightMap: {
            'default': 0,
            'type': 'texture',
        },
        lightMapVertexColor: {
            'default': false,
            'type': 'boolean',
        },
        lightMapChannel: {
            'default': 'rgb',
            'type': 'string'
        },
        lightMapUv: {
            'default': 1,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        lightMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        lightMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        depthTest: {
            'default': true,
            'type': 'boolean',
        },
        depthWrite: {
            'default': true,
            'type': 'boolean',
        },
        cull: {
            'default': 1,
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'None' },
                { v: 1, t: 'Back Faces' },
                { v: 2, t: 'Front Faces' }
            ],
            'type': 'int',
        },
        blendType: {
            'default': 3,
            'enum': [
                { v: '', t: '...' },
                { v: 3, t: 'None' },
                { v: 2, t: 'Alpha' },
                { v: 1, t: 'Additive' },
                { v: 6, t: 'Additive Alpha' },
                { v: 8, t: 'Screen' },
                { v: 4, t: 'Premultiplied Alpha' },
                { v: 5, t: 'Multiply' },
                { v: 7, t: 'Modulate 2x' },
                { v: 9, t: 'Min (Partial Support)' },
                { v: 10, t: 'Max (Partial Support)' },
            ],
            'type': 'int'
        },
        useFog: {
            'default': true,
            'type': 'boolean'
        },
        useLighting: {
            'default': true,
            'type': 'boolean'
        },
        useSkybox: {
            'default': true,
            'type': 'boolean'
        },
        useGammaTonemap: {
            'default': true,
            'type': 'boolean'
        }
    };

    editor.method('assets:material:mapping', function() {
        return mapping;
    });

    var mappingMaps = [
        'diffuse',
        'specular',
        'emissive',
        'normal',
        'metalness',
        'gloss',
        'opacity',
        'height',
        'ao',
        'light'
    ];

    var panelsStates = { };
    var panelsStatesDependencies = {
        'offset': [ 'diffuseMapOffset', 'diffuseMapTiling' ],
        'ao': [ 'aoMap' ],
        'diffuse': [ 'diffuseMap' ],
        'specular': [ 'specularMap', 'metalnessMap', 'glossMap' ],
        'emissive': [ 'emissiveMap' ],
        'opacity': [ 'opacityMap' ],
        'normals': [ 'normalMap' ],
        'height': [ 'heightMap' ],
        'environment': [ 'sphereMap', 'cubeMap' ],
        'light': [ 'lightMap' ],
        'states': [ ]
    };

    var currentPreviewModel = 'sphere';

    var vecA = new pc.Vec3();


    editor.method('material:default', function (existingData) {
        existingData = existingData || {};

        var obj = {
            shader: existingData.shader || 'blinn'
        };

        for(var key in mapping) {
            obj[key] = existingData[key] !== undefined ? existingData[key] : mapping[key].default;
        }

        return obj;
    });

    editor.method('material:rememberMissingFields', function (asset) {
        // check missing tilings / offsets
        mappingMaps.forEach(function (map) {
            var path = 'data.' + map + 'MapTiling';
            if (asset.get(path) === null)
                missingPaths[asset.get('id') + '.' + path] = true;

            path = 'data.' + map + 'MapOffset';
            if (asset.get(path) === null)
                missingPaths[asset.get('id') + '.' + path] = true;
        });
    });

    // Contains paths in this form: id.data.property
    // Holds material properties that are not in the db.
    // Used to set initial values for offsets and tilings
    // to avoid sharejs errors.
    var missingPaths = { };

    editor.on('attributes:inspect[asset]', function(assets) {
        for(var i = 0; i < assets.length; i++) {
            if (assets[i].get('type') !== 'material')
                return;
        }

        var app = editor.call('viewport:app');
        if (! app) return; // webgl not available

        if (assets.length > 1)
            editor.call('attributes:header', assets.length + ' Materials');

        var root = editor.call('attributes.rootPanel');

        var ids = [ ];
        for(var i = 0; i < assets.length; i++)
            ids.push(assets[i].get('id'));
        ids = ids.sort(function(a, b) {
            return a - b;
        }).join(',');

        var panelState = panelsStates[ids];
        var panelStateNew = false;

        if (! panelState) {
            panelStateNew = true;
            panelState = panelsStates[ids] = { };

            for(var key in panelsStatesDependencies) {
                var fields = panelsStatesDependencies[key];
                panelState[key] = true;

                for(var n = 0; n < fields.length; n++) {
                    switch(mapping[fields[n]].type) {
                        case 'vec2':
                            for(var i = 0; i < assets.length; i++) {
                                var value = assets[i].get('data.' + fields[n]);
                                if (value && value[0] !== mapping[fields[n]].default[0] || value && value[1] !== mapping[fields[n]].default[1]) {
                                    panelState[key] = false;
                                    break;
                                }
                            }
                            break;
                        case 'cubemap':
                        case 'texture':
                            for(var i = 0; i < assets.length; i++) {
                                if (assets[i].get('data.' + fields[n])) {
                                    panelState[key] = false;
                                    break;
                                }
                            }
                            break;
                    }
                }
            }
        }

        var previewTexturesHover = null;

        // preview
        if (assets.length === 1) {
            previewTexturesHover = { };

            var previewContainer = document.createElement('div');
            previewContainer.classList.add('asset-preview-container');

            var preview = document.createElement('canvas');
            var ctx = preview.getContext('2d');
            preview.width = 256;
            preview.height = 256;
            preview.classList.add('asset-preview', 'flipY');
            previewContainer.appendChild(preview);

            var modelSphere = new ui.Button({
                text: '&#58121;'
            });
            modelSphere.class.add('sphere');
            if (currentPreviewModel === 'sphere')
                modelSphere.class.add('active');
            previewContainer.appendChild(modelSphere.element);
            modelSphere.parent = panelParams;

            modelSphere.on('click', function() {
                if (currentPreviewModel === 'sphere')
                    return;

                currentPreviewModel = 'sphere';
                modelBox.class.remove('active');
                modelSphere.class.add('active');

                queueRender();
            });

            var modelBox = new ui.Button({
                text: '&#57735;'
            });
            modelBox.class.add('box');
            if (currentPreviewModel === 'box')
                modelBox.class.add('active');
            previewContainer.appendChild(modelBox.element);
            modelBox.parent = panelParams;

            modelBox.on('click', function() {
                if (currentPreviewModel === 'box')
                    return;

                currentPreviewModel = 'box';
                modelSphere.class.remove('active');
                modelBox.class.add('active');

                queueRender();
            });

            var sx = 0, sy = 0, x = 0, y = 0, nx = 0, ny = 0;
            var dragging = false;
            var previewRotation = [ 0, 0 ];

            preview.addEventListener('mousedown', function(evt) {
                if (evt.button !== 0)
                    return;

                evt.preventDefault();
                evt.stopPropagation();

                sx = x = evt.clientX;
                sy = y = evt.clientY;

                dragging = true;
            }, false);

            var onMouseMove = function(evt) {
                if (! dragging)
                    return;

                nx = x - evt.clientX;
                ny = y - evt.clientY;
                x = evt.clientX;
                y = evt.clientY;

                queueRender();
            };

            var onMouseUp = function(evt) {
                if (! dragging)
                    return;

                if ((Math.abs(sx - x) + Math.abs(sy - y)) < 8) {
                    if (root.element.classList.contains('large')) {
                        root.element.classList.remove('large');
                    } else {
                        root.element.classList.add('large');
                    }
                }

                previewRotation[0] = Math.max(-90, Math.min(90, previewRotation[0] + ((sy - y) * 0.3)));
                previewRotation[1] += (sx - x) * 0.3;
                sx = sy = x = y = 0;

                dragging = false;

                queueRender();
            };

            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('mouseup', onMouseUp, false);


            root.class.add('asset-preview');
            root.element.insertBefore(previewContainer, root.innerElement);

            // rendering preview
            var renderQueued;

            var renderPreview = function () {
                if (renderQueued)
                    renderQueued = false;

                // render
                var imageData = editor.call('preview:render', assets[0], root.element.clientWidth, root.element.clientWidth, {
                    rotation: [ Math.max(-90, Math.min(90, previewRotation[0] + (sy - y) * 0.3)), previewRotation[1] + (sx - x) * 0.3 ],
                    model: currentPreviewModel,
                    params: previewTexturesHover
                });
                if (! imageData) return;

                preview.width = imageData.width;
                preview.height = imageData.height;

                ctx.putImageData(imageData, 0, 0);
            };
            renderPreview();

            // queue up the rendering to prevent too oftern renders
            var queueRender = function() {
                if (renderQueued) return;
                renderQueued = true;
                requestAnimationFrame(renderPreview);
            };

            // render on resize
            var evtPanelResize = root.on('resize', queueRender);
            var evtSceneSettings = editor.on('preview:scene:changed', queueRender);

            // material textures loaded
            var materialWatch = editor.call('assets:material:watch', {
                asset: assets[0],
                autoLoad: true,
                callback: queueRender
            });
        }

        var handleTextureHover = function(path) {
            var valueOld = null;
            var events = [ ];

            return {
                over: function(type, data) {
                    if (previewTexturesHover !== null)
                        previewTexturesHover[path] = parseInt(data.id, 10);

                    var texture = app.assets.get(parseInt(data.id, 10));
                    app.assets.load(texture);

                    var attachTexture = function(ind) {
                        var engineAsset = app.assets.get(parseInt(assets[ind].get('id'), 10));
                        app.assets.load(engineAsset);

                        if (engineAsset && engineAsset.resource) {
                            valueOld[ind] = engineAsset.resource[path];

                            if (texture.resource) {
                                engineAsset.resource[path] = texture.resource;
                                engineAsset.resource.update();
                            } else {
                                var evt = {
                                    asset: texture,
                                    fn: function() {
                                        engineAsset.resource[path] = texture.resource;
                                        engineAsset.resource.update();
                                    }
                                };
                                events.push(evt);
                                texture.once('load', evt.fn);
                            }
                        }
                    };

                    valueOld = [ ];
                    for(var i = 0; i < assets.length; i++)
                        attachTexture(i);

                    editor.call('viewport:render');

                    if (queueRender)
                        queueRender();
                },
                leave: function() {
                    if (previewTexturesHover !== null)
                        previewTexturesHover = { };

                    if (queueRender)
                        queueRender();

                    if (valueOld === null) return;

                    for(var i = 0; i < events.length; i++)
                        events[i].asset.off('load', events[i].fn);
                    events = [ ];

                    for(var i = 0; i < assets.length; i++) {
                        var engineAsset = app.assets.get(parseInt(assets[i].get('id'), 10));
                        app.assets.load(engineAsset);

                        if (engineAsset && engineAsset.resource) {
                            engineAsset.resource[path] = valueOld[i];
                            engineAsset.resource.update();
                        }
                    }
                    editor.call('viewport:render');
                    valueOld = null;
                }
            };
        };


        // properties panel
        var panelParams = editor.call('attributes:addPanel', {
            name: 'Material'
        });
        panelParams.class.add('component');
        // reference
        editor.call('attributes:reference:attach', 'asset:material:asset', panelParams, panelParams.headerElement);
        // clean preview
        if (assets.length === 1) {
            panelParams.on('destroy', function() {
                root.class.remove('asset-preview');

                editor.call('assets:material:unwatch', assets[0], materialWatch);

                evtSceneSettings.unbind();
                evtPanelResize.unbind();
                previewContainer.parentNode.removeChild(previewContainer);

                window.removeEventListener('mousemove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);
            });
        }


        // model
        var fieldShader = editor.call('attributes:addField', {
            parent: panelParams,
            type: 'string',
            enum: {
                '': '...',
                'phong': 'Phong',
                'blinn': 'Physical'
            },
            name: 'Shading',
            link: assets,
            path: 'data.shader'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:shadingModel', fieldShader.parent.innerElement.firstChild.ui);
        // fresnelMode
        var evtFresnelModel = [ ];
        for(var i = 0; i < assets.length; i++) {
            evtFresnelModel.push(assets[i].on('data.shader:set', function(value) {
                var state = this.history.enabled;
                this.history.enabled = false;
                this.set('data.fresnelModel', value === 'blinn' ? 2 : 0);
                this.history.enabled = state;
            }));
        }
        fieldShader.once('destroy', function() {
            for(var i = 0; i < evtFresnelModel.length; i++)
                evtFresnelModel[i].unbind();
        });



        // TODO
        // make sure changes by history or to individual
        // offset/tiling fields affects state of global fields

        // tiling & offsets
        var tilingOffsetsChanging = false;
        var offset = assets[0].get('data.' + mappingMaps[0] + 'MapOffset');
        var tiling = assets[0].get('data.' + mappingMaps[0] + 'MapTiling');
        var checkTilingOffsetDifferent = function() {
            var offset = assets[0].get('data.' + mappingMaps[0] + 'MapOffset');
            var tiling = assets[0].get('data.' + mappingMaps[0] + 'MapTiling');

            for(var i = 0; i < assets.length; i++) {
                for(var m = 0; m < mappingMaps.length; m++) {
                    if (i === 0 && m === 0)
                        continue;

                    if (! offset.equals(assets[i].get('data.' + mappingMaps[m] + 'MapOffset')) || ! tiling.equals(assets[i].get('data.' + mappingMaps[m] + 'MapTiling'))) {
                        return true;
                    }
                }
            }

            return false;
        }
        var different = checkTilingOffsetDifferent();

        if (different && panelStateNew)
            panelState['offset'] = true;

        var panelTiling = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['offset'],
            name: 'Offset & Tiling'
        });
        panelTiling.class.add('component');
        panelTiling.on('fold', function() { panelState['offset'] = true; });
        panelTiling.on('unfold', function() { panelState['offset'] = false; });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:offsetTiling', panelTiling, panelTiling.headerElement);

        var tilingOffsetFields = [ ];

        // all maps
        var fieldTilingOffset = editor.call('attributes:addField', {
            parent: panelTiling,
            type: 'checkbox',
            name: 'Apply to all Maps',
            value: ! different
        });
        fieldTilingOffset.element.previousSibling.style.width = 'auto';
        fieldTilingOffset.on('change', function(value) {
            if (tilingOffsetsChanging)
                return;

            fieldOffset[0].parent.hidden = ! value;
            fieldTiling[0].parent.hidden = ! value;

            for(var i = 0; i < tilingOffsetFields.length; i++)
                tilingOffsetFields[i].element.hidden = tilingOffsetFields[i].filter();

            if (value) {
                var valueOffset = [ fieldOffset[0].value, fieldOffset[1].value ];
                var valueTiling = [ fieldTiling[0].value, fieldTiling[1].value ];
                var items = [ ];
                tilingOffsetsChanging = true;
                for(var i = 0; i < assets.length; i++) {
                    for(var m = 0; m < mappingMaps.length; m++) {
                        items.push({
                            get: assets[i].history._getItemFn,
                            path: 'data.' + mappingMaps[m] + 'Map',
                            valueOffset: assets[i].get('data.' + mappingMaps[m] + 'MapOffset'),
                            valueTiling: assets[i].get('data.' + mappingMaps[m] + 'MapTiling')
                        });
                        assets[i].history.enabled = false;
                        assets[i].set('data.' + mappingMaps[m] + 'MapOffset', valueOffset);
                        assets[i].set('data.' + mappingMaps[m] + 'MapTiling', valueTiling);
                        assets[i].history.enabled = true;
                    }
                }
                tilingOffsetsChanging = false;
                // history
                editor.call('history:add', {
                    name: 'assets.materials.tiling-offset',
                    undo: function() {
                        for(var i = 0; i < items.length; i++) {
                            var item = items[i].get();
                            if (! item)
                                continue;

                            item.history.enabled = false;
                            item.set(items[i].path + 'Offset', items[i].valueOffset);
                            item.set(items[i].path + 'Tiling', items[i].valueTiling);
                            item.history.enabled = true;
                        }
                    },
                    redo: function() {
                        for(var i = 0; i < items.length; i++) {
                            var item = items[i].get();
                            if (! item)
                                continue;

                            item.history.enabled = false;
                            item.set(items[i].path + 'Offset', valueOffset);
                            item.set(items[i].path + 'Tiling', valueTiling);
                            item.history.enabled = true;
                        }
                    }
                });
            }
        });

        // offset
        var fieldOffset = editor.call('attributes:addField', {
            parent: panelTiling,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ]
        });
        fieldOffset[0].parent.hidden = ! fieldTilingOffset.value;
        // reference
        editor.call('attributes:reference:attach', 'asset:material:offset', fieldOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldTiling = editor.call('attributes:addField', {
            parent: panelTiling,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ]
        });
        fieldTiling[0].parent.hidden = ! fieldTilingOffset.value;
        // reference
        editor.call('attributes:reference:attach', 'asset:material:tiling', fieldTiling[0].parent.innerElement.firstChild.ui);

        if (different) {
            fieldTilingOffset.value = false;

            if (panelStateNew && ! panelState['offset'])
                panelState['offset'] = true;
        }

        fieldOffset[0].value = offset[0];
        fieldOffset[1].value = offset[1];
        fieldTiling[0].value = tiling[0];
        fieldTiling[1].value = tiling[1];

        var updateAllTilingOffsetFields = function(input, type, field, value, valueOld) {
            if (! fieldTilingOffset.value || tilingOffsetsChanging)
                return;

            var items = [ ];

            tilingOffsetsChanging = true;
            for(var i = 0; i < assets.length; i++) {
                assets[i].history.enabled = false;
                for(var m = 0; m < mappingMaps.length; m++) {
                    var path = 'data.' + mappingMaps[m] + 'Map' + type;
                    // set initial value for tiling / offset if it was missing
                    if (missingPaths[assets[i].get('id') + '.' + path]) {
                        assets[i].set(path, [input[0].value, input[1].value]);
                        delete missingPaths[assets[i].get('id') + '.' + path];
                    }

                    var fullpath = path + '.' + field;
                    items.push({
                        get: assets[i].history._getItemFn,
                        path: fullpath,
                        value: assets[i].get(fullpath)
                    });
                    assets[i].set(fullpath, value);
                }
                assets[i].history.enabled = true;
            }
            tilingOffsetsChanging = false;

            // history
            editor.call('history:add', {
                name: 'assets.materials.' + type + '.' + field,
                undo: function() {
                    for(var i = 0; i < items.length; i++) {
                        var item = items[i].get();
                        if (! item)
                            continue;

                        item.history.enabled = false;
                        item.set(items[i].path, items[i].value);
                        item.history.enabled = true;
                    }
                },
                redo: function() {
                    for(var i = 0; i < items.length; i++) {
                        var item = items[i].get();
                        if (! item)
                            continue;

                        item.history.enabled = false;
                        item.set(items[i].path, value);
                        item.history.enabled = true;
                    }
                }
            });
        };

        fieldOffset[0].on('change', function(value, valueOld) {
            updateAllTilingOffsetFields(fieldOffset, 'Offset', 0, value);
        });
        fieldOffset[1].on('change', function(value, valueOld) {
            updateAllTilingOffsetFields(fieldOffset, 'Offset', 1, value);
        });
        fieldTiling[0].on('change', function(value, valueOld) {
            updateAllTilingOffsetFields(fieldTiling, 'Tiling', 0, value);
        });
        fieldTiling[1].on('change', function(value, valueOld) {
            updateAllTilingOffsetFields(fieldTiling, 'Tiling', 1, value);
        });

        var queuedOffsetsCheck = null;
        var queueOffsetsCheck = function() {
            if (queuedOffsetsCheck)
                return;

            queuedOffsetsCheck = setTimeout(function() {
                queuedOffsetsCheck = null;

                if (! fieldTilingOffset.value)
                    return;

                var offset = assets[0].get('data.diffuseMapOffset');
                var tiling = assets[0].get('data.diffuseMapTiling');

                tilingOffsetsChanging = true;

                fieldOffset[0].value = offset[0];
                fieldOffset[1].value = offset[1];

                fieldTiling[0].value = tiling[0];
                fieldTiling[1].value = tiling[1];

                tilingOffsetsChanging = false;
            });
        };

        for(var i = 0; i < assets.length; i++) {
            for(var m = 0; m < mappingMaps.length; m++) {
                assets[i].on('data.' + mappingMaps[m] + 'MapOffset.0:set', queueOffsetsCheck);
                assets[i].on('data.' + mappingMaps[m] + 'MapOffset.1:set', queueOffsetsCheck);
                assets[i].on('data.' + mappingMaps[m] + 'MapTiling.0:set', queueOffsetsCheck);
                assets[i].on('data.' + mappingMaps[m] + 'MapTiling.1:set', queueOffsetsCheck);
            }
        }

        panelTiling.once('destroy', function() {
            if (queuedOffsetsCheck)
                clearTimeout(queuedOffsetsCheck);
        });

        var rgxExtension = /\.[a-z]+$/;
        var textureFields = { };
        var texturePanels = { };
        var bulkSlots = {
            'ao': [ 'a', 'ao', 'ambient', 'ambientocclusion', 'gma', 'gmat', 'gmao', 'gmaa', 'rma', 'rmat', 'rmao', 'rmaa' ],
            'diffuse': [ 'd', 'diff', 'diffuse', 'albedo', 'color', 'rgb', 'rgba' ],
            'specular': [ 's', 'spec', 'specular' ],
            'metalness': [ 'm', 'met', 'metal', 'metalness', 'gma', 'gmat', 'gmao', 'gmaa', 'rma', 'rmat', 'rmao', 'rmaa' ],
            'gloss': [ 'g', 'gloss', 'glossiness', 'gma', 'gmat', 'gmao', 'gmaa', 'rma', 'rmat', 'rmao', 'rmaa' ],
            'emissive': [ 'e', 'emissive' ],
            'opacity': [ 'o', 't', 'opacity', 'alpha', 'transparency', 'gmat', 'gmao', 'gmaa', 'rgba', 'rmat', 'rmao', 'rmaa' ],
            'normal': [ 'n', 'norm', 'normal', 'normals' ],
            'height': [ 'p', 'h', 'height', 'parallax', 'bump' ],
            'light': [ 'l', 'lm', 'light', 'lightmap' ]
        };

        var postfixToSlot = { };
        for(var key in bulkSlots) {
            for(var i = 0; i < bulkSlots[key].length; i++) {
                postfixToSlot[bulkSlots[key][i]] = postfixToSlot[bulkSlots[key][i]] || [ ];
                postfixToSlot[bulkSlots[key][i]].push(key);
            }
        }

        var tokenizeFilename = function(filename) {
            filename = filename.trim().toLowerCase();

            if (! filename)
                return;

            // drop extension
            var ext = filename.match(rgxExtension);
            if (ext) filename = filename.slice(0, -ext[0].length);

            if (! filename)
                return;

            var parts = filename.split(/(\-|_|\.)/g);
            var tokens = [ ];

            for(var i = 0; i < parts.length; i++) {
                if (parts[i] === '-' || parts[i] === '_' || parts[i] === '.')
                    continue;

                tokens.push(parts[i]);
            }

            if (! tokens.length)
                return;

            if (tokens.length === 1)
                return [ '', tokens[0] ];

            var left = tokens.slice(0, -1).join('');
            var right = tokens[tokens.length - 1];

            return [ left, right ];
        };

        var getFilenameLeftPart = function(name) {
            var parts = asset.get('name').trim().replace(/\.[a-z]+$/i, '').split(/(\-|_|\.)/g);
            if (parts.length < 3)
                return '';

            var first = parts.slice(0, -1).join('').toLowerCase();
        };

        var onTextureBulkSet = function(asset, oldValues, slot) {
            var tokens = tokenizeFilename(asset.get('name'));
            if (! tokens)
                return;

            if (bulkSlots[slot].indexOf(tokens[1]) == -1)
                return;

            var path = asset.get('path');
            var textures = editor.call('assets:find', function(texture) {
                return texture.get('type') === 'texture' && ! texture.get('source') && texture.get('path').equals(path);
            });

            var candidates = { };
            for(var i = 0; i < textures.length; i++) {
                var t = tokenizeFilename(textures[i][1].get('name'));

                if (! t || t[0] !== tokens[0] || ! postfixToSlot[t[1]])
                    continue;

                for(var s = 0; s < postfixToSlot[t[1]].length; s++) {
                    if (postfixToSlot[t[1]][s] === slot)
                        continue;

                    candidates[postfixToSlot[t[1]][s]] = {
                        texture: textures[i][1],
                        postfix: t[1]
                    };
                }
            }

            if (! Object.keys(candidates).length)
                return;

            var records = [ ];

            for(var a = 0; a < assets.length; a++) {
                if (oldValues[assets[a].get('id')])
                    continue;

                var history = assets[a].history.enabled;
                assets[a].history.enabled = false;

                for(var s in candidates) {
                    var key = 'data.' + s + 'Map';

                    if (assets[a].get(key))
                        continue;

                    var panel = texturePanels[s];
                    if (panel) panel.folded = false;

                    var id = parseInt(candidates[s].texture.get('id'), 10);
                    assets[a].set(key, id);

                    records.push({
                        id: assets[a].get('id'),
                        key: key,
                        value: id,
                        old: null
                    });

                    if (s === 'ao') {
                        // ao can be in third color channel
                        if (/^(g|r)ma/.test(candidates[s].postfix)) {
                            var channel = assets[a].get('data.aoMapChannel');
                            if (channel !== 'b') {
                                assets[a].set('data.aoMapChannel', 'b');

                                records.push({
                                    id: assets[a].get('id'),
                                    key: 'data.aoMapChannel',
                                    value: 'b',
                                    old: channel
                                });
                            }
                        }
                    } else if (s === 'metalness') {
                        // use metalness
                        if (! assets[a].get('data.useMetalness')) {
                            assets[a].set('data.useMetalness', true);

                            records.push({
                                id: assets[a].get('id'),
                                key: 'data.useMetalness',
                                value: true,
                                old: false
                            });
                        }

                        // metalness to maximum
                        var metalness = assets[a].get('data.metalness');
                        if (metalness !== 1) {
                            assets[a].set('data.metalness', 1.0);

                            records.push({
                                id: assets[a].get('id'),
                                key: 'data.metalness',
                                value: 1.0,
                                old: metalness
                            });
                        }

                        // metalness can be in second color channel
                        if (/^(g|r)ma/.test(candidates[s].postfix)) {
                            var channel = assets[a].get('data.metalnessMapChannel');
                            if (channel !== 'g') {
                                assets[a].set('data.metalnessMapChannel', 'g');

                                records.push({
                                    id: assets[a].get('id'),
                                    key: 'data.metalnessMapChannel',
                                    value: 'g',
                                    old: channel
                                });
                            }
                        }
                    } else if (s === 'gloss') {
                        // gloss to maximum
                        var shininess = assets[a].get('data.shininess');
                        if (shininess !== 100) {
                            assets[a].set('data.shininess', 100.0);

                            records.push({
                                id: assets[a].get('id'),
                                key: 'data.shininess',
                                value: 100.0,
                                old: shininess
                            });
                        }

                        // gloss shall be in first color channel
                        var channel = assets[a].get('data.glossMapChannel');
                        if (channel !== 'r') {
                            assets[a].set('data.glossMapChannel', 'r');

                            records.push({
                                id: assets[a].get('id'),
                                key: 'data.glossMapChannel',
                                value: 'r',
                                old: channel
                            });
                        }
                    } else if (s === 'opacity') {
                        // opacity can be in fourth color channel
                        if (/^(gma|rma|rgb)(t|o|a)$/.test(candidates[s].postfix)) {
                            var channel = assets[a].get('data.opacityMapChannel');
                            if (channel !== 'a') {
                                assets[a].set('data.opacityMapChannel', 'a');

                                records.push({
                                    id: assets[a].get('id'),
                                    key: 'data.opacityMapChannel',
                                    value: 'a',
                                    old: channel
                                });
                            }
                        }
                    }
                }

                assets[a].history.enabled = history;
            }

            if (records.length) {
                editor.call('history:add', {
                    name: 'material textures auto-bind',
                    undo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var asset = editor.call('assets:get', records[i].id);
                            if (! asset)
                                continue;

                            var history = asset.history.enabled;
                            asset.history.enabled = false;
                            asset.set(records[i].key, records[i].old);
                            asset.history.enabled = history;
                        }
                    },
                    redo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var asset = editor.call('assets:get', records[i].id);
                            if (! asset)
                                continue;

                            var history = asset.history.enabled;
                            asset.history.enabled = false;
                            asset.set(records[i].key, records[i].value);
                            asset.history.enabled = history;
                        }
                    }
                });
            }
        };



        // ambient
        var panelAmbient = texturePanels.ao = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['ao'],
            name: 'Ambient'
        });
        panelAmbient.class.add('component');
        panelAmbient.on('fold', function() { panelState['ao'] = true; });
        panelAmbient.on('unfold', function() { panelState['ao'] = false; });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:ambientOverview', panelAmbient, panelAmbient.headerElement);


        // map
        var fieldAmbientMapHover = handleTextureHover('aoMap');
        var fieldAmbientMap = textureFields.ao = editor.call('attributes:addField', {
            parent: panelAmbient,
            type: 'asset',
            kind: 'texture',
            name: 'Ambient Occlusion',
            link: assets,
            path: 'data.aoMap',
            over: fieldAmbientMapHover.over,
            leave: fieldAmbientMapHover.leave,
            onSet: function(asset, oldValues) {
                onTextureBulkSet(asset, oldValues, 'ao');
            }
        });
        fieldAmbientMap.parent.class.add('channel');
        fieldAmbientMap.on('change', function(value) {
            fieldAmbientOffset[0].parent.hidden = filterAmbientOffset();
            fieldAmbientTiling[0].parent.hidden = filterAmbientTiling();
            fieldOccludeSpecular.parent.hidden = ! fieldAmbientMap.value && ! fieldAmbientMap.class.contains('null');
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:aoMap', fieldAmbientMap._label);

        // map uv
        var fieldAmbientMapUV = editor.call('attributes:addField', {
            panel: fieldAmbientMap.parent,
            type: 'number',
            enum: mapping.aoMapUv.enum,
            link: assets,
            path: 'data.aoMapUv'
        });
        fieldAmbientMapUV.flexGrow = 0;
        fieldAmbientMapUV.element.parentNode.removeChild(fieldAmbientMapUV.element);
        fieldAmbientMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldAmbientMapUV.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:aoMapUv', fieldAmbientMapUV);

        // map channel
        var fieldAmbientMapChannel = editor.call('attributes:addField', {
            panel: fieldAmbientMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A'
            },
            link: assets,
            path: 'data.aoMapChannel'
        });
        fieldAmbientMapChannel.element.parentNode.removeChild(fieldAmbientMapChannel.element);
        fieldAmbientMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldAmbientMapChannel.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:aoMapChannel', fieldAmbientMapChannel);

        // offset
        var fieldAmbientOffset = editor.call('attributes:addField', {
            parent: panelAmbient,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.aoMapOffset'
        });
        var filterAmbientOffset = function() {
            return (! fieldAmbientMap.value && ! fieldAmbientMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldAmbientOffset[0].parent,
            offset: fieldAmbientOffset,
            filter: filterAmbientOffset,
            path: 'data.aoMapOffset'
        });
        fieldAmbientOffset[0].parent.hidden = filterAmbientOffset();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:aoMapOffset', fieldAmbientOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldAmbientTiling = editor.call('attributes:addField', {
            parent: panelAmbient,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.aoMapTiling'
        });
        var filterAmbientTiling = function() {
            return (! fieldAmbientMap.value && ! fieldAmbientMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldAmbientTiling[0].parent,
            tiling: fieldAmbientTiling,
            filter: filterAmbientTiling,
            path: 'data.aoMapTiling'
        });
        fieldAmbientTiling[0].parent.hidden = filterAmbientTiling();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:aoMapTiling', fieldAmbientTiling[0].parent.innerElement.firstChild.ui);

        // vertex color
        var fieldAmbientVertexColor = editor.call('attributes:addField', {
            parent: panelAmbient,
            name: 'Vertex Color',
            type: 'checkbox',
            link: assets,
            path: 'data.aoMapVertexColor'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:aoMapVertexColor', fieldAmbientVertexColor.parent.innerElement.firstChild.ui);

        // occludeSpecular
        var fieldOccludeSpecular = editor.call('attributes:addField', {
            parent: panelAmbient,
            type: 'number',
            enum: mapping.occludeSpecular.enum,
            name: 'Occlude Specular',
            link: assets,
            path: 'data.occludeSpecular'
        });
        fieldOccludeSpecular.parent.hidden = ! fieldAmbientMap.value && ! fieldAmbientMap.class.contains('null');
        // reference
        editor.call('attributes:reference:attach', 'asset:material:occludeSpecular', fieldOccludeSpecular.parent.innerElement.firstChild.ui);

        // color
        var fieldAmbientColor = editor.call('attributes:addField', {
            parent: panelAmbient,
            name: 'Color',
            type: 'rgb',
            link: assets,
            path: 'data.ambient'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:ambient', fieldAmbientColor.parent.innerElement.firstChild.ui);


        // tint
        var fieldAmbientTint = editor.call('attributes:addField', {
            panel: fieldAmbientColor.parent,
            type: 'checkbox',
            link: assets,
            path: 'data.ambientTint'
        });
        // label
        var labelAmbientTint = new ui.Label({ text: 'Tint' });
        labelAmbientTint.style.verticalAlign = 'top';
        labelAmbientTint.style.paddingRight = '12px';
        labelAmbientTint.style.fontSize = '12px';
        labelAmbientTint.style.lineHeight = '24px';
        fieldAmbientColor.parent.append(labelAmbientTint);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:ambientTint', labelAmbientTint);


        // diffuse
        var panelDiffuse = texturePanels.diffuse = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['diffuse'],
            name: 'Diffuse'
        });
        panelDiffuse.class.add('component');
        panelDiffuse.on('fold', function() { panelState['diffuse'] = true; });
        panelDiffuse.on('unfold', function() { panelState['diffuse'] = false; });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:diffuseOverview', panelDiffuse, panelDiffuse.headerElement);

        // diffuse map
        var fieldDiffuseMapHover = handleTextureHover('diffuseMap');
        var fieldDiffuseMap = textureFields.diffuse = editor.call('attributes:addField', {
            parent: panelDiffuse,
            type: 'asset',
            kind: 'texture',
            name: 'Diffuse',
            link: assets,
            path: 'data.diffuseMap',
            over: fieldDiffuseMapHover.over,
            leave: fieldDiffuseMapHover.leave,
            onSet: function(asset, oldValues) {
                onTextureBulkSet(asset, oldValues, 'diffuse');
            }
        });
        fieldDiffuseMap.parent.class.add('channel');
        fieldDiffuseMap.on('change', function(value) {
            fieldDiffuseOffset[0].parent.hidden = filterDiffuseOffset();
            fieldDiffuseTiling[0].parent.hidden = filterDiffuseTiling();
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:diffuseMap', fieldDiffuseMap._label);

        // map uv
        var fieldDiffuseMapUV = editor.call('attributes:addField', {
            panel: fieldDiffuseMap.parent,
            type: 'number',
            enum: mapping.diffuseMapUv.enum,
            link: assets,
            path: 'data.diffuseMapUv'
        });
        fieldDiffuseMapUV.flexGrow = 0;
        fieldDiffuseMapUV.element.parentNode.removeChild(fieldDiffuseMapUV.element);
        fieldDiffuseMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldDiffuseMapUV.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:diffuseMapUv', fieldDiffuseMapUV);

        // map channel
        var fieldDiffuseMapChannel = editor.call('attributes:addField', {
            panel: fieldDiffuseMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A',
                'rgb': 'RGB'
            },
            link: assets,
            path: 'data.diffuseMapChannel'
        });
        fieldDiffuseMapChannel.element.parentNode.removeChild(fieldDiffuseMapChannel.element);
        fieldDiffuseMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldDiffuseMapChannel.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:diffuseMapChannel', fieldDiffuseMapChannel);

        // offset
        var fieldDiffuseOffset = editor.call('attributes:addField', {
            parent: panelDiffuse,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.diffuseMapOffset'
        });
        var filterDiffuseOffset = function() {
            return (! fieldDiffuseMap.value && ! fieldDiffuseMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldDiffuseOffset[0].parent,
            offset: fieldDiffuseOffset,
            filter: filterDiffuseOffset,
            path: 'data.diffuseMapOffset'
        });
        fieldDiffuseOffset[0].parent.hidden = filterDiffuseOffset();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:diffuseMapOffset', fieldDiffuseOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldDiffuseTiling = editor.call('attributes:addField', {
            parent: panelDiffuse,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.diffuseMapTiling'
        });
        var filterDiffuseTiling = function() {
            return (! fieldDiffuseMap.value && ! fieldDiffuseMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldDiffuseTiling[0].parent,
            tiling: fieldDiffuseTiling,
            filter: filterDiffuseTiling,
            path: 'data.diffuseMapTiling'
        });
        fieldDiffuseTiling[0].parent.hidden = filterDiffuseTiling();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:diffuseMapTiling', fieldDiffuseTiling[0].parent.innerElement.firstChild.ui);

        // vertex color
        var fieldDiffuseVertexColor = editor.call('attributes:addField', {
            parent: panelDiffuse,
            name: 'Vertex Color',
            type: 'checkbox',
            link: assets,
            path: 'data.diffuseMapVertexColor'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:diffuseMapVertexColor', fieldDiffuseVertexColor.parent.innerElement.firstChild.ui);

        // color
        var fieldDiffuseColor = editor.call('attributes:addField', {
            parent: panelDiffuse,
            name: 'Color',
            type: 'rgb',
            link: assets,
            path: 'data.diffuse'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:diffuse', fieldDiffuseColor.parent.innerElement.firstChild.ui);

        // tint
        var fieldDiffuseTint = editor.call('attributes:addField', {
            panel: fieldDiffuseColor.parent,
            type: 'checkbox',
            link: assets,
            path: 'data.diffuseMapTint'
        });
        // label
        var labelDiffuseTint = new ui.Label({ text: 'Tint' });
        labelDiffuseTint.style.verticalAlign = 'top';
        labelDiffuseTint.style.paddingRight = '12px';
        labelDiffuseTint.style.fontSize = '12px';
        labelDiffuseTint.style.lineHeight = '24px';
        fieldDiffuseColor.parent.append(labelDiffuseTint);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:diffuseMapTint', labelDiffuseTint);



        // specular
        var panelSpecular = texturePanels.specular = texturePanels.metalness = texturePanels.gloss = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['specular'],
            name: 'Specular'
        });
        panelSpecular.class.add('component');
        panelSpecular.on('fold', function() { panelState['specular'] = true; });
        panelSpecular.on('unfold', function() { panelState['specular'] = false; });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:specularOverview', panelSpecular, panelSpecular.headerElement);

        // use metalness
        var fieldUseMetalness = editor.call('attributes:addField', {
            parent: panelSpecular,
            type: 'checkbox',
            name: 'Use Metalness',
            link: assets,
            path: 'data.useMetalness'
        });
        fieldUseMetalness.on('change', function(value) {
            panelSpecularWorkflow.hidden = value || fieldUseMetalness.class.contains('null');
            panelMetalness.hidden = ! value || fieldUseMetalness.class.contains('null');
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:useMetalness', fieldUseMetalness.parent.innerElement.firstChild.ui);

        var panelMetalness = editor.call('attributes:addPanel');
        panelMetalness.hidden = ! fieldUseMetalness.value || fieldUseMetalness.class.contains('null');
        panelSpecular.append(panelMetalness);

        // metalness map
        var fieldMetalnessMapHover = handleTextureHover('metalnessMap');
        var fieldMetalnessMap = textureFields.metalness = editor.call('attributes:addField', {
            parent: panelMetalness,
            type: 'asset',
            kind: 'texture',
            name: 'Metalness',
            link: assets,
            path: 'data.metalnessMap',
            over: fieldMetalnessMapHover.over,
            leave: fieldMetalnessMapHover.leave,
            onSet: function(asset, oldValues) {
                onTextureBulkSet(asset, oldValues, 'metalness');
            }
        });
        fieldMetalnessMap.parent.class.add('channel');
        fieldMetalnessMap.on('change', function(value) {
            fieldMetalnessOffset[0].parent.hidden = filterMetalnessOffset();
            fieldMetalnessTiling[0].parent.hidden = filterMetalnessTiling();
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:metalnessMap', fieldMetalnessMap._label);

        // map uv
        var fieldMetalnessMapUV = editor.call('attributes:addField', {
            panel: fieldMetalnessMap.parent,
            type: 'number',
            enum: mapping.metalnessMapUv.enum,
            link: assets,
            path: 'data.metalnessMapUv'
        });
        fieldMetalnessMapUV.flexGrow = 0;
        fieldMetalnessMapUV.element.parentNode.removeChild(fieldMetalnessMapUV.element);
        fieldMetalnessMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldMetalnessMapUV.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:metalnessMapUv', fieldMetalnessMapUV);

        // map channel
        var fieldMetalnessMapChannel = editor.call('attributes:addField', {
            panel: fieldMetalnessMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A',
            },
            link: assets,
            path: 'data.metalnessMapChannel'
        });
        fieldMetalnessMapChannel.element.parentNode.removeChild(fieldMetalnessMapChannel.element);
        fieldMetalnessMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldMetalnessMapChannel.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:metalnessMapChannel', fieldMetalnessMapChannel);

        // offset
        var fieldMetalnessOffset = editor.call('attributes:addField', {
            parent: panelMetalness,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.metalnessMapOffset'
        });
        var filterMetalnessOffset = function() {
            return (! fieldMetalnessMap.value && ! fieldMetalnessMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldMetalnessOffset[0].parent,
            offset: fieldMetalnessOffset,
            filter: filterMetalnessOffset,
            path: 'data.metalnessMapOffset'
        });
        fieldMetalnessOffset[0].parent.hidden = filterMetalnessOffset();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:metalnessMapOffset', fieldMetalnessOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldMetalnessTiling = editor.call('attributes:addField', {
            parent: panelMetalness,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.metalnessMapTiling'
        });
        var filterMetalnessTiling = function() {
            return (! fieldMetalnessMap.value && ! fieldMetalnessMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldMetalnessTiling[0].parent,
            tiling: fieldMetalnessTiling,
            filter: filterMetalnessTiling,
            path: 'data.metalnessMapTiling'
        });
        fieldMetalnessTiling[0].parent.hidden = filterMetalnessTiling();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:metalnessMapTiling', fieldMetalnessTiling[0].parent.innerElement.firstChild.ui);

        // vertex color
        var fieldMetalnessVertexColor = editor.call('attributes:addField', {
            parent: panelMetalness,
            name: 'Vertex Color',
            type: 'checkbox',
            link: assets,
            path: 'data.metalnessMapVertexColor'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:metalnessMapVertexColor', fieldMetalnessVertexColor.parent.innerElement.firstChild.ui);


        // metalness
        var fieldMetalness = editor.call('attributes:addField', {
            parent: panelMetalness,
            precision: 3,
            step: 0.05,
            min: 0,
            max: 1,
            type: 'number',
            name: 'Metalness',
            link: assets,
            path: 'data.metalness'
        });
        fieldMetalness.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'asset:material:metalness', fieldMetalness.parent.innerElement.firstChild.ui);

        // metalness slider
        var fieldMetalnessSlider = editor.call('attributes:addField', {
            panel: fieldMetalness.parent,
            precision: 3,
            step: 0.05,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.metalness'
        });
        fieldMetalnessSlider.flexGrow = 4;


        // specular
        var panelSpecularWorkflow = editor.call('attributes:addPanel');
        panelSpecularWorkflow.hidden = fieldUseMetalness.value || fieldUseMetalness.class.contains('null');
        panelSpecular.append(panelSpecularWorkflow);

        // specular map
        var fieldSpecularMapHover = handleTextureHover('specularMap');
        var fieldSpecularMap = textureFields.specular = editor.call('attributes:addField', {
            parent: panelSpecularWorkflow,
            type: 'asset',
            kind: 'texture',
            name: 'Specular',
            link: assets,
            path: 'data.specularMap',
            over: fieldSpecularMapHover.over,
            leave: fieldSpecularMapHover.leave,
            onSet: function(asset, oldValues) {
                onTextureBulkSet(asset, oldValues, 'specular');
            }
        });
        fieldSpecularMap.parent.class.add('channel');
        fieldSpecularMap.on('change', function(value) {
            fieldSpecularOffset[0].parent.hidden = filterSpecularOffset();
            fieldSpecularTiling[0].parent.hidden = filterSpecularTiling();
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:specularMap', fieldSpecularMap._label);

        // map uv
        var fieldSpecularMapUV = editor.call('attributes:addField', {
            panel: fieldSpecularMap.parent,
            type: 'number',
            enum: mapping.specularMapUv.enum,
            link: assets,
            path: 'data.specularMapUv'
        });
        fieldSpecularMapUV.flexGrow = 0;
        fieldSpecularMapUV.element.parentNode.removeChild(fieldSpecularMapUV.element);
        fieldSpecularMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldSpecularMapUV.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:specularMapUv', fieldSpecularMapUV);

        // map channel
        var fieldSpecularMapChannel = editor.call('attributes:addField', {
            panel: fieldSpecularMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A',
                'rgb': 'RGB'
            },
            link: assets,
            path: 'data.specularMapChannel'
        });
        fieldSpecularMapChannel.element.parentNode.removeChild(fieldSpecularMapChannel.element);
        fieldSpecularMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldSpecularMapChannel.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:specularMapChannel', fieldSpecularMapChannel);


        // offset
        var fieldSpecularOffset = editor.call('attributes:addField', {
            parent: panelSpecularWorkflow,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.specularMapOffset'
        });
        var filterSpecularOffset = function() {
            return (! fieldSpecularMap.value && ! fieldSpecularMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldSpecularOffset[0].parent,
            offset: fieldSpecularOffset,
            filter: filterSpecularOffset,
            path: 'data.specularMapOffset'
        });
        fieldSpecularOffset[0].parent.hidden = filterSpecularOffset();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:specularMapOffset', fieldSpecularOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldSpecularTiling = editor.call('attributes:addField', {
            parent: panelSpecularWorkflow,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.specularMapTiling'
        });
        var filterSpecularTiling = function() {
            return (! fieldSpecularMap.value && ! fieldSpecularMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldSpecularTiling[0].parent,
            tiling: fieldSpecularTiling,
            filter: filterSpecularTiling,
            path: 'data.specularMapTiling'
        });
        fieldSpecularTiling[0].parent.hidden = filterSpecularTiling();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:specularMapTiling', fieldSpecularTiling[0].parent.innerElement.firstChild.ui);

        // vertex color
        var fieldSpecularVertexColor = editor.call('attributes:addField', {
            parent: panelSpecularWorkflow,
            name: 'Vertex Color',
            type: 'checkbox',
            link: assets,
            path: 'data.specularMapVertexColor'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:specularMapVertexColor', fieldSpecularVertexColor.parent.innerElement.firstChild.ui);

        // color
        var fieldSpecularColor = editor.call('attributes:addField', {
            parent: panelSpecularWorkflow,
            name: 'Color',
            type: 'rgb',
            link: assets,
            path: 'data.specular'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:specular', fieldSpecularColor.parent.innerElement.firstChild.ui);

        // tint
        var fieldSpecularTint = editor.call('attributes:addField', {
            panel: fieldSpecularColor.parent,
            type: 'checkbox',
            link: assets,
            path: 'data.specularMapTint'
        });
        // label
        var labelSpecularTint = new ui.Label({ text: 'Tint' });
        labelSpecularTint.style.verticalAlign = 'top';
        labelSpecularTint.style.paddingRight = '12px';
        labelSpecularTint.style.fontSize = '12px';
        labelSpecularTint.style.lineHeight = '24px';
        fieldSpecularColor.parent.append(labelSpecularTint);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:specularMapTint', labelSpecularTint);


        // divider
        var divider = document.createElement('div');
        divider.classList.add('fields-divider');
        panelSpecular.append(divider);


        // map (gloss)
        var fieldGlossMapHover = handleTextureHover('glossMap');
        var fieldGlossMap = textureFields.gloss = editor.call('attributes:addField', {
            parent: panelSpecular,
            type: 'asset',
            kind: 'texture',
            name: 'Glossiness',
            link: assets,
            path: 'data.glossMap',
            over: fieldGlossMapHover.over,
            leave: fieldGlossMapHover.leave,
            onSet: function(asset, oldValues) {
                onTextureBulkSet(asset, oldValues, 'gloss');
            }
        });
        fieldGlossMap.parent.class.add('channel');
        fieldGlossMap.on('change', function(value) {
            fieldGlossOffset[0].parent.hidden = filterGlossOffset();
            fieldGlossTiling[0].parent.hidden = filterGlossTiling();
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:glossMap', fieldGlossMap._label);

        // map uv
        var fieldGlossMapUV = editor.call('attributes:addField', {
            panel: fieldGlossMap.parent,
            type: 'number',
            enum: mapping.glossMapUv.enum,
            link: assets,
            path: 'data.glossMapUv'
        });
        fieldGlossMapUV.flexGrow = 0;
        fieldGlossMapUV.element.parentNode.removeChild(fieldGlossMapUV.element);
        fieldGlossMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldGlossMapUV.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:glossMapUv', fieldGlossMapUV);

        // map channel
        var fieldGlossMapChannel = editor.call('attributes:addField', {
            panel: fieldGlossMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A'
            },
            link: assets,
            path: 'data.glossMapChannel'
        });
        fieldGlossMapChannel.element.parentNode.removeChild(fieldGlossMapChannel.element);
        fieldGlossMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldGlossMapChannel.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:glossMapChannel', fieldGlossMapChannel);


        // offset
        var fieldGlossOffset = editor.call('attributes:addField', {
            parent: panelSpecular,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.glossMapOffset'
        });
        var filterGlossOffset = function() {
            return (! fieldGlossMap.value && ! fieldGlossMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldGlossOffset[0].parent,
            offset: fieldGlossOffset,
            filter: filterGlossOffset,
            path: 'data.glossMapOffset'
        });
        fieldGlossOffset[0].parent.hidden = filterGlossOffset();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:glossMapOffset', fieldGlossOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldGlossTiling = editor.call('attributes:addField', {
            parent: panelSpecular,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.glossMapTiling'
        });
        var filterGlossTiling = function() {
            return (! fieldGlossMap.value && ! fieldGlossMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldGlossTiling[0].parent,
            tiling: fieldGlossTiling,
            filter: filterGlossTiling,
            path: 'data.glossMapTiling'
        });
        fieldGlossTiling[0].parent.hidden = filterGlossTiling();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:glossMapTiling', fieldGlossTiling[0].parent.innerElement.firstChild.ui);

        // vertex color
        var fieldGlossVertexColor = editor.call('attributes:addField', {
            parent: panelSpecular,
            name: 'Vertex Color',
            type: 'checkbox',
            link: assets,
            path: 'data.glossMapVertexColor'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:glossMapVertexColor', fieldGlossVertexColor.parent.innerElement.firstChild.ui);

        // shininess
        var fieldShininess = editor.call('attributes:addField', {
            parent: panelSpecular,
            type: 'number',
            precision: 2,
            step: 0.5,
            min: 0,
            max: 100,
            name: 'Glossiness',
            link: assets,
            path: 'data.shininess'
        });
        fieldShininess.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'asset:material:shininess', fieldShininess.parent.innerElement.firstChild.ui);

        // shininess slider
        var fieldShininessSlider = editor.call('attributes:addField', {
            panel: fieldShininess.parent,
            precision: 2,
            step: 0.5,
            min: 0,
            max: 100,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.shininess'
        });
        fieldShininessSlider.flexGrow = 4;


        // emissive
        var panelEmissive = texturePanels.emissive = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['emissive'],
            name: 'Emissive'
        });
        panelEmissive.class.add('component');
        panelEmissive.on('fold', function() { panelState['emissive'] = true; });
        panelEmissive.on('unfold', function() { panelState['emissive'] = false; });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:emissiveOverview', panelEmissive, panelEmissive.headerElement);

        // map
        var fieldEmissiveMapHover = handleTextureHover('emissiveMap');
        var fieldEmissiveMap = textureFields.emissive = editor.call('attributes:addField', {
            parent: panelEmissive,
            type: 'asset',
            kind: 'texture',
            name: 'Emissive',
            link: assets,
            path: 'data.emissiveMap',
            over: fieldEmissiveMapHover.over,
            leave: fieldEmissiveMapHover.leave,
            onSet: function(asset, oldValues) {
                onTextureBulkSet(asset, oldValues, 'emissive');
            }
        });
        fieldEmissiveMap.parent.class.add('channel');
        fieldEmissiveMap.on('change', function(value) {
            fieldEmissiveOffset[0].parent.hidden = filterEmissiveOffset();
            fieldEmissiveTiling[0].parent.hidden = filterEmissiveTiling();
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:emissiveMap', fieldEmissiveMap._label);

        // map uv
        var fieldEmissiveMapUV = editor.call('attributes:addField', {
            panel: fieldEmissiveMap.parent,
            type: 'number',
            enum: mapping.emissiveMapUv.enum,
            link: assets,
            path: 'data.emissiveMapUv'
        });
        fieldEmissiveMapUV.flexGrow = 0;
        fieldEmissiveMapUV.element.parentNode.removeChild(fieldEmissiveMapUV.element);
        fieldEmissiveMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldEmissiveMapUV.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:emissiveMapUv', fieldEmissiveMapUV);

        // map channel
        var fieldEmissiveMapChannel = editor.call('attributes:addField', {
            panel: fieldEmissiveMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A',
                'rgb': 'RGB'
            },
            link: assets,
            path: 'data.emissiveMapChannel'
        });
        fieldEmissiveMapChannel.element.parentNode.removeChild(fieldEmissiveMapChannel.element);
        fieldEmissiveMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldEmissiveMapChannel.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:emissiveMapChannel', fieldEmissiveMapChannel);


        // offset
        var fieldEmissiveOffset = editor.call('attributes:addField', {
            parent: panelEmissive,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.emissiveMapOffset'
        });
        var filterEmissiveOffset = function() {
            return (! fieldEmissiveMap.value && ! fieldEmissiveMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldEmissiveOffset[0].parent,
            offset: fieldEmissiveOffset,
            filter: filterEmissiveOffset,
            path: 'data.emissiveMapOffset'
        });
        fieldEmissiveOffset[0].parent.hidden = filterEmissiveOffset();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:emissiveMapOffset', fieldEmissiveOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldEmissiveTiling = editor.call('attributes:addField', {
            parent: panelEmissive,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.emissiveMapTiling'
        });
        var filterEmissiveTiling = function() {
            return (! fieldEmissiveMap.value && ! fieldEmissiveMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldEmissiveTiling[0].parent,
            tiling: fieldEmissiveTiling,
            filter: filterEmissiveTiling,
            path: 'data.emissiveMapTiling'
        });
        fieldEmissiveTiling[0].parent.hidden = filterEmissiveTiling();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:emissiveMapTiling', fieldEmissiveTiling[0].parent.innerElement.firstChild.ui);

        // vertex color
        var fieldEmissiveVertexColor = editor.call('attributes:addField', {
            parent: panelEmissive,
            name: 'Vertex Color',
            type: 'checkbox',
            link: assets,
            path: 'data.emissiveMapVertexColor'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:emissiveMapVertexColor', fieldEmissiveVertexColor.parent.innerElement.firstChild.ui);

        // color
        var fieldEmissiveColor = editor.call('attributes:addField', {
            parent: panelEmissive,
            name: 'Color',
            type: 'rgb',
            link: assets,
            path: 'data.emissive'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:emissive', fieldEmissiveColor.parent.innerElement.firstChild.ui);

        // tint
        var fieldEmissiveTint = editor.call('attributes:addField', {
            panel: fieldEmissiveColor.parent,
            type: 'checkbox',
            link: assets,
            path: 'data.emissiveMapTint'
        });
        // label
        var labelEmissiveTint = new ui.Label({ text: 'Tint' });
        labelEmissiveTint.style.verticalAlign = 'top';
        labelEmissiveTint.style.paddingRight = '12px';
        labelEmissiveTint.style.fontSize = '12px';
        labelEmissiveTint.style.lineHeight = '24px';
        fieldEmissiveColor.parent.append(labelEmissiveTint);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:emissiveMapTint', labelEmissiveTint);



        // emissiveIntensity
        var fieldEmissiveIntensity = editor.call('attributes:addField', {
            parent: panelEmissive,
            name: 'Intensity',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            link: assets,
            path: 'data.emissiveIntensity'
        });
        fieldEmissiveIntensity.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'asset:material:emissiveIntensity', fieldEmissiveIntensity.parent.innerElement.firstChild.ui);

        // emissiveIntensity slider
        var fieldEmissiveIntensitySlider = editor.call('attributes:addField', {
            panel: fieldEmissiveIntensity.parent,
            precision: 2,
            step: .1,
            min: 0,
            max: 10,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.emissiveIntensity'
        });
        fieldEmissiveIntensitySlider.flexGrow = 4;


        // opacity
        var panelOpacity = texturePanels.opacity = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['opacity'],
            name: 'Opacity'
        });
        panelOpacity.class.add('component');
        panelOpacity.on('fold', function() { panelState['opacity'] = true; });
        panelOpacity.on('unfold', function() { panelState['opacity'] = false; });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:opacityOverview', panelOpacity, panelOpacity.headerElement);

        var filterBlendFields = function (value) {
            fieldOpacityIntensity.parent.hidden = ! (fieldBlendType.value === '' || [ 2, 4, 6 ].indexOf(fieldBlendType.value) !== -1);
            fieldOpacityOffset[0].parent.hidden = filterOpacityOffset();
            fieldOpacityTiling[0].parent.hidden = filterOpacityTiling();
            fieldAlphaTest.parent.hidden = ! (fieldOpacityMap.class.contains('null') || fieldOpacityMap.value) && ! (fieldOpacityVertexColor.value || fieldOpacityVertexColor.class.contains('null'));
        };

        // blend type
        var fieldBlendType = editor.call('attributes:addField', {
            parent: panelOpacity,
            type: 'number',
            enum: mapping.blendType.enum,
            name: 'Blend Type',
            link: assets,
            path: 'data.blendType'
        });
        fieldBlendType.on('change', filterBlendFields);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:blendType', fieldBlendType.parent.innerElement.firstChild.ui);

        // map
        var fieldOpacityMapHover = handleTextureHover('opacityMap');
        var fieldOpacityMap = textureFields.opacity = editor.call('attributes:addField', {
            parent: panelOpacity,
            type: 'asset',
            kind: 'texture',
            name: 'Opacity',
            link: assets,
            path: 'data.opacityMap',
            over: fieldOpacityMapHover.over,
            leave: fieldOpacityMapHover.leave,
            onSet: function(asset, oldValues) {
                onTextureBulkSet(asset, oldValues, 'opacity');
            }
        });
        fieldOpacityMap.parent.class.add('channel');
        fieldOpacityMap.on('change', filterBlendFields);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:opacityMap', fieldOpacityMap._label);

        // map uv
        var fieldOpacityMapUV = editor.call('attributes:addField', {
            panel: fieldOpacityMap.parent,
            type: 'number',
            enum: mapping.opacityMapUv.enum,
            link: assets,
            path: 'data.opacityMapUv'
        });
        fieldOpacityMapUV.flexGrow = 0;
        fieldOpacityMapUV.element.parentNode.removeChild(fieldOpacityMapUV.element);
        fieldOpacityMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldOpacityMapUV.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:opacityMapUv', fieldOpacityMapUV);

        // map channel
        var fieldOpacityMapChannel = editor.call('attributes:addField', {
            panel: fieldOpacityMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A'
            },
            link: assets,
            path: 'data.opacityMapChannel'
        });
        fieldOpacityMapChannel.element.parentNode.removeChild(fieldOpacityMapChannel.element);
        fieldOpacityMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldOpacityMapChannel.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:opacityMapChannel', fieldOpacityMapChannel);

        // offset
        var fieldOpacityOffset = editor.call('attributes:addField', {
            parent: panelOpacity,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.opacityMapOffset'
        });
        var filterOpacityOffset = function() {
            return fieldOpacityMap.parent.hidden || (! fieldOpacityMap.value && ! fieldOpacityMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldOpacityOffset[0].parent,
            offset: fieldOpacityOffset,
            filter: filterOpacityOffset,
            path: 'data.opacityMapOffset'
        });
        fieldOpacityOffset[0].parent.hidden = filterOpacityOffset();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:opacityMapOffset', fieldOpacityOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldOpacityTiling = editor.call('attributes:addField', {
            parent: panelOpacity,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.opacityMapTiling'
        });
        var filterOpacityTiling = function() {
            return fieldOpacityMap.parent.hidden || (! fieldOpacityMap.value && ! fieldOpacityMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldOpacityTiling[0].parent,
            tiling: fieldOpacityTiling,
            filter: filterOpacityTiling,
            path: 'data.opacityMapTiling'
        });
        fieldOpacityTiling[0].parent.hidden = filterOpacityTiling();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:opacityMapTiling', fieldOpacityTiling[0].parent.innerElement.firstChild.ui);

        // vertex color
        var fieldOpacityVertexColor = editor.call('attributes:addField', {
            parent: panelOpacity,
            name: 'Vertex Color',
            type: 'checkbox',
            link: assets,
            path: 'data.opacityMapVertexColor'
        });
        fieldOpacityVertexColor.on('change', filterBlendFields);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:opacityMapVertexColor', fieldOpacityVertexColor.parent.innerElement.firstChild.ui);

        // intensity
        var fieldOpacityIntensity = editor.call('attributes:addField', {
            parent: panelOpacity,
            name: 'Intensity',
            type: 'number',
            precision: 3,
            step: .05,
            min: 0,
            max: 1,
            link: assets,
            path: 'data.opacity'
        });
        fieldOpacityIntensity.style.width = '32px';
        fieldOpacityIntensity.flexGrow = 1;
        // reference
        editor.call('attributes:reference:attach', 'asset:material:opacity', fieldOpacityIntensity.parent.innerElement.firstChild.ui);

        // intensity slider
        var fieldOpacityIntensitySlider = editor.call('attributes:addField', {
            panel: fieldOpacityIntensity.parent,
            precision: 3,
            step: .05,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.opacity'
        });
        fieldOpacityIntensitySlider.flexGrow = 4;

        // alphaTest
        var fieldAlphaTest = editor.call('attributes:addField', {
            parent: panelOpacity,
            name: 'Alpha Test',
            type: 'number',
            precision: 3,
            step: .05,
            min: 0,
            max: 1,
            link: assets,
            path: 'data.alphaTest'
        });
        fieldAlphaTest.style.width = '32px';
        fieldAlphaTest.flexGrow = 1;
        // reference
        editor.call('attributes:reference:attach', 'asset:material:alphaTest', fieldAlphaTest.parent.innerElement.firstChild.ui);

        // alphaTest slider
        var fieldAlphaTestSlider = editor.call('attributes:addField', {
            panel: fieldAlphaTest.parent,
            precision: 3,
            step: .05,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.alphaTest'
        });
        fieldAlphaTestSlider.flexGrow = 4;

        filterBlendFields();


        // alphaToCoverage
        var fieldAlphaToCoverage = editor.call('attributes:addField', {
            parent: panelOpacity,
            name: 'Alpha To Coverage',
            type: 'checkbox',
            link: assets,
            path: 'data.alphaToCoverage'
        });
        fieldAlphaToCoverage.element.previousSibling.style.width = 'auto';
        // reference
        editor.call('attributes:reference:attach', 'asset:material:alphaToCoverage', fieldAlphaToCoverage.parent.innerElement.firstChild.ui);


        // normals
        var panelNormal = texturePanels.normal = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['normals'],
            name: 'Normals'
        });
        panelNormal.class.add('component');
        panelNormal.on('fold', function() { panelState['normals'] = true; });
        panelNormal.on('unfold', function() { panelState['normals'] = false; });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:normalOverview', panelNormal, panelNormal.headerElement);

        // map (normals)
        var fieldNormalMapHover = handleTextureHover('normalMap');
        var fieldNormalMap = textureFields.normal = editor.call('attributes:addField', {
            parent: panelNormal,
            type: 'asset',
            kind: 'texture',
            name: 'Normals',
            link: assets,
            path: 'data.normalMap',
            over: fieldNormalMapHover.over,
            leave: fieldNormalMapHover.leave,
            onSet: function(asset, oldValues) {
                onTextureBulkSet(asset, oldValues, 'normal');
            }
        });
        fieldNormalMap.on('change', function(value) {
            fieldNormalsOffset[0].parent.hidden = filterNormalOffset();
            fieldNormalsTiling[0].parent.hidden = filterNormalTiling();
            fieldBumpiness.parent.hidden = ! value && ! this.class.contains('null');
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:normalMap', fieldNormalMap._label);

        // map uv
        var fieldNormalMapUV = editor.call('attributes:addField', {
            panel: fieldNormalMap.parent,
            type: 'number',
            enum: mapping.normalMapUv.enum,
            link: assets,
            path: 'data.normalMapUv'
        });
        fieldNormalMapUV.flexGrow = 0;
        fieldNormalMapUV.element.parentNode.removeChild(fieldNormalMapUV.element);
        fieldNormalMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldNormalMapUV.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:normalMapUv', fieldNormalMapUV);


        // offset
        var fieldNormalsOffset = editor.call('attributes:addField', {
            parent: panelNormal,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.normalMapOffset'
        });
        var filterNormalOffset = function() {
            return (! fieldNormalMap.value && ! fieldNormalMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldNormalsOffset[0].parent,
            offset: fieldNormalsOffset,
            filter: filterNormalOffset,
            path: 'data.normalMapOffset'
        });
        fieldNormalsOffset[0].parent.hidden = filterNormalOffset();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:normalMapOffset', fieldNormalsOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldNormalsTiling = editor.call('attributes:addField', {
            parent: panelNormal,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.normalMapTiling'
        });
        var filterNormalTiling = function() {
            return (! fieldNormalMap.value && ! fieldNormalMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldNormalsTiling[0].parent,
            tiling: fieldNormalsTiling,
            filter: filterNormalTiling,
            path: 'data.normalMapTiling'
        });
        fieldNormalsTiling[0].parent.hidden = filterNormalTiling();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:normalMapTiling', fieldNormalsTiling[0].parent.innerElement.firstChild.ui);


        // bumpiness
        var fieldBumpiness = editor.call('attributes:addField', {
            parent: panelNormal,
            name: 'Bumpiness',
            type: 'number',
            precision: 3,
            step: .05,
            min: 0,
            max: 2,
            link: assets,
            path: 'data.bumpMapFactor'
        });
        fieldBumpiness.parent.hidden = ! fieldNormalMap.value && ! fieldNormalMap.class.contains('null');
        fieldBumpiness.style.width = '32px';
        fieldBumpiness.flexGrow = 1;
        // reference
        editor.call('attributes:reference:attach', 'asset:material:bumpiness', fieldBumpiness.parent.innerElement.firstChild.ui);

        // bumpiness slider
        var fieldBumpinessSlider = editor.call('attributes:addField', {
            panel: fieldBumpiness.parent,
            precision: 3,
            step: .05,
            min: 0,
            max: 2,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.bumpMapFactor'
        });
        fieldBumpinessSlider.flexGrow = 4;


        // parallax
        var panelParallax = texturePanels.height = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['height'],
            name: 'Parallax'
        });
        panelParallax.class.add('component');
        panelParallax.on('fold', function() { panelState['height'] = true; });
        panelParallax.on('unfold', function() { panelState['height'] = false; });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:parallaxOverview', panelParallax, panelParallax.headerElement);

        // height map
        var fieldHeightMapHover = handleTextureHover('heightMap');
        var fieldHeightMap = textureFields.height = editor.call('attributes:addField', {
            parent: panelParallax,
            type: 'asset',
            kind: 'texture',
            name: 'Heightmap',
            link: assets,
            path: 'data.heightMap',
            over: fieldHeightMapHover.over,
            leave: fieldHeightMapHover.leave,
            onSet: function(asset, oldValues) {
                onTextureBulkSet(asset, oldValues, 'height');
            }
        });
        fieldHeightMap.parent.class.add('channel');
        fieldHeightMap.on('change', function(value) {
            fieldHeightMapOffset[0].parent.hidden = filterHeightMapOffset();
            fieldHeightMapTiling[0].parent.hidden = filterHeightMapTiling();
            fieldHeightMapFactor.parent.hidden = ! value;
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:heightMap', fieldHeightMap._label);

        // map uv
        var fieldHeightMapUV = editor.call('attributes:addField', {
            panel: fieldHeightMap.parent,
            type: 'number',
            enum: mapping.heightMapUv.enum,
            link: assets,
            path: 'data.heightMapUv'
        });
        fieldHeightMapUV.flexGrow = 0;
        fieldHeightMapUV.element.parentNode.removeChild(fieldHeightMapUV.element);
        fieldHeightMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldHeightMapUV.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:heightMapUv', fieldHeightMapUV);

        // map channel
        var fieldHeightMapChannel = editor.call('attributes:addField', {
            panel: fieldHeightMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A'
            },
            link: assets,
            path: 'data.heightMapChannel'
        });
        fieldHeightMapChannel.element.parentNode.removeChild(fieldHeightMapChannel.element);
        fieldHeightMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldHeightMapChannel.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:heightMapChannel', fieldHeightMapChannel);


        // offset
        var fieldHeightMapOffset = editor.call('attributes:addField', {
            parent: panelParallax,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.heightMapOffset'
        });
        var filterHeightMapOffset = function() {
            return fieldHeightMap.parent.hidden || (! fieldHeightMap.value && ! fieldHeightMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldHeightMapOffset[0].parent,
            offset: fieldHeightMapOffset,
            filter: filterHeightMapOffset,
            path: 'data.heightMapOffset'
        });
        fieldHeightMapOffset[0].parent.hidden = filterHeightMapOffset();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:heightMapOffset', fieldHeightMapOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldHeightMapTiling = editor.call('attributes:addField', {
            parent: panelParallax,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.heightMapTiling'
        });
        var filterHeightMapTiling = function() {
            return fieldHeightMap.parent.hidden || (! fieldHeightMap.value && ! fieldHeightMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldHeightMapTiling[0].parent,
            tiling: fieldHeightMapTiling,
            filter: filterHeightMapTiling,
            path: 'data.heightMapTiling'
        });
        fieldHeightMapTiling[0].parent.hidden = filterHeightMapTiling();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:heightMapTiling', fieldHeightMapTiling[0].parent.innerElement.firstChild.ui);


        // heightMapFactor
        var fieldHeightMapFactor = editor.call('attributes:addField', {
            parent: panelParallax,
            name: 'Strength',
            type: 'number',
            precision: 3,
            step: .05,
            min: 0,
            max: 2,
            link: assets,
            path: 'data.heightMapFactor'
        });
        fieldHeightMapFactor.parent.hidden = fieldHeightMap.parent.hidden;
        fieldHeightMapFactor.style.width = '32px';
        fieldHeightMapFactor.flexGrow = 1;
        // reference
        editor.call('attributes:reference:attach', 'asset:material:bumpiness', fieldHeightMapFactor.parent.innerElement.firstChild.ui);

        // heightMapFactor slider
        var fieldHeightMapFactorSlider = editor.call('attributes:addField', {
            panel: fieldHeightMapFactor.parent,
            precision: 3,
            step: .05,
            min: 0,
            max: 2,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.heightMapFactor'
        });
        fieldHeightMapFactorSlider.flexGrow = 4;


        // reflection
        var panelReflection = texturePanels.reflection = texturePanels.refraction = texturePanels.sphere = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['environment'],
            name: 'Environment'
        });
        panelReflection.class.add('component');
        panelReflection.on('fold', function() { panelState['environment'] = true; });
        panelReflection.on('unfold', function() { panelState['environment'] = false; });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:environmentOverview', panelReflection, panelReflection.headerElement);
        // filter
        var filterReflectionMaps = function() {
            fieldReflectionCubeMap.parent.hidden = ! fieldReflectionCubeMap.value && ! fieldReflectionCubeMap.class.contains('null') && (fieldReflectionSphere.value || fieldReflectionSphere.class.contains('null'));
            fieldReflectionSphere.parent.hidden = ! fieldReflectionSphere.value && ! fieldReflectionSphere.class.contains('null') && (fieldReflectionCubeMap.value || fieldReflectionCubeMap.class.contains('null'));
        };
        // spheremap
        var fieldReflectionSphereHover = handleTextureHover('sphereMap');
        var fieldReflectionSphere = textureFields.sphere = editor.call('attributes:addField', {
            parent: panelReflection,
            type: 'asset',
            kind: 'texture',
            name: 'Sphere Map',
            link: assets,
            path: 'data.sphereMap',
            over: fieldReflectionSphereHover.over,
            leave: fieldReflectionSphereHover.leave
        });
        fieldReflectionSphere.on('change', filterReflectionMaps);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:sphereMap', fieldReflectionSphere._label);

        // cubemap
        var fieldReflectionCubeMap = editor.call('attributes:addField', {
            parent: panelReflection,
            type: 'asset',
            kind: 'cubemap',
            name: 'Cube Map',
            link: assets,
            path: 'data.cubeMap'
        });
        fieldReflectionCubeMap.on('change', filterReflectionMaps);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:cubeMap', fieldReflectionCubeMap._label);

        // reflectivity
        var fieldReflectionStrength = editor.call('attributes:addField', {
            parent: panelReflection,
            type: 'number',
            precision: 3,
            step: 0.01,
            min: 0,
            name: 'Reflectivity',
            link: assets,
            path: 'data.reflectivity'
        });
        fieldReflectionStrength.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'asset:material:reflectivity', fieldReflectionStrength.parent.innerElement.firstChild.ui);

        // reflectivity slider
        var fieldReflectionStrengthSlider = editor.call('attributes:addField', {
            panel: fieldReflectionStrength.parent,
            precision: 3,
            step: .01,
            min: 0,
            max: 8,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.reflectivity'
        });
        fieldReflectionStrengthSlider.flexGrow = 4;


        // refraction
        var fieldRefraction = editor.call('attributes:addField', {
            parent: panelReflection,
            type: 'number',
            precision: 3,
            step: 0.01,
            min: 0,
            max: 1,
            name: 'Refraction',
            link: assets,
            path: 'data.refraction'
        });
        fieldRefraction.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'asset:material:refraction', fieldRefraction.parent.innerElement.firstChild.ui);

        // reflectivity slider
        var fieldRefractionSlider = editor.call('attributes:addField', {
            panel: fieldRefraction.parent,
            precision: 3,
            step: .01,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.refraction'
        });
        fieldRefractionSlider.flexGrow = 4;


        // refractionIndex
        var fieldRefractionIndex = editor.call('attributes:addField', {
            parent: panelReflection,
            type: 'number',
            precision: 3,
            step: 0.01,
            min: 0,
            max: 1,
            name: 'Index of Refraction',
            link: assets,
            path: 'data.refractionIndex'
        });
        fieldRefractionIndex.style.width = '32px';
        // reference
        editor.call('attributes:reference:attach', 'asset:material:refractionIndex', fieldRefractionIndex.parent.innerElement.firstChild.ui);

        // reflectivity slider
        var fieldRefractionIndexSlider = editor.call('attributes:addField', {
            panel: fieldRefractionIndex.parent,
            precision: 3,
            step: .01,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.refractionIndex'
        });
        fieldRefractionIndexSlider.flexGrow = 4;


        // divider
        var divider = document.createElement('div');
        divider.classList.add('fields-divider');
        panelReflection.append(divider);


        // cubemap projection
        var fieldReflectionCubeMapProjection = editor.call('attributes:addField', {
            parent: panelReflection,
            name: 'Projection',
            type: 'number',
            enum: mapping.cubeMapProjection.enum,
            link: assets,
            path: 'data.cubeMapProjection'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:cubeMapProjection', fieldReflectionCubeMapProjection.parent.innerElement.firstChild.ui);

        // cubemap projection center
        var fieldReflectionCubeMapProjectionBoxCenter = editor.call('attributes:addField', {
            parent: panelReflection,
            placeholder: [ 'x', 'y', 'z' ],
            name: 'Center',
            type: 'vec3',
            link: assets,
            path: 'data.cubeMapProjectionBox.center'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:cubeMapProjectionBoxCenter', fieldReflectionCubeMapProjectionBoxCenter[0].parent.innerElement.firstChild.ui);

        // cubemap projection halfExtents
        var fieldReflectionCubeMapProjectionBoxHalfExtents = editor.call('attributes:addField', {
            parent: panelReflection,
            placeholder: [ 'w', 'h', 'd' ],
            name: 'Half Extents',
            type: 'vec3',
            link: assets,
            path: 'data.cubeMapProjectionBox.halfExtents'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:cubeMapProjectionBoxHalfExtents', fieldReflectionCubeMapProjectionBoxHalfExtents[0].parent.innerElement.firstChild.ui);


        var onCubemapProjectionCheck = function() {
            fieldReflectionCubeMapProjection.parent.hidden = ! fieldReflectionCubeMap.value;
            fieldReflectionCubeMapProjectionBoxCenter[0].parent.hidden = fieldReflectionCubeMapProjection.parent.hidden || fieldReflectionCubeMapProjection.value === 0 || fieldReflectionCubeMapProjection.class.contains('null');
            fieldReflectionCubeMapProjectionBoxHalfExtents[0].parent.hidden = fieldReflectionCubeMapProjectionBoxCenter[0].parent.hidden;
        };
        onCubemapProjectionCheck();
        fieldReflectionCubeMapProjection.on('change', onCubemapProjectionCheck);
        fieldReflectionCubeMap.on('change', onCubemapProjectionCheck);

        filterReflectionMaps();


        // lightmap
        var panelLightMap = texturePanels.light = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['light'],
            name: 'LightMap'
        });
        panelLightMap.class.add('component');
        panelLightMap.on('fold', function() { panelState['light'] = true; });
        panelLightMap.on('unfold', function() { panelState['light'] = false; });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:lightMapOverview', panelLightMap, panelLightMap.headerElement);

        // map
        var fieldLightMapHover = handleTextureHover('lightMap');
        var fieldLightMap = textureFields.light = editor.call('attributes:addField', {
            parent: panelLightMap,
            type: 'asset',
            kind: 'texture',
            name: 'Lightmap',
            link: assets,
            path: 'data.lightMap',
            over: fieldLightMapHover.over,
            leave: fieldLightMapHover.leave,
            onSet: function(asset, oldValues) {
                onTextureBulkSet(asset, oldValues, 'light');
            }
        });
        fieldLightMap.parent.class.add('channel');
        fieldLightMap.on('change', function (value) {
            fieldLightMapOffset[0].parent.hidden = filterLightMapOffset();
            fieldLightMapTiling[0].parent.hidden = filterLightMapTiling();
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:lightMap', fieldLightMap._label);

        // map uv
        var fieldLightMapUV = editor.call('attributes:addField', {
            panel: fieldLightMap.parent,
            type: 'number',
            enum: mapping.lightMapUv.enum,
            link: assets,
            path: 'data.lightMapUv'
        });
        fieldLightMapUV.flexGrow = 0;
        fieldLightMapUV.element.parentNode.removeChild(fieldLightMapUV.element);
        fieldLightMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldLightMapUV.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:lightMapUv', fieldLightMapUV);

        // map channel
        var fieldLightMapChannel = editor.call('attributes:addField', {
            panel: fieldLightMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A',
                'rgb': 'RGB'
            },
            link: assets,
            path: 'data.lightMapChannel'
        });
        fieldLightMapChannel.element.parentNode.removeChild(fieldLightMapChannel.element);
        fieldLightMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldLightMapChannel.element);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:lightMapChannel', fieldLightMapChannel);


        // offset
        var fieldLightMapOffset = editor.call('attributes:addField', {
            parent: panelLightMap,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.lightMapOffset'
        });
        var filterLightMapOffset = function() {
            return fieldLightMap.parent.hidden || (! fieldLightMap.value && ! fieldLightMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldLightMapOffset[0].parent,
            offset: fieldLightMapOffset,
            filter: filterLightMapOffset,
            path: 'data.lightMapOffset'
        });
        fieldLightMapOffset[0].parent.hidden = filterLightMapOffset();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:lightMapOffset', fieldLightMapOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldLightMapTiling = editor.call('attributes:addField', {
            parent: panelLightMap,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.lightMapTiling'
        });
        var filterLightMapTiling = function() {
            return fieldLightMap.parent.hidden || (! fieldLightMap.value && ! fieldLightMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldLightMapTiling[0].parent,
            tiling: fieldLightMapTiling,
            filter: filterLightMapTiling,
            path: 'data.lightMapTiling'
        });
        fieldLightMapTiling[0].parent.hidden = filterLightMapTiling();
        // reference
        editor.call('attributes:reference:attach', 'asset:material:lightMapTiling', fieldLightMapTiling[0].parent.innerElement.firstChild.ui);

        // vertex color
        var fieldLightVertexColor = editor.call('attributes:addField', {
            parent: panelLightMap,
            name: 'Vertex Color',
            type: 'checkbox',
            link: assets,
            path: 'data.lightMapVertexColor'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:lightMapVertexColor', fieldLightVertexColor.parent.innerElement.firstChild.ui);

        // render states
        var panelRenderStates = texturePanels.states = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['states'],
            name: 'Other'
        });
        panelRenderStates.class.add('component');
        panelRenderStates.on('fold', function() { panelState['states'] = true; });
        panelRenderStates.on('unfold', function() { panelState['states'] = false; });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:other', panelRenderStates, panelRenderStates.headerElement);


        // depth
        var fieldDepthTest = editor.call('attributes:addField', {
            parent: panelRenderStates,
            type: 'checkbox',
            name: 'Depth',
            link: assets,
            path: 'data.depthTest'
        });
        // label
        var label = new ui.Label({ text: 'Test' });
        label.style.verticalAlign = 'top';
        label.style.paddingRight = '12px';
        label.style.fontSize = '12px';
        label.style.lineHeight = '24px';
        fieldDepthTest.parent.append(label);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:depthTest', label);


        // depthWrite
        var fieldDepthWrite = editor.call('attributes:addField', {
            panel: fieldDepthTest.parent,
            type: 'checkbox',
            link: assets,
            path: 'data.depthWrite'
        })
        // label
        var label = new ui.Label({ text: 'Write' });
        label.style.verticalAlign = 'top';
        label.style.fontSize = '12px';
        label.style.lineHeight = '24px';
        fieldDepthTest.parent.append(label);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:depthWrite', label);


        // culling
        var fieldCull = editor.call('attributes:addField', {
            parent: panelRenderStates,
            type: 'number',
            enum: mapping.cull.enum,
            name: 'Cull Mode',
            link: assets,
            path: 'data.cull'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:material:cull', fieldCull.parent.innerElement.firstChild.ui);


        // useFog
        var fieldUseFog = editor.call('attributes:addField', {
            parent: panelRenderStates,
            type: 'checkbox',
            name: 'Use',
            link: assets,
            path: 'data.useFog'
        });
        // label
        var label = new ui.Label({ text: 'Fog' });
        label.style.verticalAlign = 'top';
        label.style.paddingRight = '12px';
        label.style.fontSize = '12px';
        label.style.lineHeight = '24px';
        fieldUseFog.parent.append(label);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:useFog', fieldUseFog.parent.innerElement.firstChild.ui);

        // useLighting
        var fieldUseLighting = editor.call('attributes:addField', {
            panel: fieldUseFog.parent,
            type: 'checkbox',
            link: assets,
            path: 'data.useLighting'
        });
        // label
        var label = new ui.Label({ text: 'Lighting' });
        label.style.verticalAlign = 'top';
        label.style.fontSize = '12px';
        label.style.lineHeight = '24px';
        fieldUseLighting.parent.append(label);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:useLighting', fieldUseLighting.parent.innerElement.firstChild.ui);


        // useSkybox
        var fieldUseLighting = editor.call('attributes:addField', {
            parent: panelRenderStates,
            type: 'checkbox',
            name: ' ',
            link: assets,
            path: 'data.useSkybox'
        });
        // label
        var label = new ui.Label({ text: 'Skybox' });
        label.style.verticalAlign = 'top';
        label.style.paddingRight = '12px';
        label.style.fontSize = '12px';
        label.style.lineHeight = '24px';
        fieldUseLighting.parent.append(label);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:useSkybox', fieldUseLighting.parent.innerElement.firstChild.ui);

        // useGammaTonemap
        var fieldUseGammaTonemap = editor.call('attributes:addField', {
            panel: fieldUseLighting.parent,
            type: 'checkbox',
            link: assets,
            path: 'data.useGammaTonemap'
        });
        // label
        var label = new ui.Label({ text: 'Gamma & Tonemap' });
        label.style.verticalAlign = 'top';
        label.style.fontSize = '12px';
        label.style.lineHeight = '24px';
        fieldUseGammaTonemap.parent.append(label);
        // reference
        editor.call('attributes:reference:attach', 'asset:material:useGammaTonemap', fieldUseGammaTonemap.parent.innerElement.firstChild.ui);


        // attach change event on tiling / offset fields
        // to set initial value if it doesn't exist
        tilingOffsetFields.forEach(function (item) {
            var field = item.tiling || item.offset;
            var onChange = function () {
                var path = item.path;
                for (var i = 0, len = assets.length; i < len; i++) {
                    if (missingPaths[assets[i].get('id') + '.' + path]) {
                        assets[i].set(path, [field[0].value, field[1].value]);
                        delete missingPaths[assets[i].get('id') + '.' + path];
                    }
                }
            }

            // make sure our change event is first otherwise
            // sharejs will complain that we can't insert a value on
            // a list that does not exist
            field[0]._events.change.splice(0, 0, onChange);
            field[1]._events.change.splice(0, 0, onChange);
        });
    });
});


/* editor/attributes/assets/attributes-asset-model.js */
editor.once('load', function() {
    'use strict';

    var pickMaterial = function(assetId, fn) {
        var asset = editor.call('assets:get', assetId);
        editor.call('picker:asset', 'material', asset);

        var evtPick = editor.once('picker:asset', function(asset) {
            fn(asset.get('id'));
            evtPick = null;
        });

        editor.once('picker:asset:close', function() {
            if (evtPick) {
                evtPick.unbind();
                evtPick = null;
            }
        });
    };

    var panelNodes = null;

    editor.method('attributes:asset:model:nodesPanel', function () {
        return panelNodes;
    });

    var panelToggles = {
        'meta': true,
        'pipeline': true,
        'nodes': false
    };

    editor.on('attributes:inspect[asset]', function(assets) {
        for(var i = 0; i < assets.length; i++) {
            if (assets[i].get('type') !== 'model' || assets[i].get('source'))
                return;
        }

        if (assets.length > 1)
            editor.call('attributes:header', assets.length + ' Models');

        var events = [ ];

        var nodesTemplate;
        if (assets.length === 1 && assets[0]._loading && assets[0]._hash !== assets[0].get('file.hash')) {
            assets[0]._loading = 0;
            // assets[0]._uv1 = false;
            assets[0]._nodes = null;
        }

        // load data
        var loadingData = false;
        var loadData = function() {
            if (assets.length !== 1 || assets[0]._loading)
                return;

            assets[0]._hash = assets[0].get('file.hash');
            assets[0]._loading = 1;
            // assets[0]._uv1 = false;
            assets[0]._nodes = null;
            loading.hidden = false;

            Ajax
                .get('{{url.home}}' + assets[0].get('file.url'))
                .on('load', function(status, data) {
                    assets[0]._loading = 2;

                    autoUnwrap.enabled = true;

                    assets[0]._nodes = [ ];
                    for(var i = 0; i < data.model.meshInstances.length; i++)
                        assets[0]._nodes[i] = data.model.nodes[data.model.meshInstances[i].node].name;

                    if (nodesTemplate)
                        nodesTemplate();

                    loading.progress = 1;
                })
                .on('progress', function(progress) {
                    loading.progress = 0.1 + progress * 0.8;
                })
                .on('error', function() {
                    loading.failed = true;

                    var error = new ui.Label({ text: 'failed loading detailed data' });
                    error.textContent = 'failed loading data';
                    error.style.display = 'block';
                    error.style.textAlign = 'center';
                    error.style.fontWeight = '100';
                    error.style.fontSize = '12px';
                    error.style.color = '#f66';
                    editor.call('attributes.rootPanel').append(error);

                    loading.progress = 1;
                });

            loading.progress = 0.1;
        };

        // loading
        var loading
        if (assets.length === 1) {
            loading = editor.call('attributes:addField', {
                type: 'progress'
            });
            loading.on('progress:100', function() {
                this.hidden = true;
            });
            if (assets[0]._loading)
                loading.hidden = true;

            if (assets[0].has('file.url') && ! assets[0]._loading)
                loadData();

            events.push(assets[0].on('file.hash:set', function(value) {
                assets[0]._loading = 0;
                loadData();
            }));
        }


        var panelMeta = editor.call('attributes:addPanel', {
            name: 'Meta'
        });
        panelMeta.class.add('component');
        panelMeta.foldable = true;
        panelMeta.folded = panelToggles['meta'];
        panelMeta.on('fold', function() {
            panelToggles['meta'] = true;
        });
        panelMeta.on('unfold', function() {
            panelToggles['meta'] = false;
        });

        var btnGetMeta = new ui.Button({
            text: 'Calculate Meta'
        });
        btnGetMeta.class.add('calculate-meta', 'large-with-icon');
        var btnGetMetaVisibility = function() {
            var visible = false;
            for(var i = 0; i < assets.length; i++) {
                if (! visible && (! assets[i].get('meta') || ! assets[i].has('meta.vertices')))
                    visible = true;
            }
            btnGetMeta.hidden = ! visible;
        };
        btnGetMeta.on('click', function() {
            if (! editor.call('permissions:write'))
                return;

            for(var i = 0; i < assets.length; i++) {
                if (assets[i].get('meta') && assets[i].has('meta.vertices'))
                    continue;

                editor.call('realtime:send', 'pipeline', {
                    name: 'meta',
                    id: assets[i].get('id')
                });
            }
            this.enabled = false;
        });
        panelMeta.append(btnGetMeta);

        btnGetMetaVisibility();
        for(var i = 0; i < assets.length; i++) {
            if (btnGetMeta.hidden && ! assets[i].get('meta'))
                btnGetMeta.hidden = false;

            events.push(assets[i].on('meta:set', function() {
                btnGetMetaVisibility();
            }));
            events.push(assets[i].on('meta:unset', function() {
                btnGetMeta.hidden = false;
            }));
        }

        var recalculateMeta = function(key) {
            var value = 0;
            var noValue = true;
            for(var i = 0; i < assets.length; i++) {
                if (! assets[i].has('meta.' + key))
                    continue;
                value += assets[i].get('meta.' + key);
                noValue = false;
            }
            if (noValue)
                metaFields[key].field.parent.hidden = true;
            else
                metaFields[key].field.parent.hidden = false;
            metaFields[key].field.value = noValue ? '' : value.toLocaleString();
        };

        var metaFields = {
            vertices: {
                title: 'Vertices',
            },
            triangles: {
                title: 'Triangles',
            },
            meshes: {
                title: 'Meshes',
            },
            meshInstances: {
                title: 'Mesh Instances',
            },
            nodes: {
                title: 'Nodes',
            },
            skins: {
                title: 'Skins',
            }
        };

        var keys = Object.keys(metaFields);

        var addMetaField = function(key) {
            metaFields[key].field = editor.call('attributes:addField', {
                parent: panelMeta,
                name: metaFields[key].title
            });
            recalculateMeta(key);

            for(var a = 0; a < assets.length; a++) {
                events.push(assets[a].on('meta:unset', function() {
                    recalculateMeta(key);
                }));
                events.push(assets[a].on('meta:set', function() {
                    recalculateMeta(key);
                }));
                events.push(assets[a].on('meta.' + key + ':set', function() {
                    recalculateMeta(key);
                }));
                events.push(assets[a].on('meta.' + key + ':unset', function() {
                    recalculateMeta(key);
                }));
            }
        };

        for(var i = 0; i < keys.length; i++) {
            if (! metaFields.hasOwnProperty(keys[i]))
                continue;

            addMetaField(keys[i]);
        }

        var calculateAttributes = function() {
            var attributes = { };
            for(var i = 0; i < assets.length; i++) {
                var attr = assets[i].get('meta.attributes');
                if (! attr)
                    continue;

                var keys = Object.keys(attr);
                for(var n = 0; n < keys.length; n++) {
                    if (! attr.hasOwnProperty(keys[n]))
                        continue;

                    attributes[keys[n]] = attributes[keys[n]] || 0;
                    attributes[keys[n]]++;
                }
            }

            var attributesValue = '';
            var keys = Object.keys(attributes);
            for(var i = 0; i < keys.length; i++) {
                if (! attributes.hasOwnProperty(keys[i]))
                    continue;

                if (attributesValue)
                    attributesValue += ', ';

                attributesValue += keys[i];

                if (attributes[keys[i]] !== assets.length)
                    attributesValue += '*';
            }

            fieldMetaAttributes.value = attributesValue;
            fieldMetaAttributes.parent.hidden = !attributesValue;
        };


        var fieldMetaAttributes = editor.call('attributes:addField', {
            parent: panelMeta,
            name: 'Attributes'
        });
        calculateAttributes();
        for(var i = 0; i < assets.length; i++)
            events.push(assets[i].on('meta:set', calculateAttributes));


        var panelPipeline = editor.call('attributes:addPanel', {
            name: 'Pipeline'
        });
        panelPipeline.class.add('component');
        panelPipeline.foldable = true;
        panelPipeline.folded = panelToggles['pipeline'];
        panelPipeline.on('fold', function() {
            panelToggles['pipeline'] = true;
        });
        panelPipeline.on('unfold', function() {
            panelToggles['pipeline'] = false;
        });


        var uv1Options = [ 'unavailable', 'available', 'various' ];
        var checkUV1 = function() {
            var uv1 = assets[0].has('meta.attributes.texCoord1') ? 1 : 0;
            for(var i = 1; i < assets.length; i++) {
                var t1 = assets[i].get('meta.attributes.texCoord1');

                if ((t1 ? 1 : 0) !== uv1) {
                    uv1 = 2;
                    break;
                }
            }
            fieldUV1.value = uv1Options[uv1];
        }

        var fieldUV1 = editor.call('attributes:addField', {
            parent: panelPipeline,
            name: 'UV1'
        });
        checkUV1();

        for(var i = 0; i < assets.length; i++) {
            events.push(assets[i].on('meta.attributes.texCoord1:set', checkUV1));
            events.push(assets[i].on('meta.attributes.texCoord1:unset', checkUV1));
        }

        // padding
        var fieldPadding = editor.call('attributes:addField', {
            parent: panelPipeline,
            name: 'Padding',
            type: 'number',
            value: 2.0,
            precision: 2
        });
        fieldPadding.style.width = '32px';

        // TODO
        // estimate good padding
        // padding = (2 / getResolutionFromArea(assetArea)) * 1024

        // unwrap
        var autoUnwrap = new ui.Button({
            text: 'Auto-Unwrap'
        });
        autoUnwrap.on('click', function() {
            if (! editor.call('permissions:write'))
                return;

            for(var i = 0; i < assets.length; i++) {
                editor.call('assets:model:unwrap', assets[i], {
                    padding: fieldPadding.value
                });
            }

            unwrapState();
        });
        autoUnwrap.class.add('generate-uv1');
        fieldPadding.parent.append(autoUnwrap);

        // unwrap progress
        var fieldUnwrapProgress = editor.call('attributes:addField', {
            parent: panelPipeline,
            name: 'Unwrapping',
        });
        var field = fieldUnwrapProgress;
        fieldUnwrapProgress = fieldUnwrapProgress.parent;
        field.destroy();
        fieldUnwrapProgress.hidden = editor.call('assets:model:unwrapping', assets[0])

        // unwrap progress
        var progressUnwrap = new ui.Progress();
        progressUnwrap.class.add('field-progress');
        fieldUnwrapProgress.append(progressUnwrap);

        // unwrap cancel
        var autoUnwrapCancel = new ui.Button({
            text: 'Cancel'
        });
        autoUnwrapCancel.on('click', function() {
            if (! editor.call('permissions:write'))
                return;

            for(var i = 0; i < assets.length; i++)
                editor.call('assets:model:unwrap:cancel', assets[i]);

            unwrapState();
        });
        autoUnwrapCancel.class.add('generate-uv1');
        fieldUnwrapProgress.append(autoUnwrapCancel);

        var unwrapState = function() {
            var worker = editor.call('assets:model:unwrapping', assets[0]);
            fieldUnwrapProgress.hidden = ! worker;
            fieldPadding.parent.hidden = ! fieldUnwrapProgress.hidden;

            if (worker)
                progressUnwrap.progress = worker.progress / 100;
        };
        unwrapState();

        events.push(editor.on('assets:model:unwrap', function(asset) {
            if (assets.indexOf(asset) === -1)
                return;

            unwrapState();
        }));
        events.push(editor.on('assets:model:unwrap:progress:' + assets[0].get('id'), function(progress) {
            progressUnwrap.progress = progress / 100;
        }));


        if (assets.length === 1 && assets[0].has('data.mapping') && assets[0].get('data.mapping').length) {
            var root = editor.call('attributes.rootPanel');

            var previewContainer = document.createElement('div');
            previewContainer.classList.add('asset-preview-container');

            // preview
            var preview = document.createElement('canvas');
            var ctx = preview.getContext('2d');
            preview.width = 256;
            preview.height = 256;
            preview.classList.add('asset-preview', 'flipY');
            previewContainer.appendChild(preview);

            var sx = 0, sy = 0, x = 0, y = 0, nx = 0, ny = 0;
            var dragging = false;
            var previewRotation = [ -15, 45 ];

            preview.addEventListener('mousedown', function(evt) {
                if (evt.button !== 0)
                    return;

                evt.preventDefault();
                evt.stopPropagation();

                sx = x = evt.clientX;
                sy = y = evt.clientY;

                dragging = true;
            }, false);

            var onMouseMove = function(evt) {
                if (! dragging)
                    return;

                nx = x - evt.clientX;
                ny = y - evt.clientY;
                x = evt.clientX;
                y = evt.clientY;

                queueRender();
            };

            var onMouseUp = function(evt) {
                if (! dragging)
                    return;

                if ((Math.abs(sx - x) + Math.abs(sy - y)) < 8) {
                    if (root.element.classList.contains('large')) {
                        root.element.classList.remove('large');
                    } else {
                        root.element.classList.add('large');
                    }
                }

                previewRotation[0] = Math.max(-90, Math.min(90, previewRotation[0] + ((sy - y) * 0.3)));
                previewRotation[1] += (sx - x) * 0.3;
                sx = sy = x = y = 0;

                dragging = false;

                queueRender();
            };

            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('mouseup', onMouseUp, false);

            root.class.add('asset-preview');
            root.element.insertBefore(previewContainer, root.innerElement);

            // rendering preview
            var renderQueued;

            var renderPreview = function () {
                if (renderQueued)
                    renderQueued = false;

                // render
                var imageData = editor.call('preview:render', assets[0], root.element.clientWidth, root.element.clientWidth, {
                    rotation: [ Math.max(-90, Math.min(90, previewRotation[0] + (sy - y) * 0.3)), previewRotation[1] + (sx - x) * 0.3 ]
                });
                if (! imageData) return;

                preview.width = imageData.width;
                preview.height = imageData.height;

                ctx.putImageData(imageData, 0, 0);
            };
            renderPreview();

            // queue up the rendering to prevent too oftern renders
            var queueRender = function() {
                if (renderQueued) return;
                renderQueued = true;
                requestAnimationFrame(renderPreview);
            };

            // render on resize
            var evtPanelResize = root.on('resize', queueRender);
            var evtSceneSettings = editor.on('preview:scene:changed', queueRender);

            // model resource loaded
            var watcher = editor.call('assets:model:watch', {
                asset: assets[0],
                autoLoad: true,
                callback: queueRender
            });

            // nodes panel
            panelNodes = editor.call('attributes:addPanel', {
                name: 'Mesh Instances'
            });
            panelNodes.class.add('component');
            panelNodes.foldable = true;
            panelNodes.folded = panelToggles['nodes'];
            panelNodes.on('fold', function() {
                panelToggles['nodes'] = true;
            });
            panelNodes.on('unfold', function() {
                panelToggles['nodes'] = false;
            });

            // reference
            editor.call('attributes:reference:attach', 'asset:model:meshInstances', panelNodes, panelNodes.headerElement);

            var nodeItems = [ ];

            var addField = function(ind) {
                var app = editor.call('viewport:app');
                if (! app) return; // webgl not available

                var engineAsset = app.assets.get(assets[0].get('id'));
                var valueBefore = null;

                nodeItems[ind] = editor.call('attributes:addField', {
                    parent: panelNodes,
                    type: 'asset',
                    kind: 'material',
                    name: '[' + ind + '] node',
                    link: assets[0],
                    path: 'data.mapping.' + ind + '.material',
                    over: function(type, data) {
                        valueBefore = assets[0].get('data.mapping.' + ind + '.material') || null;
                        if (engineAsset) {
                            engineAsset.data.mapping[ind].material = parseInt(data.id, 10);
                            engineAsset.fire('change', engineAsset, 'data', engineAsset.data, engineAsset.data);
                            editor.call('viewport:render');
                        }
                    },
                    leave: function() {
                        if (valueBefore) {
                            engineAsset.data.mapping[ind].material = valueBefore;
                            engineAsset.fire('change', engineAsset, 'data', engineAsset.data, engineAsset.data);
                            editor.call('viewport:render');
                        }
                    }
                });

                nodeItems[ind].parent.class.add('node-' + ind);

                nodeItems[ind].parent.on('click', function() {
                    this.class.remove('active');
                });

                nodeItems[ind].on('beforechange', function (id) {
                    nodeItems[ind].once('change', function () {
                        var history = assets[0].history.enabled;
                        assets[0].history.enabled = false;

                        var previous = assets[0].get('meta.userMapping.' + ind);
                        if (! assets[0].get('meta')) {
                            assets[0].set('meta', {
                                userMapping: {}
                            });
                        } else {
                            if (! assets[0].has('meta.userMapping'))
                                assets[0].set('meta.userMapping', {});
                        }

                        assets[0].set('meta.userMapping.' + ind, true);

                        assets[0].history.enabled = history;

                        var lastHistoryAction = editor.call('history:list')[editor.call('history:current')];
                        var undo = lastHistoryAction.undo;
                        var redo = lastHistoryAction.redo;

                        lastHistoryAction.undo = function () {
                            undo();

                            var item = editor.call('assets:get', assets[0].get('id'));
                            if (! item) return;

                            var history = item.history.enabled;
                            item.history.enabled = false;

                            if (! previous) {
                                item.unset('meta.userMapping.' + ind);

                                if (Object.keys(item.get('meta.userMapping')).length === 0) {
                                    item.unset('meta.userMapping');
                                }
                            }

                            item.history.enabled = history;
                        };

                        lastHistoryAction.redo = function () {
                            redo();

                            var item = editor.call('assets:get', assets[0].get('id'));
                            if (! item) return;

                            var history = item.history.enabled;
                            item.history.enabled = false;

                            if (! item.get('meta')) {
                                item.set('meta', {
                                    userMapping: {}
                                });
                            } else {
                                if (! item.has('meta.userMapping'))
                                    item.set('meta.userMapping', {});
                            }

                            item.set('meta.userMapping.' + ind, true);

                            item.history.enabled = history;
                        };
                    });
                });
            };

            // create node fields
            var mapping = assets[0].get('data.mapping');
            for(var i = 0; i < mapping.length; i++) {
                addField(i);
            }

            panelNodes.on('destroy', function () {
                root.class.remove('asset-preview', 'animate');

                editor.call('assets:model:unwatch', assets[0], watcher);

                evtSceneSettings.unbind();
                evtPanelResize.unbind();

                if (previewContainer.parentNode)
                    previewContainer.parentNode.removeChild(previewContainer);

                window.removeEventListener('mousemove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);

                panelNodes = null;
            });

            // hide preview when asset info is hidden
            events.push(editor.once('attributes:assets:toggleInfo', function (toggle) {
                panelMeta.hidden = true;
                panelPipeline.hidden = true;

                root.class.remove('asset-preview', 'animate');
                if (previewContainer.parentNode)
                    previewContainer.parentNode.removeChild(previewContainer);
            }));

            // template nodes
            nodesTemplate = function() {
                if (! panelNodes)
                    return;

                panelNodes.header = 'Mesh Instances [' + assets[0]._nodes.length + ']'

                for(var i = 0; i < assets[0]._nodes.length; i++) {
                    if (! nodeItems[i])
                        continue;

                    nodeItems[i]._label.text = '[' + i + '] ' + assets[0]._nodes[i];
                }
            };

            if (assets[0]._nodes)
            // already loaded
                nodesTemplate();
        }

        panelMeta.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();
        });
    });
});


/* editor/attributes/assets/attributes-asset-scene.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'scene' || ! assets[0].get('source'))
            return;

        var asset = assets[0];
        var events = [ ];

        // contents
        var panelContents = editor.call('attributes:addPanel', {
            name: 'Contents'
        });
        panelContents.class.add('component');
        // reference
        editor.call('attributes:reference:attach', 'asset:scene:contents', panelContents, panelContents.headerElement);


        var labelEmptyMeta = new ui.Label({
            text: 'no contents information available'
        });
        labelEmptyMeta.hidden = !! asset.get('meta');
        panelContents.append(labelEmptyMeta);


        // meta
        var panelMeta = editor.call('attributes:addPanel');
        panelMeta.hidden = ! asset.get('meta');
        events.push(asset.on('meta:set', function() {
            panelMeta.hidden = false;
            labelEmptyMeta.hidden = true;
        }));
        events.push(asset.on('meta:unset', function() {
            panelMeta.hidden = true;
            labelEmptyMeta.hidden = false;
        }));
        panelContents.append(panelMeta);


        // animation
        var fieldAnimation = editor.call('attributes:addField', {
            parent: panelMeta,
            name: 'Animation'
        });
        var animationCheck = function(available) {
            if (available) {
                fieldAnimation.value = 'yes';
            } else {
                fieldAnimation.value = 'no';
            }
        };
        animationCheck(asset.get('meta.animation.available'));
        events.push(asset.on('meta.animation.available:set', animationCheck));


        // textures
        var fieldTextures = editor.call('attributes:addField', {
            parent: panelMeta,
            name: 'Textures',
            type: 'element',
            element: new ui.List()
        });
        fieldTextures.parent.class.add('field');
        fieldTextures.class.add('source-textures');
        fieldTextures.flexGrow = 1;
        fieldTextures.selectable = false;
        // no textures
        var fieldNoTextures = new ui.Label({
            text: 'no'
        });
        fieldNoTextures.class.add('no-data');
        fieldTextures.parent.appendBefore(fieldNoTextures, fieldTextures);
        // add all textures
        var addTextures = function(list) {
            fieldTextures.clear();
            for(var i = 0; i < list.length; i++) {
                var item = new ui.ListItem({
                    text: list[i].name
                });
                var download = new ui.Button({
                    text: '&#57896;'
                });
                download.name = list[i].name;
                download.on('click', function() {
                    window.open(assets[0].get('file.url').split('/').slice(0, -1).concat([ 'content', 'textures', this.name ]).join('/'));
                });
                download.class.add('download');
                download.parent = item;
                item.element.appendChild(download.element);
                fieldTextures.append(item);
            }

            if (list.length) {
                fieldNoTextures.hidden = true;
                fieldTextures.hidden = false;
            } else {
                fieldTextures.hidden = true;
                fieldNoTextures.hidden = false;
            }
        };
        // already available
        var textures = asset.get('meta.textures');
        if (textures && textures.length) {
            addTextures(textures);
        } else {
            fieldTextures.hidden = true;
        }
        // might be set later
        events.push(asset.on('meta.textures:set', function() {
            addTextures(asset.get('meta.textures'));
        }));
        events.push(asset.on('meta.textures:unset', function() {
            fieldTextures.clear();
            fieldTextures.hidden = true;
            fieldNoTextures.hidden = false;
        }));


        // materials
        var fieldMaterials = editor.call('attributes:addField', {
            parent: panelMeta,
            name: 'Materials',
            type: 'element',
            element: new ui.List()
        });
        fieldMaterials.flexGrow = 1;
        fieldMaterials.selectable = false;
        // add all materials
        var addMaterials = function(list) {
            fieldMaterials.clear();
            for(var i = 0; i < list.length; i++) {
                var item = new ui.ListItem({
                    text: list[i].name
                });
                fieldMaterials.append(item);
            }
        };
        // already available
        var materials = asset.get('meta.materials');
        if (materials && materials.length)
            addMaterials(materials);
        // might be set/unset later
        events.push(asset.on('meta.materials:set', function(materials) {
            for(var i = 0; i < materials.length; i++)
                materials[i] = materials[i].json();

            addMaterials(materials);
        }));
        events.push(asset.on('meta.materials:unset', function() {
            fieldMaterials.clear();
        }));


        // clear up events
        panelContents.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();
        });
    });
});


/* editor/attributes/assets/attributes-asset-script.js */
editor.once('load', function() {
    'use strict';

    var legacyScripts = editor.call('settings:project').get('useLegacyScripts');


    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'script' || assets[0].get('source'))
            return;

        var asset = assets[0];
        var events = [ ];

        // panel
        var panel = editor.call('attributes:assets:panel');

        if (! legacyScripts) {
            // scripts
            var panelScripts = editor.call('attributes:addPanel', {
                name: 'Scripts'
            });
            panelScripts.class.add('component', 'asset-script');


            // order
            var fieldOrder = editor.call('attributes:addField', {
                parent: panel,
                name: 'Loading Order'
            });
            var btnOrder = new ui.Button({
                text: 'Manage'
            });
            btnOrder.class.add('loading-order');
            var panelOrder = fieldOrder.parent;
            panelOrder.innerElement.removeChild(fieldOrder.element);
            panelOrder.append(btnOrder);
            btnOrder.on('click', function() {
                editor.call('selector:set', 'editorSettings', [ editor.call('settings:projectUser') ]);
                setTimeout(function() {
                    editor.call('editorSettings:panel:unfold', 'scripts-order');
                }, 0);
            });
            // reparent
            var preloadField = panel.innerElement.querySelector('.ui-panel.field-checkbox.preload');
            if (preloadField && preloadField.nextSibling) {
                fieldOrder.parent.parent.innerElement.removeChild(fieldOrder.parent.element);
                panel.innerElement.insertBefore(fieldOrder.parent.element, preloadField.nextSibling);
            }
            // reference
            editor.call('attributes:reference:attach', 'asset:script:order', fieldOrder.parent.innerElement.firstChild.ui);


            // parse
            var btnParse = new ui.Button({
                text: 'Parse'
            });
            btnParse.hidden = ! editor.call('permissions:write');
            events.push(editor.on('permissions:writeState', function(state) {
                btnParse.hidden = ! state;
            }));
            btnParse.class.add('parse-script');
            btnParse.on('click', function() {
                btnParse.disabled = true;

                editor.call('scripts:parse', asset, function(err, result) {
                    btnParse.disabled = false;

                    if (err) {
                        panelErrors.hidden = false;
                        panelErrors.clear();
                        panelErrors.append(new ui.Label({ text: err.message }));
                        return;
                    }

                    // script validation errors
                    panelErrors.clear();

                    if (result.scriptsInvalid.length) {
                        var label = new ui.Label({ text: 'Validation Errors:' });
                        label.class.add('title');
                        panelErrors.append(label);

                        for(var i = 0; i < result.scriptsInvalid.length; i++) {
                            var label = new ui.Label({ text: result.scriptsInvalid[i] });
                            panelErrors.append(label);
                        }
                        panelErrors.hidden = false;
                    } else {
                        panelErrors.hidden = true;
                    }

                    // template attributes validation errors
                    for(var key in result.scripts) {
                        if (! result.scripts.hasOwnProperty(key) || ! scriptsPanelIndex[key])
                            continue;

                        var attrInvalid = result.scripts[key].attributesInvalid;
                        var validation = scriptsPanelIndex[key].validation;

                        if (attrInvalid.length === 0) {
                            validation.clear();
                            if (validation.collision) {
                                validation.append(validation.collision);
                                validation.hidden = false;
                            } else {
                                validation.hidden = true;
                            }
                            continue;
                        }

                        validation.clear();
                        if (validation.collision)
                            validation.append(validation.collision)

                        for(var i = 0; i < attrInvalid.length; i++)
                            validation.append(new ui.Label({ text: attrInvalid[i] }));

                        validation.hidden = false;
                    }
                });
            });
            panelScripts.headerAppend(btnParse);


            // has loading script
            var fieldLoading = new ui.Label({
                text: 'Has Loading Script'
            });
            fieldLoading.class.add('loading');
            fieldLoading.hidden = ! asset.get('data.loading');
            panelScripts.append(fieldLoading);
            events.push(asset.on('data.loading:set', function(value) {
                fieldLoading.hidden = ! value;
                checkScriptsEmpty();
            }));


            // scripts validation errors
            var panelErrors = new ui.Panel();
            panelErrors.class.add('validation');
            panelErrors.hidden = true;
            panelScripts.append(panelErrors);


            // scripts panel
            var panelScriptsList = new ui.Panel();
            panelScriptsList.class.add('scripts');
            panelScripts.append(panelScriptsList);


            var scriptsPanelIndex = { };
            var noScriptsLabel;

            var checkScriptsEmpty = function() {
                var empty = Object.keys(scriptsPanelIndex).length === 0;

                if (empty) {
                    panelScriptsList.class.add('empty');
                } else {
                    panelScriptsList.class.remove('empty');
                }

                if (empty && ! noScriptsLabel && fieldLoading.hidden) {
                    // no scripts
                    noScriptsLabel = new ui.Label({
                        text: 'No Script Objects found'
                    });
                    panelScriptsList.append(noScriptsLabel);
                } else if (! empty && noScriptsLabel) {
                    noScriptsLabel.destroy();
                    noScriptsLabel = null;
                }
            };

            var createScriptPanel = function(script) {
                if (scriptsPanelIndex[script])
                    return;

                var events = [ ];

                var panel = new ui.Panel();
                panel.class.add('script');
                panel.header = script;
                panel.attributesIndex = { };
                panelScriptsList.append(panel);

                var validation = new ui.Panel();
                validation.class.add('validation');
                validation.hidden = true;
                panel.validation = validation;
                panel.append(validation);

                var onCollide = function() {
                    if (validation.collision)
                        return;

                    validation.collision = new ui.Label({
                        text: 'script \'' + script + '\' is already defined in other asset'
                    });
                    validation.append(validation.collision);
                    validation.hidden = false;
                };

                events.push(editor.on('assets[' + asset.get('id') + ']:scripts[' + script + ']:collide', onCollide));

                events.push(editor.on('assets[' + asset.get('id') + ']:scripts[' + script + ']:resolve', function() {
                    if (! validation.collision)
                        return;

                    validation.collision.destroy();
                    if (! validation.innerElement.childNodes.firstChild)
                        validation.hidden = true;

                    validation.collision = null;
                }));

                if (editor.call('assets:scripts:collide', script))
                    onCollide();

                panel.once('destroy', function() {
                    for(var i = 0; i < events.length; i++)
                        events[i].unbind();
                    events = null;
                });

                scriptsPanelIndex[script] = panel;

                var attributesOrder = asset.get('data.scripts.' + script + '.attributesOrder');
                for(var i = 0; i < attributesOrder.length; i++)
                    createScriptAttribute(script, attributesOrder[i]);

                checkScriptsEmpty();
            };

            var createScriptAttribute = function(script, attr, ind) {
                var events = [ ];
                var panel = scriptsPanelIndex[script];
                if (! panel) return;

                if (panel.attributesIndex[attr])
                    return;

                var attribute = asset.get('data.scripts.' + script + '.attributes.' + attr);
                if (! attribute)
                    return;

                var panelAttribute = new ui.Panel();
                panelAttribute.class.add('attr');
                panelAttribute.updatingTooltip = null;
                panelAttribute.updateTooltip = function() {
                    panelAttribute.updatingTooltip = false;

                    var attribute = asset.get('data.scripts.' + script + '.attributes.' + attr);
                    if (! attribute)
                        return;

                    var subTitle = editor.call('assets:scripts:typeToSubTitle', attribute);

                    fieldType.text = subTitle;

                    tooltip.html = editor.call('attributes:reference:template', {
                        title: attr,
                        subTitle: subTitle,
                        description: (attribute.description || attribute.title || ''),
                        code: JSON.stringify(attribute, null, 4)
                    });
                };
                panel.attributesIndex[attr] = panelAttribute;

                var before = null;
                if (typeof(ind) === 'number')
                    before = panel.innerElement.childNodes[ind];

                if (before) {
                    panel.appendBefore(panelAttribute, before);
                } else {
                    panel.append(panelAttribute);
                }

                var fieldName = panelAttribute.fieldName = new ui.Label({ text: attr });
                fieldName.class.add('name');
                panelAttribute.append(fieldName);

                var fieldType = panelAttribute.fieldType = new ui.Label({
                    text: editor.call('assets:scripts:typeToSubTitle', attribute)
                });
                fieldType.class.add('type');
                panelAttribute.append(fieldType);

                var tooltip = editor.call('attributes:reference', {
                    title: attr,
                    subTitle: editor.call('assets:scripts:typeToSubTitle', attribute),
                    description: (attribute.description || attribute.title || ''),
                    code: JSON.stringify(attribute, null, 4)
                });
                tooltip.attach({
                    target: panelAttribute,
                    element: panelAttribute.element
                });

                events.push(asset.on('*:set', function(path) {
                    if (panelAttribute.updatingTooltip)
                        return;

                    if (! path.startsWith('data.scripts.' + script + '.attributes.' + attr))
                        return;

                    panelAttribute.updatingTooltip = true;
                    setTimeout(panelAttribute.updateTooltip, 0);
                }));

                fieldType.once('destroy', function() {
                    for(var i = 0; i < events.length; i++)
                        events[i].unbind();

                    events = null;
                });
            };

            var data = asset.get('data.scripts');
            var scriptKeys = [ ];
            for(var key in data) {
                if (! data.hasOwnProperty(key))
                    continue;

                createScriptPanel(key);
            }

            checkScriptsEmpty();

            events.push(asset.on('*:set', function(path, value) {
                if (! path.startsWith('data.scripts'))
                    return;

                var parts = path.split('.');

                if (parts.length === 3) {
                    // data.scripts.*
                    createScriptPanel(parts[2]);
                } else if (parts.length >= 6 && parts[3] === 'attributes') {
                    // data.scripts.*.attributes.*.**
                    var script = scriptsPanelIndex[parts[2]];
                    if (! script) return;

                    var attr = script.attributesIndex[parts[4]];
                    if (! attr || attr.updatingTooltip) return;

                    attr.updatingTooltip = true;
                    setTimeout(attr.updateTooltip, 0);
                }
            }));

            events.push(asset.on('*:unset', function(path, value) {
                if (! path.startsWith('data.scripts'))
                    return;

                var parts = path.split('.');

                if (parts.length === 3) {
                    // data.scripts.*
                    if (scriptsPanelIndex[parts[2]]) {
                        scriptsPanelIndex[parts[2]].destroy();
                        delete scriptsPanelIndex[parts[2]];
                        checkScriptsEmpty();
                    }
                } else if (parts.length >= 6 && parts[3] === 'attributes') {
                    // data.scripts.*.attributes.*.**
                    var script = scriptsPanelIndex[parts[2]];
                    if (! script) return;

                    var attr = script.attributesIndex[parts[4]];
                    if (! attr || attr.updatingTooltip) return;

                    attr.updatingTooltip = true;
                    setTimeout(attr.updateTooltip, 0);
                }
            }));

            events.push(asset.on('*:insert', function(path, value, ind) {
                if (! path.startsWith('data.scripts'))
                    return;

                var parts = path.split('.');

                if (parts.length === 4 && parts[3] === 'attributesOrder') {
                    // data.scripts.*.attributesOrder
                    createScriptAttribute(parts[2], value, ind + 1);
                }
            }));

            events.push(asset.on('*:remove', function(path, value) {
                if (! path.startsWith('data.scripts'))
                    return;

                var parts = path.split('.');

                if (parts.length === 4 && parts[3] === 'attributesOrder') {
                    // data.scripts.*.attributesOrder
                    var script = scriptsPanelIndex[parts[2]];
                    if (! script) return;

                    var attr = script.attributesIndex[value];
                    if (! attr) return;

                    attr.destroy();
                    delete script.attributesIndex[value];
                }
            }));

            events.push(asset.on('*:move', function(path, value, ind, indOld) {
                if (! path.startsWith('data.scripts'))
                    return;

                var parts = path.split('.');

                if (parts.length === 4 && parts[3] === 'attributesOrder') {
                    var script = scriptsPanelIndex[parts[2]];
                    if (! script) return;

                    var attr = script.attributesIndex[value];
                    if (! attr) return;

                    var parent = attr.element.parentNode;
                    parent.removeChild(attr.element);

                    var next = parent.children[ind + 1];
                    if (next) {
                        parent.insertBefore(attr.element, next);
                    } else {
                        parent.appendChild(attr.element);
                    }
                }
            }));
        }

        // clear events
        panel.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();

            events = null;
        });
    });
});





/* editor/attributes/assets/attributes-asset-shader.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'shader' || assets[0].get('source'))
            return;

        var asset = assets[0];

        // panel
        var panel = editor.call('attributes:assets:panel');

        var panelRaw = editor.call('attributes:addPanel', {
            name: 'Shader'
        });
        panelRaw.class.add('component');
        // reference
        editor.call('attributes:reference:attach', 'asset:shader:asset', panelRaw, panelRaw.headerElement);

        // loading
        var loading = editor.call('attributes:addField', {
            type: 'progress'
        });
        loading.progress = 1;

        // code
        var fieldCode = editor.call('attributes:addField', {
            parent: panelRaw,
            type: 'code'
        });
        fieldCode.style.margin = '-8px -6px';

        var fieldError = new ui.Label({
            text: 'failed loading data'
        });
        fieldError.class.add('asset-loading-error');
        fieldError.hidden = true;
        editor.call('attributes.rootPanel').append(fieldError);

        var loadContent = function() {
            if (asset.get('file.size') > 128 * 1024) {
                panelRaw.hidden = true;
                loading.hidden = true;
                return;
            } else {
                panelRaw.hidden = false;
                loading.hidden = false;
            }
            // load data
            Ajax({
                url: '{{url.home}}' + asset.get('file.url') + '?t=' + asset.get('file.hash'),
                notJson: true
            })
                .on('load', function(status, data) {
                    fieldCode.text = data;
                    fieldCode.hidden = false;
                    fieldError.hidden = true;
                    loading.hidden = true;
                })
                .on('error', function() {
                    loading.hidden = false;
                    loading.failed = true;
                    fieldCode.hidden = true;
                    fieldError.hidden = false;
                });
        };
        if (asset.has('file.url'))
            loadContent();

        var evtReload = asset.on('file.hash:set', function() {
            loadContent();
        });
        panel.once('destroy', function() {
            evtReload.unbind();
        });
    });
});


/* editor/attributes/assets/attributes-asset-source.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || ! assets[0].get('source'))
            return;

        var asset = assets[0];
        var events = [ ];

        // related assets
        var panelRelated = editor.call('attributes:addPanel', {
            name: 'Related Assets'
        });
        panelRelated.class.add('component');
        // reference
        editor.call('attributes:reference:attach', 'asset:source:related', panelRelated, panelRelated.headerElement);

        var list = new ui.List();
        list.class.add('related-assets');
        panelRelated.append(list);

        var assetId = asset.get('id');
        var assets = editor.call('assets:find', function(asset) {
            return asset.get('source_asset_id') === assetId;
        });

        var addAsset = function(asset) {
            panelRelated.hidden = false;

            var item = new ui.ListItem({
                text: asset.get('name')
            });
            item.class.add('type-' + asset.get('type'));
            list.append(item);

            item.element.addEventListener('click', function() {
                editor.call('selector:set', 'asset', [ asset ]);
            }, false);

            var assetEvents = [ ];

            assetEvents.push(asset.on('name:set', function(name) {
                item.text = name;
            }));

            asset.once('destroy', function() {
                item.destroy();
                for(var i = 0; i < assetEvents.length; i++)
                    assetEvents[i].unbind();
            });

            events = events.concat(assetEvents);
        };

        for(var i = 0; i < assets.length; i++)
            addAsset(assets[i][1]);

        if (! assets.length)
            panelRelated.hidden = true;


        events.push(editor.on('assets:add', function(asset) {
            if (asset.get('source_asset_id') !== assetId)
                return;

            addAsset(asset);
        }));


        list.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();
        });
    });
});


/* editor/attributes/assets/attributes-asset-text.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'text' || assets[0].get('source'))
            return;

        var asset = assets[0];

        // panel
        var panel = editor.call('attributes:assets:panel');

        var panelRaw = editor.call('attributes:addPanel', {
            name: 'TEXT'
        });
        panelRaw.class.add('component');
        // reference
        editor.call('attributes:reference:attach', 'asset:text:asset', panelRaw, panelRaw.headerElement);

        // loading
        var loading = editor.call('attributes:addField', {
            type: 'progress',
        });
        loading.progress = 1;

        // code
        var fieldText = editor.call('attributes:addField', {
            parent: panelRaw,
            type: 'code'
        });
        fieldText.style.margin = '-8px -6px';

        var fieldError = new ui.Label({
            text: 'failed loading data'
        });
        fieldError.class.add('asset-loading-error');
        fieldError.hidden = true;
        editor.call('attributes.rootPanel').append(fieldError);

        var loadContent = function() {
            if (asset.get('file.size') > 128 * 1024) {
                panelRaw.hidden = true;
                loading.hidden = true;
                return;
            } else {
                panelRaw.hidden = false;
                loading.hidden = false;
            }
            // load data
            Ajax({
                url: '{{url.home}}' + asset.get('file.url') + '?t=' + asset.get('file.hash'),
                notJson: true
            })
                .on('load', function(status, data) {
                    fieldText.text = data;
                    fieldText.hidden = false;
                    fieldError.hidden = true;
                    loading.hidden = true;
                })
                .on('error', function(status, err) {
                    loading.hidden = false;
                    loading.failed = true;
                    fieldText.hidden = true;
                    fieldError.hidden = false;
                });
        };
        if (asset.has('file.url'))
            loadContent();

        var evtReload = asset.on('file.hash:set', function() {
            loadContent();
        });
        panel.once('destroy', function() {
            evtReload.unbind();
        });
    });
});


/* editor/attributes/assets/attributes-asset-texture.js */
editor.once('load', function() {
    'use strict';

    var panelsStates = { };

    editor.on('attributes:inspect[asset]', function(assets) {
        for(var i = 0; i < assets.length; i++) {
            if (assets[i].get('type') !== 'texture' || assets[i].get('source'))
                return;
        }

        var events = [ ];

        var ids = [ ];
        for(var i = 0; i < assets.length; i++)
            ids.push(assets[i].get('id'));

        ids = ids.sort(function(a, b) {
            return a - b;
        }).join(',');

        var panelState = panelsStates[ids];
        var panelStateNew = false;
        if (! panelState) {
            panelStateNew = true;
            panelState = panelsStates[ids] = { };

            panelState['texture'] = false;
            panelState['compression'] = false;
        }

        if (assets.length > 1)
            editor.call('attributes:header', assets.length + ' Textures');

        // properties panel
        var panel = editor.call('attributes:addPanel', {
            name: 'Texture',
            foldable: true,
            folded: panelState['texture']
        });
        panel.class.add('component');
        panel.on('fold', function() { panelState['texture'] = true; });
        panel.on('unfold', function() { panelState['texture'] = false; });
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:asset', panel, panel.headerElement);


        var btnGetMeta = new ui.Button({
            text: 'Calculate Meta'
        });
        btnGetMeta.class.add('calculate-meta', 'large-with-icon');
        var btnGetMetaVisibility = function() {
            var visible = false;
            for(var i = 0; i < assets.length; i++) {
                if (! visible && ! assets[i].get('meta'))
                    visible = true;
            }
            btnGetMeta.hidden = ! visible;
        };
        btnGetMeta.on('click', function() {
            if (! editor.call('permissions:write'))
                return;

            for(var i = 0; i < assets.length; i++) {
                if (assets[i].get('meta'))
                    continue;

                editor.call('realtime:send', 'pipeline', {
                    name: 'meta',
                    id: assets[i].get('id')
                });
            }
            this.enabled = false;
        });
        panel.append(btnGetMeta);

        btnGetMetaVisibility();
        for(var i = 0; i < assets.length; i++) {
            if (btnGetMeta.hidden && ! assets[i].get('meta'))
                btnGetMeta.hidden = false;

            events.push(assets[i].on('meta:set', function() {
                btnGetMetaVisibility();
            }));
            events.push(assets[i].on('meta:unset', function() {
                btnGetMeta.hidden = false;
            }));
        }


        // width
        var fieldWidth = editor.call('attributes:addField', {
            parent: panel,
            name: 'Width',
            link: assets,
            path: 'meta.width',
            placeholder: 'pixels'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:width', fieldWidth.parent.innerElement.firstChild.ui);

        // height
        var fieldHeight = editor.call('attributes:addField', {
            parent: panel,
            name: 'Height',
            link: assets,
            path: 'meta.height',
            placeholder: 'pixels'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:height', fieldHeight.parent.innerElement.firstChild.ui);

        // depth
        var fieldDepth = editor.call('attributes:addField', {
            parent: panel,
            name: 'Depth',
            link: assets,
            path: 'meta.depth',
            placeholder: 'bit'
        });
        var checkDepthField = function() {
            if (! fieldDepth.value)
                fieldDepth.element.innerHTML = 'unknown';
        };
        checkDepthField();
        fieldDepth.on('change', checkDepthField);
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:depth', fieldDepth.parent.innerElement.firstChild.ui);


        // alpha
        var fieldAlpha = editor.call('attributes:addField', {
            parent: panel,
            name: 'Alpha',
            link: assets,
            path: 'meta.alpha'
        });
        var checkAlphaField = function() {
            if (! fieldAlpha.value)
                fieldAlpha.element.innerHTML = 'false';
        };
        checkAlphaField();
        fieldAlpha.on('change', checkAlphaField);
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:alpha', fieldAlpha.parent.innerElement.firstChild.ui);


        // interlaced
        var fieldInterlaced = editor.call('attributes:addField', {
            parent: panel,
            name: 'Interlaced',
            link: assets,
            path: 'meta.interlaced'
        });
        var checkInterlacedField = function() {
            if (! fieldInterlaced.value)
                fieldInterlaced.element.innerHTML = 'false';
        };
        checkInterlacedField();
        fieldInterlaced.on('change', checkInterlacedField);
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:interlaced', fieldInterlaced.parent.innerElement.firstChild.ui);


        // rgbm
        var fieldRgbm = editor.call('attributes:addField', {
            parent: panel,
            name: 'Rgbm',
            link: assets,
            path: 'data.rgbm',
            type: 'checkbox'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:rgbm', fieldRgbm.parent.innerElement.firstChild.ui);


        // mipmaps
        var fieldMips = editor.call('attributes:addField', {
            parent: panel,
            name: 'Mipmaps',
            link: assets,
            path: 'data.mipmaps',
            type: 'checkbox'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:mipmaps', fieldMips.parent.innerElement.firstChild.ui);


        // filtering
        var fieldFiltering = editor.call('attributes:addField', {
            parent: panel,
            name: 'Filtering',
            type: 'string',
            enum: {
                '': '...',
                'nearest': 'Point',
                'linear': 'Linear'
            }
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:filtering', fieldFiltering.parent.innerElement.firstChild.ui);

        var changingFiltering = false;

        var updateFiltering = function() {
            var value = '';
            var valueDifferent = false;
            var filter = assets[0].get('data.minfilter') + assets[0].get('data.magfilter');

            for(var i = 1; i < assets.length; i++) {
                if (filter !== (assets[i].get('data.minfilter') + assets[i].get('data.magfilter'))) {
                    valueDifferent = true;
                    break;
                }
            }

            if (! valueDifferent) {
                if (assets[0].get('data.minfilter') === 'linear_mip_linear' && assets[0].get('data.magfilter') === 'linear') {
                    value = 'linear';
                } else if (assets[0].get('data.minfilter') === 'nearest_mip_nearest' && assets[0].get('data.magfilter') === 'nearest') {
                    value = 'nearest';
                }
            }

            if (! valueDifferent && value) {
                fieldFiltering.optionElements[''].style.display = 'none';
            } else {
                fieldFiltering.optionElements[''].style.display = '';
            }

            changingFiltering = true;
            fieldFiltering.value = value;
            changingFiltering = false;
        };
        updateFiltering();

        fieldFiltering.on('change', function(value) {
            if (changingFiltering)
                return;

            var values = [ ];
            var valueMin = value + '_mip_' + value;
            var valueMag = value;

            changingFiltering = true;
            for(var i = 0; i < assets.length; i++) {
                values.push({
                    id: assets[i].get('id'),
                    valueMin: assets[i].get('data.minfilter'),
                    valueMag: assets[i].get('data.magfilter')
                });
                assets[i].history.enabled = false;
                assets[i].set('data.minfilter', valueMin);
                assets[i].set('data.magfilter', valueMag);
                assets[i].history.enabled = true;
            }
            changingFiltering = false;

            fieldFiltering.optionElements[''].style.display = 'none';

            // history
            editor.call('history:add', {
                name: 'assets.filtering',
                undo: function() {
                    for(var i = 0; i < values.length; i++) {
                        var asset = editor.call('assets:get', values[i].id);
                        if (! asset)
                            continue;

                        asset.history.enabled = false;
                        asset.set('data.minfilter', values[i].valueMin);
                        asset.set('data.magfilter', values[i].valueMag);
                        asset.history.enabled = true;
                    }
                },
                redo: function() {
                    for(var i = 0; i < values.length; i++) {
                        var asset = editor.call('assets:get', values[i].id);
                        if (! asset)
                            continue;

                        asset.history.enabled = false;
                        asset.set('data.minfilter', valueMin);
                        asset.set('data.magfilter', valueMag);
                        asset.history.enabled = true;
                    }
                }
            });
        });

        var eventsFiltering = [ ];
        var changingQueued = false;
        var changedFiltering = function() {
            if (changingQueued || changingFiltering)
                return;

            changingQueued = true;
            setTimeout(function() {
                changingQueued = false;
                updateFiltering();
            }, 0);
        };
        for(var i = 0; i < assets.length; i++) {
            eventsFiltering.push(assets[i].on('data.minfilter:set', changedFiltering));
            eventsFiltering.push(assets[i].on('data.magfilter:set', changedFiltering));
        }
        fieldFiltering.once('destroy', function() {
            for(var i = 0; i < eventsFiltering.length; i++) {
                eventsFiltering[i].unbind();
            }
        });



        // anisotropy
        var fieldAnisotropy = editor.call('attributes:addField', {
            parent: panel,
            name: 'Anisotropy',
            type: 'number',
            link: assets,
            path: 'data.anisotropy'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:anisotropy', fieldAnisotropy.parent.innerElement.firstChild.ui);



        // addressu
        var fieldAddressU = editor.call('attributes:addField', {
            parent: panel,
            name: 'Address U',
            type: 'string',
            enum: {
                '': '...',
                'repeat': 'Repeat',
                'clamp': 'Clamp',
                'mirror': 'Mirror Repeat'
            },
            link: assets,
            path: 'data.addressu'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:addressU', fieldAddressU.parent.innerElement.firstChild.ui);


        // addressv
        var fieldAddressV = editor.call('attributes:addField', {
            parent: panel,
            name: 'Address V',
            type: 'string',
            enum: {
                '': '...',
                'repeat': 'Repeat',
                'clamp': 'Clamp',
                'mirror': 'Mirror Repeat'
            },
            link: assets,
            path: 'data.addressv'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:addressV', fieldAddressV.parent.innerElement.firstChild.ui);


        var formats = {
            original: { size: 0, vram: 0 },
            dxt: { size: 0, vram: 0, timeout: false },
            pvr: { size: 0, vram: 0, timeout: false },
            etc1: { size: 0, vram: 0, timeout: false }
        };


        // compression panel
        var panelCompression = editor.call('attributes:addPanel', {
            name: 'Compression',
            foldable: true,
            folded: panelState['compression']
        });
        panelCompression.class.add('component', 'variants');
        panelCompression.on('fold', function() { panelState['compression'] = true; });
        panelCompression.on('unfold', function() { panelState['compression'] = false; });
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:compression', panelCompression, panelCompression.headerElement);

        if (! config.self.superUser && ! config.self.betaTester && config.owner.plan.type === 'free')
            panelCompression.hidden = true;

        // compress alpha
        var fieldCompressAlpha = editor.call('attributes:addField', {
            parent: panelCompression,
            type: 'checkbox',
            name: 'Options',
            link: assets,
            path: 'meta.compress.alpha'
        });
        // label
        var labelCompressAlpha = new ui.Label({ text: 'Alpha' });
        labelCompressAlpha.style.verticalAlign = 'top';
        labelCompressAlpha.style.paddingRight = '12px';
        labelCompressAlpha.style.fontSize = '12px';
        labelCompressAlpha.style.lineHeight = '24px';
        fieldCompressAlpha.parent.append(labelCompressAlpha);

        var checkCompressAlpha = function() {
            var state = false;
            var different = false;
            for(var i = 0; i < assets.length; i++) {
                var alpha = assets[i].get('meta.alpha') || false;
                var trueColorAlpha = (assets[i].get('meta.type') || '').toLowerCase() === 'truecoloralpha';
                var rgbm = assets[i].get('data.rgbm');

                if (i === 0) {
                    state = (alpha || trueColorAlpha) && ! rgbm;
                } else if (state !== ((alpha || trueColorAlpha) && ! rgbm)) {
                    different = true;
                    break;
                }
            }

            fieldCompressAlpha.disabled = labelCompressAlpha.disabled = ! different && ! state;
        };
        checkCompressAlpha();

        // reference
        editor.call('attributes:reference:attach', 'asset:texture:compress:alpha', labelCompressAlpha);


        var originalExt = '';
        var labelSize = { };

        var calculateSize = function(format) {
            formats[format].size = 0;
            formats[format].vram = 0;

            for(var i = 0; i < assets.length; i++) {
                if (! assets[i].get('file'))
                    continue;

                var size = assets[i].get('file.variants.' + format + '.size') || 0;
                var sizeGzip = assets[i].get('file.variants.' + format + '.sizeGzip') || 0;

                if (size) formats[format].vram += size - 128;
                if (sizeGzip || size) formats[format].size += (sizeGzip || size) - 128;
            }
        };

        var calculateOriginalSize = function() {
            formats.original.size = 0;
            formats.original.vram = 0;

            for(var i = 0; i < assets.length; i++) {
                if (! assets[i].get('file'))
                    continue;

                var s = assets[i].get('file.size') || 0;
                if (s) {
                    formats.original.size += s;
                }

                var pixels = (assets[i].get('meta.width') || 0) * (assets[i].get('meta.height') || 0);

                formats.original.vram += pixels * 4;
            }
        };

        var queueSizeCalculate = function(format) {
            if (formats[format].timeout)
                return;

            formats[format].timeout = true;

            setTimeout(function() {
                formats[format].timeout = false;
                calculateSize(format);

                if (! formats[format].size && ! formats[format].vram) {
                    labelSize[format].text = '-';
                } else {
                    labelSize[format].text = bytesToHuman(formats[format].size) + ' [VRAM ' + bytesToHuman(formats[format].vram) + ']'
                }
            }, 0);
        };

        var checkFormats = function() {
            var width = -1;
            var height = -1;
            var rgbm = -1;
            var alpha = -1;
            var alphaValid = -1;

            for(var i = 0; i < assets.length; i++) {
                if (assets[i].has('meta.width')) {
                    if (width === -1) {
                        width = assets[i].get('meta.width');
                        height = assets[i].get('meta.height');
                    } else if (width !== assets[i].get('meta.width') || height !== assets[i].get('meta.height')) {
                        width = -2;
                        height = -2;
                    }
                }

                if (! assets[i].get('file'))
                    continue;

                if (rgbm === -1) {
                    rgbm = assets[i].get('data.rgbm') ? 1 : 0;
                } else if (rgbm !== -2) {
                    if (rgbm !== (assets[i].get('data.rgbm') ? 1 : 0))
                        rgbm = -2;
                }

                if (alpha === -1) {
                    alpha = assets[i].get('meta.compress.alpha') ? 1 : 0;
                } else if (alpha !== -2) {
                    if (alpha !== (assets[i].get('meta.compress.alpha') ? 1 : 0))
                        alpha = -2;
                }

                var alphaValidTmp = (assets[i].get('meta.alpha') || (assets[i].get('meta.type') || '').toLowerCase() === 'truecoloralpha') ? 1 : 0;
                if (alphaValid === -1) {
                    alphaValid = alphaValidTmp;
                } else if (alphaValid !== -2) {
                    if (alphaValid !== alphaValidTmp)
                        alphaValid = -2;
                }

                var ext = assets[i].get('file.url');
                ext = ext.slice(ext.lastIndexOf('.') + 1).toUpperCase();
                ext = ext.split('?')[0];

                if (originalExt !== 'various' && originalExt && originalExt !== ext) {
                    originalExt = 'various';
                } else if (originalExt !== 'various') {
                    originalExt = ext;
                }
            }

            fieldOriginal.value = originalExt;

            if (rgbm !== 1) {
                if (width > 0 && height > 0) {
                    // size available
                    if ((width & (width - 1)) === 0 && (height & (height - 1)) === 0) {
                        // pot
                        fieldDxt.disabled = false;
                    } else {
                        // non pot
                        fieldDxt.disabled = true;
                    }
                } else if (width === -1) {
                    // no size available
                    fieldDxt.disabled = true;
                } else if (width === -2) {
                    // various sizes
                    fieldDxt.disabled = false;
                }
            } else {
                fieldDxt.disabled = true;
            }

            fieldPvr.disabled = fieldPvrBpp.disabled = rgbm !== -2 && (fieldDxt.disabled || rgbm === 1);
            fieldEtc1.disabled = fieldPvr.disabled || (alpha === 1 && alphaValid !== 0);
        };

        calculateOriginalSize();
        for(var key in formats) {
            if (key === 'original')
                continue;

            calculateSize(key);
        }

        // original
        var fieldOriginal = editor.call('attributes:addField', {
            parent: panelCompression,
            name: 'Original',
            value: originalExt
        });
        fieldOriginal.style.paddingLeft = '0px';
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:compress:original', fieldOriginal.parent.innerElement.firstChild.ui);

        // original sizes
        var labelOriginalSize = new ui.Label({
            text: bytesToHuman(formats.original.size) + ' [VRAM ' + bytesToHuman(formats.original.vram) + ']'
        });
        labelOriginalSize.class.add('size');
        fieldOriginal.parent.append(labelOriginalSize);


        // dxt
        var fieldDxt = editor.call('attributes:addField', {
            parent: panelCompression,
            type: 'checkbox',
            name: 'DXT',
            link: assets,
            path: 'meta.compress.dxt'
        });
        // label
        var labelDxtSize = labelSize['dxt'] = new ui.Label({
            text: bytesToHuman(formats.dxt.size) + ' [VRAM ' + bytesToHuman(formats.dxt.vram) + ']'
        });
        labelDxtSize.class.add('size');
        if (! formats.dxt.size && ! formats.dxt.vram) labelDxtSize.text = '-';
        fieldDxt.parent.append(labelDxtSize);
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:compress:dxt', fieldDxt.parent.innerElement.firstChild.ui);


        // pvr
        var fieldPvr = editor.call('attributes:addField', {
            parent: panelCompression,
            type: 'checkbox',
            name: 'PVR',
            link: assets,
            path: 'meta.compress.pvr'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:compress:pvr', fieldPvr.parent.innerElement.firstChild.ui);

        // pvrBpp
        var fieldPvrBpp = editor.call('attributes:addField', {
            panel: fieldPvr.parent,
            type: 'number',
            enum: [
                { v: '', t: '...' },
                { v: 2, t: '2 BPP' },
                { v: 4, t: '4 BPP' }
            ],
            link: assets,
            path: 'meta.compress.pvrBpp'
        });
        fieldPvrBpp.flexGrow = 0;
        fieldPvrBpp.style.width = '62px';
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:compress:pvrBpp', fieldPvrBpp);

        // label
        var labelPvrSize = labelSize['pvr'] = new ui.Label({
            text: bytesToHuman(formats.pvr.size) + ' [VRAM ' + bytesToHuman(formats.pvr.vram) + ']'
        });
        labelPvrSize.class.add('size');
        if (! formats.pvr.size && ! formats.pvr.vram) labelPvrSize.text = '-';
        fieldPvr.parent.append(labelPvrSize);


        // etc1
        var fieldEtc1 = editor.call('attributes:addField', {
            parent: panelCompression,
            type: 'checkbox',
            name: 'ETC1',
            link: assets,
            path: 'meta.compress.etc1'
        });
        // reference
        editor.call('attributes:reference:attach', 'asset:texture:compress:etc1', fieldEtc1.parent.innerElement.firstChild.ui);

        // label
        var labelEtc1Size = labelSize['etc1'] = new ui.Label({
            text: bytesToHuman(formats.etc1.size) + ' [VRAM ' + bytesToHuman(formats.etc1.vram) + ']'
        });
        labelEtc1Size.class.add('size');
        if (! formats.etc1.size && ! formats.etc1.vram) labelEtc1Size.text = '-';
        fieldEtc1.parent.append(labelEtc1Size);


        checkFormats();

        var bindSizeCalculate = function(format) {
            for(var i = 0; i < assets.length; i++) {
                events.push(assets[i].on('file.variants.' + format + '.size:set', function() { queueSizeCalculate(format); }));
                events.push(assets[i].on('file.variants.' + format + '.size:unset', function() { queueSizeCalculate(format); }));
                events.push(assets[i].on('file.variants.' + format + '.sizeGzip:set', function() { queueSizeCalculate(format); }));
                events.push(assets[i].on('file.variants.' + format + '.sizeGzip:unset', function() { queueSizeCalculate(format); }));
            }
        };

        for(var key in formats) {
            if (key === 'original')
                continue;

            bindSizeCalculate(key);
        }


        var btnCompress = new ui.Button();
        btnCompress.text = 'Compress';
        btnCompress.class.add('compress-asset', 'large-with-icon');
        btnCompress.disabled = true;
        btnCompress.on('click', function() {
            for(var i = 0; i < assets.length; i++) {
                if (! assets[i].get('file'))
                    continue;

                var variants = [ ];
                var toDelete = [ ];

                for(var key in formats) {
                    if (key === 'original')
                        continue;

                    if (checkCompressRequired(assets[i], key)) {
                        var width = assets[i].get('meta.width');
                        var height = assets[i].get('meta.height');

                        // no width/height
                        if (! width || ! height)
                            continue;

                        // non pot
                        if ((width & (width - 1)) !== 0 || (height & (height - 1)) !== 0)
                            continue;

                        var compress = assets[i].get('meta.compress.' + key);

                        if (assets[i].get('data.rgbm'))
                            compress = false;

                        if (compress && key === 'etc1') {
                            if (assets[i].get('meta.compress.alpha') && (assets[i].get('meta.alpha') || (assets[i].get('meta.type') || '').toLowerCase() === 'truecoloralpha'))
                                compress = false;
                        }

                        if (compress) {
                            variants.push(key);
                        } else {
                            toDelete.push(key);
                        }
                    }
                }

                if (toDelete.length) {
                    editor.call('realtime:send', 'pipeline', {
                        name: 'delete-variant',
                        data: {
                            asset: parseInt(assets[i].get('id'), 10),
                            options: {
                                formats: toDelete
                            }
                        }
                    });
                }

                if (variants.length) {
                    var task = {
                        asset: parseInt(assets[i].get('id'), 10),
                        options: {
                            formats: variants,
                            alpha: assets[i].get('meta.compress.alpha') && (assets[i].get('meta.alpha') || assets[i].get('meta.type').toLowerCase() === 'truecoloralpha'),
                            mipmaps: assets[i].get('data.mipmaps')
                        }
                    };

                    if (variants.indexOf('pvr') !== -1)
                        task.options.pvrBpp = assets[i].get('meta.compress.pvrBpp');

                    var sourceId = assets[i].get('source_asset_id');
                    if (sourceId) {
                        var sourceAsset = editor.call('assets:get', sourceId);
                        if (sourceAsset)
                            task.source = parseInt(sourceAsset.get('id'), 10);
                    }

                    editor.call('realtime:send', 'pipeline', {
                        name: 'compress',
                        data: task
                    });
                }
            }

            btnCompress.disabled = true;
        });
        panelCompression.append(btnCompress);

        var checkCompressRequired = function(asset, format) {
            if (! asset.get('file'))
                return false;

            var data = asset.get('file.variants.' + format);
            var rgbm = asset.get('data.rgbm');
            var alpha = asset.get('meta.compress.alpha') && (asset.get('meta.alpha') || ((asset.get('meta.type') || '').toLowerCase() === 'truecoloralpha')) || rgbm;
            var compress = asset.get('meta.compress.' + format);
            var mipmaps = asset.get('data.mipmaps');

            if (!! data !== compress) {
                if (format === 'etc1' && alpha)
                    return false;

                if (rgbm && ! data)
                    return false;

                return true;
            } else if (data && ((((data.opt & 1) !== 0) != alpha))) {
                return true;
            }

            if (data && format === 'pvr') {
                var bpp = asset.get('meta.compress.pvrBpp');
                if (data && ((data.opt & 128) !== 0 ? 4 : 2) !== bpp)
                    return true;
            } else if (format === 'etc1') {
                if (data && alpha)
                    return true;

                if (! data && alpha)
                    return false;
            }

            if (data && ((data.opt & 4) !== 0) !== ! mipmaps)
                return true;

            return false;
        };

        var checkCompression = function() {
            var different = false;

            for(var i = 0; i < assets.length; i++) {
                if (! assets[i].get('file') || !! assets[i].get('task'))
                    continue;

                for(var key in formats) {
                    if (key === 'original')
                        continue;

                    if (checkCompressRequired(assets[i], key)) {
                        different = true;
                        break;
                    }
                }

                if (different)
                    break;
            }

            btnCompress.disabled = ! different;
        };
        var queueCheck = false;
        var onAssetChangeCompression = function(path) {
            if (queueCheck || (path !== 'task' && ! path.startsWith('meta') && ! path.startsWith('file') && ! path.startsWith('data.rgbm') && ! path.startsWith('data.mipmaps')))
                return;

            queueCheck = true;
            setTimeout(function() {
                queueCheck = false;
                checkFormats();
                checkCompression();
                checkCompressAlpha();
            }, 0);
        };
        for(var i = 0; i < assets.length; i++) {
            events.push(assets[i].on('*:set', onAssetChangeCompression));
            events.push(assets[i].on('*:unset', onAssetChangeCompression));
        }
        checkCompression();


        // preview
        if (assets.length === 1) {
            var root = editor.call('attributes.rootPanel');

            var reloadImage = function() {
                if (assets[0].get('has_thumbnail') && assets[0].get('thumbnails.xl') && assets[0].get('file.hash')) {
                    image.src = config.url.home + assets[0].get('thumbnails.xl') + '?t=' + assets[0].get('file.hash');
                    previewContainer.style.display = '';
                } else {
                    previewContainer.style.display = 'none';
                }
            };

            var previewContainer = document.createElement('div');
            previewContainer.classList.add('asset-preview-container');

            var image = new Image();
            image.onload = function() {
                root.class.add('animate');
            };
            reloadImage();
            previewContainer.appendChild(image);

            image.addEventListener('click', function() {
                if (root.element.classList.contains('large')) {
                    root.element.classList.remove('large');
                } else {
                    root.element.classList.add('large');
                }
            }, false);

            image.classList.add('asset-preview');
            root.class.add('asset-preview');
            root.element.insertBefore(previewContainer, root.innerElement);

            var events = [ ];
            events.push(assets[0].on('file.hash:set', reloadImage));
            events.push(assets[0].on('has_thumbnail:set', reloadImage));
            events.push(assets[0].on('thumbnails.xl:set', reloadImage));

            panel.on('destroy', function() {
                for(var i = 0; i < events.length; i++)
                    events[i].unbind();
                previewContainer.parentNode.removeChild(previewContainer);
                root.class.remove('asset-preview', 'animate');
            });
        }

        panel.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();
        });
    });
});


/* editor/attributes/assets/attributes-asset-font.js */
editor.once('load', function() {
    'use strict';

    // get characters between range (inclusive)
    var characterRange = function (from, to) {
        var chars = [];
        for (var i = from; i <= to; i++) {
            chars.push(String.fromCharCode(i));
        }

        return chars.join('');
    };

    // character presets
    var LATIN = characterRange(0x20, 0x7e);
    var LATIN_SUPPLEMENT = characterRange(0xA0, 0xFF);
    var CYRILLIC = characterRange(0x400, 0x4ff);
    var GREEK = characterRange(0x370, 0x3FF);

    editor.on('attributes:inspect[asset]', function(assets) {
        var root = editor.call('attributes.rootPanel');

        for(var i = 0; i < assets.length; i++) {
            if (assets[i].get('type') !== 'font' || assets[i].get('source'))
                return;
        }

        var events = [ ];

        if (assets.length > 1)
            editor.call('attributes:header', assets.length + ' Fonts');

        // Properties
        var panelProperties = editor.call('attributes:addPanel', {
            name: "Properties"
        });
        panelProperties.class.add('component');

        var fontIntensity = editor.call('attributes:addField', {
            parent: panelProperties,
            name: 'Intensity',
            type: 'number',
            min: 0,
            max: 1,
            link: assets,
            path: 'data.intensity'
        });
        fontIntensity.style.width = '32px';

        // reference
        editor.call('attributes:reference:attach', 'asset:font:intensity', fontIntensity.parent.innerElement.firstChild.ui);

        var fontIntensitySlider = editor.call('attributes:addField', {
            panel: fontIntensity.parent,
            slider: true,
            type: 'number',
            min: 0,
            max: 1,
            link: assets,
            path: 'data.intensity'
        });

        fontIntensitySlider.flexGrow = 4;

        // Character Presets
        var panelCharacterSets = editor.call('attributes:addPanel', {
            name: 'Character Presets'
        });
        panelCharacterSets.class.add('component');

        // reference
        editor.call('attributes:reference:attach', 'asset:font:presets', panelCharacterSets, panelCharacterSets.headerElement);

        // buttons to add character sets
        var names = [
            'Latin',
            'Latin Supplement',
            'Cyrillic',
            'Greek'
        ];

        var sets = [
            LATIN,
            LATIN_SUPPLEMENT,
            CYRILLIC,
            GREEK
        ];

        // Add a button for each preset
        // which adds the respected preset to the selected
        // assets's characters
        sets.forEach(function (set, index) {
            var btn = new ui.Button({
                text: names[index]
            });

            panelCharacterSets.append(btn);

            btn.on('click', function () {
                proxyObservers.forEach(function (proxy) {
                    var val = proxy.get('chars');
                    val += set;
                    proxy.set('chars', val);
                });

                fieldFrom.value = '0x' + set.charCodeAt(0).toString(16);
                fieldTo.value = '0x' + set.charCodeAt(set.length-1).toString(16);
            });
        });

        // Custom Range
        var panelCustomRange = editor.call('attributes:addPanel', {
            name: 'Custom Character Range'
        });
        panelCustomRange.class.add('component');

        // reference
        editor.call('attributes:reference:attach', 'asset:font:customRange', panelCustomRange, panelCustomRange.headerElement);

        // Range buttons
        var panelRange = editor.call('attributes:addField', {
            parent: panelCustomRange,
            name: 'Range (hex)'
        });
        var label = panelRange;
        panelRange = panelRange.parent;
        label.destroy();

        var fieldFrom = editor.call('attributes:addField', {
            panel: panelRange,
            type: 'string',
            placeholder: 'From',
            value: '0x20'
        });

        // fieldFrom.style.width = '32px';

        fieldFrom.renderChanges = false;

        var fieldTo = editor.call('attributes:addField', {
            panel: panelRange,
            type: 'string',
            placeholder: 'To',
            value: '0x7E'
        });

        fieldTo.renderChanges = false;

        // fieldTo.style.width = '32px';

        var btnAddRange = new ui.Button({
            text: '&#57632;',
        });
        btnAddRange.class.add('font-icon');

        panelRange.append(btnAddRange);

        btnAddRange.on('click', function () {
            var from = parseInt(fieldFrom.value, 16);
            if (! from )
                return;
            var to = parseInt(fieldTo.value, 16);
            if (! to )
                return;

            if (from > to)
                return;

            var range = characterRange(from, to);

            proxyObservers.forEach(function (proxy) {
                var val = proxy.get('chars');
                val += range;
                proxy.set('chars', val);
            });
        });


        // Characters
        var paramsPanel = editor.call('attributes:addPanel', {
            name: 'Font'
        });
        paramsPanel.class.add('component');
        // reference
        editor.call('attributes:reference:attach', 'asset:font:asset', paramsPanel, paramsPanel.headerElement);

        // preview
        if (assets.length === 1) {
            var previewContainer = document.createElement('div');
            previewContainer.classList.add('asset-preview-container');

            var preview = document.createElement('canvas');
            var ctx = preview.getContext('2d');
            preview.width = 256;
            preview.height = 256;
            preview.classList.add('asset-preview');
            preview.classList.add('flipY');
            previewContainer.appendChild(preview);

            preview.addEventListener('click', function() {
                if (root.element.classList.contains('large')) {
                    root.element.classList.remove('large');
                } else {
                    root.element.classList.add('large');
                }
            }, false);

            root.class.add('asset-preview');
            root.element.insertBefore(previewContainer, root.innerElement);

            var renderQueued;

            var renderPreview = function () {
                if (renderQueued)
                    renderQueued = false;

                // render
                var imageData = editor.call('preview:render', assets[0], root.element.clientWidth, root.element.clientWidth, {});
                if (! imageData) return;

                preview.width = imageData.width;
                preview.height = imageData.height;

                ctx.putImageData(imageData, 0, 0);
            };
            renderPreview();

            // queue up the rendering to prevent too oftern renders
            var queueRender = function() {
                if (renderQueued) return;
                renderQueued = true;
                requestAnimationFrame(renderPreview);
            };

            // render on resize
            var evtPanelResize = root.on('resize', queueRender);
            var evtSceneSettings = editor.on('preview:scene:changed', queueRender);

            // font resource loaded
            var watcher = editor.call('assets:font:watch', {
                asset: assets[0],
                autoLoad: true,
                callback: queueRender
            });

            var renderTimeout;

            paramsPanel.once('destroy', function() {
                root.class.remove('asset-preview', 'animate');

                editor.call('assets:font:unwatch', assets[0], watcher);
                evtPanelResize.unbind();
                evtSceneSettings.unbind();

                if (previewContainer.parentNode)
                    previewContainer.parentNode.removeChild(previewContainer);

                paramsPanel = null;
            });
        }

        // set up proxy observer list which is used
        // to allow the user to edit meta data of each font only locally
        // Then when process font is clicked the pipeline takes care of
        // saving those meta fields in the db
        var proxyObservers = [];

        var createProxy = function (asset) {
            var proxy = new Observer({
                'id': asset.get('id'),
                'chars': asset.get('meta.chars'),
                'invert': false, //!!asset.get('meta.invert'),
                'pxrange': asset.get('meta.pxrange')
            });

            proxyObservers.push(proxy);

            events.push(asset.on('meta.chars:set', function (value) {
                proxy.set('chars', value);
            }));

            events.push(asset.on('meta.invert:set', function (value) {
                proxy.set('invert', value);
            }));

            events.push(asset.on('meta.pxrange:set', function (value) {
                proxy.set('pxrange', value);
            }));
        };

        // create proxy observer for each asset
        assets.forEach(createProxy);

        // characters
        var fieldChars = editor.call('attributes:addField', {
            parent: paramsPanel,
            type: 'string',
            name: 'Characters',
            link: proxyObservers,
            path: 'chars'
        });

        // Change handler
        fieldChars.on('change', toggleSaveButton);

        // reference
        editor.call('attributes:reference:attach', 'asset:font:characters', fieldChars.parent.innerElement.firstChild.ui);

        // invert
        var fieldInvert = editor.call('attributes:addField', {
            parent: paramsPanel,
            type: 'checkbox',
            name: 'Invert',
            link: proxyObservers,
            path: 'invert'
        });
        fieldInvert.parent.hidden = true;

        // reference
        editor.call('attributes:reference:attach', 'asset:font:invert', fieldInvert.parent.innerElement.firstChild.ui);

        // signed distance range
        var fieldRange = editor.call('attributes:addField', {
            parent: paramsPanel,
            type: 'number',
            name: 'MSDF Range',
            link: proxyObservers,
            path: 'pxrange',
            min: 0,
            max: 15,
            step: 1,
            precision: 0
        });

        fieldRange.style.width = '32px';

        // hide for now
        fieldRange.parent.hidden = true;

        // reference
        editor.call('attributes:reference:attach', 'asset:font:pxrange', fieldRange.parent.innerElement.firstChild.ui);


        var fieldRangeSlider = editor.call('attributes:addField', {
            panel: fieldRange.parent,
            type: 'number',
            link: proxyObservers,
            path: 'pxrange',
            min: 0,
            max: 15,
            step: 1,
            slider: true,
            precision: 0
        });

        fieldRangeSlider.flexGrow = 4;

        var panelSave = editor.call('attributes:addPanel', {
            parent: paramsPanel
        });
        panelSave.class.add('buttons');

        // save button
        var btnSave = new ui.Button({
            text: 'Process Font' + (assets.length > 1 ? 's' : '')
        });
        btnSave.style.flexGrow = 1;
        btnSave.style.width = '100%';
        btnSave.style.textAlign = 'center';

        panelSave.append(btnSave);

        // Enables or disabled the SAVE button
        var toggleSaveButton = function () {
            var sameChars = true;
            var lastChars = proxyObservers[0].get('chars');
            for (var i = 1; i < proxyObservers.length; i++) {
                if (proxyObservers[i].get('chars') !== lastChars) {
                    sameChars = false;
                    break;
                }
            }

            if (! sameChars) {
                btnSave.disabled = true;
                return;
            }

            var tasksInProgress = false;

            for (var i = 0; i < assets.length; i++) {
                if (!editor.call('assets:get', assets[i].get('source_asset_id'))) {
                    btnSave.disabled = true;
                    return;
                }

                if (assets[i].get('task') === 'running') {
                    tasksInProgress = true;
                    break;
                }
            }

            btnSave.disabled = tasksInProgress;
        };


        toggleSaveButton();

        // subscribe to asset task updates to disable / enable the button
        assets.forEach(function (asset) {
            events.push(asset.on('task:set', toggleSaveButton));
        });

        // Trigger pipeline job
        btnSave.on('click', function () {
            var value = fieldChars.value;

            if (! value || value === '...')
                return;

            proxyObservers.forEach(function (proxy) {
                var asset = editor.call('assets:get', proxy.get('id'));
                if (! asset) return;

                var sourceId = asset.get('source_asset_id');
                if (! sourceId) return;

                var source = editor.call('assets:get', sourceId);
                if (! source) return;

                // remove duplicate chars
                // remove duplicate chars but keep same order
                var unique = '';
                var chars = {};

                for (var i = 0, len = value.length; i < len; i++) {
                    if (chars[value[i]]) continue;
                    chars[value[i]] = true;
                    unique += value[i];
                }

                var task = {
                    source: parseInt(source.get('id'), 10),
                    target: parseInt(asset.get('id'), 10),
                    chars: unique,
                    invert: false//fieldInvert.value
                };

                // if (fieldRange.value !== null)
                //     task.pxrange = fieldRange.value;

                editor.call('realtime:send', 'pipeline', {
                    name: 'convert',
                    data: task
                });
            });
        });

        paramsPanel.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();
        });
    });
});


/* editor/chat/chat-widget.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var viewport = editor.call('layout.viewport');
    var lastMessage = null;

    var panel = new ui.Panel();
    panel.header = 'Chat';
    panel.flexShrink = false;
    panel.foldable = true;
    panel.folded = true;
    panel.class.add('chat-widget');
    panel.hidden = ! editor.call('permissions:read') || editor.call('viewport:expand:state');
    editor.on('permissions:set', function(level) {
        panel.hidden = ! level || editor.call('viewport:expand:state');
    });
    viewport.append(panel);
    editor.method('chat:panel', function() {
        return panel;
    });

    editor.on('viewport:expand', function(state) {
        if (state) {
            panel.class.add('expanded');
        } else {
            panel.class.remove('expanded');
        }
    });

    panel.element.addEventListener('mouseover', function() {
        editor.emit('viewport:hover', false);
    }, false);

    // notification icon
    var notify = new ui.Button({
        text: '&#57751;'
    });
    notify.class.add('notifyToggle');
    panel.headerAppend(notify);

    var tooltipNotify = Tooltip.attach({
        target: notify.element,
        text: 'Notifications (enabled)',
        align: 'bottom',
        root: root
    });

    notify.on('click', function() {
        var permission = editor.call('notify:state');

        if (permission === 'denied') {
            return;
        } else if (permission === 'granted') {
            var granted = editor.call('localStorage:get', 'editor:notifications:chat');
            editor.call('localStorage:set', 'editor:notifications:chat', ! granted);
            editor.emit('chat:notify', ! granted);
        } else {
            editor.call('notify:permission');
        }
    });
    var checkNotificationsState = function() {
        var permission = editor.call('notify:state');

        if (permission === 'denied') {
            tooltipNotify.text = 'Notifications Denied in Browser Settings';
            notify.class.remove('active');
        } else if (permission === 'granted') {
            var granted = editor.call('localStorage:get', 'editor:notifications:chat');
            if (granted === false) {
                tooltipNotify.text = 'Notifications Disabled';
                notify.class.remove('active');
            } else {
                tooltipNotify.text = 'Notifications Enabled';
                notify.class.add('active');
            }
        } else {
            tooltipNotify.text = 'Enable Notifications';
            notify.class.remove('active');
        }
    };
    editor.on('notify:permission', checkNotificationsState);
    editor.on('chat:notify', checkNotificationsState);
    checkNotificationsState();

    // typers
    var typersLast = null;
    var typers = document.createElement('span');
    typers.classList.add('typers');
    panel.headerAppend(typers);

    // typers single
    var typersSingle = document.createElement('span');
    typersSingle.classList.add('single');
    typers.appendChild(typersSingle);

    var typersSingleUser = document.createElement('span');
    typersSingleUser.classList.add('user');
    typersSingle.appendChild(typersSingleUser);

    typersSingle.appendChild(document.createTextNode(' is typing...'));

    // typers double
    var typersDouble = document.createElement('span');
    typersDouble.classList.add('double');
    typers.appendChild(typersDouble);

    var typersDoubleUserA = document.createElement('span');
    typersDoubleUserA.classList.add('user');
    typersDouble.appendChild(typersDoubleUserA);

    typersDouble.appendChild(document.createTextNode(' and '));

    var typersDoubleUserB = document.createElement('span');
    typersDoubleUserB.classList.add('user');
    typersDouble.appendChild(typersDoubleUserB);

    typersDouble.appendChild(document.createTextNode(' are typing...'));

    // typers multiple
    var typersMultiple = document.createElement('span');
    typersMultiple.classList.add('multiple');
    typers.appendChild(typersMultiple);

    var typersMultipleUsers = document.createElement('span');
    typersMultipleUsers.classList.add('user');
    typersMultiple.appendChild(typersMultipleUsers);

    typersMultiple.appendChild(document.createTextNode(' users are typing...'));


    editor.on('chat:typing', function(count, ids) {
        if (count === 0) {
            if (typersLast) typersLast.classList.remove('active');
            typersLast = null;
        } else if (count === 1) {
            if (typersLast) typersLast.classList.remove('active');
            typersLast = typersSingle;
            typersSingle.classList.add('active');
            // user
            var user = editor.call('users:get', ids[0]);
            var color = editor.call('whoisonline:color', user && user.id, 'hex');
            typersSingleUser.textContent = user && user.username || 'user';
            typersSingleUser.style.color = color;
        } else if (count === 2) {
            if (typersLast) typersLast.classList.remove('active');
            typersLast = typersDouble;
            typersDouble.classList.add('active');
            // userA
            var userA = editor.call('users:get', ids[0]);
            var color = editor.call('whoisonline:color', userA && userA.id, 'hex');
            typersDoubleUserA.textContent = userA && userA.username || 'user';
            typersDoubleUserA.style.color = color;
            // userB
            var userB = editor.call('users:get', ids[1]);
            var color = editor.call('whoisonline:color', userB && userB.id, 'hex');
            typersDoubleUserB.textContent = userB && userB.username || 'userB';
            typersDoubleUserB.style.color = color;
        } else {
            if (typersLast) typersLast.classList.remove('active');
            typersLast = typersMultiple;
            typersMultiple.classList.add('active');
            typersMultipleUsers.textContent = count;
        }
    });

    // number
    var messagesNumber = 0;
    var number = document.createElement('span');
    number.classList.add('number');
    number.textContent = '0';
    panel.headerAppend(number);

    editor.method('chat:unreadCount', function() {
        return messagesNumber;
    });

    editor.on('chat:post', function(type, msg, element) {
        if (! panel.folded)
            lastMessage = element;

        if (! panel.folded || type === 'typing')
            return;

        messagesNumber++;
        panel.class.add('notify');
        number.classList.add('notify');

        if (! number.classList.contains('typing'))
            number.textContent = messagesNumber;
    });
    editor.on('chat:typing', function(typing, ids) {
        if (! panel.folded)
            return;

        if (typing) {
            number.textContent = '...';
            number.classList.add('typing');

            if (typing === 1) {
                var color = editor.call('whoisonline:color', ids[0], 'hex');
                number.style.color = color;
            } else {
                number.style.color = '';
            }
        } else {
            number.textContent = messagesNumber;
            number.classList.remove('typing');
            number.style.color = '';
        }
    });
    panel.on('unfold', function() {
        messagesNumber = 0;
        number.textContent = '0';
        number.classList.remove('typing', 'notify');
        panel.class.remove('notify');

        if (messageDivider.parentNode)
            messageDivider.parentNode.removeChild(messageDivider);

        if (lastMessage && lastMessage !== messages.innerElement.lastChild) {
            messages.innerElement.scrollTop = lastMessage.offsetTop;
            messages.appendAfter(messageDivider, lastMessage);

            lastMessage = messages.innerElement.lastChild;
        }

        setTimeout(function() {
            input.elementInput.select();
            input.elementInput.focus();
        }, 200);
    });

    // messages
    var messages = new ui.Panel();
    messages.class.add('messages');
    messages.innerElement.classList.add('selectable');
    messages.scroll = true;
    panel.append(messages);

    messages.innerElement.addEventListener('contextmenu', function(evt) {
        if (evt.target.tagName !== 'A')
            return;

        evt.stopPropagation();
    });

    editor.method('chat:messagesPanel', function() {
        return messages;
    });

    var messageDivider = document.createElement('div');
    messageDivider.classList.add('divider');

    // input
    var typing = false;
    var typingTimeout = null;
    var typingTimeoutDelay = 1000;
    var input = new ui.TextField();
    input.blurOnEnter = false;
    input.keyChange = true;
    input.renderChanges = false;
    input.placeholder = '>';
    panel.append(input);

    editor.method('chat:inputField', function() {
        return input;
    });

    var clear = document.createElement('div');
    clear.innerHTML = '&#57650;';
    clear.classList.add('clear');
    input.element.appendChild(clear);

    clear.addEventListener('click', function() {
        input.value = '';
        onTypingEnd();
    }, false);

    var onTypingEnd = function() {
        if (typingTimeout) {
            clearTimeout(typingTimeout);
            typingTimeout = null;
        }

        if (! typing)
            return;

        typing = false;
        editor.call('chat:typing', false);
    };

    input.on('change', function(value) {
        value = value.trim();

        if (value.length > 1024) {
            input.value = value.slice(0, 1024);
            return;
        }

        if (typingTimeout)
            clearTimeout(typingTimeout);

        typingTimeout = setTimeout(onTypingEnd, typingTimeoutDelay);

        if (value) {
            input.class.add('not-empty');

            if (! typing) {
                typing = true;
                editor.call('chat:typing', true);
            }
        } else {
            input.class.remove('not-empty');
            onTypingEnd();
        }
    });

    input.element.addEventListener('keydown', function(evt) {
        if (evt.keyCode === 27) {
            // esc
            input.value = '';
            onTypingEnd();
        } else if (evt.keyCode === 13) {
            // enter
            editor.call('chat:send', input.value);
            input.value = '';
            onTypingEnd();
        }
    }, false);
});


/* editor/chat/chat-typing.js */
editor.once('load', function() {
    'use strict';

    var typing = 0;
    var typingMessage;
    var users = { };

    editor.on('whoisonline:add', function(id) {
        if (users[id])
            return;

        users[id] = {
            id: id,
            typing: 0,
            username: ''
        };

        editor.call('users:loadOne', id, function (user) {
            if (! users[id])
                return;

            users[id].username = user.username;
        });
    });

    editor.on('whoisonline:remove', function(id) {
        if (! users[id])
            return;

        if (users[id].typing) {
            typing--;
            notifyTypers();
        }

        delete users[id];
    });

    var notifyTypers = function() {
        var typers = [ ];
        for(var id in users) {
            if (! users.hasOwnProperty(id) || ! users[id].typing)
                continue;

            typers.push(id);
        }

        editor.emit('chat:typing', typing, typers, msg);
    };

    editor.method('chat:sync:typing', function(data) {
        if (! users[data.user] || data.user === config.self.id || users[data.user].typing === data.d)
            return;

        users[data.user].typing = data.d;

        if (data.d) {
            typing++;
        } else {
            typing--;
        }

        notifyTypers();
    });

    editor.method('chat:typing', function(state) {
        editor.call('realtime:send', 'chat', {
            t: 'typing',
            d: state ? 1 : 0
        });
    });
});


/* editor/chat/chat-system.js */
editor.once('load', function () {
    'use strict';

    var root = editor.call('layout.root');
    var widget = editor.call('chat:panel');
    var messages = editor.call('chat:messagesPanel');
    var lastUser = null;
    var lastMessage = 0;
    var lastMessageDelay = 60 * 1000;

    var regexUrl = /[a-z]+:\/\/[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b[-a-zA-Z0-9@:%_\+.~#?&\/=]*/g;
    var regexEmail = /[-a-zA-Z0-9:%._\+~]{1,256}@[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-z]{2,16}/g;

    var stringToElements = function(args) {
        var items = [ ];

        var bits = args.string.match(args.regex);
        if (! bits) return [ args.string ];

        var parts = args.string.split(args.regex);

        for(var i = 0; i < parts.length; i++) {
            items.push(parts[i]);

            if (bits.length > i)
                items.push(args.filter(bits[i]));
        }

        return items;
    };

    var parseMessageFilterLink = function(string) {
        var link = document.createElement('a');
        link.target = '_blank';
        link.href = string;
        link.textContent = string;
        return link;
    };

    var parseMessageFilterEmail = function(string) {
        var link = document.createElement('a');
        link.href = 'mailto:' + string;
        link.textContent = string;
        return link;
    };

    var parseMessage = function(message) {
        var items = stringToElements({
            string: message,
            regex: regexUrl,
            filter: parseMessageFilterLink
        });

        for(var i = 0; i < items.length; i++) {
            if (typeof(items[i]) !== 'string')
                continue;

            var emails = stringToElements({
                string: items[i],
                regex: regexEmail,
                filter: parseMessageFilterEmail
            });

            for(var e = 0; e < emails.length; e++) {
                var item;

                if (typeof(emails[e]) === 'string') {
                    item = document.createTextNode(emails[e]);
                } else {
                    item = emails[e];
                }

                if (e === 0) {
                    items[i] = item;
                } else {
                    items.splice(i + 1, 0, item);
                    i++;
                }
            }
        }

        return items;
    };

    editor.on('whoisonline:remove', function(id) {
        if (lastUser === id) {
            lastUser = null;
            lastMessage = 0;
        }
    });

    editor.method('chat:post', function(type, string) {
        if (type !== 'system' && typeof(type) !== 'number')
            return;

        var element = document.createElement('div');
        element.classList.add('selectable');

        var text = element.text = document.createElement('span');
        text.classList.add('selectable');
        element.appendChild(text);

        var message;

        if (type === 'system') {
            lastUser = null;
            lastMessage = 0;
            var date = new Date();
            message = ('00' + date.getHours()).slice(-2) + ':' + ('00' + date.getMinutes()).slice(-2) + ' - ' + string;
            element.classList.add('system');
        } else if (typeof(type) === 'number') {
            element.classList.add('message');
            message = string;

            // if same user posts within 60 seconds,
            // don't add image and username
            if (lastUser !== type || (Date.now() - lastMessage) > lastMessageDelay) {
                var img = document.createElement('img');
                img.classList.add('selectable');
                img.width = 14;
                img.height = 14;
                img.src = '/api/users/' + type + '/thumbnail?size=14';
                element.insertBefore(img, text);

                var date = new Date();

                element.tooltip = Tooltip.attach({
                    target: img,
                    text: ('00' + date.getHours()).slice(-2) + ':' + ('00' + date.getMinutes()).slice(-2),
                    align: 'right',
                    root: root
                });

                var user = editor.call('users:get', type);

                var username = document.createElement('span');
                username.classList.add('username', 'selectable');
                username.textContent = (user ? user.username : '') + ': ';
                if (type !== config.self.id)
                    username.style.color = editor.call('whoisonline:color', user.id, 'hex');
                element.insertBefore(username, text);
            } else {
                element.classList.add('multi');
            }

            lastUser = type;
            lastMessage = Date.now();
        }

        var elements = parseMessage(message);
        var fragment = document.createDocumentFragment();
        for(var i = 0; i < elements.length; i++)
            fragment.appendChild(elements[i]);
        text.appendChild(fragment);

        var scrollDown = ! widget.folded && Math.abs((messages.innerElement.scrollHeight - messages.innerElement.clientHeight) - messages.innerElement.scrollTop) < 4;

        messages.append(element);

        if (scrollDown)
            messages.innerElement.scrollTop = messages.innerElement.scrollHeight - messages.innerElement.clientHeight;

        editor.emit('chat:post', type, message, element);

        return element;
    });

    editor.method('chat:sync:msg', function(data) {
        editor.call('chat:post', data.user, data.d);
    });

    editor.method('chat:send', function(message) {
        message = message.trim();
        if (! message)
            return;

        editor.call('realtime:send', 'chat', {
            t: 'msg',
            d: message
        });
    });
});


/* editor/chat/chat-notifications.js */
editor.once('load', function() {
    'use strict';

    var panel = editor.call('chat:panel');
    var inputField = editor.call('chat:inputField');
    var number = 0;

    editor.on('visibility', function(state) {
        if (state) {
            number = 0;
            editor.call('notify:title', config.project.name + ' | Editor');
        } else {
            number = editor.call('chat:unreadCount');
            if (number) editor.call('notify:title', '(' + number + ') ' + config.project.name + ' | Editor');
        }
    });

    editor.on('chat:post', function(type, msg, element) {
        editor.call('notify:permission');

        var granted = editor.call('localStorage:get', 'editor:notifications:chat');
        var visible = editor.call('visibility');

        if (! visible) {
            number++;
            editor.call('notify:title', '(' + number + ') ' + config.project.name + ' | Editor');
        }

        if (visible || granted === false)
            return;

        var title;
        var icon;
        if (msg.length > 64)
            msg = msg.slice(0, 64) + '...';

        if (type === 'system') {
            title = 'System Message';

        } else if (typeof(type) === 'number') {
            var user = editor.call('users:get', type);
            title = 'Message from ' + (user && ('@' + user.username) || 'a user');
            icon = '/api/users/' + user.id + '/thumbnail?size=128'
        }

        editor.call('notify', {
            title: title,
            body: msg,
            icon: icon,
            click: function() {
                window.focus();
                panel.folded = false;
            }
        });
    });
});


/* editor/toolbar/toolbar.js */
editor.once('load', function() {
    'use strict';

    var toolbar = editor.call('layout.toolbar');
});


/* editor/toolbar/toolbar-logo.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var toolbar = editor.call('layout.toolbar');
    var legacyScripts = editor.call('settings:project').get('useLegacyScripts');


    var logo = new ui.Button();
    logo.class.add('logo');
    logo.on('click', function() {
        menu.open = true;
    });
    toolbar.append(logo);

    var componentsLogos = {
        'animation': '&#57875;',
        'audiolistener': '&#57750;',
        'audiosource': '&#57751;',
        'camera': '&#57874;',
        'collision': '&#57735;',
        'light': '&#57748;',
        'model': '&#57736;',
        'particlesystem': '&#57753;',
        'rigidbody': '&#57737;',
        'script': '&#57910;'
    };

    var hasLegacyScript = function (entity, url) {
        var scriptComponent = entity.get('components.script');
        if (scriptComponent) {
            for (var i = 0; i < scriptComponent.scripts.length; i++) {
                if (scriptComponent.scripts[i].url === url) {
                    return true;
                }
            }
        }

        return false;
    };

    var setField = function(items, field, value) {
        var records = [ ];

        for(var i = 0; i < items.length; i++) {
            records.push({
                get: items[i].history._getItemFn,
                value: value,
                valueOld: items[i].get(field)
            });

            items[i].history.enabled = false;
            items[i].set(field, value);
            items[i].history.enabled = true;
        }

        editor.call('history:add', {
            name: 'entities.set[' + field + ']',
            undo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set(field, records[i].valueOld);
                    item.history.enabled = true;
                }
            },
            redo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set(field, records[i].value);
                    item.history.enabled = true;
                }
            }
        });
    };

    var addBultinLegacyScript = function (entity, url) {
        var resourceId = entity.get('resource_id');

        var addedComponent = false;

        var action = {
            name: 'entity.' + resourceId + '.builtinscript',
            combine: false,
            undo: function () {
                var e = editor.call('entities:get', resourceId);
                if (! e) return;

                var history = e.history.enabled;
                e.history.enabled = false;

                if (addedComponent) {
                    e.unset('components.script');
                } else {
                    var scripts = e.get('components.script.scripts');
                    if (scripts) {
                        for (var i = 0; i < scripts.length; i++) {
                            if (scripts[i].url === url) {
                                e.remove('components.script.scripts', i);
                                break;
                            }
                        }
                    }
                }

                e.history.enabled = history;
            },
            redo: function () {
                var e = editor.call('entities:get', resourceId);
                if (! e) return;

                var history = e.history.enabled;
                e.history.enabled = false;

                if (!e.get('components.script')) {
                    editor.call('entities:addComponent', [e], 'script');
                    addedComponent = true;
                }

                // add script
                var script = new Observer({
                    url: url
                });
                e.insert('components.script.scripts', script);

                e.history.enabled = history;

                // scan script
                editor.call('sourcefiles:scan', url, function (data) {
                    e.history.enabled = false;

                    data.url = url;
                    script.patch(data);

                    e.history.enabled = history;
                });
            }
        };

        // perform action
        action.redo();

        // raise history event
        entity.history.emit('record', 'add', action);
    };

    var menuData = {
        'entity': {
            title: 'Entity',
            filter: function() {
                return editor.call('selector:type') === 'entity' && editor.call('permissions:write');
            },
            items: {
                'new-entity': {
                    title: 'New Entity',
                    filter: function () {
                        return editor.call('selector:items').length === 1;
                    },
                    select: function () {
                        editor.call('entities:new', {parent: editor.call('entities:selectedFirst')});
                    },
                    items: editor.call('menu:entities:new')
                },
                'add-component': {
                    title: 'Add Component',
                    filter: function() {
                        return editor.call('selector:type') === 'entity';
                    },
                    items: { }
                }
            }
        },
        'edit': {
            title: 'Edit',
            filter: function() {
                return editor.call('permissions:write');
            },
            items: {
                'undo': {
                    title: 'Undo',
                    icon: '&#57620;',
                    filter: function() {
                        return editor.call('history:canUndo');
                    },
                    select: function() {
                        editor.call('history:undo');
                    }
                },
                'redo': {
                    title: 'Redo',
                    icon: '&#57621;',
                    filter: function() {
                        return editor.call('history:canRedo');
                    },
                    select: function() {
                        editor.call('history:redo');
                    }
                },
                'enable': {
                    title: 'Enable',
                    icon: '&#57651;',
                    filter: function() {
                        if (! editor.call('permissions:write'))
                            return false;

                        return editor.call('selector:type') === 'entity';
                    },
                    hide: function () {
                        var type = editor.call('selector:type');
                        if (type !== 'entity')
                            return true;

                        var items = editor.call('selector:items');

                        if (items.length === 1) {
                            return items[0].get('enabled');
                        } else {
                            var enabled = items[0].get('enabled');
                            for(var i = 1; i < items.length; i++) {
                                if (enabled !== items[i].get('enabled'))
                                    return false;
                            }
                            return enabled;
                        }
                    },
                    select: function() {
                        setField(editor.call('selector:items'), 'enabled', true);
                    }
                },
                'disable': {
                    title: 'Disable',
                    icon: '&#57650;',
                    filter: function() {
                        if (! editor.call('permissions:write'))
                            return false;

                        return editor.call('selector:type') === 'entity';
                    },
                    hide: function () {
                        var type = editor.call('selector:type');
                        if (type !== 'entity')
                            return true;

                        var items = editor.call('selector:items');

                        if (items.length === 1) {
                            return ! items[0].get('enabled');
                        } else {
                            var disabled = items[0].get('enabled');
                            for(var i = 1; i < items.length; i++) {
                                if (disabled !== items[i].get('enabled'))
                                    return false;
                            }
                            return ! disabled;
                        }
                    },
                    select: function() {
                        setField(editor.call('selector:items'), 'enabled', false);
                    }
                },
                'copy': {
                    title: 'Copy',
                    icon: '&#58193;',
                    filter: function () {
                        if (! editor.call('permissions:write'))
                            return false;

                        return editor.call('selector:type') === 'entity' && editor.call('selector:items').length;
                    },
                    select: function () {
                        var items = editor.call('selector:items');
                        editor.call('entities:copy', items);
                    }
                },
                'paste': {
                    title: 'Paste',
                    icon: '&#58184;',
                    filter: function () {
                        if (! editor.call('permissions:write'))
                            return false;

                        if (! editor.call('entities:clipboard:empty')) {
                            var items = editor.call('selector:items');
                            if (items.length === 0 || items.length === 1 && editor.call('selector:type') === 'entity') {
                                return true;
                            }
                        }

                        return false;
                    },
                    select: function () {
                        var items = editor.call('selector:items');
                        editor.call('entities:paste', items[0]);
                    }
                },
                'edit': {
                    title: 'Edit',
                    icon: '&#57648;',
                    filter: function() {
                        var type = editor.call('selector:type');
                        if (! type || type !== 'asset')
                            return false;

                        var items = editor.call('selector:items');
                        return items.length === 1 && ['html', 'css', 'json', 'text', 'script', 'shader'].indexOf(items[0].get('type')) !== -1;
                    },
                    select: function() {
                        var type = editor.call('selector:type');
                        if (! type || type !== 'asset') return;
                        var items = editor.call('selector:items');

                        editor.call('assets:edit', items[0]);
                    }
                },
                'duplicate': {
                    title: 'Duplicate',
                    icon: '&#57638;',
                    filter: function() {
                        if (! editor.call('permissions:write'))
                            return false;

                        var type = editor.call('selector:type');
                        if (! type)
                            return false;

                        var items = editor.call('selector:items');

                        if (type === 'entity') {
                            if (items.indexOf(editor.call('entities:root')) !== -1)
                                return false;

                            return items.length > 0;
                        } else if (type === 'asset') {
                            return items.length === 1 && items[0].get('type') === 'material';
                        } else {
                            return false;
                        }
                    },
                    select: function() {
                        var type = editor.call('selector:type');
                        if (! type) return;
                        var items = editor.call('selector:items');

                        if (type === 'entity') {
                            editor.call('entities:duplicate', items);
                        } else if (type === 'asset') {
                            editor.call('assets:duplicate', items[0]);
                        }
                    }
                },
                'delete': {
                    title: 'Delete',
                    icon: '&#57636;',
                    filter: function() {
                        if (! editor.call('permissions:write'))
                            return false;

                        var type = editor.call('selector:type');
                        if (!type) return false;

                        if (type === 'entity') {
                            var root = editor.call('entities:root');
                            var items = editor.call('selector:items');
                            for (var i = 0; i < items.length; i++) {
                                if (items[i] === root) {
                                    return false;
                                }
                            }
                        }

                        return true;
                    },
                    select: function() {
                        var type = editor.call('selector:type');
                        if (! type) return;
                        var items = editor.call('selector:items');

                        if (type === 'entity') {
                            var root = editor.call('entities:root');
                            if (items.indexOf(root) !== -1)
                                return;
                            editor.call('entities:delete', items);
                        } else if (type === 'asset') {
                            editor.call('assets:delete:picker', items);
                        }
                    }
                }
            }
        },
        'launch': {
            title: 'Launch',
            select: function() {
                editor.call('launch');
            },
            items: {
                'launch-remote': {
                    title: 'Launch',
                    icon: '&#57649;',
                    select: function() {
                        editor.call('launch', 'default');
                    }
                }
            }
        },
        'help': {
            title: 'Help',
            items: {
                'controls': {
                    title: 'Controls',
                    icon: '&#57654;',
                    select: function() {
                        editor.call('help:controls');
                    }
                },
                'reference': {
                    title: 'Reference',
                    icon: '&#57906;',
                    select: function() {
                        window.open('http://developer.playcanvas.com/en/engine/api/stable/');
                    }
                },
                'learn': {
                    title: 'Learn',
                    icon: '&#57906;',
                    select: function() {
                        window.open('http://developer.playcanvas.com/en/');
                    }
                },
                'forum': {
                    title: 'Forum',
                    icon: '&#57907;',
                    select: function() {
                        window.open('http://forum.playcanvas.com/');
                    }
                },
                'answers': {
                    title: 'Answers',
                    icon: '&#57656;',
                    select: function() {
                        window.open('http://answers.playcanvas.com/');
                    }
                },
                'howdoi': {
                    title: 'How do I...',
                    icon: '&#57656;',
                    select: function () {
                        editor.call('help:howdoi');
                    }
                },
                'resetTips': {
                    title: 'Reset Tips',
                    icon: '&#57656;',
                    select: function () {
                        editor.call('editor:tips:reset');
                    }
                }
            }
        },
        'scenes': {
            title: 'Scenes',
            icon: '&#57671;',
            select: function() {
                editor.call('picker:scene');
            }
        },
        'publishing': {
            title: 'Publishing',
            icon: '&#57911;',
            select: function() {
                editor.call('picker:publish');
            }
        },
        'bake': {
            title: 'Bake LightMaps',
            icon: '&#57745;',
            select: function() {
                editor.call('lightmapper:bake');
                editor.call('entities:shadows:update');
            }
        },
        'code-editor': {
            title: 'Code Editor',
            icon: '&#57648;',
            hide: function () {
                return editor.call('settings:project').get('useLegacyScripts');
            },
            select: function () {
                editor.call('picker:codeeditor');
            }
        },
        'settings': {
            title: 'Settings',
            icon: '&#57652;',
            filter: function() {
                return editor.call('selector:type') !== 'editorSettings' && ! editor.call('viewport:expand:state');
            },
            select: function() {
                editor.call('selector:set', 'editorSettings', [ editor.call('settings:projectUser') ]);
            }
        },
        'priorityScripts': null,
        'feedback': {
            title: 'Feedback',
            icon: '&#57625;',
            select: function() {
                window.open('http://forum.playcanvas.com/t/playcanvas-editor-feedback/616');
            }
        }
    };

    if (legacyScripts) {
        menuData['entity']['items']['add-builtin-script'] = {
            title: 'Add Built-In Script',
            filter: function () {
                return editor.call('selector:type') === 'entity';
            },
            items: {
                'post-effects': {
                    title: 'Post-Effects',
                    filter: function () {
                        return editor.call('selector:type') === 'entity';
                    },
                    items: {}
                },
                'camera-scripts': {
                    title: 'Camera',
                    filter: function () {
                        return editor.call('selector:type') === 'entity';
                    },
                    items: {}
                }
            }
        };

        menuData['priorityScripts'] = {
            title: 'Script Priority',
            icon: '&#57652;',
            filter: function() {
                return editor.call('permissions:write');
            },
            select: function() {
                editor.call('sceneSettings:priorityScripts');
            }
        };
    } else {
        // TODO scripts2
        // add built-in-scripts for new system

        menuData['priorityScripts'] = {
            title: 'Scripts Loading Order',
            icon: '&#57652;',
            filter: function() {
                return editor.call('permissions:write');
            },
            select: function() {
                editor.call('selector:set', 'editorSettings', [ editor.call('settings:projectUser') ]);
                setTimeout(function() {
                    editor.call('editorSettings:panel:unfold', 'scripts-order');
                }, 0);
            }
        };
    }

    var makeMenuComponentItem = function(key) {
        var data = {
            title: components[key].title,
            icon: componentsLogos[key],
            filter: function() {
                if (editor.call('selector:type') !== 'entity')
                    return false;

                var items = editor.call('selector:items');
                var path = 'components.' + key;

                for (var i = 0, len = items.length; i < len; i++) {
                    if (! items[i].has(path))
                        return true;
                }

                return false;
            },
            select: function() {
                if (editor.call('selector:type') !== 'entity')
                    return;

                var items = editor.call('selector:items');
                var component = this._value;

                editor.call('entities:addComponent', items, component);
            }
        };

        if (key === 'audiosource') {
            data.hide = function () {
                return !editor.call('settings:project').get('useLegacyAudio');
            };
        }

        return data;
    };

    var components = editor.call('components:schema');
    var list = editor.call('components:list');
    for(var i = 0; i < list.length; i++) {
        var key = list[i];
        menuData['entity'].items['add-component'].items[key] = makeMenuComponentItem(key);
    }

    if (legacyScripts) {
        var builtInScripts = [{
            group: 'post-effects',
            title: 'Bloom',
            name: 'posteffect-bloom',
            url: 'https://code.playcanvas.com/posteffects/posteffect_bloom.js',
            requires: 'camera'
        }, {
            group: 'post-effects',
            title: 'Bloom',
            name: 'posteffect-bloom',
            url: 'https://code.playcanvas.com/posteffects/posteffect_bloom.js',
            requires: 'camera'
        }, {
            group: 'post-effects',
            title: 'Bloom',
            name: 'posteffect-bloom',
            url: 'https://code.playcanvas.com/posteffects/posteffect_bloom.js',
            requires: 'camera'
        }, {
            group: 'post-effects',
            title: 'Brightness-Contrast',
            name: 'posteffect-brightnesscontrast',
            url: 'https://code.playcanvas.com/posteffects/posteffect_brightnesscontrast.js',
            requires: 'camera'
        }, {
            group: 'post-effects',
            title: 'Hue-Saturation',
            name: 'posteffect-huesaturation',
            url: 'https://code.playcanvas.com/posteffects/posteffect_huesaturation.js',
            requires: 'camera'
        }, {
            group: 'post-effects',
            title: 'FXAA',
            name: 'posteffect-fxaa',
            url: 'https://code.playcanvas.com/posteffects/posteffect_fxaa.js',
            requires: 'camera'
        }, {
            group: 'post-effects',
            title: 'Sepia',
            name: 'posteffect-sepia',
            url: 'https://code.playcanvas.com/posteffects/posteffect_sepia.js',
            requires: 'camera'
        }, {
            group: 'post-effects',
            title: 'Vignette',
            name: 'posteffect-vignette',
            url: 'https://code.playcanvas.com/posteffects/posteffect_vignette.js',
            requires: 'camera'
        }, {
            group: 'camera-scripts',
            title: 'Fly Camera',
            name: 'camera-fly',
            url: 'https://code.playcanvas.com/camera/camera_fly.js',
            requires: 'camera'
        }];

        builtInScripts.forEach(function (data) {
            menuData['entity'].items['add-builtin-script'].items[data.group].items[data.name] = {
                title: data.title,
                filter: function () {
                    var entity = editor.call('selector:items')[0];

                    return editor.call('selector:type') === 'entity' &&
                        editor.call('permissions:write') &&
                        !hasLegacyScript(entity, data.url) &&
                        (!data.requires || entity.get('components.' + data.requires));
                },
                select: function () {
                    var entity = editor.call('selector:items')[0];
                    addBultinLegacyScript(entity, data.url);
                }
            };
        });
    }

    var root = editor.call('layout.root');

    var menu = ui.Menu.fromData(menuData);
    menu.position(45, 0);
    root.append(menu);

    var tooltip = Tooltip.attach({
        target: logo.element,
        text: 'Menu',
        align: 'left',
        root: root
    });
    menu.on('open', function(state) {
        tooltip.disabled = state;
    });

    // get part of menu data
    editor.method('menu:get', function (name) {
        return menuData[name];
    });
});


/* editor/toolbar/toolbar-editor-settings.js */
editor.once('load', function() {
    'use strict';

    var toolbar = editor.call('layout.toolbar');

    // settings button
    var button = new ui.Button({
        text: '&#57652;'
    });
    button.class.add('pc-icon', 'editor-settings');
    toolbar.append(button);

    button.on('click', function() {
        editor.call('selector:set', 'editorSettings', [ editor.call('settings:projectUser') ]);
    });

    editor.on('attributes:clear', function() {
        button.class.remove('active');
    });

    editor.on('attributes:inspect[editorSettings]', function() {
        editor.call('attributes.rootPanel').folded = false;

        button.class.add('active');
    });

    editor.on('viewport:expand', function(state) {
        button.disabled = state;
    });

    Tooltip.attach({
        target: button.element,
        text: 'Settings',
        align: 'left',
        root: editor.call('layout.root')
    });
});


/* editor/toolbar/toolbar-contact.js */
editor.once('load', function() {
    'use strict';

    var toolbar = editor.call('layout.toolbar');

    var contact = new ui.Button({
        text: '&#57625;'
    });
    contact.class.add('pc-icon', 'contact');
    toolbar.append(contact);

    Tooltip.attach({
        target: contact.element,
        text: 'Feedback',
        align: 'left',
        root: editor.call('layout.root')
    });

    contact.on('click', function() {
        window.open('http://forum.playcanvas.com/t/playcanvas-editor-feedback/616');
    });
});


/* editor/toolbar/toolbar-controls.js */
editor.once('load', function() {
    'use strict';

    var toolbar = editor.call('layout.toolbar');

    var button = new ui.Button({
        text: '&#57654;'
    });
    button.class.add('pc-icon', 'help-controls');
    toolbar.append(button);

    button.on('click', function() {
        editor.call('help:controls');
    });

    editor.on('help:controls:open', function () {
        button.class.add('active');
    });

    editor.on('help:controls:close', function () {
        button.class.remove('active');
    });

    Tooltip.attach({
        target: button.element,
        text: 'Controls',
        align: 'left',
        root: editor.call('layout.root')
    });
});


/* editor/toolbar/toolbar-help.js */
editor.once('load', function() {
    'use strict';

    var toolbar = editor.call('layout.toolbar');

    var button = new ui.Button({
        text: '&#57656;'
    });
    button.class.add('pc-icon', 'help-howdoi');
    toolbar.append(button);

    button.on('click', function() {
        editor.call('help:howdoi:toggle');
    });

    editor.on('help:howdoi:open', function () {
        button.class.add('active');
    });

    editor.on('help:howdoi:close', function () {
        button.class.remove('active');
    });

    Tooltip.attach({
        target: button.element,
        text: 'How do I...?',
        align: 'left',
        root: editor.call('layout.root')
    });
});


/* editor/toolbar/toolbar-gizmos.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var toolbar = editor.call('layout.toolbar');

    var activeGizmo = null;
    var gizmoButtons = { };

    // create gizmo type buttons
    [{
        icon: '&#57617;',
        tooltip: 'Translate',
        op: 'translate'
    }, {
        icon: '&#57619;',
        tooltip: 'Rotate',
        op: 'rotate'
    }, {
        icon: '&#57618;',
        tooltip: 'Scale',
        op: 'scale'
    }, {
        icon: '&#57666;',
        tooltip: 'Resize Element Component',
        op: 'resize'
    }].forEach(function (item, index) {
        var button = new ui.Button({
            text: item.icon
        });
        button.hidden = ! editor.call('permissions:write');
        button.op = item.op;
        button.class.add('pc-icon');

        gizmoButtons[item.op] = button;

        button.on('click', function () {
            if (activeGizmo.op === this.op)
                return;

            activeGizmo.class.remove('active');
            activeGizmo.tooltip.class.add('innactive');
            activeGizmo = this;
            activeGizmo.class.add('active');
            activeGizmo.tooltip.class.remove('innactive');

            editor.call('gizmo:type', this.op);
        });

        toolbar.append(button);

        button.tooltip = Tooltip.attach({
            target: button.element,
            text: item.tooltip,
            align: 'left',
            root: root
        });

        if (item.op === 'translate') {
            activeGizmo = button;
            button.class.add('active');
        } else {
            button.tooltip.class.add('innactive');
        }
    });

    // coordinate system
    var buttonWorld = new ui.Button({
        text: '&#57624;'
    });
    buttonWorld.hidden = ! editor.call('permissions:write');
    buttonWorld.class.add('pc-icon', 'active');
    toolbar.append(buttonWorld);

    buttonWorld.on('click', function () {
        if (this.class.contains('active')) {
            this.class.remove('active');
            tooltipWorld.html = 'World / <span style="color:#fff">Local</span>';
        } else {
            this.class.add('active');
            tooltipWorld.html = '<span style="color:#fff">World</span> / Local';
        }
        editor.call('gizmo:coordSystem', this.class.contains('active') ? 'world' : 'local');
    });

    var tooltipWorld = Tooltip.attach({
        target: buttonWorld.element,
        align: 'left',
        root: root
    });
    tooltipWorld.html = '<span style="color:#fff">World</span> / Local';
    tooltipWorld.class.add('innactive');


    // toggle grid snap
    var buttonSnap = new ui.Button({
        text: '&#57622;'
    });
    buttonSnap.hidden = ! editor.call('permissions:write');
    buttonSnap.class.add('pc-icon');
    buttonSnap.on('click', function () {
        if (this.class.contains('active')) {
            this.class.remove('active');
            tooltipSnap.class.add('innactive');
        } else {
            this.class.add('active');
            tooltipSnap.class.remove('innactive');
        }
        editor.call('gizmo:snap', this.class.contains('active'));
    });
    toolbar.append(buttonSnap);

    var tooltipSnap = Tooltip.attach({
        target: buttonSnap.element,
        text: 'Snap',
        align: 'left',
        root: root
    });
    tooltipSnap.class.add('innactive');


    editor.on('permissions:writeState', function(state) {
        for(var key in gizmoButtons) {
            gizmoButtons[key].hidden = ! state;
        }

        buttonWorld.hidden = ! state;
        buttonSnap.hidden = ! state;
    });


    // focus on entity
    var buttonFocus = new ui.Button({
        text: '&#57623;'
    });
    buttonFocus.disabled = true;
    buttonFocus.class.add('pc-icon');
    buttonFocus.on('click', function() {
        editor.call('viewport:focus');
    });
    toolbar.append(buttonFocus);

    editor.on('attributes:clear', function() {
        buttonFocus.disabled = true;
        tooltipFocus.class.add('innactive');
    });
    editor.on('attributes:inspect[*]', function(type) {
        buttonFocus.disabled = type !== 'entity';
        if (type === 'entity') {
            tooltipFocus.class.remove('innactive');
        } else {
            tooltipFocus.class.add('innactive');
        }
    });

    var tooltipFocus = Tooltip.attach({
        target: buttonFocus.element,
        text: 'Focus',
        align: 'left',
        root: root
    });
    tooltipFocus.class.add('innactive');


    // translate hotkey
    editor.call('hotkey:register', 'gizmo:translate', {
        key: '1',
        callback: function() {
            gizmoButtons['translate'].emit('click');
        }
    });

    // rotate hotkey
    editor.call('hotkey:register', 'gizmo:rotate', {
        key: '2',
        callback: function() {
            gizmoButtons['rotate'].emit('click');
        }
    });

    // scale hotkey
    editor.call('hotkey:register', 'gizmo:scale', {
        key: '3',
        callback: function() {
            gizmoButtons['scale'].emit('click');
        }
    });

    // resize hotkey
    editor.call('hotkey:register', 'gizmo:resize', {
        key: '4',
        callback: function() {
            gizmoButtons['resize'].emit('click');
        }
    });

    // world/local hotkey
    editor.call('hotkey:register', 'gizmo:world', {
        key: 'l',
        callback: function() {
            buttonWorld.emit('click');
        }
    });

    // focus
    editor.call('hotkey:register', 'viewport:focus', {
        key: 'f',
        callback: function() {
            editor.call('viewport:focus');
        }
    });
});





/* editor/toolbar/toolbar-history.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var toolbar = editor.call('layout.toolbar');


    // undo
    var buttonUndo = new ui.Button({
        text: '&#57620;'
    });
    buttonUndo.hidden = ! editor.call('permissions:write');
    buttonUndo.class.add('pc-icon');
    buttonUndo.enabled = editor.call('history:canUndo');
    toolbar.append(buttonUndo);

    editor.on('history:canUndo', function(state) {
        buttonUndo.enabled = state;
        if (state) {
            tooltipUndo.class.remove('innactive');
        } else {
            tooltipUndo.class.add('innactive');
        }
    });
    buttonUndo.on('click', function() {
        editor.call('history:undo');
    });

    var tooltipUndo = Tooltip.attach({
        target: buttonUndo.element,
        text: 'Undo',
        align: 'left',
        root: root
    });
    if (! editor.call('history:canUndo'))
        tooltipUndo.class.add('innactive');


    // redo
    var buttonRedo = new ui.Button({
        text: '&#57621;'
    });
    buttonRedo.hidden = ! editor.call('permissions:write');
    buttonRedo.class.add('pc-icon');
    buttonRedo.enabled = editor.call('history:canRedo');
    toolbar.append(buttonRedo);

    editor.on('history:canRedo', function(state) {
        buttonRedo.enabled = state;
        if (state) {
            tooltipRedo.class.remove('innactive');
        } else {
            tooltipRedo.class.add('innactive');
        }
    });
    buttonRedo.on('click', function() {
        editor.call('history:redo');
    });

    var tooltipRedo = Tooltip.attach({
        target: buttonRedo.element,
        text: 'Redo',
        align: 'left',
        root: root
    });
    if (! editor.call('history:canUndo'))
        tooltipRedo.class.add('innactive');

    editor.on('permissions:writeState', function(state) {
        buttonUndo.hidden = buttonRedo.hidden = ! state;
    });
});





/* editor/toolbar/toolbar-lightmapper.js */
editor.once('load', function() {
    'use strict';

    var app;
    var root = editor.call('layout.root');
    var toolbar = editor.call('layout.toolbar');

    // coordinate system
    var buttonBake = new ui.Button({
        text: '&#57745;'
    });
    buttonBake.class.add('pc-icon', 'light-mapper');
    toolbar.append(buttonBake);

    buttonBake.on('click', function () {
        editor.call('lightmapper:bake');
        editor.call('entities:shadows:update');
    });
    editor.on('lightmapper:uv1Missing', function(state) {
        if (state) {
            buttonBake.class.add('active');
        } else {
            buttonBake.class.remove('active');
        }
    });


    // tooltip
    var tooltipBake = Tooltip.attach({
        target: buttonBake.element,
        align: 'left',
        root: root
    });
    tooltipBake.class.add('light-mapper');
    tooltipBake.hoverable = true;


    // header
    var elHeader = document.createElement('span');
    elHeader.classList.add('header');
    elHeader.textContent = 'Light Mapper';
    tooltipBake.innerElement.appendChild(elHeader);


    // auto toggle
    var elAuto = document.createElement('div');

    if (! editor.call('permissions:write'))
        elAuto.style.display = 'none';

    editor.on('permissions:writeState', function(state) {
        if (state) {
            elAuto.style.display = '';
        } else {
            elAuto.style.display = 'none';
        }
    });

    elAuto.classList.add('auto-toggle');
    tooltipBake.innerElement.appendChild(elAuto);

    var checkAuto = new ui.Checkbox();
    checkAuto.class.add('tick');
    checkAuto.parent = tooltipBake;
    elAuto.appendChild(checkAuto.element);
    editor.on('lightmapper:auto', function(state) {
        checkAuto.value = state;
    });
    checkAuto.on('change', function(value) {
        editor.call('lightmapper:auto', value);
    });

    var labelAuto = new ui.Label({ text: 'Auto Rebake' });
    labelAuto.parent = tooltipBake;
    elAuto.appendChild(labelAuto.element);



    // uv1 missing
    var elUV1 = document.createElement('div');
    elUV1.classList.add('uv1');
    elUV1.textContent = 'UV1 is missing on some models. Please upload models with UV1 or use ';
    tooltipBake.innerElement.appendChild(elUV1);

    var btnAutoUnwrap = new ui.Button({
        text: 'Auto-Unwrap'
    });
    btnAutoUnwrap.parent = tooltipBake;
    elUV1.appendChild(btnAutoUnwrap.element);
    btnAutoUnwrap.on('click', function() {
        if (! uv1Missing)
            return;

        var assetIds = Object.keys(uv1MissingAssets);
        for(var i = 0; i < assetIds.length; i++) {
            if (! uv1MissingAssets.hasOwnProperty(assetIds[i]))
                continue;

            var asset = uv1MissingAssets[assetIds[i]];
            editor.call('assets:model:unwrap', asset);
        }
    });


    // hotkey ctrl+b
    editor.call('hotkey:register', 'lightmapper:bake', {
        key: 'b',
        ctrl: true,
        callback: function() {
            editor.call('lightmapper:bake');
            editor.call('entities:shadows:update');
        }
    });


    // manage if uv1 is missing
    var uv1Missing = false;
    var uv1MissingAssets = { };

    editor.on('assets:model:unwrap', function(asset) {
        if (! uv1MissingAssets[asset.get('id')])
            return;

        delete uv1MissingAssets[asset.get('id')];
        editor.call('lightmapper:uv1missing', uv1MissingAssets);
    })

    editor.method('lightmapper:uv1missing', function(assets) {
        if (assets === undefined)
            return uv1Missing;

        uv1MissingAssets = assets;

        var state = Object.keys(assets).length !== 0

        if (uv1Missing === state)
            return;

        uv1Missing = state;
        editor.emit('lightmapper:uv1Missing', uv1Missing);
    });

    tooltipBake.on('show', function() {
        if (uv1Missing) {
            elUV1.classList.remove('hidden');
        } else {
            elUV1.classList.add('hidden');
        }
    });
});


/* editor/toolbar/toolbar-publish.js */
editor.once('load', function() {
    'use strict';

    var toolbar = editor.call('layout.toolbar');

    var button = new ui.Button({
        text: '&#57911;'
    });
    button.class.add('pc-icon', 'publish-download');
    toolbar.append(button);

    button.on('click', function() {
        editor.call('picker:publish');
    });

    editor.on('picker:publish:open', function () {
        button.class.add('active');
    });

    editor.on('picker:publish:close', function () {
        button.class.remove('active');
    });

    Tooltip.attach({
        target: button.element,
        text: 'Publish / Download',
        align: 'left',
        root: editor.call('layout.root')
    });
});


/* editor/toolbar/toolbar-code-editor.js */
editor.once('load', function() {
    'use strict';

    if (editor.call('settings:project').get('useLegacyScripts'))
        return;

    var toolbar = editor.call('layout.toolbar');
    var firefox = navigator.userAgent.indexOf('Firefox') !== -1;

    var button = new ui.Button({
        text: '&#57648;'
    });
    button.class.add('pc-icon');

    var publishButton = toolbar.innerElement.querySelector('.publish-download');
    toolbar.appendBefore(button, publishButton);

    button.on('click', function() {
        editor.call('picker:codeeditor');
    });

    editor.method('picker:codeeditor', function (asset) {
        // open the new code editor - try to focus existing tab if it exists
        // (only works in Chrome and only if the Code Editor has been opened by the Editor)

        var url = '/editor/code/' + config.project.id;
        if (asset) {
            url += '?tabs=' + asset.get('id');
        }
        var name = 'codeeditor:' + config.project.id;

        if (firefox) {
            // (Firefox doesn't work at all so open a new tab everytime)
            window.open(url);
        } else {
            var wnd = window.open('', name);
            try {
                if (wnd.editor && wnd.editor.isCodeEditor) {
                    if (asset) {
                        wnd.editor.call('integration:selectWhenReady', asset.get('id'));
                    }
                } else {
                    wnd.location = url;
                }
            } catch (ex) {
                // accessing wnd will throw an exception if it
                // is at a different domain
                window.open(url, name);
            }

        }
    });

    Tooltip.attach({
        target: button.element,
        text: 'Code Editor',
        align: 'left',
        root: editor.call('layout.root')
    });

    editor.call('hotkey:register', 'code-editor', {
        key: 'i',
        ctrl: true,
        callback: function () {
            editor.call('picker:codeeditor');
        }
    });
});


/* editor/toolbar/toolbar-scene.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var viewport = editor.call('layout.viewport');

    var panel = new ui.Panel();
    panel.class.add('widget-title');
    viewport.append(panel);

    editor.method('layout.toolbar.scene', function () {
        return panel;
    });

    var projectName = new ui.Label();
    projectName.text = config.project.name;
    projectName.class.add('project-name');
    projectName.renderChanges = false;
    panel.append(projectName);

    projectName.on('click', function (argument) {
        window.open('/project/' + config.project.id, '_blank');
    });

    Tooltip.attach({
        target: projectName.element,
        text: 'Project',
        align: 'top',
        root: root
    });

    var sceneName = new ui.Label();
    sceneName.class.add('scene-name');
    sceneName.renderChanges = false;
    panel.append(sceneName);

    Tooltip.attach({
        target: sceneName.element,
        text: 'Settings',
        align: 'top',
        root: root
    });

    editor.on('scene:name', function(name) {
        sceneName.text = name;
    });

    sceneName.on('click', function() {
        editor.call('selector:set', 'editorSettings', [ editor.call('settings:projectUser') ]);
    });

    editor.on('attributes:clear', function() {
        sceneName.class.remove('active');
    });

    editor.on('attributes:inspect[editorSettings]', function() {
        sceneName.class.add('active');
    });

    editor.on('scene:unload', function () {
        sceneName.text = '';
    });

    var sceneList = new ui.Label();
    sceneList.class.add('scene-list');
    panel.append(sceneList);

    Tooltip.attach({
        target: sceneList.element,
        text: 'Manage Scenes',
        align: 'top',
        root: root
    });

    sceneList.on('click', function () {
        editor.call('picker:scene');
    });

    editor.on('picker:scene:open', function () {
        sceneList.class.add('active');
    });

    editor.on('picker:scene:close', function () {
        sceneList.class.remove('active');
    });
});


/* editor/toolbar/toolbar-launch.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var viewport = editor.call('layout.viewport');
    var legacyScripts = editor.call('settings:project').get('useLegacyScripts');

    var settings = editor.call('settings:projectUser');
    var privateSettings = editor.call('settings:projectPrivate');

    // panel
    var panel = new ui.Panel();
    panel.class.add('top-controls');
    viewport.append(panel);

    editor.method('layout.toolbar.launch', function () {
        return panel;
    });

    // launch
    var launch = new ui.Panel();
    launch.class.add('launch');
    panel.append(launch);
    launch.disabled = true;

    editor.on('scene:load', function () {
        launch.disabled = false;
    });

    editor.on('scene:unload', function () {
        launch.disabled = true;
    });

    var buttonLaunch = new ui.Button({
        text: '&#57649;'
    });
    buttonLaunch.class.add('icon');
    launch.append(buttonLaunch);

    var launchApp = function () {
        var url = config.url.launch + config.scene.id;

        var query = [ ];

        if (launchOptions.local) {
            url = url.replace(/^https/, 'http');
            query.push('local=' + settings.get('editor.localServer'));
        }

        if (launchOptions.webgl1)
            query.push('webgl1=true');

        if (launchOptions.profiler)
            query.push('profile=true');

        if (launchOptions.debug)
            query.push('debug=true');

        if (!launchOptions.local && launchOptions.facebook && privateSettings.get('facebook.appId')) {
            url = 'https://www.facebook.com/embed/instantgames/' +
                privateSettings.get('facebook.appId') +
                '/player?game_url=' +
                url;

            query.push('facebook=true');
        }

        if (query.length)
            url += '?' + query.join('&');

        var launcher = window.open();
        launcher.opener = null;
        launcher.location = url;
    };

    buttonLaunch.on('click', launchApp);

    var tooltip = Tooltip.attach({
        target: launch.element,
        text: 'Launch',
        root: root
    });

    var layoutRight = editor.call('layout.right');

    var launchOptions = { };

    var panelOptions = new ui.Panel();
    panelOptions.class.add('options');
    launch.append(panelOptions);
    panelOptions.hidden = true;

    var createOption = function (name, title) {
        var panel = new ui.Panel();
        panelOptions.append(panel);

        var option = new ui.Checkbox();
        option.value = false;
        option.class.add('tick');
        panel.append(option);

        option.on('click', function (e) {
            e.stopPropagation();
        });

        var label = new ui.Label({text: title});
        panel.append(label);

        panel.on('click', function () {
            option.value = !option.value;
        });

        launchOptions[name] = false;
        option.on('change', function (value) {
            launchOptions[name] = value;
        });

        return option;
    };

    var optionProfiler = createOption('profiler', 'Profiler');
    var tooltipProfiler = Tooltip.attach({
        target: optionProfiler.parent.element,
        text: 'Enable to include panel for profiling Frame, Scene and Timeline data.',
        align: 'right',
        root: root
    });
    tooltipProfiler.class.add('launch-tooltip');

    var optionDebug = createOption('debug', 'Debug');

    var suspendDebug = false;
    optionDebug.value = settings.get('editor.launchDebug');
    settings.on('editor.launchDebug:set', function (value) {
        suspendDebug = true;
        optionDebug.value = value;
        suspendDebug = false;
    });
    optionDebug.on('change', function (value) {
        if (suspendDebug) return;
        settings.set('editor.launchDebug', value);
    });

    var tooltipDebug = Tooltip.attach({
        target: optionDebug.parent.element,
        text: 'Enable to ensure engine logs warnings and errors to be addressed during development.',
        align: 'right',
        root: root
    });
    tooltipDebug.class.add('launch-tooltip');


    if (legacyScripts) {
        var local = createOption('local', 'Use Local Server');
        local.on('change', function (value) {
            fb.parent.disabled = value;
        });

        var getTooltipText = function () {
            var tooltipText = 'Enable this if you want to load scripts from your local server.';
            if (settings.get('editor.localServer')) {
                tooltipText +=  ' If enabled scripts will be loaded from <a href="' +
                    settings.get('editor.localServer') + '" target="_blank">' + settings.get('editor.localServer') + '</a>.';
            }

            tooltipText += ' You can change your Local Server URL from the Editor settings.';
            return tooltipText;
        };

        settings.on('editor.localServer:set', function () {
            tooltipLocal.html = getTooltipText();
        });

        var tooltipLocal = Tooltip.attach({
            target: local.parent.element,
            html: getTooltipText(),
            align: 'right',
            root: root
        });

        tooltipLocal.class.add('launch-tooltip');
    }

    var preferWebGl1 = createOption('webgl1', 'Prefer WebGL 1.0');

    var tooltipPreferWebGl1 = Tooltip.attach({
        target: preferWebGl1.parent.element,
        text: 'If WebGL 2.0 is preferred in Project Settings, for testing purposes WebGL 1.0 can be enforced.',
        align: 'right',
        root: root
    });
    tooltipPreferWebGl1.class.add('launch-tooltip');

    if (! editor.call('settings:project').get('preferWebGl2'))
        preferWebGl1.parent.disabled = true;

    editor.call('settings:project').on('preferWebGl2:set', function(value) {
        preferWebGl1.parent.disabled = ! value;
    });

    // facebook
    var fb = createOption('facebook', 'Launch on Facebook');

    if (!config.self.superUser && !config.self.publishFacebook)
        fb.parent.hidden = true;

    var tooltipFb = Tooltip.attach({
        target: fb.parent.element,
        text: 'In order to launch on Facebook you have to set your Facebook App ID in the settings.',
        align: 'right',
        root: root
    });
    tooltipFb.class.add('launch-tooltip');

    if (privateSettings.get('facebook.appId'))
        tooltipFb.class.add('invisible');

    privateSettings.on('facebook.appId:set', function (value) {
        if (value) {
            tooltipFb.class.add('invisible');
        } else {
            tooltipFb.class.remove('invisible');
        }
    });

    fb.on('change', function (value) {
        if (! value) return;

        if (! privateSettings.get('facebook.appId')) {
            editor.call('viewport:expand', false);

            // open facebook settings
            editor.call('selector:set', 'editorSettings', [ editor.call('settings:projectUser') ]);
            setTimeout(function() {
                editor.call('editorSettings:panel:unfold', 'facebook');
            }, 0);
        }
    });


    var onLaunchClick = function() {
        panelOptions.hidden = true;
        launchApp();
    };

    editor.method('launch', launchApp);

    editor.call('hotkey:register', 'launch', {
        key: 'enter',
        ctrl: true,
        callback: launchApp
    });


    var timeout;

    // show dropdown menu
    launch.element.addEventListener('mouseenter', function () {
        if (! editor.call('permissions:read') || launch.disabled)
            return;

        tooltip.align = (layoutRight && (layoutRight.hidden || layoutRight.folded)) ? 'right' : 'left';

        panelOptions.hidden = false;
        if (timeout)
            clearTimeout(timeout);
    });

    // hide dropdown menu after a delay
    launch.element.addEventListener('mouseleave', function () {
        if (! editor.call('permissions:write'))
            return;

        if (timeout) clearTimeout(timeout);
        timeout = setTimeout(function () {
            panelOptions.hidden = true;
            timeout = null;
        }, 50);
    });

    // cancel hide
    panel.element.addEventListener('mouseenter', function () {
        if (!panelOptions.hidden && timeout)
            clearTimeout(timeout);

    });

    // hide options after a while
    panel.element.addEventListener('mouseleave', function () {
        if (timeout) clearTimeout(timeout);
        timeout = setTimeout(function () {
            panelOptions.hidden = true;
            timeout = null;
        }, 50);
    });


    // fullscreen
    var buttonExpand = new ui.Button({
        text: '&#57639;'
    });
    buttonExpand.class.add('icon', 'expand');
    panel.append(buttonExpand);

    buttonExpand.on('click', function() {
        editor.call('viewport:expand');
    });
    editor.on('viewport:expand', function(state) {
        if (state) {
            tooltipExpand.text = 'Show Panels';
            buttonExpand.class.add('active');
        } else {
            tooltipExpand.text = 'Hide Panels';
            buttonExpand.class.remove('active');
        }

        tooltipExpand.hidden = true;
    });

    var tooltipExpand = Tooltip.attach({
        target: buttonExpand.element,
        text: 'Hide Panels',
        align: 'top',
        root: root
    });
});


/* editor/toolbar/toolbar-options.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var viewport = editor.call('layout.viewport');
    var controls = editor.call('layout.toolbar.launch');

    var panel = new ui.Panel();
    panel.class.add('modes');
    panel.hidden = true;
    controls.append(panel);


    // show collision
    var panelCollision = new ui.Panel();
    panelCollision.class.add('field');
    panel.append(panelCollision);
    // field
    var fieldCollisionVisible = new ui.Checkbox();
    fieldCollisionVisible.class.add('tick');
    panelCollision.append(fieldCollisionVisible);
    fieldCollisionVisible.value = editor.call('gizmo:collision:visible');
    fieldCollisionVisible.on('change', function(value) {
        editor.call('gizmo:collision:visible', value);
    });
    editor.on('gizmo:collision:visible', function(visible) {
        fieldCollisionVisible.value = visible;
    });
    // label
    var label = new ui.Label({
        text: 'Physics Edit Mode'
    });
    label.on('click', function() {
        fieldCollisionVisible.element.click();
    });
    panelCollision.append(label);


    // show zones
    var panelZones = new ui.Panel();
    panelZones.class.add('field');
    panel.append(panelZones);
    // field
    var fieldZonesVisible = new ui.Checkbox();
    fieldZonesVisible.class.add('tick');
    panelZones.append(fieldZonesVisible);
    fieldZonesVisible.value = editor.call('gizmo:zone:visible');
    fieldZonesVisible.on('change', function(value) {
        editor.call('gizmo:zone:visible', value);
    });
    editor.on('gizmo:zone:visible', function(visible) {
        fieldZonesVisible.value = visible;
    });
    // label
    var label = new ui.Label({
        text: 'Zones Edit Mode'
    });
    label.on('click', function() {
        fieldZonesVisible.element.click();
    });
    panelZones.append(label);



    // fullscreen
    var buttonOptions = new ui.Button({
        text: '&#57652;'
    });
    buttonOptions.class.add('icon', 'options');
    controls.append(buttonOptions);


    var timeout;

    var onHover = function() {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }

        panel.hidden = false;
    };

    var onBlur = function() {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }

        timeout = setTimeout(function() {
            panel.hidden = true;
            timeout = null;
        }, 50);
    };

    buttonOptions.element.addEventListener('mouseenter', function() {
        if (! editor.call('permissions:read') || buttonOptions.disabled)
            return;

        onHover();
    }, false);

    buttonOptions.element.addEventListener('mouseleave', function() {
        if (! editor.call('permissions:read'))
            return;

        onBlur();
    }, false);

    panel.element.addEventListener('mouseenter', function() {
        if (! panel.hidden)
            onHover();
    }, false);

    panel.element.addEventListener('mouseleave', function() {
        onBlur();
    }, false);
});


/* editor/toolbar/toolbar-cameras.js */
editor.once('viewport:load', function() {
    'use strict';

    var viewport = editor.call('layout.viewport');
    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var options = { };
    var index = { };
    var events = { };

    var combo = new ui.SelectField({
        options: options
    });
    combo.disabledClick = true;
    combo.class.add('viewport-camera');

    combo.on('open', function() {
        tooltip.disabled = true;
    });
    combo.on('close', function() {
        tooltip.disabled = false;
    });


    viewport.append(combo);

    combo.on('change', function(value) {
        var entity = app.root.findByGuid(value);
        editor.call('camera:set', entity);
    });

    var tooltip = Tooltip.attach({
        target: combo.element,
        text: 'Camera',
        align: 'top',
        root: editor.call('layout.root')
    });

    var refreshOptions = function() {
        combo._updateOptions(options);

        var writePermission = editor.call('permissions:write');
        for(var key in combo.optionElements) {
            if (index[key].__editorCamera)
                continue;

            if (writePermission) {
                combo.optionElements[key].classList.remove('hidden');
            } else {
                combo.optionElements[key].classList.add('hidden');
            }
        }
    };

    editor.on('permissions:writeState', refreshOptions);

    editor.on('camera:add', function(entity) {
        options[entity.getGuid()] = entity.name;
        index[entity.getGuid()] = entity;
        refreshOptions();

        if (events[entity.getGuid()])
            events[entity.getGuid()].unbind();

        var obj = editor.call('entities:get', entity.getGuid());
        if (obj) {
            events[entity.getGuid()] = obj.on('name:set', function (value) {
                options[entity.getGuid()] = value;
                refreshOptions();

                if (combo.value === entity.getGuid())
                    combo.elementValue.textContent = value;
            });
        }
    });

    editor.on('camera:remove', function(entity) {
        delete options[entity.getGuid()];
        refreshOptions();

        if (events[entity.getGuid()]) {
            events[entity.getGuid()].unbind();
            delete events[entity.getGuid()];
        }
    });

    editor.on('camera:change', function(entity) {
        combo.value = entity.getGuid();
    });
});


/* editor/toolbar/toolbar-whois.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var viewport = editor.call('layout.viewport');

    var panel = new ui.Panel();
    panel.class.add('whoisonline');
    viewport.append(panel);

    editor.on('viewport:expand', function(state) {
        if (state) {
            panel.class.add('expanded');
        } else {
            panel.class.remove('expanded');
        }
    });


    editor.on('whoisonline:add', function (id) {
        for(var i = 0; i < panel.innerElement.childNodes.length; i++) {
            var child = panel.innerElement.childNodes[i];
            if (child.userId === id)
                return;
        }

        var link = document.createElement('a');
        link.userId = id;
        link.href = '/' + id;
        link.target = "_blank";
        panel.append(link);

        var img = document.createElement('img');
        img.src = '/api/users/' + id + '/thumbnail?size=28';
        link.appendChild(img);

        link.tooltip = Tooltip.attach({
            target: link,
            text: '',
            align: 'bottom',
            root: root
        });

        editor.call('users:loadOne', id, function (user) {
            link.href = '/' + user.username;
            link.tooltip.text = user.username;
            link.style.backgroundColor = editor.call('whoisonline:color', user.id, 'hex');
        });
    });


    editor.on('whoisonline:remove', function (id, index) {
        for(var i = 0; i < panel.innerElement.childNodes.length; i++) {
            var child = panel.innerElement.childNodes[i];
            if (child.userId === id) {
                if (child.tooltip)
                    child.tooltip.destroy();
                panel.innerElement.removeChild(child);
                return;
            }
        }
    });


    editor.method('whoisonline:panel', function() {
        return panel;
    });

    var chatWidget = editor.call('chat:panel');
    if (chatWidget) {
        panel.class.add('chat-minified');

        chatWidget.on('fold', function() {
            panel.class.add('chat-minified');
        });
        chatWidget.on('unfold', function() {
            panel.class.remove('chat-minified');
        });

        if (! editor.call('permissions:read'))
            panel.class.add('no-chat');
    }

    editor.on('permissions:set', function(level) {
        if (level) {
            panel.class.remove('no-chat');
        } else {
            panel.class.add('no-chat');
        }
    });
});


/* editor/toolbar/toolbar-connection.js */
editor.once('load', function() {
    'use strict';

    var timeout;
    var viewportError = false;

    // overlay
    var overlay = new ui.Overlay();
    overlay.class.add('connection-overlay');
    overlay.center = false;
    overlay.transparent = false;
    overlay.clickable = false;
    overlay.hidden = true;

    var root = editor.call('layout.root');
    root.append(overlay);

    // icon
    var icon = document.createElement('div');
    icon.classList.add('connection-icon');
    overlay.innerElement.appendChild(icon);

    // content
    var content = document.createElement('div');
    content.classList.add('connection-content');
    overlay.innerElement.appendChild(content);

    editor.on('realtime:connected', function () {
        if (viewportError) return;

        overlay.hidden = true;
        clearIconClass();
    });

    editor.on('realtime:disconnected', function () {
        setIconClass('error');
        content.innerHTML = 'You have been disconnected from the server.';
        overlay.hidden = false;
    });

    editor.on('realtime:nextAttempt', function (time) {

        setIconClass('error');

        function setText (remaining) {
            content.innerHTML = 'Disconnected. Reconnecting in ' + remaining + ' seconds...';
        }

        var before = new Date();

        function renderTime () {
            var now = new Date();
            var elapsed = now.getTime() - before.getTime();
            before = now;
            time -= Math.round(elapsed / 1000);
            if (time < 0) {
                time = 0;
            } else {
                timeout = setTimeout(renderTime, 1000);
            }

            setText(time);
        }

        setText(time);

        timeout = setTimeout(renderTime, 1000);
    });

    editor.on('realtime:connecting', function (attempt) {
        if (viewportError) return;

        overlay.hidden = true;
        clearTimeout(timeout);
    });

    editor.on('realtime:cannotConnect', function () {
        overlay.hidden = false;
        clearTimeout(timeout);
        setIconClass('error');
        content.innerHTML = 'Cannot connect to the server. Please try again later.';
    });

    var onError = function (err) {
        console.log(err);
        console.trace();
        setIconClass('error');
        content.innerHTML = 'Error while saving changes. Please refresh the editor.';
        overlay.hidden = false;
    };

    editor.on('viewport:error', function(err) {
        viewportError = true;
        console.error(err);
        console.trace();
        setIconClass('error');
        content.innerHTML = 'Failed creating WebGL Context.<br />Please check <a href="http://webglreport.com/" target="_blank">WebGL Report</a> and report to <a href="http://forum.playcanvas.com/" target="_blank">Forum</a>.';
        overlay.hidden = false;
    });

    editor.on('realtime:error', onError);
    editor.on('realtime:scene:error', onError);
    editor.on('realtime:userdata:error', function (err) {
        console.error(err);
    });
    editor.on('realtime:assets:error', onError);

    editor.on('messenger:pack.delete', function (data) {
        if (config.scene.id && data.pack.id === parseInt(config.scene.id, 10)) {
            setIconClass('error');
            content.innerHTML = 'This scene has been deleted.';
            overlay.hidden = false;
        }
    });

    editor.on('scene:unload', function () {
        if (viewportError) return;

        overlay.hidden = true;
    });

    var clearIconClass = function () {
        icon.classList.remove('error');
    };

    var setIconClass = function (cls) {
        clearIconClass();
        icon.classList.add(cls);
    };
});


/* editor/toolbar/toolbar-usage.js */
editor.once('load', function () {
    'use strict';

    if (config.owner.plan.type !== 'free')
        return;

    var root = editor.call('layout.root');
    var panel = new ui.Panel();
    panel.class.add('usage');

    var label = new ui.Label();
    panel.append(label);

    var btnClose = new ui.Button({
        text: '&#57650;'
    });
    panel.append(btnClose);
    btnClose.class.add('close');
    btnClose.on('click', function () {
        panel.hidden = true;
    });

    var refreshUsage = function () {
        var diff = config.owner.diskAllowance - config.owner.size;
        var upgrade = '<a href="/upgrade" target="_blank">UPGRADE</a> to get more disk space.';
        if (diff > 0 && diff < 30000000) {
            label.text = 'You are close to your disk allowance limit. ' + upgrade;
            panel.hidden = false;
        } else if (diff < 0) {
            label.text = 'You are over your disk allowance limit. ' + upgrade;
            panel.hidden = false;
        } else {
            panel.hidden = true;
        }
    };

    root.append(panel);

    refreshUsage();

    editor.on('user:' + config.owner.id + ':usage', refreshUsage);
});

/* editor/toolbar/toolbar-script.js */
editor.once('load', function () {
    'use script';

    if (! editor.call('settings:project').get('useLegacyScripts'))
        return;

    var root = editor.call('layout.root');
    var overlay = new ui.Overlay();
    overlay.class.add('new-script');
    overlay.clickable = true;
    overlay.hidden = true;
    root.append(overlay);

    var panel = new ui.Panel();
    overlay.append(panel);

    var label = new ui.Label({
        text: 'Enter script name and press Enter:'
    });
    label.class.add('action');
    panel.append(label);

    var fieldName = new ui.TextField();
    fieldName.blurOnEnter = false;
    fieldName.renderChanges = false;
    panel.append(fieldName);

    var fieldError = new ui.Label();
    fieldError.renderChanges = false;
    fieldError.class.add('error');
    panel.append(fieldError);
    fieldError.hidden = true;

    var newContent = '';
    var creating = false;

    // close overlay on esc
    var onKey = function (e) {
        if (e.keyCode === 27) {
            overlay.hidden = true;
        }
    };

    overlay.on('show', function () {
        editor.emit('sourcefiles:new:open');
        window.addEventListener('keydown', onKey);
        setTimeout(function () {
            fieldName.elementInput.focus();
        }, 100);
    });

    overlay.on('hide', function () {
        window.removeEventListener('keydown', onKey);
        fieldName.value = '';
        fieldError.hidden = true;
        fieldError.text = '';
        newContent = '';
        creating = false;
        editor.emit('sourcefiles:new:close');

    });

    editor.method('sourcefiles:new', function (content) {
        newContent = content;
        overlay.hidden = false;
    });

    var onError = function (error) {
        fieldError.text = error;
        fieldError.hidden = false;
    };

    var onSubmit = function () {
        if (creating)
            return;

        creating = true;

        fieldError.hidden = true;

        if (! validateFilename(fieldName.value)) {
            creating = false;
            onError('Invalid filename');
            return;
        }

        if (!fieldName.value.toLowerCase().endsWith('.js'))
            fieldName.value = fieldName.value + '.js';

        createScript(fieldName.value, function (err, script) {
            creating = false;

            if (err) {
                onError(err);
            } else {
                // select script
                editor.call('assets:panel:currentFolder', 'scripts');
                editor.call('selector:set', 'asset', [script]);

                overlay.hidden = true;
            }
        });
    };

    // submit on enter
    fieldName.elementInput.addEventListener('keydown', function (e) {
        if (e.keyCode === 13) {
            onSubmit();
        }
    });

    // clear error on input
    fieldName.elementInput.addEventListener('input', function () {
        if (!fieldError.hidden) {
            fieldError.hidden = true;
            fieldError.text = '';
        }
    });

    var pattern = /^(?:[\w\.-]+\/)*[_\.-]*[A-Za-z][\w_\.-]*?$/i;
    var validateFilename = function (filename) {
        return pattern.test(filename);
    };

    var createScript = function (filename, callback) {
        // try to get the file first and create it only if it doesn't exist
        // TODO: don't do that when scripts are assets
        editor.call('sourcefiles:content', filename, function (err) {
            if (! err) {
                // already exists
                callback('Script with that name already exists.');
            } else {
                // create script
                var content = newContent || editor.call('sourcefiles:skeleton', filename);
                editor.call('sourcefiles:create', filename, content, function (err, sourcefile) {
                    callback(err, sourcefile);
                });
            }
        });
    };
});


/* editor/pickers/picker-confirm.js */
editor.once('load', function() {
    'use strict';

    var callback = null;
    var className = '';
    var timeoutClass = null;

    // overlay
    var overlay = new ui.Overlay();
    overlay.class.add('picker-confirm');
    overlay.hidden = true;

    // label
    var label = new ui.Label();
    label.text = 'Are you sure?';
    label.class.add('text');
    label.renderChanges = false;
    overlay.append(label);

    // yes
    var btnYes = new ui.Button();
    btnYes.text = 'Yes';
    btnYes.class.add('yes');
    btnYes.on('click', function() {
        editor.emit('picker:confirm:yes');

        if (callback)
            callback();

        overlay.hidden = true;
    });
    overlay.append(btnYes);

    // no
    var btnNo = new ui.Button();
    btnNo.text = 'No';
    btnNo.class.add('no');
    btnNo.on('click', function() {
        editor.emit('picker:confirm:no');
        overlay.hidden = true;
    });
    overlay.append(btnNo);


    var root = editor.call('layout.root');
    root.append(overlay);


    // esc > no
    editor.call('hotkey:register', 'picker:confirm:no', {
        key: 'esc',
        callback: function() {
            if (overlay.hidden)
                return;

            btnNo.emit('click');
        }
    });

    // enter > yes
    window.addEventListener('keydown', function(evt) {
        if (evt.keyCode !== 13 || overlay.hidden)
            return;

        btnYes.emit('click');
        evt.preventDefault();
        evt.stopPropagation();
    });


    // on overlay hide
    overlay.on('hide', function() {
        if (className) {
            timeoutClass = setTimeout(function() {
                overlay.class.remove(className);
                className = '';
            }, 100);
        }

        editor.emit('picker:confirm:close');
    });


    editor.method('picker:confirm:class', function(name) {
        if (timeoutClass) {
            clearTimeout(timeoutClass);
            timeoutClass = null;
        }

        if (className)
            overlay.class.remove(className);

        if (name)
            overlay.class.add(name);

        className = name;
    });


    // call picker
    editor.method('picker:confirm', function(text, fn) {
        label.text = text || 'Are you sure?';
        callback = fn || null;

        // show overlay
        overlay.hidden = false;
    });

    // close picker
    editor.method('picker:confirm:close', function() {
        overlay.hidden = true;
    });
});


/* editor/pickers/picker-color.js */
editor.once('load', function() {
    'use strict';

    var size = 144;
    var directInput = true;
    var colorHSV = [ 0, 0, 0 ];
    var channels = [ ];
    var channelsNumber = 4;
    var changing = false;
    var dragging = false;


    // make hex out of channels
    var getHex = function() {
        var hex = '';
        for(var i = 0; i < channelsNumber; i++) {
            hex += ('00' + channels[i].value.toString(16)).slice(-2).toUpperCase();
        }
        return hex;
    };

    // rect drag
    var pickRectMouseMove = function(evt) {
        changing = true;
        var rect = pickRect.getBoundingClientRect();
        var x = Math.max(0, Math.min(size, Math.floor(evt.clientX - rect.left)));
        var y = Math.max(0, Math.min(size, Math.floor(evt.clientY - rect.top)));

        colorHSV[1] = x / size;
        colorHSV[2] = 1.0 - (y / size);

        directInput = false;
        var rgb = hsv2rgb([ colorHSV[0], colorHSV[1], colorHSV[2] ]);
        for(var i = 0; i < 3; i++) {
            channels[i].value = rgb[i];
        }
        fieldHex.value = getHex();
        directInput = true;

        pickRectHandle.style.left = Math.max(4, Math.min(size - 4, x)) + 'px';
        pickRectHandle.style.top = Math.max(4, Math.min(size - 4, y)) + 'px';
        changing = false;
    };

    // rect drag stop
    var pickRectMouseUp = function() {
        window.removeEventListener('mousemove', pickRectMouseMove, false);
        window.removeEventListener('mouseup', pickRectMouseUp, false);
        dragging = false;
        editor.emit('picker:color:end');
    };

    // hue drag
    var pickHueMouseMove = function(evt) {
        changing = true;
        var rect = pickHue.getBoundingClientRect();
        var y = Math.max(0, Math.min(size, Math.floor(evt.clientY - rect.top)));
        var h = y / size;

        var rgb = hsv2rgb([ h, colorHSV[1], colorHSV[2] ]);
        colorHSV[0] = h;

        directInput = false;
        for(var i = 0; i < 3; i++) {
            channels[i].value = rgb[i];
        }
        fieldHex.value = getHex();
        updateRects();
        directInput = true;
        changing = false;
    };

    // hue drag stop
    var pickHueMouseUp = function() {
        window.removeEventListener('mousemove', pickHueMouseMove, false);
        window.removeEventListener('mouseup', pickHueMouseUp, false);
        dragging = false;
        editor.emit('picker:color:end');
    };

    // opacity drag
    var pickOpacityMouseMove = function(evt) {
        changing = true;
        var rect = pickHue.getBoundingClientRect();
        var y = Math.max(0, Math.min(size, Math.floor(evt.clientY - rect.top)));
        var o = 1.0 - y / size;

        directInput = false;
        fieldA.value = Math.max(0, Math.min(255, Math.round(o * 255)));
        fieldHex.value = getHex();
        directInput = true;
        changing = false;
    };

    // opacity drag stop
    var pickOpacityMouseUp = function() {
        window.removeEventListener('mousemove', pickOpacityMouseMove, false);
        window.removeEventListener('mouseup', pickOpacityMouseUp, false);
        dragging = false;
        editor.emit('picker:color:end');
    };


    var updateHex = function() {
        if (! directInput)
            return;

        changing = true;

        var hex = fieldHex.value.trim().toLowerCase();
        if (/^([0-9a-f]{2}){3,4}$/.test(hex)) {
            for(var i = 0; i < channelsNumber; i++) {
                channels[i].value = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
            }
        }

        changing = false;
    };


    // update rgb
    var updateRects = function() {
        var color = channels.map(function(channel) {
            return channel.value || 0;
        }).slice(0, channelsNumber);

        var hsv = rgb2hsv(color);
        if (directInput) {
            var sum = color[0] + color[1] + color[2];
            if (sum !== 765 && sum !== 0)
                colorHSV[0] = hsv[0];

            colorHSV[1] = hsv[1];
            colorHSV[2] = hsv[2];

            dragging = true;
            editor.emit('picker:color:start');
        }

        // hue position
        pickHueHandle.style.top = Math.floor(size * colorHSV[0]) + 'px'; // h

        // rect position
        pickRectHandle.style.left = Math.max(4, Math.min(size - 4, size * colorHSV[1])) + 'px'; // s
        pickRectHandle.style.top = Math.max(4, Math.min(size - 4, size * (1.0 - colorHSV[2]))) + 'px'; // v

        if (channelsNumber >= 3) {
            var plainColor = hsv2rgb([ colorHSV[0], 1, 1 ]).join(',');

            // rect background color
            pickRect.style.backgroundColor = 'rgb(' + plainColor + ')';

            // rect handle color
            pickRectHandle.style.backgroundColor = 'rgb(' + color.slice(0, 3).join(',') + ')';

            // hue handle color
            pickHueHandle.style.backgroundColor = 'rgb(' + plainColor + ')';
        }

        callCallback();
    };

    // update alpha handle
    var updateRectAlpha = function(value) {
        if (channelsNumber !== 4)
            return;

        // position
        pickOpacityHandle.style.top = Math.floor(size * (1.0 - (Math.max(0, Math.min(255, value)) / 255))) + 'px';

        // color
        pickOpacityHandle.style.backgroundColor = 'rgb(' + [ value, value, value ].join(',') + ')';

        callCallback();
    };


    var callingCallaback = false;
    var callbackHandle = function() {
        callingCallaback = false;

        editor.emit('picker:color', channels.map(function(channel) {
            return channel.value || 0;
        }).slice(0, channelsNumber));
    };
    var callCallback = function() {
        if (callingCallaback)
            return;

        callingCallaback = true;
        setTimeout(callbackHandle, 1000 / 60);
    };


    // overlay
    var overlay = new ui.Overlay();
    overlay.class.add('picker-color');
    overlay.center = false;
    overlay.transparent = true;
    overlay.hidden = true;


    // rectangular picker
    var pickRect = document.createElement('div');
    pickRect.classList.add('pick-rect');
    overlay.append(pickRect);

    // rect drag start
    pickRect.addEventListener('mousedown', function(evt) {
        pickRectMouseMove(evt);

        window.addEventListener('mousemove', pickRectMouseMove, false);
        window.addEventListener('mouseup', pickRectMouseUp, false);

        evt.stopPropagation();
        evt.preventDefault();
        dragging = true;
        editor.emit('picker:color:start');
    });

    // white
    var pickRectWhite = document.createElement('div');
    pickRectWhite.classList.add('white');
    pickRect.appendChild(pickRectWhite);

    // black
    var pickRectBlack = document.createElement('div');
    pickRectBlack.classList.add('black');
    pickRect.appendChild(pickRectBlack);

    // handle
    var pickRectHandle = document.createElement('div');
    pickRectHandle.classList.add('handle');
    pickRect.appendChild(pickRectHandle);


    // hue (rainbow) picker
    var pickHue = document.createElement('div');
    pickHue.classList.add('pick-hue');
    overlay.append(pickHue);

    // hue drag start
    pickHue.addEventListener('mousedown', function(evt) {
        pickHueMouseMove(evt);

        window.addEventListener('mousemove', pickHueMouseMove, false);
        window.addEventListener('mouseup', pickHueMouseUp, false);

        evt.stopPropagation();
        evt.preventDefault();
        dragging = true;
        editor.emit('picker:color:start');
    });

    // handle
    var pickHueHandle = document.createElement('div');
    pickHueHandle.classList.add('handle');
    pickHue.appendChild(pickHueHandle);


    // opacity (gradient) picker
    var pickOpacity = document.createElement('div');
    pickOpacity.classList.add('pick-opacity');
    overlay.append(pickOpacity);

    // opacoty drag start
    pickOpacity.addEventListener('mousedown', function(evt) {
        pickOpacityMouseMove(evt);

        window.addEventListener('mousemove', pickOpacityMouseMove, false);
        window.addEventListener('mouseup', pickOpacityMouseUp, false);

        evt.stopPropagation();
        evt.preventDefault();
        dragging = true;
        editor.emit('picker:color:start');
    });

    // handle
    var pickOpacityHandle = document.createElement('div');
    pickOpacityHandle.classList.add('handle');
    pickOpacity.appendChild(pickOpacityHandle);



    // fields
    var panelFields = document.createElement('div');
    panelFields.classList.add('fields');
    overlay.append(panelFields);


    // R
    var fieldR = new ui.NumberField({
        precision: 1,
        step: 1,
        min: 0,
        max: 255
    });
    channels.push(fieldR);
    fieldR.renderChanges = false;
    fieldR.placeholder = 'r';
    fieldR.flexGrow = 1;
    fieldR.class.add('field', 'field-r');
    fieldR.on('change', updateRects);
    panelFields.appendChild(fieldR.element);

    // G
    var fieldG = new ui.NumberField({
        precision: 1,
        step: 1,
        min: 0,
        max: 255
    });
    channels.push(fieldG);
    fieldG.renderChanges = false;
    fieldG.placeholder = 'g';
    fieldG.class.add('field', 'field-g');
    fieldG.on('change', updateRects);
    panelFields.appendChild(fieldG.element);

    // B
    var fieldB = new ui.NumberField({
        precision: 1,
        step: 1,
        min: 0,
        max: 255
    });
    channels.push(fieldB);
    fieldB.renderChanges = false;
    fieldB.placeholder = 'b';
    fieldB.class.add('field', 'field-b');
    fieldB.on('change', updateRects);
    panelFields.appendChild(fieldB.element);


    // A
    var fieldA = new ui.NumberField({
        precision: 1,
        step: 1,
        min: 0,
        max: 255
    });
    channels.push(fieldA);
    fieldA.renderChanges = false;
    fieldA.placeholder = 'a';
    fieldA.class.add('field', 'field-a');
    fieldA.on('change', updateRectAlpha);
    panelFields.appendChild(fieldA.element);


    // HEX
    var fieldHex = new ui.TextField();
    fieldHex.renderChanges = false;
    fieldHex.placeholder = '#';
    fieldHex.class.add('field', 'field-hex');
    fieldHex.on('change', function() {
        updateHex();
    });
    panelFields.appendChild(fieldHex.element);


    var root = editor.call('layout.root');
    root.append(overlay);


    // esc to close
    editor.call('hotkey:register', 'picker:color:close', {
        key: 'esc',
        callback: function() {
            if (overlay.hidden)
                return;

            overlay.hidden = true;
        }
    });


    overlay.on('hide', function() {
        editor.emit('picker:color:close');
    });


    // call picker
    editor.method('picker:color', function(color) {
        // class for channels
        for(var i = 0; i < 4; i++) {
            if (color.length - 1 < i) {
                overlay.class.remove('c-' + (i + 1));
            } else {
                overlay.class.add('c-' + (i + 1));
            }
        }

        // number of channels
        channelsNumber = color.length;

        if (channelsNumber >= 3) {
            var hsv = rgb2hsv(color);
            colorHSV[0] = hsv[0];
            colorHSV[1] = hsv[1];
            colorHSV[2] = hsv[2];
        }

        // set fields
        directInput = false;
        for(var i = 0; i < color.length; i++) {
            channels[i].value = color[i];
        }
        fieldHex.value = getHex();
        directInput = true;

        // show overlay
        overlay.hidden = false;

        // focus on hex field
        fieldHex.elementInput.focus();

        setTimeout(function() {
            fieldHex.elementInput.focus();
            fieldHex.elementInput.select();
        }, 100);
    });

    editor.method('picker:color:close', function() {
        overlay.hidden = true;
    });

    editor.method('picker:color:rect', function() {
        return overlay.rect;
    });

    // position color picker
    editor.method('picker:color:position', function(x, y) {
        overlay.position(x, y);
    });

    // position color picker
    editor.method('picker:color:set', function(color) {
        if (changing || dragging)
            return;

        if (channelsNumber >= 3) {
            var hsv = rgb2hsv(color);
            colorHSV[0] = hsv[0];
            colorHSV[1] = hsv[1];
            colorHSV[2] = hsv[2];
        }

        // set fields
        directInput = false;
        for(var i = 0; i < color.length; i++) {
            channels[i].value = color[i];
        }
        fieldHex.value = getHex();
        directInput = true;
    });
});


/* editor/pickers/picker-asset.js */
editor.once('load', function() {
    'use strict';

    var legacyScripts = editor.call('settings:project').get('useLegacyScripts');

    var overlay = new ui.Overlay();
    overlay.class.add('picker-asset');
    overlay.center = false;
    overlay.hidden = true;

    var root = editor.call('layout.root');
    root.append(overlay);

    // initial select state
    var currentType = '';
    var currentAsset = null;
    var gridSelected = null;
    var assetsPanelFolded = false;
    var assetsPanelFilter = '';
    var assetsPanelSearch = '';
    var assetsPanelFolder = null;
    // elements
    var assetsGrid = editor.call('assets:grid');
    var assetsPanel = editor.call('layout.assets');

    var pluralize = function (word) {
        return word + ' assets';
    };

    // empty filter messages
    var getNoResultsMessage = function (type, filter) {
        var result;

        if (legacyScripts && type === 'script') {
            result = 'There are no scripts. Click on the <span class="font-icon" style="font-size: 18px">&#57632;</span> button to add one';
        } else if (type === 'material' || type === 'cubemap' || type === 'text' || type === 'json' || type === 'html' || type === 'shader' || type === 'css' || (! legacyScripts && type === 'script')) {
            result = 'There are no ' + pluralize(type) + ' in this folder. Click on the <span class="font-icon" style="font-size: 18px">&#57632;</span> button to add one';
        } else {
            result = 'There are no ' + pluralize(type) + ' in this folder. Add one by uploading a ' + type + ' file';
        }

        if (filter) {
            result += ' or change your search term.';
        } else {
            result += '.';
        }

        return result;
    };

    // esc to close
    editor.call('hotkey:register', 'picker:assets:close', {
        key: 'esc',
        callback: function() {
            if (overlay.hidden)
                return;

            overlay.hidden = true;
        }
    });

    assetsGrid.on('deselect', function(item) {
        if (overlay.hidden || ! item.asset || item.asset !== currentAsset)
            return;

        this.selected = [ item ];
    });

    // picked asset
    assetsGrid.on('select', function(item) {
        if (item.asset) {
            if (overlay.hidden ||
                (currentType !== '*' && item.asset.get('type') !== currentType) ||
                item.asset === currentAsset) {
                return;
            }

            // emit event
            if (item.asset)
                editor.emit('picker:asset', item.asset);
        } else if (item.script) {
            if (overlay.hidden ||
                (currentType !== '*' && currentType !== "script")) {
                return;
            }

            if (item.script)
                editor.emit('picker:asset', item.script);
        }


        // hide picker
        overlay.hidden = true;
    });


    // on close asset picker
    overlay.on('hide', function() {
        // show all assets back
        editor.call('assets:filter:type:disabled', false);
        editor.call('assets:filter:type', assetsPanelFilter);
        editor.call('assets:filter:search', assetsPanelSearch);
        editor.call('assets:panel:currentFolder', assetsPanelFolder);
        // fold back assets panel if needed
        if (assetsPanelFolded)
            assetsPanel.folded = true;
        // enable selector
        editor.call('selector:enabled', true);
        // select what was selected
        assetsGrid.selected = gridSelected;
        // emit event
        editor.emit('picker:asset:close');
        // styling
        assetsPanel.style.zIndex = '';
        assetsPanel.style.overflow = '';
    });


    // open asset picker
    editor.method('picker:asset', function(type, asset) {
        // show only asset assets
        assetsPanelFilter = editor.call('assets:filter:type');
        assetsPanelSearch = editor.call('assets:filter:search');
        assetsPanelFolder = editor.call('assets:panel:currentFolder');
        // navigate to scripts folder

        if (legacyScripts && type === 'script')
            editor.call('assets:panel:currentFolder', 'scripts');
        // initial grid selected items
        gridSelected = assetsGrid.selected;
        // filters
        var pickerType = type === 'texture' ? 'textureTarget' : type;
        editor.call('assets:filter:type', (pickerType === '*') ? 'all' : pickerType);
        editor.call('assets:filter:type:disabled', (! pickerType || pickerType === '*') ? false : true);
        // disable selector
        editor.call('selector:enabled', false);
        // find current asset
        currentType = type;
        currentAsset = asset;
        if (currentAsset) {
            var gridItem = assetsGrid.assetsIndex[currentAsset.get('id')];
            // select in grid
            if (gridItem) {
                assetsGrid.selected = [ gridItem ];
                // navigate to folder of referenced file
                if (legacyScripts && type === 'script') {
                    editor.call('assets:panel:currentFolder', 'scripts');
                } else {
                    var path = currentAsset.get('path');
                    if (path.length) {
                        editor.call('assets:panel:currentFolder', editor.call('assets:get', path[path.length - 1]));
                    } else {
                        editor.call('assets:panel:currentFolder', null);
                    }
                }
            }
        }
        // show asset panel in front
        assetsPanel.style.zIndex = 102;
        assetsPanel.style.overflow = 'visible';
        // if panel folded?
        assetsPanelFolded = assetsPanel.folded;
        if (assetsPanelFolded)
            assetsPanel.folded = false;
        // show overlay
        overlay.hidden = false;
        // flash assets panel
        assetsPanel.flash();
        // focus on panel
        setTimeout(function() {
            if (assetsGrid.selected && assetsGrid.selected.length) {
                assetsGrid.selected[0].element.focus();
            } else {
                assetsGrid.element.focus();
            }

            // if no assets then show message
            var visible = assetsGrid.element.querySelectorAll('.ui-grid-item:not(.hidden)');
            if (visible.length === 0) {
                var msg = getNoResultsMessage(type, assetsPanelSearch);
                editor.call('assets:panel:message', msg);
            }
        }, 100);
    });


    // close asset picker
    editor.method('picker:asset:close', function() {
        // hide overlay
        overlay.hidden = true;
    });
});


/* editor/pickers/picker-curve.js */
editor.once('load', function() {
    'use strict';

    // used to disable event handlers
    var suspendEvents = false;

    // true while changing curves
    var changing = false;

    // overlay
    var overlay = new ui.Overlay();
    overlay.class.add('picker-curve');
    overlay.center = false;
    overlay.transparent = true;
    overlay.hidden = true;

    // color variables
    var colors = {
        bg: '#293538',
        gridLines: '#20292b',
        anchors: ['rgb(255, 0, 0)', 'rgb(0, 255, 0)', 'rgb(133, 133, 252)', 'rgb(255, 255, 255)'],
        curves: ['rgb(255, 0, 0)', 'rgb(0, 255, 0)', 'rgb(133, 133, 252)', 'rgb(255, 255, 255)'],
        curveFilling: ['rgba(255, 0, 0, 0.5)', 'rgba(0, 255, 0, 0.5)', 'rgba(133, 133, 252, 0.5)', 'rgba(255, 255, 255, 0.5)'],
        text: 'white',
        highlightedLine: 'yellow'
    };

    // canvas variables
    var padding = 10;
    var axisSpacing = 20;
    var anchorRadius = 4;
    var curveHoverRadius = 8;
    var anchorHoverRadius = 8;
    var textSize = 10;

    // input related variables
    var curves = []; // holds all the curves
    var enabledCurves = []; // holds the rendered order of the curves
    var numCurves; // number of pairs of curves
    var betweenCurves = false;
    var curveType = 1;
    var curveNames = [];
    var verticalValue = 5;
    var verticalTopValue = 5;
    var verticalBottomValue = -5;
    var maxVertical = null;
    var minVertical = null;
    var hoveredAnchor = null;
    var hoveredCurve = null;
    var selectedAnchor = null;
    var selectedAnchorIndex = -1;
    var selectedCurve = null;
    var selectedCurveIndex = -1;
    var dragging = false;
    var scrolling = false;
    var gradient = false;
    var mouseY = 0;

    var swizzle = [0, 1, 2, 3];

    var root = editor.call('layout.root');
    root.append(overlay);

    overlay.on('hide', function () {
        editor.emit('picker:curve:close');
        cleanup();
    });

    // rectangular picker
    var panel = document.createElement('div');
    panel.classList.add('picker-curve-panel');
    overlay.append(panel);

    // header
    var header = new ui.Panel();
    header.class.add('picker-curve-header');

    panel.appendChild(header.element);

    header.append(new ui.Label({
        text: 'Type'
    }));


    // esc to close
    editor.call('hotkey:register', 'picker:curve:close', {
        key: 'esc',
        callback: function() {
            if (overlay.hidden)
                return;

            overlay.hidden = true;
        }
    });


    // type selector
    var fieldType = new ui.SelectField({
        options: {
            0: 'Linear',
            1: 'Smooth Step',
            2: 'Spline'
        },
        type: 'number'
    });

    fieldType.style['font-size'] = '11px';
    fieldType.value = 1;

    fieldType.on('change', function (value) {
        changing = true;

        curveType = value;

        var paths, values;

        if (! suspendEvents) {
            paths = [];
            values = [];
        }

        // set type for each curve
        curves.forEach(function (curve, i) {
            curve.type = value;
            if (! suspendEvents) {
                paths.push(i.toString() + '.type');
                values.push(curveType);
            }
        });

        if (! suspendEvents)
            editor.emit('picker:curve:change', paths, values);

        render();

        changing = false;
    });

    header.append(fieldType);

    // randomize
    var labelRandomize = new ui.Label({
        text: 'Randomize'
    });

    labelRandomize.style['margin-left'] = '25px';
    header.append(labelRandomize);

    var fieldRandomize = new ui.Checkbox();
    fieldRandomize.class.add('component-toggle');
    fieldRandomize.on('change', function (value) {
        var i;

        changing = true;

        betweenCurves = value;

        var paths, values;

        if (! suspendEvents) {
            paths = ['0.betweenCurves'];
            values = [betweenCurves];
        }

        if (!betweenCurves) {
            for (i = 0; i < numCurves; i++) {
                if (! curves[i + numCurves]) continue;

                // disable the secondary graph
                toggleCurve(curves[i + numCurves], false);

                // make keys of secondary graph to be the same
                // as the primary graph
                if (! suspendEvents) {
                    paths.push(getKeysPath(curves[i + numCurves]));
                    values.push(serializeCurveKeys(curves[i]));
                }
            }
        } else {
            // enable the secondary graphs if their respective primary graphs are enabled
            for (i = 0; i < numCurves; i++) {
                if (! curves[i + numCurves]) continue;

                // we might have a different value for the secondary graphs
                // when we re-enable betweenCurves so fire change event
                // to make sure the different values are saved
                if (! suspendEvents) {
                    paths.push(getKeysPath(curves[i + numCurves]));
                    values.push(serializeCurveKeys(curves[i + numCurves]));
                }

                var isEnabled = enabledCurves.indexOf(curves[i]) >= 0;
                toggleCurve(curves[i + numCurves], false);
                if (isEnabled) {
                    toggleCurve(curves[i + numCurves], true);
                }
            }
        }

        if (! suspendEvents)
            editor.emit('picker:curve:change', paths, values);

        changing = false;
    });

    header.append(fieldRandomize);

    // curve toggles
    var curveToggles = [];

    var onCurveToggleClick = function () {
        var i = curveToggles.indexOf(this);
        var enabled = !this.class.contains('active');
        if (enabled) {
            this.class.add('active');
        } else {
            this.class.remove('active');
        }

        toggleCurve(curves[i], enabled);
    };

    for (var i = 0; i < colors.curves.length; i++) {
        var btn = new ui.Button();
        btn.class.add('picker-curve-toggle', 'active');
        btn.element.style.color = colors.curves[3 - i];
        curveToggles.splice(0, 0, btn);
        header.append(btn);

        btn.on('click', onCurveToggleClick.bind(btn));
    }

    // canvas
    var canvas = new ui.Canvas();
    canvas.resize(panel.clientWidth, 200);
    panel.appendChild(canvas.element);

    // canvas for checkerboard pattern
    var checkerboardCanvas = new ui.Canvas();
    checkerboardCanvas.width = 16;
    checkerboardCanvas.height = 16;
    var pctx = checkerboardCanvas.element.getContext('2d');
    pctx.fillStyle = "#949a9c";
    pctx.fillRect(0,0,8,8);
    pctx.fillRect(8,8,8,8);
    pctx.fillStyle = "#657375";
    pctx.fillRect(8,0,8,8);
    pctx.fillRect(0,8,8,8);
    var checkerboardPattern = canvas.element.getContext('2d').createPattern(checkerboardCanvas.element, 'repeat');

    // gradient canvas
    var gradientCanvas = new ui.Canvas();
    gradientCanvas.resize(panel.clientWidth, 32);
    gradientCanvas.style.display = 'block';
    panel.appendChild(gradientCanvas.element);

    // footer
    var footer = new ui.Panel();
    footer.class.add('picker-curve-footer');
    panel.appendChild(footer.element);

    // time input field
    var fieldTime = new ui.NumberField({
        min: 0,
        max: 1,
        step: 0.1
    });

    fieldTime.renderChanges = false;
    fieldTime.value = 0;
    fieldTime.on('change', onFieldChanged);
    fieldTime.flexGrow = 1;
    fieldTime.placeholder = 'Time';
    footer.append(fieldTime);

    // value input field
    var fieldValue = new ui.NumberField();
    fieldValue.renderChanges = false    ;
    fieldValue.value = 0;
    fieldValue.on('change', onFieldChanged);
    fieldValue.flexGrow = 1;
    fieldValue.placeholder = 'Value';
    footer.append(fieldValue);

    // called when time or value field change value
    function onFieldChanged () {
        if (suspendEvents || !selectedAnchor) return;

        changing = true;

        var newAnchorTime = fieldTime.value;
        var newAnchorValue = fieldValue.value;

        // set time for the selected anchor
        updateAnchor(selectedCurve, selectedAnchor, newAnchorTime, newAnchorValue);

        collapseAnchors();

        if (newAnchorValue > verticalTopValue || newAnchorValue < verticalBottomValue) {
            resetZoom();
        }

        render();

        changing = false;
    }

    // reset zoom
    var btnResetZoom = new ui.Button({
        text: '&#57623;'
    });

    btnResetZoom.flexGrow = 1;

    btnResetZoom.on('click', function () {
        if (resetZoom()) {
            render();
        }
    });

    footer.append(btnResetZoom);

    Tooltip.attach({
        target: btnResetZoom.element,
        text: 'Reset Zoom',
        align: 'bottom',
        root: root
    });

    // reset curve
    var btnResetCurve = new ui.Button({
        text: '&#57680;'
    });

    btnResetCurve.flexGrow = 1;

    Tooltip.attach({
        target: btnResetCurve.element,
        text: 'Reset Curve',
        align: 'bottom',
        root: root
    });

    btnResetCurve.on('click', function () {
        // reset keys of selected curve
        if (selectedCurve) {
            changing = true;

            resetCurve(selectedCurve);

            render();

            changing = false;
        }
    });

    footer.append(btnResetCurve);

    var btnCopy = new ui.Button({
        text: '&#58193'
    });

    btnCopy.on('click', function () {
        var data = {
            primaryKeys: [],
            secondaryKeys: [],
            betweenCurves: betweenCurves,
            curveType: curveType
        };

        for (var i = 0; i < numCurves; i++) {
            data.primaryKeys.push(serializeCurveKeys(curves[i]));
        }

        for (var i = 0; i < numCurves; i++) {
            if (! curves[numCurves + i]) continue;

            if (betweenCurves) {
                data.secondaryKeys.push(serializeCurveKeys(curves[numCurves + i]));
            } else {
                data.secondaryKeys.push(serializeCurveKeys(curves[i]));
            }
        }

        editor.call('localStorage:set', 'playcanvas_editor_clipboard_curves', data);
    });

    Tooltip.attach({
        target: btnCopy.element,
        text: 'Copy',
        align: 'bottom',
        root: root
    });

    footer.append(btnCopy);

    var btnPaste = new ui.Button({
        text: '&#58184'
    });

    btnPaste.on('click', function () {
        var data = editor.call('localStorage:get', 'playcanvas_editor_clipboard_curves');
        if (! data) return;

        var paths = [];
        var values = [];

        curveType = data.curveType;
        betweenCurves = data.betweenCurves && !fieldRandomize.hidden;

        var copyKeys = function (i, data) {
            if (data && curves[i]) {
                var keys = data;

                // clamp keys to min max values
                if (minVertical != null || maxVertical != null) {
                    keys = [];
                    for (var j = 0, len = data.length; j < len; j += 2) {
                        keys.push(data[j]);

                        var value = data[j+1];
                        if (minVertical != null && value < minVertical)
                            keys.push(minVertical);
                        else if (maxVertical != null && value > maxVertical)
                            keys.push(maxVertical);
                        else
                            keys.push(value);
                    }
                }

                curves[i] = new pc.Curve(keys);
                curves[i].type = curveType;

                paths.push(getKeysPath(curves[i]));
                values.push(keys);

                if (fieldType.value !== curveType) {
                    paths.push(i.toString() + '.type');
                    values.push(curveType);
                }
            }
        };

        for (var i = 0; i < numCurves; i++) {
            copyKeys(i, data.primaryKeys[i]);
        }

        for (var i = 0; i < numCurves; i++) {
            copyKeys(i + numCurves, data.secondaryKeys[i]);
        }

        enabledCurves.length = 0;
        for (var i = 0; i < numCurves; i++)  {
            if (curveToggles[i].class.contains('active')) {
                enabledCurves.push(curves[i]);
                if (betweenCurves) {
                    enabledCurves.push(curves[i+numCurves]);
                }
            }
        }

        setHovered(null,null);
        setSelected(enabledCurves[0], null);

        var suspend = suspendEvents;
        suspendEvents = true;

        if (fieldRandomize.value !== betweenCurves) {
            fieldRandomize.value = betweenCurves;
            paths.push('0.betweenCurves');
            values.push(betweenCurves);
        }

        if (fieldType.value !== curveType) {
            fieldType.value = curveType;
        }

        suspendEvents = suspend;

        if (! suspendEvents)
            editor.emit('picker:curve:change', paths, values);

        if (shouldResetZoom())
            resetZoom();

        render();
    });

    Tooltip.attach({
        target: btnPaste.element,
        text: 'Paste',
        align: 'bottom',
        root: root
    });

    footer.append(btnPaste);

    var context = canvas.element.getContext('2d');

    function cleanup () {
        selectedCurveIndex = -1;
        selectedAnchorIndex = -1;
        changing = false;
        dragging = false;
        scrolling = false;
        window.removeEventListener('mouseup', onMouseUp);
        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('mousewheel', onMouseWheel);
        window.removeEventListener('DOMMouseScroll', onMouseWheel);
    }

    function resetCurve (curve) {
        var suspend = suspendEvents;
        suspendEvents = true;

        curve.keys.length = 0;
        createAnchor(curve, 0, 0);
        fieldTime.value = 0;
        fieldValue.value = 0;
        setSelected(curve, null);

        var paths = [getKeysPath(curve)];
        var values = [serializeCurveKeys(curve)];

        // reset secondary curve too
        var otherCurve = getOtherCurve(curve);
        if (otherCurve) {
            otherCurve.keys.length = 0;
            createAnchor(otherCurve, 0, 0);

            paths.push(getKeysPath(otherCurve));
            values.push(serializeCurveKeys(otherCurve));
        }

        suspendEvents = suspend;

        if (! suspendEvents)
            editor.emit('picker:curve:change', paths, values);
    }

    // Sets value for the picker and render it
    function setValue (value, args) {
        // sanity checks mostly for script 'curve' attributes
        if (!(value instanceof Array) || value.length === 0 || value[0].keys === undefined)
            return;

        var suspend = suspendEvents;
        suspendEvents = true;

        numCurves = value[0].keys[0].length ? value[0].keys.length : 1;

        betweenCurves = value[0].betweenCurves;
        fieldRandomize.value = betweenCurves;

        curveType = value[0].type;
        fieldType.value = curveType;

        gradient = args.gradient !== undefined ? args.gradient : false;
        gradientCanvas.style.display = gradient ? 'block' : 'none';
        fieldRandomize.hidden = gradient || args.hideRandomize;
        labelRandomize.hidden = gradient || args.hideRandomize;

        maxVertical = args.max;
        fieldValue.max = args.max;

        minVertical = args.min;
        fieldValue.min = args.min;

        curveNames = args.curves || [];
        for (var i = 0; i < colors.curves.length; i++) {
            if (i < numCurves) {
                curveToggles[i].text = curveNames[i];
                curveToggles[i].class.remove('hidden');
            } else {
                curveToggles[i].class.add('hidden');
            }
        }

        curves.length = 0;
        value.forEach(function (data) {
            if (numCurves === 1) {
                var c = new pc.Curve(data.keys);
                c.type = curveType;
                curves.push(c);
            } else {
                data.keys.forEach(function (keys) {
                    var c = new pc.Curve(keys);
                    c.type = curveType;
                    curves.push(c);
                });
            }
        });

        enabledCurves.length = 0;
        for (var i = 0; i < numCurves; i++)  {
            if (curveToggles[i].class.contains('active')) {
                enabledCurves.push(curves[i]);
                if (betweenCurves) {
                    enabledCurves.push(curves[i+numCurves]);
                }
            }
        }

        // try to select the same curve / anchor as the ones selected before setting the value
        var selCurve = selectedCurveIndex >= 0 ? curves[selectedCurveIndex] : enabledCurves[numCurves - 1];
        var selAnchor = selectedAnchorIndex >= 0 ? (selCurve ? selCurve.keys[selectedAnchorIndex] : null) : null;
        setSelected(selCurve, selAnchor);

        setHovered(null,null);

        suspendEvents = suspend;

        if (!args.keepZoom) {
            verticalValue = args.verticalValue !== undefined ? args.verticalValue : 5;
            verticalTopValue = args.max !== undefined ? Math.min(verticalValue, args.max) : verticalValue;
            verticalBottomValue = args.min !== undefined ? Math.max(-verticalValue, args.min) : -verticalValue;

            if (shouldResetZoom()) {
                resetZoom();
            }
        }

        // refresh swizzle
        swizzle = getColorSwizzle();

        // refresh toggle colors in case we are rendering single color curves
        for (var i = 0; i < curveToggles.length; i++) {
            curveToggles[i].style.color = colors.curves[swizzle[i]];
        }

        render();
    }

    function render () {
        renderGrid();
        renderCurves();
        renderHighlightedAnchors();
        renderMask();
        renderText();

        if (gradient) {
            renderColorGradient();
        }
    }

    function renderGrid() {
        var i;

        // draw background
        context.fillStyle = colors.bg;
        context.fillRect(0, 0, canvas.width, canvas.height);

        // draw grid
        for (i=0; i<5; i++) {
            var y = gridTop() + gridHeight() * i / 4;
            drawLine([gridLeft(), y], [gridRight(), y], colors.gridLines);
        }

        for (i=0; i<11; i++) {
            var x = gridLeft() + gridWidth() * i / 10;
            drawLine([x, gridTop()], [x, gridBottom()], colors.gridLines);
        }
    }

    function gridWidth () {
        return canvas.width - 2 * padding - axisSpacing;
    }

    function gridHeight () {
        return canvas.height - 2 * padding - axisSpacing;
    }

    function gridLeft () {
        return padding + axisSpacing;
    }

    function gridRight () {
        return gridLeft() + gridWidth();
    }

    function gridTop () {
        return padding;
    }

    function gridBottom () {
        return gridTop() + gridHeight();
    }

    function drawLine (start, end, color) {
        context.beginPath();
        context.moveTo(start[0], start[1]);
        context.lineTo(end[0], end[1]);
        context.strokeStyle = color;
        context.stroke();
    }

    // Draws text at the specified coordinates
    function drawText (text, x, y) {
        context.font = textSize + 'px Verdana';
        context.fillStyle = colors.text;
        context.fillText(text.toString(), x, y);
    }

    function renderCurves() {
        // holds indices of graphs that were rendered to avoid
        // rendering the same graphs twice
        var renderedCurveIndices = {};

        // // draw curves in the order in which they were enabled
        for (var i = 0; i < enabledCurves.length; i++) {
            var curve = enabledCurves[i];
            var index = curves.indexOf(curve);

            if (!renderedCurveIndices[index]) {
                renderedCurveIndices[index] = true;

                var otherCurve = getOtherCurve(curve);
                drawCurvePair(curve, betweenCurves ? otherCurve : null);

                drawCurveAnchors(curve);

                if (betweenCurves && otherCurve) {
                    var otherIndex = curves.indexOf(otherCurve);
                    if (!renderedCurveIndices[otherIndex]) {
                        drawCurveAnchors(otherCurve);
                        renderedCurveIndices[otherIndex] = true;
                    }
                }
            }
        }
    }

    // If the specified curve is the primary returns the secondary
    // otherwise if the specified curve is the secondary returns the primary
    function getOtherCurve (curve) {
        var ind = curves.indexOf(curve);
        if (ind < numCurves) {
            return curves[numCurves + ind];
        } else {
            return curves[ind - numCurves];
        }
    }

    // Draws a pair of curves with their in-between filling. If the second
    // curve is null then only the first curve will be rendered
    function drawCurvePair (curve1, curve2) {
        var colorIndex = swizzle[curves.indexOf(curve1) % numCurves];

        context.strokeStyle = colors.curves[colorIndex];
        context.fillStyle = colors.curveFilling[colorIndex];
        context.beginPath();

        var time = 0;
        var value = curve1.value(time);
        var x;
        var coords = calculateAnchorCoords([time, value]);
        context.moveTo(coords[0], coords[1]);

        var precision = 1;
        var width = canvas.width;

        for (x = precision; x <= Math.ceil(width / precision); x++) {
            time = x * precision / width;
            value = curve1.value(time);
            coords = calculateAnchorCoords([time, value]);
            context.lineTo(coords[0], coords[1]);
        }

        if (curve2) {
            for (x = Math.ceil(width / precision); x >= 0; x--) {
                time = x * precision / width;
                value = curve2.value(time);
                coords = calculateAnchorCoords([time, value]);
                context.lineTo(coords[0], coords[1]);
            }

            context.closePath();
            context.fill();
        }

        context.stroke();
    }

    // Returns the coordinates of the specified anchor on this grid
    function calculateAnchorCoords (anchor) {
        var time = anchor[0];
        var value = anchor[1];

        var coords = [0, 0];
        coords[0] = gridLeft() + time * gridWidth();

        var top = gridTop();
        coords[1] = top + gridHeight() * (value - verticalTopValue) / (verticalBottomValue - verticalTopValue);

        return coords;
    }

    // Draws the anchors for the specified curve
    function drawCurveAnchors (curve) {
        var colorIndex = swizzle[curves.indexOf(curve) % numCurves];
        curve.keys.forEach(function (anchor) {
            if (anchor !== hoveredAnchor && anchor !== selectedAnchor) {
                var color = colors.anchors[colorIndex];
                var lineColor = colors.curves[colorIndex];
                drawAnchor(calculateAnchorCoords(anchor), color, lineColor);
            }
        });
    }

    // Draws an anchor point at the specified coordinates
    function drawAnchor (coords, fillColor, lineColor) {
        context.beginPath();
        context.arc(coords[0], coords[1], anchorRadius, 0, 2 * Math.PI, false);
        context.fillStyle = fillColor;
        context.fill();
        var lineWidth = context.lineWidth;
        context.lineWidth = 2;
        context.strokeStyle = lineColor;
        context.stroke();
        context.lineWidth = lineWidth;
    }

    function renderHighlightedAnchors() {
        // draw highlighted anchors on top of the others
        if (hoveredAnchor) {
            drawAnchor(
                calculateAnchorCoords(hoveredAnchor),
                colors.anchors[curves.indexOf(hoveredCurve) % numCurves],
                colors.highlightedLine
            );
        }

        if (selectedAnchor && selectedAnchor !== hoveredAnchor) {
            drawAnchor(
                calculateAnchorCoords(selectedAnchor),
                colors.anchors[curves.indexOf(selectedCurve) % numCurves],
                colors.highlightedLine
            );
        }
    }

    // renders a quad in the same color as the bg color
    // to hide the portion of the curves that is outside the grid
    function renderMask () {
        context.fillStyle = colors.bg;

        var offset = anchorRadius + 1;

        // top
        context.fillRect(0, 0, canvas.width, gridTop() - offset);

        // bottom
        context.fillRect(0, gridBottom() + offset, canvas.width, 33 - offset);
    }

    function renderText () {
        // draw vertical axis values
        var left = gridLeft() - textSize * 2;
        drawText(+verticalTopValue.toFixed(2), left, gridTop() + textSize * 0.5);
        drawText(+((verticalTopValue + verticalBottomValue) * 0.5).toFixed(2), left, gridTop() + (gridHeight() + textSize) * 0.5);
        drawText(+verticalBottomValue.toFixed(2), left, gridBottom() + textSize * 0.5);

        // draw horizontal axis values
        drawText('0.0', left + textSize * 2, gridBottom() + 2 * textSize);
        drawText('1.0', gridRight() - textSize * 2, gridBottom() + 2 * textSize);
    }

    // if we only have one curve then
    // use 'swizzle' - an array of indexes
    // that remaps other arrays to different colors
    var getColorSwizzle = function () {
        var result = [0, 1, 2, 3];
        if (gradient && curves.length === 1) {
            if (curveNames[0] === 'g') {
                result = [1, 0, 2, 3];
            } else if (curveNames[0] === 'b') {
                result = [2, 1, 0, 3];
            } else if (curveNames[0] === 'a') {
                result = [3, 1, 2, 0];
            }
        }

        return result;
    };

    // Draws color gradient for a set of curves
    function renderColorGradient () {
        var ctx = gradientCanvas.element.getContext('2d');
        var t;
        var rgb = [];
        var precision = 2;

        var keys = [];
        for (var i = 0; i < curves.length; i++) {
            var k = curves[i].keys;
            var ka = [];
            for (var j = 0, len = k.length; j < len; j++ ) {
                ka.push(k[j][0], k[j][1]);
            }
            keys.push(ka);
        }

        var curveset = new pc.CurveSet(keys);
        curveset.type = curveType;

        ctx.fillStyle = checkerboardPattern;
        ctx.fillRect(0, 0, gradientCanvas.width, gradientCanvas.height);

        var gradient = ctx.createLinearGradient(0, 0, gradientCanvas.width, gradientCanvas.height);

        for (t = 0; t <= gradientCanvas.width; t += precision) {

            curveset.value(t / gradientCanvas.width, rgb);
            var rgba = Math.round((rgb[swizzle[0]] || 0) * 255) + ',' +
                Math.round((rgb[swizzle[1]] || 0) * 255) + ',' +
                Math.round((rgb[swizzle[2]] || 0) * 255) + ',' +
                (isNaN(rgb[swizzle[3]]) ? 1 : rgb[swizzle[3]]);

            gradient.addColorStop(t / gradientCanvas.width, 'rgba(' + rgba + ')');
        }

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, gradientCanvas.width, gradientCanvas.height);
    }

    // Calculate the anchor value based on the specified coordinates
    function calculateAnchorValue (coords) {
        var top = gridTop();
        var height = gridHeight();

        return pc.math.lerp(verticalTopValue, verticalBottomValue, (coords[1] - top) / height);
    }

    // Calculate the anchor time based on the specified coordinates
    function calculateAnchorTime (coords) {
        return pc.math.clamp((coords[0] - gridLeft()) / gridWidth(), 0, 1);
    }

    // zoom in - out based on delta
    function adjustZoom (delta) {
        var maxDelta = 1;
        if (delta > maxDelta) delta = maxDelta;
        else if (delta < -maxDelta) delta = -maxDelta;

        var speed = delta * (verticalTopValue - verticalBottomValue) / 10;

        var verticalTop = verticalTopValue - speed;
        var verticalBottom = verticalBottomValue + speed;

        // if we have a hovered or selected anchor then try to focus on
        // that when zooming in
        var focus = hoveredAnchor || selectedAnchor;
        if (delta > 0 && focus) {
            var value = focus[1];
            var mid = (verticalTopValue + verticalBottomValue) / 2;
            verticalTop += (value - mid) * delta;
            verticalBottom += (value - mid) * delta;
        } else if (delta > 0 && minVertical != null) {
            verticalBottom = verticalBottomValue;
        }

        // keep limits
        if (maxVertical != null && verticalTop > maxVertical)
            verticalTop = maxVertical;

        if (minVertical != null && verticalBottom < minVertical)
            verticalBottom = minVertical;

        // try not to bring values too close together
        if (+(verticalTop - verticalBottom).toFixed(2) <= 0.01)
            return;

        verticalTopValue = verticalTop;
        verticalBottomValue = verticalBottom;

        render();
    }

    function resetZoom () {
        var minMax = getCurvesMinMax(enabledCurves);

        var oldVerticalTop = verticalTopValue;
        var oldVerticalBottom = verticalBottomValue;

        var maxLimit = Math.ceil(2 * Math.max(Math.abs(minMax[0]), Math.abs(minMax[1])));
        if (maxLimit === 0) {
            maxLimit = verticalValue;
        }

        verticalTopValue = maxLimit;
        if (maxVertical != null) {
            verticalTopValue = Math.min(maxLimit, maxVertical);
        }

        verticalBottomValue = -verticalTopValue;
        if (minVertical != null) {
            verticalBottomValue = Math.max(minVertical, verticalBottomValue);
        }

        return oldVerticalTop != verticalTopValue || oldVerticalBottom != verticalBottomValue;
    }

    function scroll (delta) {
        var range = verticalTopValue - verticalBottomValue;
        var fraction = delta / gridHeight();
        var diff = range * fraction;

        if (maxVertical != null && verticalTopValue + diff > maxVertical) {
            diff = maxVertical - verticalTopValue;
        }

        if (minVertical != null && verticalBottomValue + diff < minVertical) {
            diff = minVertical - verticalBottomValue;
            if (maxVertical != null && verticalTopValue + diff > maxVertical) {
                diff = maxVertical - verticalTopValue;
            }
        }

        verticalTopValue += diff;
        verticalBottomValue += diff;

        render();
    }

    function getCurvesMinMax (curves) {
        var maxValue = -Infinity;
        var minValue = Infinity;

        curves.forEach(function (curve) {
            curve.keys.forEach(function (anchor) {
                var value = anchor[1];
                if (value > maxValue) {
                    maxValue = value;
                }

                if (value < minValue) {
                    minValue = value;
                }
            });
        });

        if (maxValue == -Infinity) {
            maxValue = maxVertical != null ? maxVertical : verticalValue;
        }

        if (minValue == Infinity) {
            minValue = minVertical != null ? minVertical : -verticalValue;
        }

        return [minValue, maxValue];
    }

    function updateFields (anchor) {
        var suspend = suspendEvents;
        suspendEvents = true;
        fieldTime.value = anchor ? +anchor[0].toFixed(3) : 0;
        fieldValue.value = anchor ? +anchor[1].toFixed(3) : 0;
        suspendEvents = suspend;
    }

    function getTargetCoords (e) {
        var rect = canvas.element.getBoundingClientRect();
        var left = Math.floor(rect.left);
        var top = Math.floor(rect.top);

        return [e.clientX - left, e.clientY - top];
    }

    // Returns true if the specidifed coordinates are within the grid bounds
    function areCoordsInGrid (coords) {
        return coords[0] >= gridLeft() &&
            coords[0] <= gridRight() &&
            coords[1] >= gridTop() &&
            coords[1] <= gridBottom();
    }

    function areCoordsClose (coords1, coords2, range) {
        return Math.abs(coords1[0] - coords2[0]) <= range &&
            Math.abs(coords1[1] - coords2[1]) <= range;
    }

    // If there are any anchors with the same time, collapses them to one
    function collapseAnchors () {
        var changedCurves = {};

        var paths, values;
        if (! suspendEvents) {
            paths = [];
            values = [];
        }

        enabledCurves.forEach(function (curve) {
            for (var i = curve.keys.length - 1; i > 0; i--) {
                var key = curve.keys[i];
                var prevKey = curve.keys[i-1];
                if (key[0].toFixed(3) === prevKey[0].toFixed(3)) {
                    curve.keys.splice(i, 1);

                    changedCurves[i] = true;

                    if (selectedAnchor === key) {
                        setSelected(selectedCurve, prevKey);
                    }

                    if (hoveredAnchor === key) {
                        setHovered(hoveredCurve, prevKey);
                    }
                }
            }
        });


        if (! suspendEvents) {
            for (var index in changedCurves) {
                var curve = curves[parseInt(index)];
                if (curve) {
                    var val = serializeCurveKeys(curve);
                    paths.push(getKeysPath(curve));
                    values.push(val.slice(0));

                    // if randomize is false set secondary graph the same as the first
                    if (! betweenCurves) {
                        var other = getOtherCurve(curve);
                        if (other) {
                            paths.push(getKeysPath(other));
                            values.push(val);
                        }
                    }
                }
            }

            if (paths.length) {
                editor.emit('picker:curve:change', paths, values);
            }
        }

    }

    // Creates and returns an anchor and fires change event
    function createAnchor (curve, time, value) {
        var anchor = curve.add(time, value);

        if (! suspendEvents)
            onCurveKeysChanged(curve);

        return anchor;
    }

    // Updates the time / value of an anchor and fires change event
    function updateAnchor (curve, anchor, time, value) {
        anchor[0] = time;
        anchor[1] = value;
        curve.sort();

        // reset selected anchor index because it
        // might have changed after sorting the curve keys
        if (selectedCurve === curve && selectedAnchor) {
            selectedAnchorIndex = curve.keys.indexOf(selectedAnchor);
        }

        if (! suspendEvents)
            onCurveKeysChanged(curve);
    }

    // Deletes an anchor from the curve and fires change event
    function deleteAnchor (curve, anchor) {
        var index = curve.keys.indexOf(anchor);
        if (index >= 0) {
            curve.keys.splice(index, 1);
        }

        // Have at least one key in the curve
        if (curve.keys.length === 0) {
            createAnchor(curve, 0, 0);
        } else {
            if (! suspendEvents)
                onCurveKeysChanged(curve);
        }
    }

    function getKeysPath (curve) {
        var curveIndex = curves.indexOf(curve);
        if (numCurves > 1) {
            return curveIndex >= numCurves ? '1.keys.' + (curveIndex - numCurves) : '0.keys.' + curveIndex;
        } else {
            return curveIndex === 0 ? '0.keys' : '1.keys';
        }
    }

    function serializeCurveKeys (curve) {
        var result = [];
        curve.keys.forEach(function (k) {
            result.push(k[0], k[1]);
        });
        return result;
    }

    function onCurveKeysChanged (curve) {
        var paths = [getKeysPath(curve)];
        var values = [serializeCurveKeys(curve)];

        // if randomize is false set secondary graph the same as the first
        if (! betweenCurves) {
            var other = getOtherCurve(curve);
            if (other) {
                paths.push(getKeysPath(other));
                values.push(values[0].slice(0));
            }
        }

        editor.emit('picker:curve:change', paths, values);
    }

    // Make the specified curve appear in front of the others
    function sendCurveToFront (curve) {
        var index = enabledCurves.indexOf(curve);
        if (index >= 0) {
            enabledCurves.splice(index, 1);
        }

        enabledCurves.push(curve);
    }

    // Sets the hovered graph and anchor
    function setHovered (curve, anchor) {
        hoveredCurve = curve;
        hoveredAnchor = anchor;

        // Change the mouse cursor to a pointer
        if (curve || anchor) {
            canvas.element.style.cursor = 'pointer';
            updateFields(anchor);
        } else {
            canvas.element.style.cursor = '';
            updateFields(selectedAnchor);
        }
    }

    // Sets the selected anchor and curve
    function setSelected (curve, anchor) {
        selectedCurve = curve;
        selectedAnchor = anchor;

        updateFields(anchor);

        // make the selected curve appear in front of all the others
        if (curve) {
            // set selected curve index
            selectedCurveIndex = curves.indexOf(curve);

            // set selected anchor index
            selectedAnchorIndex = anchor ? curve.keys.indexOf(anchor) : -1;

            // render curve pair in front of the others
            if (betweenCurves) {
                var otherCurve = getOtherCurve(curve);
                if (otherCurve) {
                    sendCurveToFront(otherCurve);
                }
            }


            sendCurveToFront(curve);
        } else {
            selectedCurveIndex = -1;
            selectedAnchorIndex = -1;
        }
    }

    // Return the hovered anchor and graph
    function getHoveredAnchor (coords) {
        var x,y;

        var result = {
            graph: null,
            anchor: null
        };

        var hoveredTime = calculateAnchorTime(coords);

        // go through all the curves from front to back
        // and check if the mouse cursor is hovering on them
        for (var j = enabledCurves.length - 1; j >= 0; j--) {
            var curve = enabledCurves[j];

            if (!result.curve) {
                // get the value at the current hovered time
                var value = curve.value(hoveredTime);

                // convert hoveredTime, value to coords
                var curvePointCoords = calculateAnchorCoords([hoveredTime, value]);

                // check coords are close to a radius
                x = coords[0] - curvePointCoords[0];
                y = coords[1] - curvePointCoords[1];

                if (areCoordsClose(coords, curvePointCoords, curveHoverRadius)) {
                    result.curve = curve;
                }
            }

            for (var i = 0, imax = curve.keys.length; i < imax; i++) {
                var anchor = curve.keys[i];
                var anchorCoords = calculateAnchorCoords(anchor);

                if (areCoordsClose(coords, anchorCoords, anchorHoverRadius)) {
                    result.anchor = anchor;
                    result.curve = curve;
                    return result;
                }
            }
        }

        return result;
    }

    // Enables / disables a curve
    function toggleCurve (curve, toggle) {
        if (toggle) {
            // when we enable a curve make it the selected one
            setSelected(curve, null);
        } else {
            // remove the curve from the enabledCurves array
            var index = enabledCurves.indexOf(curve);
            if (index >= 0) {
                enabledCurves.splice(index, 1);
            }

            // remove its matching curve too
            if (betweenCurves) {
                var otherCurve = getOtherCurve(curve);
                if (otherCurve) {
                    index = enabledCurves.indexOf(otherCurve);
                    if (index >= 0) {
                        enabledCurves.splice(index, 1);
                    }
                }
            }


            // if the selected curve was disabled select the next enabled one
            if (selectedCurve === curve || selectedCurve === otherCurve) {
                setSelected(null, null);

                if (enabledCurves.length) {
                    selectedCurve = enabledCurves[enabledCurves.length - 1];
                    selectedCurveIndex = curves.indexOf(selectedCurve);

                    // make sure we select the primary curve
                    if (betweenCurves && selectedCurveIndex >= numCurves) {
                        selectedCurveIndex -= numCurves;
                        selectedCurve = curves[selectedCurveIndex];
                    }
                }
            }

            if (hoveredCurve === curve || hoveredCurve === otherCurve) {
                hoveredCurve = null;
            }
        }

        render();
    }

    // Returns true if it would be a good idea to reset the zoom
    function shouldResetZoom () {
        var minMax = getCurvesMinMax(enabledCurves);

        // if min value is less than the bottom vertical value...
        if (minMax[0] < verticalBottomValue) {
            return true;
        }

        // ... or if max is bigger than the top vertical value...
        if (minMax[1] > verticalTopValue) {
            return true;
        }

        // // ... or if min and max are between the [25%, 75%] interval of the editor, return true
        // if (minMax[1] < Math.ceil(pc.math.lerp(verticalBottomValue, verticalTopValue, 0.75)) &&
        //     minMax[0] > Math.ceil(pc.math.lerp(verticalBottomValue, verticalTopValue, 0.25))) {
        //     return true;
        // }

        // don't reset zoom
        return false;
    }

    function toggleTextSelection (enable) {
        if (enable) {
            document.body.classList.remove('noSelect');
        } else {
            if (!document.body.classList.contains('noSelect')) {
                document.body.classList.add('noSelect');
            }
        }
    }

    // Handles mouse down
    canvas.element.addEventListener('mousedown', function (e) {
        if (e.target !== canvas.element) {
            return;
        }

        toggleTextSelection(false);

        var point = getTargetCoords(e);
        var inGrid = areCoordsInGrid(point);

        // collapse anchors on mouse down because we might
        // have placed another anchor on top of another by directly
        // editing its time through the input fields
        var suspend = suspendEvents;
        suspendEvents = true;
        collapseAnchors();
        suspendEvents = suspend;

        // select or add anchor on left click
        if (e.button === 0) {
            dragging = true;
            changing = true;
            scrolling = false;

            // if we are clicking on an empty area
            if (!hoveredAnchor) {

                if (!inGrid) {
                    return;
                }

                var curve = hoveredCurve || selectedCurve;

                // create a new anchor
                if (curve) {

                    var time = calculateAnchorTime(point);
                    var value = calculateAnchorValue(point);
                    var anchor = createAnchor(curve, time, value);

                    // combine changes from now on until mouse is up
                    editor.emit('picker:curve:change:start');

                    // select the new anchor and make it hovered
                    setSelected(curve, anchor);
                    setHovered(curve, anchor);
                }
            } else {
                // if we are hovered over a graph or an anchor then select it
                setSelected(hoveredCurve, hoveredAnchor);
                onCurveKeysChanged(selectedCurve);
            }
        } else if (e.button === 2) {
            if (! dragging) {
                scrolling = true;
                mouseY = e.y;

                panel.classList.add('scroll');
            }
        }

        render();
    });

    // Handles mouse move
    var onMouseMove = function (e) {
        var coords = getTargetCoords(e);

        // if we are dragging the selected anchor
        if (selectedAnchor && dragging) {
            // clamp coords to grid
            coords[0] = pc.math.clamp(coords[0], gridLeft(), gridRight());
            coords[1] = pc.math.clamp(coords[1], gridTop(), gridBottom());

            var time = calculateAnchorTime(coords);
            var value = calculateAnchorValue(coords);

            // if there is another point with the same time
            // then make the two points have the same values
            var keys = selectedCurve.keys;
            for (var i = 0, len = keys.length; i < len; i++) {
                if (keys[i] !== selectedAnchor && keys[i][0] === time) {
                    value = keys[i][1];
                }
            }

            updateAnchor(selectedCurve, selectedAnchor, time, value);
            updateFields(selectedAnchor);

            // combine changes from now on
            editor.emit('picker:curve:change:start');

            render();
        } else {

            if (scrolling) {
                scroll(e.y - mouseY);
                mouseY = e.y;
            }

            // mouse is moving without selected anchors so just check for hovered anchors or hovered curves
            var hovered = getHoveredAnchor(coords);
            if (hovered.curve != hoveredCurve || hovered.anchor != hoveredAnchor) {
                setHovered(hovered.curve, hovered.anchor);
                render();
            }
        }
    };

    // Handles mouse up
    var onMouseUp = function (e) {
        toggleTextSelection(true);

        if (e.button === 0) {
            if (changing) {
                // collapse anchors on mouse up because we might have
                // placed an anchor on top of another one
                collapseAnchors();

                dragging = false;
                changing = false;

                render();
            }

            editor.emit('picker:curve:change:end');
        } else if (e.button === 2 && !dragging) {
            scrolling = false;
            panel.classList.remove('scroll');

            // delete anchor on right click
            if (hoveredAnchor) {
                deleteAnchor(hoveredCurve, hoveredAnchor);

                // clean up selected anchor
                if (selectedAnchor == hoveredAnchor) {
                    setSelected(selectedCurve, null);
                }

                // clean up hovered anchor
                setHovered(null, null);

                render();
            }
        }
    };

    // Handle mouse wheel
    var onMouseWheel = function (e) {
        var delta = 0;
        if (e.detail)
            delta = -1 * e.detail * 0.05;
        else if (e.wheelDelta)
            delta = e.wheelDelta / 120;

        if (delta !== 0)
            adjustZoom(delta);
    };

    // call picker
    editor.method('picker:curve', function (value, args) {
        // show overlay
        overlay.hidden = false;

        var suspend = suspendEvents;
        suspendEvents = true;
        curveToggles.forEach(function (toggle) {
            toggle.class.add('active');
        });
        suspendEvents = suspend;

        setValue(value, args || {});

        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mousewheel', onMouseWheel);
        window.addEventListener('DOMMouseScroll', onMouseWheel);
    });

    editor.method('picker:curve:close', function () {
        overlay.hidden = true;
        cleanup();

        toggleTextSelection(true);
    });

    editor.method('picker:curve:isOpen', function () {
        return !overlay.hidden;
    });

    editor.method('picker:curve:rect', function () {
        return overlay.rect;
    });

    // position picker
    editor.method('picker:curve:position', function (x, y) {
        // limit to bottom of screen
        if (y + panel.clientHeight > window.innerHeight) {
            y = window.innerHeight - panel.clientHeight;
        }

        overlay.position(x, y);
    });

    // update value of picker
    editor.method('picker:curve:set', function (value, args) {
        if (!changing) {
            setValue(value, args || {});
        }
    });

    var onDeleteKey = function () {
        if (hoveredCurve && hoveredAnchor) {
            deleteAnchor(hoveredCurve, hoveredAnchor);
        } else if (selectedCurve && selectedAnchor) {
            deleteAnchor(selectedCurve, selectedAnchor);
        }
    };

    // delete key
    editor.call('hotkey:register', 'curve-anchor:delete', {
        key: 'delete',
        callback: onDeleteKey
    });
    // ctrl + backspace
    editor.call('hotkey:register', 'curve-anchor:delete', {
        ctrl: true,
        key: 'backspace',
        callback: onDeleteKey
    });
});


/* editor/pickers/picker-entity.js */
editor.once('load', function() {
    'use strict';

    var overlay = new ui.Overlay();
    overlay.class.add('picker-entity');
    overlay.center = false;
    overlay.hidden = true;

    var root = editor.call('layout.root');
    root.append(overlay);

    // initial select state
    var currentEntity = null;
    var initialSelection = null;

    // elements
    var hierarchy = editor.call('entities:hierarchy');
    var hierarchyPanel = hierarchy.parent;
    var hierarchyFolded = false;
    var filter = null;

    // esc to close
    editor.call('hotkey:register', 'picker:entity:close', {
        key: 'esc',
        callback: function() {
            if (overlay.hidden)
                return;

            overlay.hidden = true;
        }
    });

    hierarchy.on('deselect', function (item) {
        if (overlay.hidden || !item.entity || item.entity !== currentEntity)
            return;
    });

    // picked entity
    hierarchy.on('select', function (item) {
        if (overlay.hidden || item.entity === currentEntity || (filter && ! filter(item.entity)))
            return;

        // emit event
        if (item.entity)
            editor.emit('picker:entity', item.entity);

        // hide picker
        overlay.hidden = true;
    });


    // on close entity picker
    overlay.on('hide', function() {
        // fold back hierarchy panel if needed
        if (hierarchyFolded)
            hierarchyPanel.folded = true;

        // disable new selections
        for (var i = 0, len = hierarchy.selected.length; i < len; i++)
            hierarchy.selected[i].selected = false;

        // select what was selected
        hierarchy.selected = initialSelection;
        for (var i = 0, len = initialSelection.length; i < len; i++)
            initialSelection[i].selected = true;

        if (initialSelection.length)
            initialSelection[initialSelection.length - 1].elementTitle.focus();

        currentEntity = null;

        var entities = editor.call('entities:list');
        for(var i = 0; i < entities.length; i++) {
            var id = entities[i].get('resource_id');
            var item = editor.call('entities:panel:get', id);
            if (! item) continue;
            item.elementTitle.classList.remove('disabled');
        }

        // enable selector
        editor.call('selector:enabled', true);

        // emit event
        editor.emit('picker:entity:close');
        // styling
        hierarchyPanel.style.zIndex = '';
        hierarchyPanel.style.overflow = '';
    });


    // open entity picker
    editor.method('picker:entity', function(resourceId, fn) {
        // disable selector
        editor.call('selector:enabled', false);

        // get current hierarchy selection
        initialSelection = hierarchy.selected ? hierarchy.selected.slice(0) : [];
        if (initialSelection) {
            for (var i = 0, len = initialSelection.length; i < len; i++) {
                initialSelection[i].selected = false;
            }
        }

        // find current entity
        if (resourceId)
            currentEntity = editor.call('entities:get', resourceId);

        if (currentEntity) {
            var item = editor.call('entities:panel:get', resourceId);
            // select in hierarchy
            if (item) {
                hierarchy.selected = [ item ];
                item.selected = true;
            }
        } else {
            hierarchy.selected = [ ];
        }

        filter = fn || null;
        var entities = editor.call('entities:list');
        for(var i = 0; i < entities.length; i++) {
            var id = entities[i].get('resource_id');
            var item = editor.call('entities:panel:get', id);
            if (! item) continue;

            if (filter) {
                if (! filter(entities[i]))
                    item.elementTitle.classList.add('disabled');
            }
        }

        // show hierarchy panel in front
        hierarchyPanel.style.zIndex = 102;
        hierarchyPanel.style.overflow = 'visible';
        // if panel folded?
        hierarchyFolded = hierarchyPanel.folded;
        if (hierarchyFolded)
            hierarchyPanel.folded = false;

        // show overlay
        overlay.hidden = false;
        // flash entities panel
        hierarchyPanel.flash();
        // focus on panel
        setTimeout(function() {
            if (hierarchy.selected.length) {
                hierarchy.selected[0].elementTitle.focus();
            } else {
                hierarchy.element.focus();
            }
        }, 100);
    });


    // close entity picker
    editor.method('picker:entity:close', function() {
        // hide overlay
        overlay.hidden = true;
    });
});


/* editor/pickers/picker-node.js */
editor.once('load', function() {
    'use strict';

    var overlay = new ui.Overlay();
    overlay.class.add('picker-node');
    overlay.center = false;
    overlay.hidden = true;

    var root = editor.call('layout.root');
    root.append(overlay);

    var currentEntities = null;
    var currentAsset = null;

    // esc to close
    editor.call('hotkey:register', 'picker:node:close', {
        key: 'esc',
        callback: function() {
            if (overlay.hidden)
                return;

            overlay.hidden = true;
        }
    });

    // on close asset picker
    overlay.on('hide', function() {
        // reset root header
        var root = editor.call('attributes.rootPanel');
        root.style.zIndex = '';

        // select entities again
        editor.call('selector:history', false);
        editor.call('selector:set', 'entity', currentEntities);
        editor.once('selector:change', function () {
            editor.call('selector:history', true);
        });

        // emit event
        editor.emit('picker:node:close');

        currentEntities = null;
        currentAsset = null;
    });

    var addMapping = function (index, assetId) {
        var resourceIds = [];
        var actions = [];

        for (var i = 0, len = currentEntities.length; i < len; i++) {

            var history = currentEntities[i].history.enabled;
            currentEntities[i].history.enabled = false;

            if (! currentEntities[i].get('components.model.mapping')) {
                var mapping = {};
                mapping[index] = parseInt(assetId, 10);

                actions.push({
                    path: 'components.model.mapping',
                    undo: undefined,
                    redo: mapping
                });

                currentEntities[i].set('components.model.mapping', mapping);

                resourceIds.push(currentEntities[i].get('resource_id'));
            } else {
                if (currentEntities[i].has('components.model.mapping.' + index))
                    continue;

                var id = parseInt(assetId, 10);

                actions.push({
                    path: 'components.model.mapping.' + index,
                    undo: undefined,
                    redo: id
                });

                currentEntities[i].set('components.model.mapping.' + index, id);

                resourceIds.push(currentEntities[i].get('resource_id'));
            }

            currentEntities[i].history.enabled = history;
        }

        editor.call('history:add', {
            name: 'entities.' + (resourceIds.length > 1 ? '*' : resourceIds[0]) + '.components.model.mapping',
            undo: function() {
                for(var i = 0; i < resourceIds.length; i++) {
                    var item = editor.call('entities:get', resourceIds[i]);
                    if (! item)
                        continue;

                    var history = item.history.enabled;
                    item.history.enabled = false;

                    if (actions[i].undo === undefined)
                        item.unset(actions[i].path);
                    else
                        item.set(actions[i].path, actions[i].undo);

                    item.history.enabled = history;
                }
            },
            redo: function() {
                for(var i = 0; i < resourceIds.length; i++) {
                    var item = editor.call('entities:get', resourceIds[i]);
                    if (! item)
                        continue;

                    var history = item.history.enabled;
                    item.history.enabled = false;
                    item.set(actions[i].path, actions[i].redo);
                    item.history.enabled = history;
                }
            }
        });


    };

    var addClickEvent = function (field, index) {
        field.addEventListener('click', function () {
            addMapping(index, currentAsset.get('data.mapping.' + index + '.material'));
            overlay.hidden = true;
        });
    };

    var isAlreadyOverriden = function (index) {
        var len = currentEntities.length;
        var overrideCount = 0;
        for (var i = 0; i < len; i++) {
            if (currentEntities[i].has('components.model.mapping.' + index))
                overrideCount++;
        }

        return overrideCount && overrideCount === len;
    };


    // open asset picker
    editor.method('picker:node', function(entities) {
        // show overlay
        overlay.hidden = false;

        currentEntities = entities;

        // select model asset
        currentAsset = editor.call('assets:get', entities[0].get('components.model.asset'));
        editor.call('selector:history', false);
        editor.call('selector:set', 'asset', [currentAsset]);

        editor.once('attributes:inspect[asset]', function () {
            editor.call('selector:history', true);

            // change header name
            editor.call('attributes:header', 'Entity Materials');

            // hide asset info
            editor.emit('attributes:assets:toggleInfo', false);

            // get mesh instances panel
            var panelNodes = editor.call('attributes:asset:model:nodesPanel');
            if (! panelNodes)
                return;

            panelNodes.style.zIndex = 102;
            panelNodes.style.overflow = 'visible';

            var root = editor.call('attributes.rootPanel');
            root.style.zIndex = 102;

            // flash panel
            panelNodes.flash();

            // add special class
            panelNodes.class.add('picker-node', 'noHeader');

            // add help
            var help = new ui.Label({
                text: '<h5>SELECT MESH INSTANCE</h5>Choose a mesh instance to customize the material for ' + (currentEntities.length > 1 ? 'these Entities.' : 'this Entity.')
            });
            help.class.add('help');
            panelNodes.prepend(help);

            // add click events for each mesh instance field
            var fields = panelNodes.element.getElementsByClassName('field-asset');
            for (var i = 0, len = fields.length; i < len; i++) {
                if (isAlreadyOverriden(i)) {
                    fields[i].classList.add('disabled');
                } else {
                    addClickEvent(fields[i], i);
                }
            }

            // focus panel
            setTimeout(function() {
                panelNodes.element.focus();
            }, 100);
        });

    });


    // close asset picker
    editor.method('picker:node:close', function() {
        // hide overlay
        overlay.hidden = true;
    });
});


/* editor/pickers/picker-project.js */
editor.once('load', function () {
    'use strict';

    // overlay
    var overlay = new ui.Overlay();
    overlay.class.add('picker-project');
    overlay.clickable = true;
    overlay.hidden = true;

    var root = editor.call('layout.root');
    root.append(overlay);

    // main panel
    var panel = new ui.Panel();
    panel.class.add('project');
    overlay.append(panel);

    // left side panel
    var leftPanel = new ui.Panel();
    panel.append(leftPanel);
    leftPanel.class.add('left');

    // project image
    var blankImage = config.url.static + '/platform/images/common/blank_project.png';

    var projectImg = document.createElement('div');
    projectImg.classList.add('image');
    projectImg.style.backgroundImage = 'url("' + (config.project.thumbnails.m || blankImage) + '")';
    leftPanel.append(projectImg);

    var uploadProjectImage = function (file) {
        if (! editor.call('permissions:write'))
            return;

        if (uploadingImage)
            return;

        projectImg.style.backgroundImage = 'url("' + config.url.static + '/platform/images/common/ajax-loader.gif")';
        projectImg.classList.add('progress');

        uploadingImage = true;

        editor.call('images:upload', file, function (data) {
            editor.call('project:save', {image_url: data.url}, function () {
                uploadingImage = false;

            }, function () {
                // error
                uploadingImage = false;

            });
        }, function (status, data) {
            // error
            uploadingImage = false;
        });
    };

    var dropRef = editor.call('drop:target', {
        ref: projectImg,
        filter: function (type, data) {
            return editor.call('permissions:write') &&
                ! uploadingImage &&
                type === 'files';
        },
        drop: function (type, data) {
            if (type !== 'files')
                return;

            var file = data[0];
            if (! file)
                return;

            if (! /^image\//.test(file.type))
                return;

            uploadProjectImage(file);
        }
    });

    dropRef.element.classList.add('drop-area-project-img');

    // hidden file input to upload project image
    var fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';

    var currentSelection = null;
    var uploadingImage = false;

    projectImg.addEventListener('click', function () {
        if (! editor.call('permissions:write'))
            return;

        fileInput.click();
    });


    fileInput.addEventListener('change', function () {
        var file = fileInput.files[0];
        fileInput.value = null;

        uploadProjectImage(file);
    });

    // project info
    var info = document.createElement('div');
    info.classList.add('info');
    leftPanel.append(info);

    // name
    var projectName = new ui.Label({
        text: config.project.name
    });
    projectName.class.add('name');
    info.appendChild(projectName.element);

    // quick stats
    // TODO

    // store all panels for each menu option
    var menuOptions = {};

    var defaultMenuOption = null;

    // menu
    var list = new ui.List();
    leftPanel.append(list);

    // right side panel
    var rightPanel = new ui.Panel('Project');
    panel.append(rightPanel);
    rightPanel.class.add('right');

    // close button
    var btnClose = new ui.Button({
        text: '&#57650;'
    });
    btnClose.class.add('close');
    btnClose.on('click', function () {
        overlay.hidden = true;
    });
    rightPanel.headerElement.appendChild(btnClose.element);

    // register new panel / menu option
    editor.method('picker:project:registerMenu', function (name, title, panel) {
        var menuItem = new ui.ListItem({text: name});
        menuItem.class.add(name);
        list.append(menuItem);

        menuItem.on('click', function () {
            select(name);
        });

        menuOptions[name] = {
            item: menuItem,
            title: title,
            panel: panel
        };
        panel.hidden = true;
        rightPanel.append(panel);
        return menuItem;
    });

    // register panel without a menu option
    editor.method('picker:project:registerPanel', function (name, title, panel) {
        // just do the regular registration but hide the menu
        var item = editor.call('picker:project:registerMenu', name, title, panel);
        item.class.add('hidden');
        return item;
    });

    // set default menu option
    editor.method('picker:project:setDefaultMenu', function (name) {
        defaultMenuOption = name;
    });

    // open popup
    editor.method('picker:project', function (option) {
        overlay.hidden = false;
        select(option || defaultMenuOption);
    });

    // close popup
    editor.method('picker:project:close', function () {
        overlay.hidden = true;
    });

    // ESC key should close popup
    var onKeyDown = function (e) {
        if (e.target && /(input)|(textarea)/i.test(e.target.tagName))
            return;

        if (e.keyCode === 27 && overlay.clickable) {
            overlay.hidden = true;
        }
    };

    // handle show
    overlay.on('show', function () {
        window.addEventListener('keydown', onKeyDown);

        projectImg.classList.remove('progress');
        projectImg.style.backgroundImage = 'url("' + (config.project.thumbnails.m || blankImage) + '")';

        if (editor.call('permissions:write')) {
            projectImg.classList.add('hover');
        } else {
            projectImg.classList.remove('hover');
        }
    });

    // handle hide
    overlay.on('hide', function () {
        currentSelection = null;

        // unsubscribe from keydown
        window.removeEventListener('keydown', onKeyDown);

        // hide all panels
        for (var key in menuOptions) {
            menuOptions[key].panel.hidden = true;
            menuOptions[key].item.class.remove('active');
            menuOptions[key].item.class.remove('selected');
        }
    });

    // prevent user closing popup
    editor.method('picker:project:setClosable', function (closable) {
        btnClose.hidden = !closable;
        overlay.clickable = closable;
    });

    // activate menu option
    var select = function (name) {
        if (! name) return;

        if (currentSelection === name)
            return;

        currentSelection = name;

        // if this is not a scene URL disallow closing the popup
        if (!config.scene.id) {
            editor.call('picker:project:setClosable', false);
        } else {
            // reset closable state
            editor.call('picker:project:setClosable', true);
        }

        // hide all first
        for (var key in menuOptions) {
            menuOptions[key].item.class.remove('active');
            menuOptions[key].panel.hidden = true;
        }

        // show desired option
        menuOptions[name].item.class.add('active');
        menuOptions[name].panel.hidden = false;
        rightPanel.headerElementTitle.textContent = menuOptions[name].title;
        rightPanel.innerElement.scrollTop = 0;
    };

    // subscribe to project image
    editor.on('messenger:project.image', function (data) {
        config.project.thumbnails = data.project.thumbnails;
        projectImg.style.backgroundImage = 'url("' + data.project.thumbnails.m + '")';
        projectImg.classList.remove('progress');
    });


});

/* editor/pickers/picker-scene.js */
editor.once('load', function () {
    'use strict';

    var panel = new ui.Panel();
    panel.class.add('picker-scene-panel');

    editor.call('picker:project:registerMenu', 'scenes', 'Scenes', panel);

    // scene should be the default
    editor.call('picker:project:setDefaultMenu', 'scenes');

    if (!editor.call('permissions:write'))
        panel.class.add('disabled');

    // progress bar and loading label
    var loading = new ui.Label({
        text: 'Loading...'
    });
    panel.append(loading);

    var progressBar = new ui.Progress({progress: 1});
    progressBar.hidden = true;
    panel.append(progressBar);

    var container = new ui.List();
    container.class.add('scene-list');
    panel.append(container);
    container.hidden = true;

    var tooltips = [];
    var events = [];
    var scenes = [];

    var toggleProgress = function (toggle) {
        loading.hidden = !toggle;
        progressBar.hidden = !toggle;
        container.hidden = toggle || !scenes.length;
    };

    // dropdown menu for each scene
    var dropdownMenu = ui.Menu.fromData({
        'scene-duplicate': {
            title: 'Duplicate Scene',
            filter: function () {
                return editor.call('permissions:write');
            },
            select: function () {
                var name = dropdownScene.name;
                var regex = /^(.*?) ([0-9]+)$/;
                var numberPart = 2;
                var namePart = dropdownScene.name;
                var matches = dropdownScene.name.match(regex);
                if (matches && matches.length === 3) {
                    namePart = matches[1];
                    numberPart = parseInt(matches[2], 10);
                }

                // create duplicate scene name
                while (true)  {
                    name = namePart + ' ' + numberPart;
                    var found = true;
                    for (var i = 0; i < scenes.length; i++) {
                        if (scenes[i].name === name) {
                            numberPart++;
                            found = false;
                            break;
                        }
                    }

                    if (found)
                        break;
                }

                editor.call('scenes:duplicate', dropdownScene.id, name);
            }
        },
        'scene-delete': {
            title: 'Delete Scene',
            filter: function () {
                return editor.call('permissions:write');
            },
            select: function () {
                editor.call('picker:confirm', 'Are you sure you want to delete this Scene?');
                editor.once('picker:confirm:yes', function () {
                    var id = dropdownScene.id;
                    onSceneDeleted(id);
                    editor.call('scenes:delete', id);
                });
            }
        }
    });

    editor.call('layout.root').append(dropdownMenu);

    var dropdownScene = null;

    // disables / enables field depending on permissions
    var handlePermissions = function (field) {
        field.disabled = ! editor.call('permissions:write');
        return editor.on('permissions:set:' + config.self.id, function (accessLevel) {
            if (accessLevel === 'write' || accessLevel == 'admin') {
                field.disabled = false;
            } else {
                field.disabled = true;
            }
        });
    };

    // on closing menu remove 'clicked' class from respective dropdown
    dropdownMenu.on('open', function (open) {
        if (! open && dropdownScene) {
            var item = document.getElementById('picker-scene-' + dropdownScene.id);
            if (item) {
                var clicked = item.querySelector('.clicked');
                if (clicked) {
                    clicked.classList.remove('clicked');
                    clicked.innerHTML = '&#57689;';
                }
            }
        }
    });

    // new scene button
    var newScene = new ui.Button({
        text: 'Add new Scene'
    });

    handlePermissions(newScene);
    newScene.class.add('new');

    panel.append(newScene);

    newScene.on('click', function () {
        if (! editor.call('permissions:write'))
            return;

        newScene.disabled = true;

        // add list item
        var listItem = new ui.ListItem();
        container.append(listItem);

        // add label
        var label = new ui.Label({
            text: 'Enter Scene name and press Enter:'
        });
        label.class.add('new-scene-label');
        listItem.element.appendChild(label.element);

        // add new scene input field
        var input = new ui.TextField({
            default: 'Untitled',
            placeholder: 'Enter Scene name and press Enter'
        });

        input.blurOnEnter = false;

        listItem.element.appendChild(input.element);

        input.elementInput.focus();
        input.elementInput.select();

        var destroyField = function () {
            listItem.destroy();
            newScene.disabled = false;
        };

        input.elementInput.addEventListener('blur', destroyField);

        input.elementInput.addEventListener('keydown', function (e) {
            if (e.keyCode === 13) {
                if (! input.value) return;

                editor.call('picker:scene:close');
                editor.call('scenes:new', input.value, function (scene) {
                    editor.call('scene:load', scene.id, true);
                });
            }
        });
    });

    // on show
    panel.on('show', function () {
        toggleProgress(true);

        // load scenes
        editor.call('scenes:list', function (items) {
            toggleProgress(false);
            scenes = items;
            refreshScenes();
        });

        if (editor.call('viewport:inViewport'))
            editor.emit('viewport:hover', false);
    });

    // on hide
    panel.on('hide', function() {
        destroyTooltips();
        destroyEvents();
        scenes = [];

        // destroy scene items because same row ids
        // might be used by download / new build popups
        container.element.innerHTML = '';

        editor.emit('picker:scene:close');

        if (editor.call('viewport:inViewport'))
            editor.emit('viewport:hover', true);
    });

    editor.on('viewport:hover', function(state) {
        if (state && ! panel.hidden) {
            setTimeout(function() {
                editor.emit('viewport:hover', false);
            }, 0);
        }
    });

    // create row for scene
    var createSceneEntry = function (scene) {
        var row = new ui.ListItem();
        row.element.id = 'picker-scene-' + scene.id;

        container.append(row);

        if (config.scene.id && parseInt(scene.id, 10) === parseInt(config.scene.id, 10))
            row.class.add('current');

        if (parseInt(scene.id, 10) === parseInt(config.project.primaryScene, 10))
            row.class.add('primary');

        // primary scene icon
        var primary = new ui.Button({
            text: '&#57891'
        });
        events.push(handlePermissions(primary));
        primary.class.add('primary');
        row.element.appendChild(primary.element);

        events.push(primary.on('click', function () {
            if (!editor.call('permissions:write') || config.project.primaryScene === scene.id)
                return;

            var prevPrimary = config.project.primaryScene;
            config.project.primaryScene = scene.id;
            onPrimarySceneChanged(scene.id, prevPrimary);
            editor.call('project:setPrimaryScene', scene.id);
        }));

        // show tooltip for primary scene icon
        var tooltipText = parseInt(scene.id, 10) === parseInt(config.project.primaryScene, 10) ? 'Primary Scene' : 'Set Primary Scene';
        var tooltip = Tooltip.attach({
            target: primary.element,
            text: tooltipText,
            align: 'right',
            root: editor.call('layout.root')
        });
        tooltips.push(tooltip);

        // scene name
        var name = new ui.Label({
            text: scene.name
        });
        name.class.add('name');

        row.element.appendChild(name.element);

        // scene date
        var date = new ui.Label({
            text: editor.call('datetime:convert', scene.modified)
        });
        date.class.add('date');
        row.element.appendChild(date.element);

        // dropdown
        var dropdown = new ui.Button({
            text: '&#57689;'
        });
        dropdown.class.add('dropdown');
        row.element.appendChild(dropdown.element);

        dropdown.on('click', function () {
            dropdown.class.add('clicked');
            dropdown.element.innerHTML = '&#57687;';

            dropdownScene = scene;
            dropdownMenu.open = true;
            var rect = dropdown.element.getBoundingClientRect();
            dropdownMenu.position(rect.right - dropdownMenu.innerElement.clientWidth, rect.bottom);
        });

        if (parseInt(config.scene.id, 10) !== parseInt(scene.id, 10)) {
            events.push(row.on('click', function (e) {
                if (e.target === row.element || e.target === name.element || e.target === date.element) {
                    if (parseInt(config.scene.id, 10) === parseInt(scene.id, 10))
                        return;

                    editor.call('picker:scene:close');
                    editor.call('scene:load', scene.id);
                }
            }));
        }

        return row;
    };

    var sortScenes = function (scenes) {
        scenes.sort(function (a, b) {
            var primary = parseInt(config.project.primaryScene, 10);
            if (primary === parseInt(a.id, 10)) {
                return -1;
            } else if (primary === parseInt(b.id, 10)) {
                return 1;
            } else {
                if (a.modified < b.modified) {
                    return 1;
                } else if (a.modified > b.modified) {
                    return -1;
                } else {
                    return 0;
                }
            }
        });
    };

    var refreshScenes = function () {
        dropdownMenu.open = false;
        destroyTooltips();
        destroyEvents();
        container.element.innerHTML = '';
        sortScenes(scenes);
        container.hidden = scenes.length === 0;
        scenes.forEach(createSceneEntry);
    };

    // call picker
    editor.method('picker:scene', function() {
        editor.call('picker:project', 'scenes');
    });

    // close picker
    editor.method('picker:scene:close', function() {
        editor.call('picker:project:close');
    });

    var onSceneDeleted = function (sceneId) {
        // if loaded scene deleted do not allow closing popup
        if (!config.scene.id || parseInt(config.scene.id, 10) === parseInt(sceneId, 10)) {
            editor.call('picker:project:setClosable', false);
        }

        if (panel.hidden) return;

        var row = document.getElementById('picker-scene-' + sceneId);
        if (row) {
            row.parentElement.removeChild(row);
        }

        for (var i = 0; i < scenes.length; i++) {
            if (parseInt(scenes[i].id, 10) === parseInt(sceneId, 10)) {
                // close dropdown menu if current scene deleted
                if (dropdownScene === scenes[i])
                    dropdownMenu.open = false;

                scenes.splice(i, 1);
                break;
            }
        }

        if (! scenes.length) {
            container.hidden = true;
        }

    };

    // subscribe to messenger pack.delete
    editor.on('messenger:pack.delete', function (data) {
        onSceneDeleted(data.pack.id);
    });

    // subscribe to messenger pack.new
    editor.on('messenger:pack.new', function (data) {
        if (panel.hidden) return;

        editor.call('scenes:get', data.pack.id, function (scene) {
            if (panel.hidden) return; // check if hidden when Ajax returns

            scenes.push({
                id: scene.id,
                modified: scene.modified,
                name: scene.name
            });

            refreshScenes();
        });
    });

    editor.on('project:primaryScene', onPrimarySceneChanged);

    var destroyTooltips = function () {
        tooltips.forEach(function (tooltip) {
            tooltip.destroy();
        });
        tooltips = [];
    };

    var destroyEvents = function () {
        events.forEach(function (evt) {
            evt.unbind();
        });
        events = [];
    };

    var onPrimarySceneChanged = function (newValue, oldValue) {
        if (panel.hidden || parseInt(newValue, 10) === parseInt(oldValue, 10)) return;

        refreshScenes();
    };


    // open picker if no scene is loaded
    if (!config.scene.id)
        editor.call('picker:scene');

});


/* editor/pickers/picker-script-create.js */
editor.once('load', function() {
    'use strict';

    var callback = null;
    var filenameValid = /^([^0-9.#<>$+%!`&='{}@\\/:*?"<>|\n])([^#<>$+%!`&='{}@\\/:*?"<>|\n])*$/i;

    // overlay
    var overlay = new ui.Overlay();
    overlay.class.add('picker-script-create');
    overlay.hidden = true;

    // label
    var label = new ui.Label();
    label.text = 'Enter script filename:';
    label.class.add('text');
    overlay.append(label);

    var input = new ui.TextField();
    input.blurOnEnter = false;
    input.renderChanges = false;
    overlay.append(input);

    var validate = new ui.Label();
    validate.text = 'Invalid filename';
    validate.class.add('validate');
    overlay.append(validate);

    input.element.addEventListener('keydown', function(evt) {
        if (overlay.hidden) return;

        if (evt.keyCode === 13) {
            // enter
            var filename = input.value.trim();
            if (! filename || ! filenameValid.test(filename)) {
                validate.hidden = false;
            } else {
                validate.hidden = true;

                if (! filename.endsWith('.js'))
                    filename += '.js';

                if (callback)
                    callback(filename);

                overlay.hidden = true;
            }
        } else if (evt.keyCode === 27) {
            // esc
            overlay.hidden = true;
        }
    }, false);

    var root = editor.call('layout.root');
    root.append(overlay);


    // on overlay hide
    overlay.on('hide', function() {
        editor.emit('picker:script-create:close');
    });

    editor.method('picker:script-create:validate', function(filename) {
        if (! filename || ! filenameValid.test(filename)) {
            return false;
        } else {
            if (! filename.endsWith('.js'))
                filename += '.js';

            return filename;
        }
    });

    // call picker
    editor.method('picker:script-create', function(fn, string) {
        callback = fn || null;

        // show overlay
        overlay.hidden = false;
        validate.hidden = true;
        input.value = string || '';

        setTimeout(function() {
            input.elementInput.focus();
        }, 100);
    });

    // close picker
    editor.method('picker:script-create:close', function() {
        overlay.hidden = true;
    });
});


/* editor/pickers/picker-builds.js */
editor.once('load', function () {
    'use strict';

    // main panel
    var panel = new ui.Panel();
    panel.class.add('picker-builds');

    // holds events that need to be destroyed
    var events = [];

    // disables / enables field depending on permissions
    var handlePermissions = function (field) {
        field.disabled = ! editor.call('permissions:write');
        return editor.on('permissions:set:' + config.self.id, function (accessLevel) {
            if (accessLevel === 'write' || accessLevel == 'admin') {
                field.disabled = false;
            } else {
                field.disabled = true;
            }
        });
    };

    // progress bar and loading label
    var loading = new ui.Label({
        text: 'Loading...'
    });
    panel.append(loading);

    var progressBar = new ui.Progress({progress: 1});
    progressBar.hidden = true;
    panel.append(progressBar);

    // no builds message
    var noBuilds = new ui.Label({
        text: 'You have not published any builds. Click PUBLISH to create a new build.'
    });
    noBuilds.hidden = true;
    noBuilds.style.padding = '15px';
    panel.append(noBuilds);

    // published build section
    var publishedBuild = new ui.Label({
        text: 'Your primary build is available at <a href="' + config.project.playUrl + '" target="_blank">' + config.project.playUrl + '</a>.'
    });
    publishedBuild.class.add('build');
    panel.append(publishedBuild);

    // container for builds
    var container = new ui.List();
    panel.append(container);

    // app whose dropdown was last clicked
    var dropdownApp = null;

    // all loaded builds
    var apps = [];

    // holds all tooltips
    var tooltips = [];

    var dropdownMenu = ui.Menu.fromData({
        'app-delete': {
            title: 'Delete',
            filter: function () {
                return editor.call('permissions:write');
            },
            select: function () {
                editor.call('picker:confirm', 'Are you sure you want to delete this Build?');
                editor.once('picker:confirm:yes', function () {
                    removeApp(dropdownApp);
                    editor.call('apps:delete', dropdownApp.id);
                });
            }
        }
    });

    // add menu
    editor.call('layout.root').append(dropdownMenu);

    // on closing menu remove 'clicked' class from respective dropdown
    dropdownMenu.on('open', function (open) {
        if (! open && dropdownApp) {
            var item = document.getElementById('app-' + dropdownApp.id);
            if (item) {
                var clicked = item.querySelector('.clicked');
                if (clicked) {
                    clicked.innerHTML = '&#57689;';
                    clicked.classList.remove('clicked');
                }
            }
        }
    });

    // register panel with project popup
    editor.call('picker:project:registerMenu', 'builds', 'Builds', panel);

    // open publishing popup
    editor.method('picker:builds', function () {
        editor.call('picker:project', 'builds');
    });

    var toggleProgress = function (toggle) {
        loading.hidden = !toggle;
        progressBar.hidden = !toggle;
        container.hidden = toggle || apps.length === 0;
        publishedBuild.hidden = toggle || !config.project.primaryApp;
        noBuilds.hidden = toggle || apps.length > 0;
    };

    // load app list
    var loadApps = function () {
        toggleProgress(true);

        editor.call('apps:list', function (results) {
            apps = results;
            toggleProgress(false);
            refreshApps();
        });
    };

    // recreate app list UI
    var refreshApps = function () {
        dropdownMenu.open = false;
        destroyTooltips();
        destroyEvents();
        container.element.innerHTML = '';
        sortApps(apps);
        container.hidden = apps.length === 0;
        apps.forEach(createAppItem);
    };

    var destroyTooltips = function () {
        tooltips.forEach(function (tooltip) {
            tooltip.destroy();
        });
        tooltips = [];
    };

    var destroyEvents = function () {
        events.forEach(function (evt) {
            evt.unbind();
        });
        events = [];
    };

    // sort apps by primary first and then created date
    var sortApps = function (apps) {
        return apps.sort(function (a, b) {
            if (config.project.primaryApp === a.id) {
                return -1;
            } else if (config.project.primaryApp === b.id) {
                return 1;
            } else {
                if (a.created_at < b.created_at) {
                    return 1;
                } else if (a.created_at > b.created_at) {
                    return -1;
                } else {
                    return 0;
                }
            }
        });
    };

    // create UI for single app
    var createAppItem = function (app) {
        var item = new ui.ListItem();
        item.element.id = 'app-' + app.id;

        container.append(item);

        if (config.project.primaryApp === app.id) {
            item.class.add('primary');
        }

        item.class.add(app.task.status);

        // primary app button
        var primary = new ui.Button({
            text: '&#57891'
        });
        events.push(handlePermissions(primary));
        if (! primary.disabled && app.task.status !== 'complete')
            primary.disabled = true;
        primary.class.add('primary');
        item.element.appendChild(primary.element);

        // set primary app
        events.push(primary.on('click', function () {
            if (config.project.primaryApp === app.id || app.task.status !== 'complete')
                return;

            editor.call('project:setPrimaryApp', app.id, null, function () {
                // error - refresh apps again to go back to previous state
                refreshApps();
            });

            // refresh apps instantly
            refreshApps();
        }));

        // primary icon tooltip
        var tooltipText = config.project.primaryApp === app.id ? 'Primary build' : 'Change the projects\'s primary build';
        var tooltip = Tooltip.attach({
            target: primary.element,
            text: tooltipText,
            align: 'right',
            root: editor.call('layout.root')
        });
        tooltips.push(tooltip);

        // status icon or image
        var status = document.createElement('span');
        status.classList.add('status');
        item.element.appendChild(status);

        var img;

        if (app.task.status === 'complete') {
            img = new Image();
            img.src = app.thumbnails ? app.thumbnails.s : (config.project.thumbnails.s || config.url.static + '/platform/images/common/blank_project.png');
            status.appendChild(img);
        } else if (app.task.status === 'running') {
            img = new Image();
            img.src = config.url.static + "/platform/images/common/ajax-loader.gif";
            status.appendChild(img);
        }

        var nameRow = document.createElement('div');
        nameRow.classList.add('name-row');
        item.element.appendChild(nameRow);

        // app name
        var name = new ui.Label({
            text: app.name
        });
        name.class.add('name');
        nameRow.appendChild(name.element);

        // app version
        var version = new ui.Label({
            text: app.version
        });
        version.class.add('version');
        nameRow.appendChild(version.element);

        // row below name
        var info = document.createElement('div');
        info.classList.add('info');
        item.element.appendChild(info);

        // date
        var date = new ui.Label({
            text: editor.call('datetime:convert', app.created_at)
        });
        date.class.add('date');
        date.hidden = app.task.status === 'error';
        info.appendChild(date.element);

        // views
        var views = new ui.Label({
            text: numberWithCommas(app.views)
        });
        views.class.add('views');
        views.hidden = app.task.status !== 'complete';
        info.appendChild(views.element);

        // size
        var size = new ui.Label({
            text: sizeToString(app.size)
        });
        size.hidden = app.task.status !== 'complete';
        size.class.add('size');
        info.appendChild(size.element);

        // error message
        var error = new ui.Label({
            text: app.task.message
        });
        error.hidden = app.task.status !== 'error';
        error.class.add('error');
        item.element.appendChild(error.element);

        // release notes
        var releaseNotes = app.release_notes || '';
        var indexOfNewLine = releaseNotes.indexOf('\n');
        if (indexOfNewLine !== -1) {
            releaseNotes = releaseNotes.substring(0, indexOfNewLine);
        }
        var notes = new ui.Label({
            text: app.release_notes
        });
        notes.renderChanges = false;
        notes.class.add('notes');
        notes.hidden = !error.hidden;
        item.element.appendChild(notes.element);

        // dropdown
        var dropdown = new ui.Button({
            text: '&#57689;'
        });
        dropdown.class.add('dropdown');
        item.element.appendChild(dropdown.element);

        events.push(dropdown.on('click', function () {
            dropdown.class.add('clicked');
            // change arrow
            dropdown.element.innerHTML = '&#57687;';
            dropdownApp = app;

            // open menu
            dropdownMenu.open = true;

            // position dropdown menu
            var rect = dropdown.element.getBoundingClientRect();
            dropdownMenu.position(rect.right - dropdownMenu.innerElement.clientWidth, rect.bottom);
        }));

        var more = new ui.Button({text: 'more...'});
        more.class.add('more');
        item.element.appendChild(more.element);
        more.hidden = true;

        events.push(more.on('click', function () {
            if (notes.class.contains('no-wrap')) {
                notes.text = app.release_notes;
                notes.class.remove('no-wrap');
                more.text = 'less...';
            } else {
                notes.class.add('no-wrap');
                more.text = 'more...';
                notes.text = releaseNotes;
            }
        }));

        if (notes.element.clientHeight > 22) {
            more.hidden = false;
            notes.class.add('no-wrap');
            notes.text = releaseNotes;
        }

        if (app.task.status === 'complete') {
            // handle row click
            var validTargets = [
                status,
                img,
                info,
                item.element,
                name.element,
                date.element,
                size.element,
                views.element,
                notes.element
            ];

            events.push(item.on('click', function (e) {
                if (validTargets.indexOf(e.target) !== -1) {
                    e.stopPropagation();
                    window.open(app.url);
                }
            }));
        }


        return item;
    };

    // Return the size fixed to 2 digits precision.
    // If the result does not have any decimal points then remove them
    var toFixed = function (size) {
        var result = size.toFixed(2);
        if (result % 1 === 0) {
            result = Math.floor(result);
        }

        return result;
    };

    // convert size in bytes to readable string
    var sizeToString = function (size) {
        var base = 1000;

        if (isNaN(size))
            size = 0;

        if (size < base)
            return size + ' Bytes';

        size /= base;

        if (size < base)
            return toFixed(size) + ' KB';

        size /= base;

        if (size < base)
            return toFixed(size) + ' MB';

        size /= base;

        if (size < base)
            return toFixed(size) + ' GB';

        size /= base;

        return toFixed(size) + ' TB';
    };

    // adds commas every 3 decimals
    var numberWithCommas = function (number) {
        var parts = number.toString().split(".");
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        return parts.join(".");
    };

    // removes an app from the UI
    var removeApp = function (app) {
        var item = document.getElementById('app-' + app.id);
        if (item) {
            item.remove();
        }

        // remove from apps array
        for (var i = 0; i < apps.length; i++) {
            if (apps[i].id === app.id) {
                // close dropdown menu if current app deleted
                if (dropdownApp === apps[i])
                    dropdownMenu.open = false;

                apps.splice(i, 1);
                break;
            }
        }

        container.hidden = apps.length === 0;
    };

    // handle external updates to primary app
    editor.on('project:primaryApp', function (newValue, oldValue) {
        if (panel.hidden) return;

        if (!newValue) {
            publishedBuild.hidden = true;
            return;
        }

        publishedBuild.hidden = false;

        // check if we need to refresh UI
        var currentPrimary = document.getElementById('app-' + newValue);
        if (currentPrimary && currentPrimary.classList.contains('primary'))
            return;

        refreshApps();
    });

    // handle app created externally
    editor.on('messenger:app.new', function (data) {
        if (panel.hidden) return;

        // get app from server
        editor.call('apps:get', data.app.id, function (app) {
            apps.push(app);
            refreshApps();
        });
    });

    // handle external delete
    editor.on('messenger:app.delete', function (data) {
        if (panel.hidden) return;

        removeApp(data.app);
    });

    // handle external app updates
    editor.on('messenger:app.update', function (data) {
        if (panel.hidden) return;

        // get app from server
        editor.call('apps:get', data.app.id, function (app) {
            for (var i = 0; i < apps.length; i++) {
                if (apps[i].id === app.id) {
                    apps[i] = app;
                }
            }
            refreshApps();
        });
    });

    // on show
    panel.on('show', function () {
        loadApps();

        if (editor.call('viewport:inViewport'))
            editor.emit('viewport:hover', false);
    });

    // on hide
    panel.on('hide', function () {
        apps = [];
        destroyTooltips();
        destroyEvents();

        if (editor.call('viewport:inViewport'))
            editor.emit('viewport:hover', true);
    });

    editor.on('viewport:hover', function(state) {
        if (state && ! panel.hidden) {
            setTimeout(function() {
                editor.emit('viewport:hover', false);
            }, 0);
        }
    });
});


/* editor/pickers/picker-publish.js */
editor.once('load', function () {
    'use strict';

    // main panel
    var panel = new ui.Panel();
    panel.class.add('picker-publish');

    // register panel with project popup
    editor.call('picker:project:registerMenu', 'publish', 'Publish', panel);

    // disables / enables field depending on permissions
    var handlePermissions = function (field) {
        field.disabled = ! editor.call('permissions:write');
        return editor.on('permissions:set:' + config.self.id, function (accessLevel) {
            if (accessLevel === 'write' || accessLevel == 'admin') {
                field.disabled = false;
            } else {
                field.disabled = true;
            }
        });
    };

    // open publishing popup
    editor.method('picker:publish', function () {
        editor.call('picker:project', 'publish');
    });


    // playcanv.as
    var panelPlaycanvas = new ui.Panel();
    panelPlaycanvas.class.add('buttons');
    panel.append(panelPlaycanvas);

    panelPlaycanvas.append(new ui.Label({
        text: 'Publish on PlayCanvas.'
    }));

    // publish button
    var btnPublish = new ui.Button({text: 'Publish'});
    btnPublish.class.add('publish');
    handlePermissions(btnPublish);
    panelPlaycanvas.append(btnPublish);

    btnPublish.on('click', function () {
        editor.call('picker:publish:new');
    });

    // facebook instant
    var panelFbInstant = new ui.Panel();
    panelFbInstant.class.add('buttons');
    panel.append(panelFbInstant);
    panelFbInstant.hidden = !config.self.superUser && !config.self.publishFacebook

    panelFbInstant.append(new ui.Label({
        text: 'Publish build to Facebook Instant Games.'
    }));

    var btnPublishFb = new ui.Button({text: 'Publish'});
    btnPublishFb.class.add('publish-fb');
    handlePermissions(btnPublishFb);
    panelFbInstant.append(btnPublishFb);

    btnPublishFb.on('click', function () {
        editor.call('picker:publish:facebook');
    });


    // self host
    var panelSelfHost = new ui.Panel();
    panelSelfHost.class.add('buttons');
    panel.append(panelSelfHost);

    panelSelfHost.append(new ui.Label({
        text: 'Download build and host it on your own server.'
    }));

    // download button
    var btnDownload = new ui.Button({text: 'Download'});
    btnDownload.class.add('download');
    handlePermissions(btnDownload);
    panelSelfHost.append(btnDownload);

    btnDownload.on('click', function () {
        editor.call('picker:publish:download');
    });

    // on show
    panel.on('show', function () {
        editor.emit('picker:publish:open');

        if (editor.call('viewport:inViewport'))
            editor.emit('viewport:hover', false);
    });

    // on hide
    panel.on('hide', function () {
        editor.emit('picker:publish:close');

        if (editor.call('viewport:inViewport'))
            editor.emit('viewport:hover', true);
    });

    editor.on('viewport:hover', function(state) {
        if (state && ! panel.hidden) {
            setTimeout(function() {
                editor.emit('viewport:hover', false);
            }, 0);
        }
    });
});


/* editor/pickers/picker-publish-new.js */
editor.once('load', function () {
    'use strict';

    var legacyScripts = editor.call('settings:project').get('useLegacyScripts');

    // holds all tooltips
    var tooltips = [];

    // holds events that need to be destroyed
    var events = [];

    // main panel
    var panel = new ui.Panel();
    panel.class.add('picker-publish-new');

    var privateSettings = editor.call('settings:projectPrivate');

    // register panel with project popup
    editor.call('picker:project:registerPanel', 'publish-download', 'Download New Build', panel);
    editor.call('picker:project:registerPanel', 'publish-new', 'Publish New Build', panel);
    editor.call('picker:project:registerPanel', 'publish-facebook', 'Publish to Facebook Instant Games', panel);

    var mode = 'publish';

    editor.method('picker:publish:new', function () {
        mode = 'publish';
        editor.call('picker:project', 'publish-new');
        panel.class.remove('download-mode');
        panel.class.remove('facebook-mode');
        panel.class.remove('upgrade');
    });

    editor.method('picker:publish:download', function () {
        mode = 'download';
        editor.call('picker:project', 'publish-download');
        panel.class.add('download-mode');
        panel.class.remove('facebook-mode');

        if (config.owner.plan.type === 'free') {
            panel.class.add('upgrade');
        } else {
            panel.class.remove('upgrade');
        }
    });

    editor.method('picker:publish:facebook', function () {
        mode = 'facebook';
        editor.call('picker:project', 'publish-facebook')
        panel.class.remove('download-mode');
        panel.class.add('facebook-mode');

        if (config.owner.plan.type === 'free') {
            panel.class.add('upgrade');
        } else {
            panel.class.remove('upgrade');
        }

        panelFbId.hidden = !!privateSettings.get('facebook.appId');
        panelFbToken.hidden = !!privateSettings.get('facebook.uploadToken');
        if (! panelFbToken.hidden) {
            tooltipToken.html = getTooltipTokenHtml();
        }
    });

    // upgrade notice
    var labelUpgrade = new ui.Label({
        text: 'This is a premium feature. <a href="/upgrade?account=' + config.owner.username + '" target="_blank">UPGRADE</a> to be able to download your project.'
    });
    labelUpgrade.class.add('upgrade');
    panel.append(labelUpgrade);

    // info panel
    var panelInfo = new ui.Panel();
    panelInfo.class.add('info');
    panel.append(panelInfo);

    // image
    var imageField = document.createElement('div');
    imageField.classList.add('image');
    panelInfo.append(imageField);

    var blankImage = config.url.static + '/platform/images/common/blank_project.png';

    var clearAppImage = function () {
        imageField.classList.remove('progress');
        if (config.project.thumbnails.m) {
            imageField.classList.remove('blank');
            imageField.style.backgroundImage = 'url("' + config.project.thumbnails.m + '")';
        } else {
            imageField.classList.add('blank');
            imageField.style.backgroundImage = 'url("' + blankImage + '")';
        }
    };

    var setAppImage = function (url) {
        imageField.classList.remove('progress');
        imageField.classList.remove('blank');
        imageField.style.backgroundImage = 'url("' + url + '")';
    };

    clearAppImage();

    // hidden file picker used to upload image
    var fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';

    imageField.addEventListener('click', function () {
        if (! editor.call('permissions:write'))
            return;

        fileInput.click();
    });

    var imageS3Key = null;
    var isUploadingImage = false;

    fileInput.addEventListener('change', function () {
        if (isUploadingImage)
            return;

        isUploadingImage = true;
        refreshButtonsState();

        imageField.classList.remove('blank');
        imageField.classList.add('progress');
        imageField.style.backgroundImage = 'url("' + config.url.static + '/platform/images/common/ajax-loader.gif")';

        var file = fileInput.files[0];
        fileInput.value = null;

        editor.call('images:upload', file, function (data) {
            imageS3Key = data.s3Key;
            isUploadingImage = false;
            refreshButtonsState();

            setAppImage(data.url);
        }, function (status, data) {
            // error
            isUploadingImage = false;
            refreshButtonsState();

            clearAppImage();
        });
    });

    var group = document.createElement('span');
    panelInfo.append(group);

    // name
    var label = new ui.Label({text: 'Title'});
    label.class.add('field-label');
    group.appendChild(label.element);

    var inputNameError = new ui.Label({
        text: 'Cannot exceed 1000 characters'
    });
    inputNameError.class.add('error');
    inputNameError.hidden = true;
    group.appendChild(inputNameError.element);

    var inputName = new ui.TextField();
    inputName.renderChanges = false;
    inputName.placeholder = 'Required';
    inputName.class.add('name');
    inputName.class.add('input-field');
    group.appendChild(inputName.element);

    inputName.elementInput.addEventListener('keyup', function (e) {
        inputNameError.hidden = inputName.elementInput.value.length <= 1000;
        refreshButtonsState();
    });

    label = new ui.Label({text: 'Click on the image to upload artwork. 720 x 720px'});
    label.class.add('image-click');
    group.appendChild(label.element);

    // description
    var panelDescription = new ui.Panel();
    panelDescription.class.add('description');
    panel.append(panelDescription);

    label = new ui.Label({text: 'Description'});
    label.class.add('field-label');
    panelDescription.append(label);

    var inputDescError = new ui.Label({
        text: 'Cannot exceed 10000 characters'
    });
    inputDescError.class.add('error');
    inputDescError.hidden = true;
    panelDescription.append(inputDescError);

    var inputDescription = document.createElement('textarea');
    inputDescription.addEventListener('keyup', function (e) {
        if (e.keyCode === 27) {
            inputDescription.blur();
        }

        inputDescError.hidden = inputDescription.value.length < 10000;
        refreshButtonsState();
    });
    panelDescription.append(inputDescription);

    // version
    var panelVersion = new ui.Panel();
    panelVersion.class.add('version');
    panel.append(panelVersion);

    label = new ui.Label({text: 'Version'});
    label.class.add('field-label');
    panelVersion.append(label);

    var inputVersionError = new ui.Label({
        text: 'Cannot exceed 20 characters'
    });
    inputVersionError.class.add('error');
    inputVersionError.hidden = true;
    panelVersion.append(inputVersionError);

    var inputVersion = new ui.TextField();
    inputVersion.renderChanges = false;
    inputVersion.class.add('input-field');
    inputVersion.placeholder = 'e.g. 1.0.0';
    panelVersion.append(inputVersion);

    inputVersion.elementInput.addEventListener('keyup', function (e) {
        inputVersionError.hidden = inputVersion.value.length <= 20;
        refreshButtonsState();
    });

    // facebook
    var panelFbId = new ui.Panel()
    panelFbId.class.add('facebook');
    panel.append(panelFbId)

    // app id
    label = new ui.Label({text: 'App ID'});
    label.class.add('field-label');
    panelFbId.append(label);

    var btnHelpAppId = new ui.Button({
        text: '&#57656;'
    });
    btnHelpAppId.class.add('help');
    panelFbId.append(btnHelpAppId);

    var tooltipFbId = Tooltip.attach({
        target: btnHelpAppId.element,
        html: 'This is the Facebook App ID which you can find at the dashboard of your Facebook application. Click <a href="https://developers.facebook.com/apps/" target="_blank">here</a> to see all your Facebook applications.',
        align: 'left',
        hoverable: true,
        root: editor.call('layout.root')
    });
    tooltipFbId.class.add('publish-facebook');

    var suspendFbChanges = false;

    var inputFbAppId = new ui.TextField();
    inputFbAppId.class.add('input-field');
    inputFbAppId.renderChanges = false;
    inputFbAppId.placeholder = 'e.g. 777394875732366';
    panelFbId.append(inputFbAppId);
    inputFbAppId.on('change', function (value) {
        if (! suspendFbChanges)
            privateSettings.set('facebook.appId', value);
        tooltipToken.html = getTooltipTokenHtml();
        refreshButtonsState();
    });

    privateSettings.on('facebook.appId:set', function (value) {
        suspendFbChanges = true;
        inputFbAppId.value = value;
        suspendFbChanges = false;
    });

    // upload token
    var panelFbToken = new ui.Panel()
    panelFbToken.class.add('facebook');
    panel.append(panelFbToken);

    label = new ui.Label({text: 'Upload Access Token'});
    label.class.add('field-label');
    panelFbToken.append(label);

    var btnHelpToken = new ui.Button({
        text: '&#57656;'
    });
    btnHelpToken.class.add('help');
    panelFbToken.append(btnHelpToken);

    var getTooltipTokenHtml = function () {
        var result = 'An Access Token used when uploading a build to Facebook. You can find this under the ';
        if (privateSettings.get('facebook.appId')) {
            result += '<a href="https://developers.facebook.com/apps/' + privateSettings.get('facebook.appId') + '/hosting/" target="_blank">Canvas Hosting page</a>';
        } else {
            result +=  'Canvas Hosting page';
        }
        result += ' at the dashboard of your Facebook application.';
        return result;
    };

    var tooltipToken = Tooltip.attach({
        target: btnHelpToken.element,
        html: getTooltipTokenHtml(),
        align: 'left',
        hoverable: true,
        root: editor.call('layout.root')
    });
    tooltipToken.class.add('publish-facebook');

    var inputFbUploadToken = new ui.TextField();
    inputFbUploadToken.class.add('input-field');
    inputFbUploadToken.renderChanges = false;
    panelFbToken.append(inputFbUploadToken);

    inputFbUploadToken.on('change', function (value) {
        if (! suspendFbChanges)
            privateSettings.set('facebook.uploadToken', value);
        refreshButtonsState();
    });

    privateSettings.on('facebook.uploadToken:set', function (value) {
        suspendFbChanges = true;
        inputFbUploadToken.value = value;
        suspendFbChanges = false;
    });

    // release notes
    var panelNotes = new ui.Panel();
    panelNotes.class.add('notes');
    panel.append(panelNotes);

    label = new ui.Label({text: 'Release Notes'});
    label.class.add('field-label');
    panelNotes.append(label);

    var inputNotesError = new ui.Label({
        text: 'Cannot exceed 10000 characters'
    });
    inputNotesError.class.add('error');
    inputNotesError.hidden = true;
    panelNotes.append(inputNotesError);

    var inputNotes = document.createElement('textarea');
    panelNotes.append(inputNotes);
    inputNotes.addEventListener('keyup', function (e) {
        if (e.keyCode === 27) {
            inputNotes.blur();
        }

        inputNotesError.hidden = inputNotes.value.length <= 10000;
        refreshButtonsState();
    });


    if (! legacyScripts) {
        // options
        var panelOptions = new ui.Panel();
        panelOptions.class.add('options');
        panel.append(panelOptions);

        label = new ui.Label({text: 'Options'});
        label.class.add('field-label');
        panelOptions.append(label);

        // concatenate scripts
        var panelOptionsConcat = new ui.Panel();
        panelOptionsConcat.class.add('field');
        panelOptions.append(panelOptionsConcat);
        var fieldOptionsConcat = new ui.Checkbox();
        fieldOptionsConcat.value = true;
        fieldOptionsConcat.class.add('tick');
        panelOptionsConcat.append(fieldOptionsConcat);
        var label = new ui.Label({ text: 'Concatenate Scripts' });
        panelOptionsConcat.append(label);
    }


    // scenes
    var panelScenes = new ui.Panel();
    panelScenes.class.add('scenes');
    panel.append(panelScenes);

    label = new ui.Label({text: 'Choose Scenes'});
    panelScenes.append(label);

    var selectAll = new ui.Checkbox();
    selectAll.class.add('tick');
    panelScenes.append(selectAll);

    label = new ui.Label({text: 'Select all'});
    panelScenes.append(label);
    label.class.add('select-all');

    // scenes container
    var container = new ui.List();
    container.class.add('scene-list');
    panelScenes.append(container);

    var panelNoScenes = new ui.Panel();
    panelNoScenes.class.add('scenes');
    panel.append(panelNoScenes);

    // no scenes msg
    var labelNoScenes = new ui.Label({text: 'There are no scenes.'});
    labelNoScenes.class.add('error');
    labelNoScenes.hidden = true;
    panelNoScenes.append(labelNoScenes);

    // loading scenes
    var loadingScenes = new ui.Label({
        text: 'Loading scenes...'
    });
    panelNoScenes.append(loadingScenes);

    var progressBar = new ui.Progress({progress: 1});
    progressBar.hidden = false;
    panelNoScenes.append(progressBar);

    // holds all scenes
    var scenes = [];

    // holds selected scenes
    var selectedScenes = [];

    var jobInProgress = false;

    // publish button
    var btnPublish = new ui.Button({
        text: 'Publish Now'
    });
    btnPublish.class.add('publish');
    panel.append(btnPublish);

    btnPublish.on('click', function () {
        if (jobInProgress)
            return;

        jobInProgress = true;

        refreshButtonsState();

        var data = {
            name: inputName.value,
            project_id: config.project.id,
            scenes: selectedScenes.map(function (scene) { return scene.id; })
        };

        if (inputDescription.value)
            data.description = inputDescription.value;

        if (inputVersion.value)
            data.version = inputVersion.value;

        if (inputNotes.value)
            data.release_notes = inputNotes.value;

        if (imageS3Key)
            data.image_s3_key = imageS3Key;

        if (fieldOptionsConcat)
            data.scripts_concatenate = fieldOptionsConcat.value;

        editor.call('apps:new', data, function () {
            jobInProgress = false;
            editor.call('picker:builds');
        }, function (status) {
            jobInProgress = false;
            editor.call('status:error', 'Error while publishing: ' + status);
            editor.call('picker:builds');
        });
    });

    // publish on facebook button
    var btnPublishFb = new ui.Button({
        text: 'Publish Now'
    });
    btnPublishFb.class.add('publish-fb');
    panel.append(btnPublishFb);

    btnPublishFb.on('click', function () {
        if (jobInProgress)
            return;

        jobInProgress = true;
        refreshButtonsState();

        var data = {
            project_id: config.project.id,
            scenes: selectedScenes.map(function (scene) { return scene.id; })
        };

        if (inputNotes.value)
            data.release_notes = inputNotes.value;

        // ajax call
        editor.call('apps:publishFb', data, function (job) {
            // show progress
            panelFacebookProgress.hidden = false;
            btnFacebookLink.hidden = true;
            facebookProgressIconWrapper.classList.remove('success');
            facebookProgressIconWrapper.classList.remove('error');

            facebookProgressTitle.class.remove('error');
            facebookProgressTitle.text = 'Preparing build...';

            // when job is updated get the job and
            // proceed depending on job status
            var evt = editor.on('messenger:job.update', function (msg) {
                console.log('messenger update')
                if (msg.job.id === job.id) {
                    evt.unbind();

                    // get job
                    Ajax({
                        url: '{{url.api}}/jobs/' + job.id,
                        auth: true
                    })
                        .on('load', function (status, data) {
                            var job = data;
                            // success ?
                            if (job.status === 'complete') {
                                facebookProgressIconWrapper.classList.add('success');
                                facebookProgressTitle.text = 'Build published';
                                btnFacebookLink.hidden = false;
                                jobInProgress = false;
                                refreshButtonsState();
                            }
                            // handle error
                            else if (job.status === 'error') {
                                facebookProgressIconWrapper.classList.add('error');
                                facebookProgressTitle.class.add('error');
                                facebookProgressTitle.text = job.messages[0];
                                jobInProgress = false;
                                refreshButtonsState();
                            }
                        }).on('error', function () {
                        // error
                        facebookProgressIconWrapper.classList.add('error');
                        facebookProgressTitle.class.add('error');
                        facebookProgressTitle.text = 'Error: Could not publish';
                        jobInProgress = false;
                        refreshButtonsState();
                    });
                }
            });
            events.push(evt);
        }, function () {
            jobInProgress = false;
            refreshButtonsState();

            // error
            console.error(arguments);
        });
    });

    // web download button
    var btnWebDownload = new ui.Button({
        text: 'Web Download'
    });
    btnWebDownload.class.add('web-download');
    panel.append(btnWebDownload);

    var urlToDownload = null;

    // download app for specified target (web or ios)
    var download = function (target) {
        jobInProgress = true;

        refreshButtonsState();

        // post data
        var data = {
            name: inputName.value,
            project_id: config.project.id,
            scenes: selectedScenes.map(function (scene) { return scene.id; }),
            target: target,
            scripts_concatenate: fieldOptionsConcat ? fieldOptionsConcat.value : false
        };

        // ajax call
        editor.call('apps:download', data, function (job) {
            // show download progress
            panelDownloadProgress.hidden = false;
            btnDownloadReady.hidden = true;
            downloadProgressIconWrapper.classList.remove('success');
            downloadProgressIconWrapper.classList.remove('error');

            downloadProgressTitle.class.remove('error');
            downloadProgressTitle.text = 'Preparing build...';

            // when job is updated get the job and
            // proceed depending on job status
            var evt = editor.on('messenger:job.update', function (msg) {
                if (msg.job.id === job.id) {
                    evt.unbind();

                    // get job
                    Ajax({
                        url: '{{url.api}}/jobs/' + job.id,
                        auth: true
                    })
                        .on('load', function (status, data) {
                            var job = data;
                            // success ?
                            if (job.status === 'complete') {
                                downloadProgressIconWrapper.classList.add('success');
                                downloadProgressTitle.text = 'Your build is ready';
                                urlToDownload = job.data.download_url;
                                btnDownloadReady.hidden = false;
                                jobInProgress = false;

                                refreshButtonsState();
                            }
                            // handle error
                            else if (job.status === 'error') {
                                downloadProgressIconWrapper.classList.add('error');
                                downloadProgressTitle.class.add('error');
                                downloadProgressTitle.text = job.messages[0];
                                jobInProgress = false;

                                refreshButtonsState();
                            }
                        }).on('error', function () {
                        // error
                        downloadProgressIconWrapper.classList.add('error');
                        downloadProgressTitle.class.add('error');
                        downloadProgressTitle.text = 'Error: Could not start download';
                        jobInProgress = false;

                        refreshButtonsState();
                    });
                }
            });
            events.push(evt);
        }, function () {
            jobInProgress = false;

            refreshButtonsState();

            // error
            console.error(arguments);
        });
    };

    btnWebDownload.on('click', function () {
        if (jobInProgress)
            return;

        download('web');
    });

    // ios download button
    var btnIosDownload = new ui.Button({
        text: 'iOS Download'
    });
    btnIosDownload.class.add('ios-download');
    panel.append(btnIosDownload);

    btnIosDownload.on('click', function () {
        if (jobInProgress)
            return;

        if (config.owner.plan.type !== 'org' && config.owner.plan.type !== 'organization') {
            editor.call('picker:confirm', 'You need an Organization account to be able to download for iOS. Would you like to upgrade?', function () {
                window.open('/upgrade');
            });

            return;
        }
        download('ios');
    });

    // download progress
    var panelDownloadProgress = document.createElement('div');
    panelDownloadProgress.classList.add('progress');
    panelDownloadProgress.classList.add('download');
    panel.append(panelDownloadProgress);

    // icon
    var downloadProgressIconWrapper = document.createElement('span');
    downloadProgressIconWrapper.classList.add('icon');
    panelDownloadProgress.appendChild(downloadProgressIconWrapper);

    var downloadProgressImg = new Image();
    downloadProgressIconWrapper.appendChild(downloadProgressImg);
    downloadProgressImg.src = config.url.static + "/platform/images/common/ajax-loader.gif";

    // progress info
    var downloadProgressInfo = document.createElement('span');
    downloadProgressInfo.classList.add('progress-info');
    panelDownloadProgress.appendChild(downloadProgressInfo);

    var downloadProgressTitle = new ui.Label({text: 'Preparing build'});
    downloadProgressTitle.renderChanges = false;
    downloadProgressTitle.class.add('progress-title');
    downloadProgressInfo.appendChild(downloadProgressTitle.element);

    var btnDownloadReady = new ui.Button({text: 'Download'});
    btnDownloadReady.class.add('ready');
    downloadProgressInfo.appendChild(btnDownloadReady.element);

    btnDownloadReady.on('click', function () {
        if (urlToDownload) {
            window.open(urlToDownload);
        }

        editor.call('picker:publish');
    });

    // facebook progress
    var panelFacebookProgress = document.createElement('div');
    panelFacebookProgress.classList.add('progress');
    panelFacebookProgress.classList.add('facebook');
    panel.append(panelFacebookProgress);

    // icon
    var facebookProgressIconWrapper = document.createElement('span');
    facebookProgressIconWrapper.classList.add('icon');
    panelFacebookProgress.appendChild(facebookProgressIconWrapper);

    var facebookProgressImg = new Image();
    facebookProgressIconWrapper.appendChild(facebookProgressImg);
    facebookProgressImg.src = config.url.static + "/platform/images/common/ajax-loader.gif";

    // progress info
    var facebookProgressInfo = document.createElement('span');
    facebookProgressInfo.classList.add('progress-info');
    panelFacebookProgress.appendChild(facebookProgressInfo);

    var facebookProgressTitle = new ui.Label({text: 'Preparing build'});
    facebookProgressTitle.renderChanges = false;
    facebookProgressTitle.class.add('progress-title');
    facebookProgressInfo.appendChild(facebookProgressTitle.element);

    var btnFacebookLink = new ui.Button({text: 'View Builds'});
    btnFacebookLink.class.add('ready');
    facebookProgressInfo.appendChild(btnFacebookLink.element);

    btnFacebookLink.on('click', function () {
        window.open('https://developers.facebook.com/apps/' + privateSettings.get('facebook.appId') + '/hosting');
    });

    var refreshButtonsState = function () {
        var disabled = !inputName.value ||
            !selectedScenes.length ||
            inputName.value.length > 1000 ||
            inputDescription.value.length > 10000 ||
            inputNotes.value.length > 10000 ||
            inputVersion.value.length > 20 ||
            isUploadingImage ||
            jobInProgress;

        btnPublish.disabled = disabled;
        btnWebDownload.disabled = disabled;
        btnIosDownload.disabled = disabled;

        btnPublishFb.disabled = jobInProgress ||
            !privateSettings.get('facebook.appId') ||
            !privateSettings.get('facebook.uploadToken') ||
            !selectedScenes.length;
    };

    var createSceneItem = function (scene) {
        var row = new ui.ListItem();
        row.element.id = 'picker-scene-' + scene.id;

        container.append(row);

        if (config.scene.id && parseInt(scene.id, 10) === parseInt(config.scene.id, 10))
            row.class.add('current');

        if (parseInt(scene.id, 10) === parseInt(config.project.primaryScene, 10))
            row.class.add('primary');

        // primary scene icon
        var primary = new ui.Button({
            text: '&#57891'
        });
        primary.class.add('primary');
        row.element.appendChild(primary.element);

        primary.on('click', function () {
            if (!editor.call('permissions:write'))
                return;

            var prevPrimary = config.project.primaryScene;
            config.project.primaryScene = scene.id;
            onPrimarySceneChanged(scene.id, prevPrimary);
            editor.call('project:setPrimaryScene', scene.id);
        });

        // show tooltip for primary scene icon
        var tooltipText = parseInt(scene.id, 10) === parseInt(config.project.primaryScene, 10) ? 'Primary Scene' : 'Set Primary Scene';
        var tooltip = Tooltip.attach({
            target: primary.element,
            text: tooltipText,
            align: 'right',
            root: editor.call('layout.root')
        });
        tooltips.push(tooltip);

        // scene name
        var name = new ui.Label({
            text: scene.name
        });
        name.class.add('name');

        row.element.appendChild(name.element);

        // scene date
        var date = new ui.Label({
            text: editor.call('datetime:convert', scene.modified)
        });
        date.class.add('date');
        row.element.appendChild(date.element);

        // selection
        var select = new ui.Checkbox();
        select.class.add('tick');
        row.element.appendChild(select.element);

        if (selectedScenes.indexOf(scene) !== -1) {
            select.value = true;
        }

        // if selectAll changes then change this too
        events.push(selectAll.on('change', function (value) {
            select.value = value;
        }));

        // handle checkbox tick
        select.on('change', function (value) {
            if (value) {
                // put primary scene in the beginning
                if (config.project.primaryScene === scene.id) {
                    selectedScenes.splice(0, 0, scene);
                } else {
                    // if not primary scene just add to the list
                    selectedScenes.push(scene);
                }
            } else {
                // remove scene from selection
                selectedScenes.splice(selectedScenes.indexOf(scene), 1);
            }

            refreshButtonsState();
        });

        return row;
    };

    var destroyTooltips = function () {
        tooltips.forEach(function (tooltip) {
            tooltip.destroy();
        });
        tooltips = [];
    };

    var destroyEvents = function () {
        events.forEach(function (evt) {
            evt.unbind();
        });

        events = [];
    };

    // handle permission changes
    editor.on('permissions:set:' + config.self.id, function (accessLevel) {
        if (accessLevel === 'write' || accessLevel === 'admin') {
            panel.class.remove('disabled');
        } else {
            panel.class.add('disabled');
        }
    });

    var sortScenes = function (scenes) {
        scenes.sort(function (a, b) {
            var primary = parseInt(config.project.primaryScene, 10);
            if (primary === parseInt(a.id, 10)) {
                return -1;
            } else if (primary === parseInt(b.id, 10)) {
                return 1;
            } else {
                if (a.modified < b.modified) {
                    return 1;
                } else if (a.modified > b.modified) {
                    return -1;
                } else {
                    return 0;
                }
            }
        });
    };

    var refreshScenes = function () {
        var content = document.querySelector('.ui-panel.right > .content');
        var scrollTop = content.scrollTop;

        destroyTooltips();
        destroyEvents();
        container.element.innerHTML = '';
        sortScenes(scenes);
        panelScenes.hidden = !scenes.length;
        panelNoScenes.hidden = !panelScenes.hidden;
        labelNoScenes.hidden = scenes.length;
        loadingScenes.hidden = true;
        progressBar.hidden = true;
        refreshButtonsState();
        scenes.forEach(createSceneItem);

        content.scrollTop = scrollTop;
    };

    var onPrimarySceneChanged = function (newValue, oldValue) {
        if (panel.hidden || parseInt(newValue, 10) === parseInt(oldValue, 10)) return;

        refreshScenes();
    };

    // on show
    panel.on('show', function () {
        panelDownloadProgress.hidden = true;
        panelFacebookProgress.hidden = true;
        panelNoScenes.hidden = false;
        labelNoScenes.hidden = true;
        loadingScenes.hidden = false;
        progressBar.hidden = false;
        container.element.innerHTML = '';
        inputName.value = config.project.name;
        inputDescription.value = config.project.description;
        inputVersion.value = '';
        inputNotes.value = '';
        imageS3Key = null;
        if (config.project.thumbnails.xl) {
            imageS3Key = config.project.thumbnails.xl.substring(config.url.images.length + 1);
        }

        clearAppImage();

        selectAll.value = false;

        var loadedApps = mode !== 'publish';
        var loadedScenes = false;

        editor.call('scenes:list', function (items) {
            loadedScenes = true;

            scenes = items;
            // select primary scene
            for (var i = 0; i < scenes.length; i++) {
                if (scenes[i].id === config.project.primaryScene) {
                    selectedScenes.push(scenes[i]);
                    break;
                }
            }

            if (loadedApps)
                refreshScenes();
        });

        if (! loadedApps) {
            editor.call('apps:list', function (apps) {
                loadedApps = true;

                var version = 'e.g. 1.0.0';

                if (apps.length) {
                    apps.sort(function (a, b) {
                        if (a.id === config.project.primaryApp)
                            return -1;
                        if (b.id === config.project.primaryApp)
                            return 1;
                        if (b.modified_at < a.modified_at)
                            return -1;
                        else if (a.modified_at > b.modified_at)
                            return 1;

                        return 0;
                    });

                    if (apps[0].version) {
                        version = 'Previous version: ' + apps[0].version;
                    }
                }

                inputVersion.placeholder = version;

                if (loadedScenes)
                    refreshScenes();
            });
        }


        inputName.elementInput.focus();

        if (editor.call('viewport:inViewport'))
            editor.emit('viewport:hover', false);
    });

    // on hide
    panel.on('hide', function () {
        scenes = [];
        imageS3Key = null;
        isUploadingImage = false;
        selectedScenes = [];
        urlToDownload = null;
        jobInProgress = false;
        destroyTooltips();
        destroyEvents();

        if (editor.call('viewport:inViewport'))
            editor.emit('viewport:hover', true);
    });

    editor.on('viewport:hover', function(state) {
        if (state && ! panel.hidden) {
            setTimeout(function() {
                editor.emit('viewport:hover', false);
            }, 0);
        }
    });

    // subscribe to messenger pack.delete
    editor.on('messenger:pack.delete', function (data) {
        if (panel.hidden) return;

        var sceneId = parseInt(data.pack.id, 10);

        var row = document.getElementById('picker-scene-' + sceneId);
        if (row) {
            row.remove();
        }

        for (var i = 0; i < scenes.length; i++) {
            if (parseInt(scenes[i].id, 10) === sceneId) {
                scenes.splice(i, 1);
                break;
            }
        }

        if (! scenes.length) {
            panelScenes.hidden = true;
            panelNoScenes.hidden = false;
            refreshButtonsState();
        }
    });

    // subscribe to messenger pack.new
    editor.on('messenger:pack.new', function (data) {
        if (panel.hidden) return;

        editor.call('scenes:get', data.pack.id, function (scene) {
            if (panel.hidden) return; // check if hidden when Ajax returns

            scenes.push({
                id: scene.id,
                modified: scene.modified,
                name: scene.name
            });

            refreshScenes();
        });
    });

    editor.on('project:primaryScene', onPrimarySceneChanged);

});


/* editor/viewport/viewport-application.js */
editor.once('load', function() {
    var time;
    var rect = new pc.Vec4(0, 0, 1, 1);

    var Application = function (canvas, options) {
        this._inTools = true;
        pc.app = this;

        if (! this.scene)
            this.scene = new pc.Scene();

        for (var key in this.systems) {
            if (this.systems.hasOwnProperty(key))
                this.systems[key]._inTools = true;
        }

        this.grid = null;
        this.setEditorSettings(options.editorSettings);

        this.picker = new pc.scene.Picker(this.graphicsDevice, 1, 1);
        this.shading = pc.RENDERSTYLE_SOLID;

        // Draw immediately
        this.redraw = true;

        // define the tick method
        this.tick = this.makeTick();;

        pc.ComponentSystem.on('toolsUpdate', this.systems.particlesystem.onUpdate, this.systems.particlesystem);
        pc.ComponentSystem.on('toolsUpdate', this.systems.animation.onUpdate, this.systems.animation);
    };

    editor.method('viewport:application', function() {
        return Application;
    });

    Application = pc.inherits(Application, pc.Application);

    Application.prototype.render = function() {
        this.root.syncHierarchy();

        this.fire('prerender', null);
        editor.emit('viewport:preRender');

        var device = this.graphicsDevice;
        var dw = device.width;
        var dh = device.height;

        // render current camera
        var cameraEntity = editor.call('camera:current');
        if (cameraEntity && cameraEntity.camera) {
            var cameraNode = cameraEntity.camera.camera;

            cameraNode.renderTarget = null;

            if (cameraEntity.__editorCamera) {
                var clearColor = this.editorSettings.cameraClearColor;
                cameraEntity.camera.clearColor = new pc.Color(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
                if (cameraEntity.camera.projection === pc.PROJECTION_PERSPECTIVE) {
                    cameraEntity.camera.nearClip = this.editorSettings.cameraNearClip || 0.0001;
                    cameraEntity.camera.farClip = this.editorSettings.cameraFarClip;
                }
            }

            cameraEntity.camera.rect = rect;

            cameraEntity.camera.frameBegin();
            this.renderer.render(this.scene, cameraNode);
            cameraEntity.camera.frameEnd();
        }
    };

    Application.prototype.getDt = function () {
        var now = (window.performance && window.performance.now) ? performance.now() : Date.now();
        var dt = (now - (time || now)) / 1000.0;
        dt = pc.math.clamp(dt, 0, 0.1); // Maximum delta is 0.1s or 10 fps.
        time = now;
        return dt;
    };

    Application.prototype.makeTick = function() {
        var app = this;
        return function() {
            requestAnimationFrame(app.tick);

            pc.app = app;

            var dt = app.getDt();

            if (app.redraw) {
                app.redraw = editor.call('viewport:keepRendering');

                app.graphicsDevice.updateClientRect();

                // Perform ComponentSystem update
                editor.emit('viewport:preUpdate', dt);
                editor.emit('viewport:update', dt);
                pc.ComponentSystem.fire('toolsUpdate', dt);
                editor.emit('viewport:postUpdate', dt);
                editor.emit('viewport:gizmoUpdate', dt);

                app.render();

                editor.emit('viewport:postRender');
            }
        };
    };

    Application.prototype.resize = function (w, h) {
        this.graphicsDevice.width = w;
        this.graphicsDevice.height = h;
        this.picker.resize(w, h);
        this.redraw = true;
    };

    Application.prototype.setEditorSettings = function (settings) {
        this.editorSettings = settings;

        if (this.grid) {
            this.scene.removeModel(this.grid.model);
            this.grid.destroy();
        }

        settings.gridDivisions = parseInt(settings.gridDivisions, 10);
        if (settings.gridDivisions > 0) {
            var size = settings.gridDivisions * settings.gridDivisionSize;
            this.grid = new pc.Grid(this.graphicsDevice, size, settings.gridDivisions);
            this.grid.model.meshInstances[0].aabb.halfExtents.set(size / 2, size / 2, size / 2);
            this.scene.addModel(this.grid.model);
        }

        this.redraw = true;
    };

    // Redraw when we set the skybox
    Application.prototype._setSkybox = function (cubemaps) {
        Application._super._setSkybox.call(this, cubemaps);
        this.redraw = true;
    };
});


/* editor/viewport/viewport-grid.js */
pc.Grid = function (device, size, divisions) {
    // Create the vertex format
    var vertexFormat = new pc.gfx.VertexFormat(device, [
        { semantic: pc.gfx.SEMANTIC_POSITION, components: 3, type: pc.gfx.ELEMENTTYPE_FLOAT32 },
        { semantic: pc.gfx.SEMANTIC_COLOR, components: 4, type: pc.gfx.ELEMENTTYPE_UINT8, normalize: true }
    ]);

    var size = size || 140;
    var divisions = divisions || 14;
    var interval = size / divisions;
    var numVerts = (divisions + 1) * 4;
    var gridColor = [136, 136, 136, 255];
    var axisColor = [0, 0, 0, 255];
    var color;

    // Create a vertex buffer
    this.vertexBuffer = new pc.gfx.VertexBuffer(device, vertexFormat, numVerts);
    var vertexBuffer = this.vertexBuffer;

    // Fill the vertex buffer
    var iterator = new pc.gfx.VertexIterator(vertexBuffer);
    for (i = -(divisions / 2); i <= divisions / 2; i++) {
        color = (i === 0) ? axisColor : gridColor;
        iterator.element[pc.gfx.SEMANTIC_POSITION].set(-size/2, 0.0, i * interval);
        iterator.element[pc.gfx.SEMANTIC_COLOR].set(color[0], color[1], color[2], color[3]);
        iterator.next();
        iterator.element[pc.gfx.SEMANTIC_POSITION].set( size/2, 0.0, i * interval);
        iterator.element[pc.gfx.SEMANTIC_COLOR].set(color[0], color[1], color[2], color[3]);
        iterator.next();
        iterator.element[pc.gfx.SEMANTIC_POSITION].set(i * interval, 0.0, -size/2);
        iterator.element[pc.gfx.SEMANTIC_COLOR].set(color[0], color[1], color[2], color[3]);
        iterator.next();
        iterator.element[pc.gfx.SEMANTIC_POSITION].set(i * interval, 0.0,  size/2);
        iterator.element[pc.gfx.SEMANTIC_COLOR].set(color[0], color[1], color[2], color[3]);
        if (i !== divisions / 2) {
            iterator.next();
        }
    }
    iterator.end();

    var library = device.getProgramLibrary();
    var shader = library.getProgram("basic", { vertexColors: true, diffuseMapping: false });

    var material = new pc.Material();
    material.shader = shader;

    var mesh = new pc.Mesh();
    mesh.vertexBuffer = vertexBuffer;
    mesh.indexBuffer[0] = null;
    mesh.primitive[0].type = pc.gfx.PRIMITIVE_LINES;
    mesh.primitive[0].base = 0;
    mesh.primitive[0].count = vertexBuffer.getNumVertices();
    mesh.primitive[0].indexed = false;

    var node = new pc.GraphNode('grid');

    var meshInstance = new pc.MeshInstance(node, mesh, material);
    meshInstance.mask = 8;

    var model = new pc.Model();
    model.graph = node;
    model.meshInstances = [ meshInstance ];

    this.model = model;
};

pc.Grid.prototype = {
    destroy: function () {
        if (this.vertexBuffer) {
            this.vertexBuffer.destroy();
            this.vertexBuffer = null;
        }
    }
};


/* editor/viewport/viewport.js */
editor.once('load', function() {
    'use strict'

    var canvas = new ui.Canvas({
        id: 'canvas-3d'
    });

    var keepRendering = false;
    var editorSettings = editor.call('settings:projectUser');
    var Application = editor.call('viewport:application');

    // create playcanvas application
    try {
        var app = new Application(canvas.element, {
            mouse: new pc.input.Mouse(canvas.element),
            touch: !!('ontouchstart' in window) ? new pc.input.TouchDevice(canvas.element) : null,
            editorSettings: editorSettings.json().editor,
            graphicsDeviceOptions: {
                alpha: false
            }
        });
    } catch(ex) {
        editor.emit('viewport:error', ex);
        return;
    }

    editorSettings.on('*:set', function() {
        app.setEditorSettings(editorSettings.json().editor);
    });


    // add canvas
    editor.call('layout.viewport').prepend(canvas);

    // get canvas
    editor.method('viewport:canvas', function() {
        return canvas;
    });

    // get app
    editor.method('viewport:app', function() {
        return app;
    });

    // re-render viewport
    editor.method('viewport:render', function () {
        app.redraw = true;
    });

    // returns true if the viewport should continuously render
    editor.method('viewport:keepRendering', function (value) {
        if (typeof(value) === 'boolean')
            keepRendering = value;

        return keepRendering;
    });

    editor.method('viewport:flyMode', function () {
        return flyMode;
    });

    app.start();
    editor.emit('viewport:load', app);
});


/* editor/viewport/viewport-resize.js */
editor.once('load', function() {
    'use strict'

    var container = editor.call('layout.viewport');
    var canvas = editor.call('viewport:canvas');
    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    if (! canvas)
        return;


    // once canvas resized
    // notify app
    canvas.on('resize', function(width, height) {
        app.resize(width, height);
        editor.call('viewport:render');
        editor.emit('viewport:resize', width, height);
    });

    // handle canvas resizing
    // 20 times a second
    // if size is already same, nothing will happen
    setInterval(function() {
        var rect = container.element.getBoundingClientRect();
        canvas.resize(Math.floor(rect.width), Math.floor(rect.height));
    }, 1000 / 60);
});


/* editor/viewport/viewport-expand.js */
editor.once('load', function() {
    'use strict';

    var panels = [ ];
    panels.push(editor.call('layout.left'));
    panels.push(editor.call('layout.assets'));
    panels.push(editor.call('layout.right'));

    var expanded = false;


    editor.method('viewport:expand', function(state) {
        if (state === undefined)
            state = ! expanded;

        if (expanded === state)
            return;

        expanded = state;

        for(var i = 0; i < panels.length; i++)
            panels[i].hidden = expanded;

        editor.emit('viewport:expand', state);
    });


    editor.method('viewport:expand:state', function() {
        return expanded;
    });


    // expand hotkey
    editor.call('hotkey:register', 'viewport:expand', {
        key: 'space',
        callback: function() {
            editor.call('viewport:expand');
        }
    });
});


/* editor/viewport/viewport-entities-create.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');

    // entities indexes for parenting
    var childIndex = { };
    var entitiesIndex = { };
    var unknowns = { };

    // queue for hierarchy resync
    var awaitingResyncHierarchy = false;

    var resyncHierarchy = function() {
        awaitingResyncHierarchy = false;

        if (! app) return; // webgl not available

        // sync hierarchy
        app.context.root.syncHierarchy();

        // render
        editor.call('viewport:render');
    };

    var createEntity = function (obj) {
        var entity = new pc.Entity();

        entitiesIndex[obj.get('resource_id')] = entity;

        entity.name = obj.get('name');
        entity.setGuid(obj.get('resource_id'));
        entity.setLocalPosition(obj.get('position.0'), obj.get('position.1'), obj.get('position.2'));
        entity.setLocalEulerAngles(obj.get('rotation.0'), obj.get('rotation.1'), obj.get('rotation.2'));
        entity.setLocalScale(obj.get('scale.0'), obj.get('scale.1'), obj.get('scale.2'));
        entity._enabled = obj.has('enabled') ? obj.get('enabled') : true;

        if (obj.has('labels')) {
            obj.get('labels').forEach(function (label) {
                entity.addLabel(label);
            });
        }

        entity.template = obj.get('template');

        return entity;
    };

    var insertChild = function (parent, node, index) {
        // try to insert the node at the right index
        for (var i = 0, len = parent._children.length; i < len; i++) {
            var child = parent._children[i];
            if (childIndex[child._guid]) {
                // if our indes is less than this child's index
                // then put the item here
                if (index < childIndex[child._guid].index) {
                    parent.insertChild(node, i);
                    return;
                }
            }
        }

        // the node can be safely added to the end of the child list
        parent.addChild(node);
    };

    var processEntity = function (obj) {
        if (! app) return; // webgl not available

        // create entity
        var entity = obj.entity = createEntity(obj);

        // add components
        var components = obj.json().components;
        for(var key in components) {
            if (app.context.systems[key]) {
                if (key === 'script')
                    continue;

                // override particlesystem
                if (key === 'particlesystem') {
                    components[key].enabled = false;
                    components[key].autoPlay = true;
                } else if (key === 'animation') {
                    components[key].enabled = false;
                }

                app.context.systems[key].addComponent(entity, components[key]);
            } else if (! unknowns[key]) {
                unknowns[key] = true;
                console.log('unknown component "' + key + '", in entity ' + obj.get('resource_id'));
            }
        }

        var children = obj.get('children');
        for(var i = 0; i < children.length; i++) {
            childIndex[children[i]] = {
                index: i,
                parent: entity
            };

            if (entitiesIndex[children[i]]) {
                insertChild(entity, entitiesIndex[children[i]], i);
            }
        }

        // parenting
        if (! obj.get('parent')) {
            // root
            app.context.root.addChild(entity);
        } else {
            // child
            var details = childIndex[obj.get('resource_id')];
            if (details && details.parent) {
                insertChild(details.parent, entity, details.index);
            }
        }

        // queue resync hierarchy
        // done on timeout to allow bulk entity creation
        // without rerender and sync after each entity
        if (! awaitingResyncHierarchy) {
            awaitingResyncHierarchy = true;
            setTimeout(resyncHierarchy, 0);
        }

        editor.emit('entities:add:entity', obj);
    };

    var createEntities = function() {
        // new entity created
        editor.on('entities:add', function (obj) {
            processEntity(obj);
        });

        // clear entitiesIndex and childIndex
        editor.on('entities:remove', function (obj) {
            delete entitiesIndex[obj.get('resource_id')];
            var children = obj.get('children');
            for(var i = 0; i < children.length; i++) {
                delete childIndex[children[i]];
            }
        });

        var entities = editor.call('entities:list');
        entities.forEach(processEntity);
    };

    // handle synchronization - all assets must be loaded
    // before creating entities in the engine
    var assetsLoaded = false;
    var entitiesLoaded = false;

    editor.once('assets:load', function () {
        assetsLoaded = true;
        // if entities already loaded then create them
        if (entitiesLoaded)
            createEntities();
    });

    editor.once('entities:load', function() {
        entitiesLoaded = true;
        // if assets already loaded then create entities
        if (assetsLoaded)
            createEntities();
    });
});


/* editor/viewport/viewport-entities-observer-binding.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    editor.on('entities:add', function (obj) {
        // subscribe to changes
        obj.on('*:set', function(path, value) {
            var entity = obj.entity;
            if (! entity)
                return;

            if (path === 'name') {
                entity.name = obj.get('name');

            } else if (path.startsWith('position')) {
                entity.setLocalPosition(obj.get('position.0'), obj.get('position.1'), obj.get('position.2'));

            } else if (path.startsWith('rotation')) {
                entity.setLocalEulerAngles(obj.get('rotation.0'), obj.get('rotation.1'), obj.get('rotation.2'));

            } else if (path.startsWith('scale')) {
                entity.setLocalScale(obj.get('scale.0'), obj.get('scale.1'), obj.get('scale.2'));

            } else if (path.startsWith('enabled')) {
                entity.enabled = obj.get('enabled');

            } else if (path.startsWith('parent')) {
                var parent = editor.call('entities:get', obj.get('parent'));
                if (parent && parent.entity && entity.parent !== parent.entity)
                    entity.reparent(parent.entity);
            } else if (path === 'components.model.type' && value === 'asset') {
                // WORKAROUND
                // entity deletes asset when switching to primitive, restore it
                // do this in a timeout to allow the model type to change first
                setTimeout(function () {
                    var assetId = obj.get('components.model.asset');
                    if (assetId)
                        entity.model.asset = assetId;
                });
            }

            // render
            editor.call('viewport:render');
        });

        var reparent = function (child, index) {
            var childEntity = editor.call('entities:get', child);
            if (childEntity && childEntity.entity && obj.entity) {
                if (childEntity.entity.parent)
                    childEntity.entity.parent.removeChild(childEntity.entity);

                // skip any graph nodes
                if (index > 0) {
                    var children = obj.entity.children;
                    for (var i = 0, len = children.length; i < len && index > 0; i++) {
                        if (children[i] instanceof pc.Entity) {
                            index--;
                        }
                    }

                    index = i;
                }

                // re-insert
                obj.entity.insertChild(childEntity.entity, index);
            }
        };

        obj.on('children:insert', reparent);
        obj.on('children:move', reparent);

        obj.on('destroy', function () {
            if (obj.entity) {
                obj.entity.destroy();
                editor.call('viewport:render');
            }
        });
    });

    editor.on('entities:remove', function (obj) {
        var entity = obj.entity;
        if (! entity)
            return;

        entity.destroy();
        editor.call('viewport:render');
    });
});


/* editor/viewport/viewport-entities-components-binding.js */
editor.once('load', function() {
    'use strict';

    // converts the data to runtime types
    var runtimeComponentData = function (component, data) {
        var result = {};
        for (var key in data) {
            if (data.hasOwnProperty(key)) {
                result[key] = editor.call('components:convertValue', component, key, data[key]);
            }
        }

        return result;
    };

    editor.on('entities:add', function (obj) {
        var app;

        // subscribe to changes
        obj.on('*:set', function(path, value) {
            if (obj._silent || ! path.startsWith('components'))
                return;

            var entity = obj.entity;
            if (! entity) return;

            var parts = path.split('.');
            var component = parts[1];
            var property = parts[2];

            // ignore script component
            if (component === 'script')
                return;

            if (!entity[component]) {
                if (!property) {
                    // add component
                    var data = runtimeComponentData(component, value);

                    // override particlesystem
                    if (component === 'particlesystem') {
                        data.enabled = false;
                        data.autoPlay = true;
                    } else if (component === 'animation') {
                        data.enabled = false;
                    }

                    app = editor.call('viewport:app');
                    if (! app) return; // webgl not available
                    app.context.systems[component].addComponent(entity, data);

                    // render
                    editor.call('viewport:render');
                }
            } else if (property) {
                // edit component property
                value = obj.get('components.' + component + '.' + property);

                if (component === 'particlesystem') {
                    if (property === 'enabled') {
                        value = false;
                    } else if (property === 'autoPlay') {
                        value = true;
                    }
                } else if (component === 'animation') {
                    if (property === 'enabled') {
                        value = false;
                    }
                }

                entity[component][property] = editor.call('components:convertValue', component, property, value);

                // render
                editor.call('viewport:render');
            }
        });

        var setComponentProperty = function (path, value) {
            if (obj._silent || ! path.startsWith('components'))
                return;

            var entity = obj.entity;
            if (! entity) return;

            var parts = path.split('.');
            var component = parts[1];
            var property = parts[2];

            // ignore script component
            if (component === 'script')
                return;

            if (property) {
                // edit component property
                value = obj.get('components.' + component + '.' + property);
                entity[component][property] = editor.call('components:convertValue', component, property, value);

                // render
                editor.call('viewport:render');
            }
        };

        obj.on('*:insert', setComponentProperty);
        obj.on('*:remove', setComponentProperty);

        obj.on('*:unset', function (path) {
            if (obj._silent || ! path.startsWith('components'))
                return;

            var entity = obj.entity;
            if (! entity) return;

            var parts = path.split('.');
            var component = parts[1];
            var property = parts[2];

            if (component === 'script')
                return;

            if (property) {
                // edit component property
                var value = obj.get('components.' + component + '.' + property);
                entity[component][property] = editor.call('components:convertValue', component, property, value);
            } else if (entity[component]) {
                // remove component
                var app = editor.call('viewport:app');
                if (! app) return; // webgl not available

                app.context.systems[component].removeComponent(entity);
            }

            // render
            editor.call('viewport:render');
        });
    });
});


/* editor/viewport/viewport-entities-elements.js */
editor.once('load', function() {
    'use strict';

    var events = [];

    editor.on('attributes:inspect[entity]', function(entities) {
        if (events.length)
            clear();

        for (var i = 0, len = entities.length; i < len; i++) {
            addEvents(entities[i]);
        }
    });

    var fixed = function (value) {
        return +value.toFixed(3);
    };

    var addEvents = function (entity) {
        var setting = {
            pos: false,
            anchor: false,
            pivot: false,
            size: false,
            margin: false,
            text: false,
            autoWidth: false,
            autoHeight: false
        };

        events.push(entity.on('*:set', function (path, value, valueOld, remote) {
            if (remote || ! entity.entity || ! entity.has('components.element')) return;

            // position change
            if (/^position/.test(path)) {
                if (setting.position) return;

                setting.position = true;

                // timeout because if we do it in the handler
                // it won't get sent to C3 due to observer.silence
                setTimeout(function () {
                    var margin = entity.entity.element.margin.data;
                    var history = entity.history.enabled;
                    entity.history.enabled = false;
                    setting.margin = true;
                    entity.set('components.element.margin', [fixed(margin[0]), fixed(margin[1]), fixed(margin[2]), fixed(margin[3])]);
                    setting.margin = false;
                    entity.history.enabled = history;

                    setting.position = false;
                });
            }
            // anchor change
            else if (/^components.element.anchor/.test(path)) {
                if (setting.anchor) return;
                setting.anchor = true;

                setTimeout(function () {
                    var pos = entity.entity.getLocalPosition().data;
                    var width = entity.entity.element.width;
                    var height = entity.entity.element.height;

                    var history = entity.history.enabled;
                    entity.history.enabled = false;
                    setting.size = true;
                    entity.set('position', [fixed(pos[0]), fixed(pos[1]), fixed(pos[2])]);
                    entity.set('components.element.width', fixed(width));
                    entity.set('components.element.height', fixed(height));
                    setting.size = false;
                    entity.history.enabled = history;

                    setting.anchor = false;
                });
            }
            // pivot change
            else if (/^components.element.pivot/.test(path)) {
                if (setting.pivot) return;

                setting.pivot = true;

                setTimeout(function () {

                    var pos = entity.entity.getLocalPosition().data;
                    var margin = entity.entity.element.margin.data;

                    var history = entity.history.enabled;
                    entity.history.enabled = false;
                    setting.position = true;
                    setting.margin = true;
                    entity.set('position', [fixed(pos[0]), fixed(pos[1]), fixed(pos[2])]);
                    entity.set('components.element.margin', [fixed(margin[0]), fixed(margin[1]), fixed(margin[2]), fixed(margin[3])]);
                    setting.position = false;
                    setting.margin = false;
                    entity.history.enabled = history;

                    setting.pivot = false;
                });
            }
            // width / height change
            else if (/^components.element.(width|height)/.test(path)) {
                if (setting.size) return;

                setting.size = true;

                setTimeout(function () {
                    var margin = entity.entity.element.margin.data;

                    var history = entity.history.enabled;
                    entity.history.enabled = false;
                    setting.margin = true;
                    entity.set('components.element.margin', [fixed(margin[0]), fixed(margin[1]), fixed(margin[2]), fixed(margin[3])]);
                    setting.margin = false;
                    entity.history.enabled = history;

                    setting.size = false;
                });
            }
            // margin change
            else if (/^components.element.margin/.test(path)) {
                if (setting.margin) return;

                setting.margin = true;

                setTimeout(function () {
                    var pos = entity.entity.getLocalPosition().data;
                    var width = entity.entity.element.width;
                    var height = entity.entity.element.height;

                    var history = entity.history.enabled;
                    entity.history.enabled = false;
                    setting.position = true;
                    setting.size = true;
                    entity.set('position', [fixed(pos[0]), fixed(pos[1]), fixed(pos[2])]);
                    entity.set('components.element.width', fixed(width));
                    entity.set('components.element.height', fixed(height));
                    setting.size = false;
                    setting.position = false;
                    entity.history.enabled = history;

                    setting.margin = false;
                });
            }
            // autoWidth change
            else if (/^components.element.autoWidth/.test(path)) {
                if (setting.autoWidth) return;

                setting.autoWidth = true;
                setTimeout(function () {
                    var width = entity.entity.element.width;

                    var history = entity.history.enabled;
                    entity.history.enabled = false;
                    entity.set('components.element.width', fixed(width));
                    entity.history.enabled = history;
                    setting.autoWidth = false;
                });
            }
            // autoHeight change
            else if (/^components.element.autoHeight/.test(path)) {
                if (setting.autoHeight) return;

                setting.autoHeight = true;
                setTimeout(function () {
                    var height = entity.entity.element.height;

                    var history = entity.history.enabled;
                    entity.history.enabled = false;
                    entity.set('components.element.height', fixed(height));
                    entity.history.enabled = history;
                    setting.autoHeight = false;
                });
            }
            // text / font change
            else if (/^components.element.(text|fontAsset)/.test(path)) {
                if (setting.text) return;

                setting.text = true;
                if (entity.get('components.element.autoWidth') ||
                    entity.get('components.element.autoHeight')) {

                    setTimeout(function () {
                        var width = entity.entity.element.width;
                        var height = entity.entity.element.height;

                        var history = entity.history.enabled;
                        entity.history.enabled = false;
                        if (entity.get('components.element.autoWidth'))
                            entity.set('components.element.width', fixed(width));
                        if (entity.get('components.element.autoHeight'))
                            entity.set('components.element.height', fixed(height));
                        entity.history.enabled = history;

                        setting.text = false;
                    });

                }
            }
        }));
    };

    var clear = function () {
        for (var i = 0, len = events.length; i < len; i++)
            events[i].unbind();

        events.length = 0;
    };

    editor.on('attributes:clear', clear);

});


/* editor/viewport/viewport-scene-settings.js */
editor.once('load', function() {
    'use strict';

    var sceneSettings = editor.call('sceneSettings');
    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var assetsLoaded = false;
    var sceneSettingsLoaded = false;
    var updating;

    // queue settings apply
    var queueApplySettings = function() {
        if (! sceneSettingsLoaded || updating || ! assetsLoaded)
            return;

        updating = true;

        editor.call('viewport:render');
        editor.once('viewport:update', applySettings);
    };

    // apply settings
    var applySettings = function() {
        if (! app) return;

        updating = false;

        // apply scene settings
        app.applySceneSettings(sceneSettings.json());

        // need to update all materials on scene settings change
        for(var i = 0; i < app.assets._assets.length; i++) {
            if (app.assets._assets[i].type !== 'material' || !app.assets._assets[i].resource)
                continue;

            app.assets._assets[i].resource.update();
        }

        editor.call('viewport:render');
    };

    // on settings change
    sceneSettings.on('*:set', queueApplySettings);

    editor.on('assets:load', function () {
        assetsLoaded = true;
        queueApplySettings();
    });

    editor.on('sceneSettings:load', function () {
        sceneSettingsLoaded = true;
        queueApplySettings();
    });
});


/* editor/viewport/viewport-assets.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return;

    var assets = app.assets;

    editor.call('assets:registry:bind', assets);

    // add assets to asset registry
    editor.on('assets:add', function (asset) {
        // do only for target assets
        if (asset.get('source'))
            return;

        // when data is changed
        asset.on('*:set', function (path, value) {
            editor.call('viewport:render');
        });

        var assetEngine = assets.get(asset.get('id'));
        // render on asset load
        assetEngine.on('load', function() {
            editor.call('viewport:render');
        });
        // render on asset data change
        assetEngine.on('change', function() {
            editor.call('viewport:render');
        });

        // render
        editor.call('viewport:render');
    });

    // remove assets from asset registry
    editor.on('assets:remove', function (asset) {
        // re-render
        editor.call('viewport:render');
    });

    // patch update for materials to re-render the viewport
    var update = pc.PhongMaterial.prototype.update;
    pc.PhongMaterial.prototype.update = function () {
        update.call(this);
        editor.call('viewport:render');
    };
});


/* editor/viewport/viewport-lightmapper.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var uv1MissingAssets = { };


    // bake
    editor.method('lightmapper:bake', function(entities) {
        if (! entities) {
            entities = editor.call('entities:list').filter(function(e) {
                return e.get('components.model.lightmapped');
            });
        }

        uv1MissingAssets = { };
        var areaJobs = { };
        var jobs = 0;

        var readyForBake = function() {
            app.lightmapper.bake(null, app.scene.lightmapMode);
            app.renderer.prepareStaticMeshes(app.graphicsDevice, app.scene);
            editor.call('viewport:render');
            editor.emit('lightmapper:baked');
        };

        // validate lightmapped entities
        for(var i = 0; i < entities.length; i++) {
            var obj = entities[i];

            // might be primitive
            if (obj.get('components.model.type') !== 'asset')
                continue;

            // might have no model asset attached
            var assetId = obj.get('components.model.asset');
            if (! assetId)
                continue;

            // model asset might be missing
            var asset = editor.call('assets:get', assetId);
            if (! asset)
                continue;

            // check if asset has uv1
            var uv1 = asset.has('meta.attributes.texCoord1');
            if (! uv1) {
                // uv1 might be missing
                if (! uv1MissingAssets[assetId])
                    uv1MissingAssets[assetId] = asset;
                continue;
            }

            // check if asset has area
            var area = asset.get('data.area');
            if (! area && ! areaJobs[assetId]) {
                // if area not available
                // recalculate area
                areaJobs[assetId] = asset;
                jobs++;
                editor.call('assets:model:area', asset, function() {
                    jobs--;

                    if (jobs === 0)
                        readyForBake();
                });
            }
        }

        editor.call('lightmapper:uv1missing', uv1MissingAssets);

        if (jobs === 0)
            readyForBake();
    });


    editor.method('entities:shadows:update', function() {
        var entities = editor.call('entities:list').filter(function(e) {
            return e.get('components.light.castShadows') && e.get('components.light.shadowUpdateMode') === 1 && e.entity && e.entity.light && e.entity.light.shadowUpdateMode === pc.SHADOWUPDATE_THISFRAME;
        });

        if (! entities.length)
            return;

        for(var i = 0; i < entities.length; i++)
            entities[i].entity.light.light.shadowUpdateMode = pc.SHADOWUPDATE_THISFRAME;

        editor.call('viewport:render');
    });
});


/* editor/viewport/viewport-lightmapper-auto.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var entityAssetLoading = { };
    var bakingNextFrame = false;
    var state = false;
    var timeLast = 0;
    var timeDelay = 500;
    var queued = false;


    editor.on('lightmapper:baked', function() {
        queued = false;
        timeLast = Date.now();
    });


    editor.method('lightmapper:auto', function(value) {
        if (value === undefined)
            return state;

        if (state === value)
            return;

        state = value;
        editor.emit('lightmapper:auto', state);

        rebakeScene();
    });
    editor.emit('lightmapper:auto', state);


    // track entities model assets loading state to re-bake
    var rebakeEntity = function(entity, force) {
        if (! (state || force))
            return;

        if (! entity.has('components.model'))
            return;

        var type = entity.get('components.model.type');

        if (type === 'asset') {
            var assetId = entity.get('components.model.asset');
            if (! assetId)
                return;

            var asset = app.assets.get(parseInt(assetId, 10));
            if (! asset || ! asset.resource) {
                var loading = entityAssetLoading[entity.get('resource_id')];
                if (loading) {
                    if (loading.assetId === assetId)
                        return;

                    app.assets.off('load:' + loading.assetId, loading.fn);
                    delete entityAssetLoading[entity.get('resource_id')];
                }

                loading = {
                    assetId: assetId,
                    fn: function(asset) {
                        delete entityAssetLoading[entity.get('resource_id')];

                        if (asset.id !== parseInt(entity.get('components.model.asset'), 10))
                            return;

                        rebakeEntity(entity);
                    }
                };
                app.assets.once('load:' + assetId, loading.fn);
                return;
            }
        }

        editor.call('viewport:render');
        editor.once('viewport:update', function() {
            // console.log('rebake self');
            editor.call('lightmapper:bake', [ entity ]);
        });
    };

    var rebakeScene = function(force) {
        if (! (state || force))
            return;

        if (bakingNextFrame)
            return;

        if (! force && (Date.now() - timeLast) < timeDelay) {
            if (! queued) {
                queued = true;
                setTimeout(function() {
                    if (! queued) return;
                    rebakeScene();
                }, (timeDelay - (Date.now() - timeLast)) + 16);
            }
            return;
        }

        bakingNextFrame = true;
        editor.call('viewport:render');
        editor.once('viewport:update', function() {
            if (! bakingNextFrame)
                return;

            bakingNextFrame = false;
            editor.call('lightmapper:bake');
            editor.call('entities:shadows:update');
        });
    };


    editor.on('viewport:update', function() {
        if (queued && (Date.now() - timeLast) >= timeDelay)
            rebakeScene();
    });


    // bake once all assets are loaded on first time-load
    var loadingAssets = { };
    var onLoadStart = function(asset) {
        loadingAssets[asset.id] = true;
        asset.once('load', function() {
            delete loadingAssets[asset.id];

            if (Object.keys(loadingAssets).length === 0) {
                app.assets.off('load:start', onLoadStart);
                rebakeScene(true);
            }
        });
    };
    app.assets.on('load:start', onLoadStart);

    // re-bake on scene switches
    editor.on('scene:load', function() {
        // needs to wait 3 frames
        // before it is safe to re-bake
        // don't ask why :D

        editor.call('viewport:render');
        editor.once('viewport:update', function() {
            editor.call('viewport:render');
            editor.once('viewport:update', function() {
                rebakeScene(true);
            });
        });
    });

    // re-bake on scene settings loaded
    editor.on('sceneSettings:load', function() {
        rebakeScene(true);
    });


    var evtRebakeEntity = function() {
        rebakeEntity(this);
    };
    var evtRebakeLight = function() {
        if (! this.get('components.light.bake'))
            return;

        rebakeScene();
    };

    var evtRebakeScene = function() {
        rebakeScene();
    };

    // subscribe to model, light and scene changes
    // to do rebaking
    var fieldsLocal = [
        'components.model.lightmapped',
        'components.model.lightmapSizeMultiplier',
        'components.model.receiveShadows'
    ];
    var fieldsLight = [
        'components.light.color',
        'components.light.intensity',
        'components.light.range',
        'components.light.falloffMode',
        'components.light.castShadows',
        'components.light.shadowResolution',
        'components.light.shadowBias',
        'components.light.normalOffsetBias'
    ];
    var fieldsGlobal = [
        'enabled',
        'components.model.enabled',
        'components.model.type',
        'components.model.asset',
        'components.model.castShadowsLightmap',
        'components.light.bake'
    ];

    editor.on('entities:add', function(entity) {
        // model
        for(var i = 0; i < fieldsLocal.length; i++)
            entity.on(fieldsLocal[i] + ':set', evtRebakeEntity);

        // light
        for(var i = 0; i < fieldsLight.length; i++)
            entity.on(fieldsLight[i] + ':set', evtRebakeLight);

        // global
        for(var i = 0; i < fieldsGlobal.length; i++)
            entity.on(fieldsGlobal[i] + ':set', evtRebakeScene);
    });

    editor.on('gizmo:translate:end', evtRebakeScene);
    editor.on('gizmo:rotate:end', evtRebakeScene);
    editor.on('gizmo:scale:end', evtRebakeScene);
});


/* editor/viewport/viewport-drop-model.js */
editor.once('load', function() {
    'use strict';

    var canvas = editor.call('viewport:canvas');
    if (! canvas) return;

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var aabb = new pc.BoundingBox();
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var vecC = new pc.Vec3();


    var dropRef = editor.call('drop:target', {
        ref: canvas.element,
        filter: function(type, data) {
            if (type === 'asset.model') {
                var asset = app.assets.get(data.id);
                if (asset) app.assets.load(asset);

                return true;
            }

            if (type === 'assets') {
                for(var i = 0; i < data.ids.length; i++) {
                    var asset = editor.call('assets:get', data.ids[i]);
                    if (! asset)
                        return false;

                    if (asset.get('type') !== 'model')
                        return false;
                }

                for(var i = 0; i < data.ids.length; i++) {
                    var asset = app.assets.get(data.ids[i]);
                    if (asset) app.assets.load(asset);
                }

                return true;
            }
        },
        drop: function(type, data) {
            if (! config.scene.id)
                return;

            var assets = [ ];

            if (type === 'asset.model') {
                var asset = editor.call('assets:get', parseInt(data.id, 10));
                if (asset) assets.push(asset);
            } else if (type === 'assets') {
                for(var i = 0; i < data.ids.length; i++) {
                    var asset = editor.call('assets:get', parseInt(data.ids[i], 10));
                    if (asset && asset.get('type') === 'model')
                        assets.push(asset);
                }
            }

            if (! assets.length)
                return;

            // parent
            var parent = null;
            if (editor.call('selector:type') === 'entity')
                parent = editor.call('selector:items')[0];

            if (! parent)
                parent = editor.call('entities:root');

            var entities = [ ];
            var data = [ ];

            // calculate aabb
            var first = true;
            for(var i = 0; i < assets.length; i++) {
                var assetEngine = app.assets.get(assets[i].get('id'));
                if (! assetEngine) continue;

                if (assetEngine.resource) {
                    var meshes = assetEngine.resource.meshInstances;
                    for(var m = 0; m < meshes.length; m++) {
                        if (first) {
                            first = false;
                            aabb.copy(meshes[m].aabb);
                        } else {
                            aabb.add(meshes[m].aabb);
                        }
                    }
                }
            }

            if (first) {
                aabb.center.set(0, 0, 0);
                aabb.halfExtents.set(1, 1, 1);
            }

            // calculate point
            var camera = editor.call('camera:current');
            var distance = 0;

            if (ui.Tree._ctrl && ui.Tree._ctrl()) {
                vecA.copy(camera.forward).scale(aabb.halfExtents.length() * 2.2);
                vecB.copy(camera.getPosition()).add(vecA);
                vecC.copy(vecB).sub(aabb.center);

                var tmp = new pc.Entity();
                parent.entity.addChild(tmp);
                tmp.setPosition(vecC);
                vecC.copy(tmp.getLocalPosition());
                tmp.destroy();

                // focus distance
                distance = vecA.copy(camera.getPosition()).sub(vecB).length();
            } else {
                vecC.set(0, 0, 0);
                vecB.copy(parent.entity.getPosition()).add(aabb.center);
                distance = aabb.halfExtents.length() * 2.2;
            }

            for(var i = 0; i < assets.length; i++) {
                var component = editor.call('components:getDefault', 'model');
                component.type = 'asset';
                component.asset = parseInt(assets[i].get('id'), 10);

                var name = assets[i].get('name');
                if (/\.json$/i.test(name))
                    name = name.slice(0, -5) || 'Untitled';

                // new entity
                var entity = editor.call('entities:new', {
                    parent: parent,
                    name: name,
                    position: [ vecC.x, vecC.y, vecC.z ],
                    components: {
                        model: component
                    },
                    noSelect: true,
                    noHistory: true
                });

                entities.push(entity);
                data.push(entity.json());
            }

            editor.call('selector:history', false);
            editor.call('selector:set', 'entity', entities);
            editor.once('selector:change', function() {
                editor.call('selector:history', true);
            });

            var selectorType = editor.call('selector:type');
            var selectorItems = editor.call('selector:items');
            if (selectorType === 'entity') {
                for(var i = 0; i < selectorItems.length; i++)
                    selectorItems[i] = selectorItems[i].get('resource_id');
            }

            var parentId = parent.get('resource_id');
            var resourceIds = [ ];
            for(var i = 0; i < entities.length; i++)
                resourceIds.push(entities[i].get('resource_id'));

            editor.call('history:add', {
                name: 'new model entities ' + entities.length,
                undo: function() {
                    for(var i = 0; i < resourceIds.length; i++) {
                        var entity = editor.call('entities:get', resourceIds[i]);
                        if (! entity)
                            continue;

                        editor.call('entities:removeEntity', entity);
                    }

                    if (selectorType === 'entity' && selectorItems.length) {
                        var items = [ ];
                        for(var i = 0; i < selectorItems.length; i++) {
                            var item = editor.call('entities:get', selectorItems[i]);
                            if (item)
                                items.push(item);
                        }

                        if (items.length) {
                            editor.call('selector:history', false);
                            editor.call('selector:set', selectorType, items);
                            editor.once('selector:change', function() {
                                editor.call('selector:history', true);
                            });
                        }
                    }
                },
                redo: function() {
                    var parent = editor.call('entities:get', parentId);
                    if (! parent)
                        return;

                    var entities = [ ];

                    for(var i = 0; i < data.length; i++) {
                        var entity = new Observer(data[i]);
                        entities.push(entity);
                        editor.call('entities:childToParent', entity, parent);
                        editor.call('entities:addEntity', entity, parent, false);
                    }

                    editor.call('selector:history', false);
                    editor.call('selector:set', 'entity', entities);
                    editor.once('selector:change', function() {
                        editor.call('selector:history', true);
                    });

                    editor.call('viewport:render');
                    editor.call('camera:focus', vecB, distance);
                }
            });

            editor.call('viewport:render');
            editor.call('camera:focus', vecB, distance);
        }
    });
});


/* editor/viewport/viewport-drop-material.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var canvas = editor.call('viewport:canvas');
    var active = false;
    var hoverMaterial = null;
    var hoverAsset = null;
    var hoverEntity = null;
    var hoverNode = null;
    var hoverPicked = null;
    var hoverMeshInstance = null;


    editor.on('viewport:pick:hover', function(node, picked) {
        hoverNode = node;
        hoverPicked = picked;

        if (active)
            onPick(node, picked);
    });


    var onPick = function(node, picked) {
        var meshInstance = null;

        if (node && node._icon)
            node = node._getEntity();

        if (! node || ! editor.call('entities:get', node.getGuid())) {
            onHover(null);
            return;
        }

        if (picked instanceof pc.MeshInstance)
            meshInstance = picked;

        if (node.model && meshInstance && (! meshInstance.node._parent || ! meshInstance.node._parent._icon)) {
            onHover(node, meshInstance);
        } else {
            onHover(null);
        }
    };


    var onLeave = function() {
        if (! hoverEntity)
            return;

        if (hoverEntity.model.type === 'asset') {

            if (hoverAsset) {
                hoverAsset.data.mapping[hoverAsset._materialIndHover].material = hoverAsset._materialBeforeHover;
                hoverAsset.fire('change', hoverAsset, 'data', hoverAsset.data, hoverAsset.data);
                delete hoverAsset._materialBeforeHover;
            } else {
                var mapping = hoverEntity.model.mapping;
                if (hoverEntity._materialBeforeHover === undefined)
                    delete mapping[hoverEntity._materialIndHover];
                else
                    mapping[hoverEntity._materialIndHover] = hoverEntity._materialBeforeHover;
                hoverEntity.model.mapping = mapping;
            }
        } else if (hoverEntity._materialBeforeHover) {
            hoverEntity.model.material = hoverEntity._materialBeforeHover;
        }

        delete hoverEntity._materialBeforeHover;
        delete hoverEntity._materialIndHover;

        editor.call('viewport:render');
    };

    var onHover = function(entity, meshInstance) {
        if (entity === hoverEntity && meshInstance === hoverMeshInstance)
            return;

        onLeave();

        hoverAsset = null;
        hoverEntity = entity;
        hoverMeshInstance = meshInstance;

        if (hoverEntity) {
            if (hoverEntity.model.type === 'asset') {
                var ind = hoverEntity.model.model.meshInstances.indexOf(hoverMeshInstance);
                if (ind !== -1) {
                    var mapping = hoverEntity.model.mapping;
                    if (!mapping || !mapping.hasOwnProperty(ind)) {

                        hoverAsset = app.assets.get(hoverEntity.model.asset);
                        hoverAsset._materialBeforeHover = hoverAsset.data.mapping[ind].material;
                        hoverAsset._materialIndHover = ind;

                        hoverAsset.data.mapping[ind].material = hoverMaterial.id;
                        hoverAsset.fire('change', hoverAsset, 'data', hoverAsset.data, hoverAsset.data);
                    } else {
                        hoverEntity._materialBeforeHover = mapping[ind];
                        hoverEntity._materialIndHover = ind;

                        mapping[ind] = hoverMaterial.id;
                        hoverEntity.model.mapping = mapping;
                    }

                    editor.call('viewport:render');
                }
            } else {
                hoverEntity._materialBeforeHover = hoverEntity.model.material;
                hoverEntity.model.material = hoverMaterial.resource;
                editor.call('viewport:render');
            }
        }
    };

    var dropRef = editor.call('drop:target', {
        ref: canvas.element,
        type: 'asset.material',
        hole: true,
        drop: function(type, data) {
            if (! config.scene.id)
                return;

            active = false;

            if (! hoverEntity || ! hoverEntity.model)
                return;

            var entity = editor.call('entities:get', hoverEntity.getGuid());
            if (! entity)
                return;

            if (entity.get('components.model.type') === 'asset') {
                var ind = hoverEntity.model.model.meshInstances.indexOf(hoverMeshInstance);
                if (ind === -1)
                    return;

                // if we are setting the model asset mapping then set it and return
                if (hoverAsset) {
                    var asset = editor.call('assets:get', hoverAsset.id);
                    if (asset.has('data.mapping.' + ind + '.material')) {
                        var history = asset.history.enabled;
                        asset.history.enabled = false;

                        var prevMapping = asset.get('data.mapping.' + ind + '.material');
                        var prevUserMapping = asset.get('meta.userMapping.' + ind);
                        var newMapping = hoverMaterial.id;

                        // set mapping and also userMapping
                        asset.set('data.mapping.' + ind + '.material', newMapping);
                        if (! asset.get('meta')) {
                            asset.set('meta', {
                                userMapping: {}
                            });
                        } else {
                            if (! asset.has('meta.userMapping')) {
                                asset.set('meta.userMapping', {});
                            }
                        }

                        asset.set('meta.userMapping.' + ind, true);

                        asset.history.enabled = history;

                        editor.call('history:add', {
                            name: 'assets.' + asset.get('id') + '.data.mapping.' + ind + '.material',
                            undo: function() {
                                var item = editor.call('assets:get', asset.get('id'));
                                if (! item) return;

                                var history = item.history.enabled;
                                item.history.enabled = false;
                                item.set('data.mapping.' + ind + '.material', prevMapping);

                                if (! prevUserMapping) {
                                    item.unset('meta.userMapping.' + ind);

                                    if (! Object.keys(item.get('meta.userMapping')).length) {
                                        item.unset('meta.userMapping');
                                    }
                                }

                                item.history.enabled = history;
                            },
                            redo: function() {
                                var item = editor.call('assets:get', asset.get('id'));
                                if (! item) return;

                                var history = item.history.enabled;
                                item.history.enabled = false;
                                item.set('data.mapping.' + ind + '.material', newMapping);
                                if (! item.get('meta')) {
                                    item.set('meta', {
                                        userMapping: {}
                                    });
                                } else {
                                    if (! item.has('meta.userMapping')) {
                                        item.set('meta.userMapping', {});
                                    }
                                }

                                item.set('meta.userMapping.' + ind, true);
                                item.history.enabled = history;
                            }
                        });
                    }
                } else {
                    // set mapping with custom history action
                    // to prevent bug where undoing will set the mapping to
                    // null instead of unsetting it
                    var history = entity.history.enabled;
                    entity.history.enabled = false;
                    var resourceId = entity.get('resource_id');

                    var undo = {};
                    var redo = {};

                    if (!entity.get('components.model.mapping')) {
                        var mapping = {};
                        mapping[ind] = parseInt(hoverMaterial.id, 10);
                        entity.set('components.model.mapping', mapping);
                        undo.path = 'components.model.mapping';
                        undo.value = undefined;
                        redo.path = undo.path;
                        redo.value = mapping;
                    } else {
                        undo.path = 'components.model.mapping.' + ind;
                        undo.value = entity.has('components.model.mapping.' + ind) ?
                            entity.get('components.model.mapping.' + ind) :
                            undefined;
                        redo.path = undo.path;
                        redo.value = parseInt(hoverMaterial.id, 10);

                        entity.set('components.model.mapping.' + ind, parseInt(hoverMaterial.id, 10));

                    }
                    entity.history.enabled = history;

                    editor.call('history:add', {
                        name: 'entities.' + resourceId + '.components.model.mapping',
                        undo: function() {
                            var item = editor.call('entities:get', resourceId);
                            if (! item) return;

                            var history = item.history.enabled;
                            item.history.enabled = false;

                            if (undo.value === undefined)
                                item.unset(undo.path);
                            else
                                item.set(undo.path, undo.value);

                            item.history.enabled = history;
                        },
                        redo: function() {
                            var item = editor.call('entities:get', resourceId);
                            if (! item) return;

                            var history = item.history.enabled;
                            item.history.enabled = false;
                            if (redo.value === undefined)
                                item.unset(redo.path);
                            else
                                item.set(redo.path, redo.value);
                            item.history.enabled = history;
                        }
                    });
                }
            } else {
                // primitive model
                entity.set('components.model.materialAsset', hoverMaterial.id);
            }
        },
        over: function(type, data) {
            if (! config.scene.id)
                return;

            hoverMaterial = app.assets.get(parseInt(data.id, 10));
            if (! hoverMaterial)
                return;

            app.assets.load(hoverMaterial);

            hoverEntity = null;
            hoverMeshInstance = null;

            active = true;

            onPick(hoverNode, hoverPicked);
        },
        leave: function() {
            if (!config.scene.id)
                return;

            active = false;

            onLeave();
        }
    });
});


/* editor/viewport/viewport-drop-cubemap.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var canvas = editor.call('viewport:canvas');
    var evtPickHover = null;
    var evtViewportHover = null;
    var evtOnLoad = null;
    var hoverSkybox = null;
    var hoverMaterial = null;
    var hoverCubemap = null;
    var hoverEntity = undefined;
    var hoverMeshInstance = null;
    var hoverSkyboxFields = [ 'cubeMap', 'prefilteredCubeMap128', 'prefilteredCubeMap64', 'prefilteredCubeMap32', 'prefilteredCubeMap16', 'prefilteredCubeMap8', 'prefilteredCubeMap4' ]

    var onPickHover = function(node, picked) {
        var meshInstance = null;

        if (node && node._icon)
            node = node._getEntity();

        if (! node) {
            onHover(null);
            return;
        }

        if (picked instanceof pc.MeshInstance)
            meshInstance = picked;

        if (node.model && meshInstance && (! meshInstance.node._parent || ! meshInstance.node._parent._icon)) {
            onHover(node, meshInstance);
        } else {
            onHover(null);
        }
    };

    var onLeave = function() {
        if (hoverSkybox) {
            app.scene.setSkybox(hoverSkybox);
            hoverSkybox = null;
            editor.call('viewport:render');
        }

        if (hoverMaterial) {
            for(var i = 0; i < hoverSkyboxFields.length; i++)
                hoverMaterial[hoverSkyboxFields[i]] = hoverMaterial._hoverCubeMap[hoverSkyboxFields[i]];
            hoverMaterial.update();
            delete hoverMaterial._hoverCubeMap;
            hoverMaterial = null;

            editor.call('viewport:render');
        }
    };

    var onCubemapLoad = function() {
        setCubemap();
    };

    var setCubemap = function() {
        if (hoverEntity) {
            hoverMaterial = hoverMeshInstance.material;

            if (hoverMaterial) {
                if (! hoverMaterial._hoverCubeMap) {
                    hoverMaterial._hoverCubeMap = { };
                    for(var i = 0; i < hoverSkyboxFields.length; i++)
                        hoverMaterial._hoverCubeMap[hoverSkyboxFields[i]] = hoverMaterial[hoverSkyboxFields[i]];
                }

                for(var i = 0; i < hoverSkyboxFields.length; i++)
                    hoverMaterial[hoverSkyboxFields[i]] = hoverCubemap.resources[i];

                hoverMaterial.update();

                editor.call('viewport:render');
            }
        } else {
            if (! hoverSkybox) {
                hoverSkybox = [ null, null, null, null, null, null ];
                var id = editor.call('sceneSettings').get('render.skybox');
                if (id) {
                    var engineCubemap = app.assets.get(id);
                    if (engineCubemap)
                        hoverSkybox = engineCubemap.resources;
                }
            }

            if (hoverCubemap)
                app.scene.setSkybox(hoverCubemap.resources);

            editor.call('viewport:render');
        }
    };

    var onHover = function(entity, meshInstance) {
        if (entity === hoverEntity && meshInstance === hoverMeshInstance)
            return;

        onLeave();

        hoverEntity = entity;
        hoverMeshInstance = meshInstance;

        setCubemap();
    };

    var dropRef = editor.call('drop:target', {
        ref: canvas.element,
        type: 'asset.cubemap',
        hole: true,
        drop: function(type, data) {
            if (!config.scene.id)
                return;

            if (evtPickHover) {
                evtPickHover.unbind();
                evtPickHover = null;
            }

            hoverCubemap.off('load', onCubemapLoad);

            onLeave();

            if (hoverEntity) {
                var materialId;
                if (hoverEntity.model.type === 'asset') {
                    var ind = hoverEntity.model.model.meshInstances.indexOf(hoverMeshInstance);

                    if (hoverEntity.model.mapping && hoverEntity.model.mapping[ind]) {
                        materialId = hoverEntity.model.mapping[ind];
                    } else if (hoverEntity.model.asset) {
                        var modelAsset = editor.call('assets:get', hoverEntity.model.asset);

                        if (modelAsset && ind !== -1)
                            materialId = modelAsset.get('data.mapping.' + ind + '.material');
                    }
                } else if (hoverEntity.model.materialAsset) {
                    materialId = hoverEntity.model.materialAsset.id;
                }

                if (materialId) {
                    var materialAsset = editor.call('assets:get', materialId);
                    if (materialAsset)
                        materialAsset.set('data.cubeMap', hoverCubemap.id);
                }
                editor.call('viewport:render');
            } else {
                editor.call('sceneSettings').set('render.skybox', hoverCubemap.id);
                app.scene.setSkybox(hoverCubemap.resources);
                editor.call('viewport:render');
            }
        },
        over: function(type, data) {
            if (!config.scene.id)
                return;

            hoverCubemap = app.assets.get(parseInt(data.id, 10));
            if (! hoverCubemap)
                return;

            hoverCubemap.loadFaces = true;
            app.assets.load(hoverCubemap);
            hoverCubemap.on('load', onCubemapLoad);

            hoverEntity = undefined;
            hoverMeshInstance = null;

            evtPickHover = editor.on('viewport:pick:hover', onPickHover);
            onHover(null, null);
        },
        leave: function() {
            if (!config.scene.id)
                return;

            if (evtPickHover) {
                evtPickHover.unbind();
                evtPickHover = null;
            }

            hoverCubemap.off('load', onCubemapLoad);

            onLeave();
        }
    });
});


/* editor/viewport/viewport-userdata.js */
editor.once('load', function() {
    'use strict';

    editor.on('userdata:load', function (userdata) {
        if (! editor.call('permissions:read'))
            return;

        var cameras = userdata.get('cameras');

        if (cameras) {
            for(var name in cameras) {
                if (! cameras.hasOwnProperty(name))
                    continue;

                var camera = editor.call('camera:get', name);
                if (! camera)
                    continue;

                var data = cameras[name];

                if (data.position)
                    camera.setPosition(data.position[0], data.position[1], data.position[2]);

                if (data.rotation)
                    camera.setEulerAngles(data.rotation[0], data.rotation[1], data.rotation[2]);

                if (data.orthoHeight && camera.camera.projection === pc.PROJECTION_ORTHOGRAPHIC)
                    camera.camera.orthoHeight = parseInt(data.orthoHeight, 10);

                if (data.focus)
                    camera.focus.set(data.focus[0], data.focus[1], data.focus[2]);
            }
        }

        editor.call('viewport:render');
    });
});


/* editor/viewport/viewport-user-cameras.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var container = new pc.Entity(app);
    app.root.addChild(container);

    var cameraModel = null;
    var cameras = { };
    var userdata = { };


    // material default
    var materialDefault = new pc.BasicMaterial();
    materialDefault.color = new pc.Color(1, 1, 1, 1);
    materialDefault.update();
    // material quad
    var materialQuad = new pc.BasicMaterial();
    materialQuad.color = new pc.Color(1, 1, 1, .25);
    materialQuad.cull = pc.CULLFACE_NONE;
    materialQuad.blend = true;
    materialQuad.blendSrc = pc.BLENDMODE_SRC_ALPHA;
    materialQuad.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
    materialQuad.update();
    // material behind
    var materialBehind = new pc.BasicMaterial();
    materialBehind.color = new pc.Color(1, 1, 1, .15);
    materialBehind.blend = true;
    materialBehind.blendSrc = pc.BLENDMODE_SRC_ALPHA;
    materialBehind.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
    materialBehind.depthTest = false;
    materialBehind.update();


    // Subscribes to user data of specified user
    var addUser = function (userId) {
        editor.once('userdata:' + userId + ':raw', function (data) {
            loadUserData(userId, data);
        });

        userdata[userId] = editor.call('realtime:subscribe:userdata', config.scene.id, userId);
    };

    // Removes user camera and unsubscribes from userdata
    var removeUser = function (userId) {
        if (userId === config.self.id) return;

        // unsubscribe from realtime userdata
        if (userdata[userId]) {
            userdata[userId].destroy();
            delete userdata[userId];
            editor.unbind('realtime:userdata:' + userId + ':op:cameras');
        }

        // remove user camera
        if (cameras[userId]) {
            cameras[userId].destroy();
            delete cameras[userId];
            editor.call('viewport:render');
        }
    };

    var close = .25;
    var far = .5;
    var horiz = .5;
    var vert = .375;

    var createCameraModel = function() {
        var vertexFormat = new pc.gfx.VertexFormat(app.graphicsDevice, [
            { semantic: pc.gfx.SEMANTIC_POSITION, components: 3, type: pc.gfx.ELEMENTTYPE_FLOAT32 }
        ]);
        // box
        var buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, 12 * 2);
        var iterator = new pc.gfx.VertexIterator(buffer);

        // top
        iterator.element[pc.SEMANTIC_POSITION].set(close * horiz, close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(horiz, vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(horiz, vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-horiz, vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-horiz, vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-close * horiz, close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-close * horiz, close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(close * horiz, close * vert, 0);
        iterator.next();
        // bottom
        iterator.element[pc.SEMANTIC_POSITION].set(close * horiz, -close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(horiz, -vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(horiz, -vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-horiz, -vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-horiz, -vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-close * horiz, -close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-close * horiz, -close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(close * horiz, -close * vert, 0);
        iterator.next();
        // sides
        iterator.element[pc.SEMANTIC_POSITION].set(close * horiz, -close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(close * horiz, close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(horiz, -vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(horiz, vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-horiz, -vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-horiz, vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-close * horiz, -close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-close * horiz, close * vert, 0);
        iterator.next();
        iterator.end();
        // node
        var node = new pc.GraphNode();
        // mesh
        var mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        var meshInstance = new pc.MeshInstance(node, mesh, materialDefault);
        meshInstance.updateKey();
        // model
        cameraModel = new pc.Model();
        cameraModel.graph = node;
        cameraModel.meshInstances = [ meshInstance ];
    };

    // Creates user camera and binds to real time events
    var loadUserData = function (userId, data) {
        if (! cameraModel)
            createCameraModel();

        // add user camera
        var camera = cameras[userId] = new pc.Entity(app);
        camera.addComponent('model', {
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        camera.model.model = cameraModel.clone();
        container.addChild(camera);

        var cameraInner = new pc.Entity(app);
        cameraInner.addComponent('model', {
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        cameraInner.model.model = cameraModel.clone();
        cameraInner.model.model.meshInstances[0].material = materialBehind;
        camera.addChild(cameraInner);

        var cameraQuad = new pc.Entity(app);
        cameraQuad._userCamera = userId;
        cameraQuad.addComponent('model', {
            type: 'plane',
            castShadows: false,
            receiveShadows: false,
            castShadowsLightmap: false
        });
        cameraQuad.model.material = materialQuad;
        cameraQuad.rotate(90, 0, 0);
        cameraQuad.setLocalScale(close * horiz * 2, 1, close * vert * 2);
        camera.addChild(cameraQuad);

        var pos = data.cameras.perspective.position || [ 0, 0, 0 ];
        camera.setPosition(pos[0], pos[1], pos[2]);

        var rot = data.cameras.perspective.rotation || [ 0, 0, 0 ];
        camera.setEulerAngles(rot[0], rot[1], rot[2]);

        camera.pos = camera.getPosition().clone();
        camera.rot = camera.getRotation().clone();

        editor.call('viewport:render');

        // server > client
        var evt = editor.on('realtime:userdata:' + userId + ':op:cameras', function(op) {
            if (op.p.length !== 3 || ! op.oi || op.p[1] !== 'perspective')
                return;

            if (op.p[2] === 'position') {
                camera.pos.set(op.oi[0], op.oi[1], op.oi[2]);
                editor.call('viewport:render');
            } else if (op.p[2] === 'rotation') {
                camera.rot.setFromEulerAngles(op.oi[0], op.oi[1], op.oi[2]);
                editor.call('viewport:render');
            }
        });

        var unload = function () {
            if (evt) {
                evt.unbind();
                evt = null;
            }

            removeUser(userId);
        };

        editor.once('scene:unload', unload);
        editor.once('realtime:disconnected', unload);

        editor.call('users:loadOne', userId, function(user) {
            var dataNormal = editor.call('whoisonline:color', user.id, 'data');
            var colorNormal = new pc.Color(dataNormal[0], dataNormal[1], dataNormal[2], 1.0);
            camera.model.meshInstances[0].setParameter('uColor', colorNormal.data);

            var colorBehind = new pc.Color(dataNormal[0], dataNormal[1], dataNormal[2], 0.15);
            cameraInner.model.meshInstances[0].setParameter('uColor', colorBehind.data);

            var dataLight = editor.call('whoisonline:color', user.id, 'data');
            var colorLight = new pc.Color(dataLight[0], dataLight[1], dataLight[2], 0.25);
            cameraQuad.model.meshInstances[0].setParameter('uColor', colorLight.data);
        });
    };

    // Add user who comes online
    editor.on('whoisonline:add', function (userId) {
        // ignore the logged in user
        if (userId === config.self.id) return;

        var add = function () {
            // do not add users without read access
            if (editor.call('permissions:read', userId))
                addUser(userId);

            // subscribe to project permission changes
            editor.on('permissions:set:' + userId, function () {
                if (editor.call('permissions:read', userId)) {
                    if (! userdata[userId]) {
                        // WORKAROUND
                        // wait a bit before adding, for userdata to be created at sharejs
                        setTimeout(function () {
                            addUser(userId);
                        }, 500);
                    }
                } else {
                    removeUser(userId);
                }
            });
        };

        if (!config.scene.id) {
            editor.once('scene:raw', add);
        } else {
            add();
        }

    });

    // Remove user who goes offline
    editor.on('whoisonline:remove', function (userId) {
        if (userId === config.self.id) return;

        removeUser(userId);
        editor.unbind('permissions:set:' + userId);
    });

    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var quat = new pc.Quat();

    editor.on('viewport:update', function(dt) {
        var render = false;

        for(var id in cameras) {
            var camera = cameras[id];

            if (vecA.copy(camera.getPosition()).sub(camera.pos).length() > 0.01) {
                vecA.lerp(camera.getPosition(), camera.pos, 4 * dt);
                camera.setPosition(vecA);
                render = true;
            } else {
                camera.setPosition(camera.pos);
            }

            vecA.set(0, 0, -1);
            vecB.set(0, 0, -1);
            camera.getRotation().transformVector(vecA, vecA);
            camera.rot.transformVector(vecB, vecB);

            if (vecA.dot(vecB) < 0.999) {
                quat = camera.getRotation().slerp(camera.getRotation(), camera.rot, 8 * dt);
                camera.setRotation(quat);
                render = true;
            } else {
                camera.setRotation(camera.rot);
            }
        }

        if (render)
            editor.call('viewport:render');
    });
});


/* editor/viewport/viewport-context-menu.js */
editor.once('load', function() {
    'use strict';

    var currentEntity = null;
    var root = editor.call('layout.root');

    // create data for entity menu
    var menu;

    // wait until all entities are loaded
    // before creating the menu to make sure
    // that the menu data for entities have been created
    editor.once('entities:load', function () {
        var menuData = { };
        var entityMenuData = editor.call('menu:get', 'entity');
        if (entityMenuData) {
            for (var key in entityMenuData.items) {
                menuData[key] = entityMenuData.items[key];
            }
        }

        // TODO
        // menuData['enable'] = {
        //     title: 'Enable',
        //     icon: '&#58421;',
        //     hide: function () {
        //         return currentEntity.get('enabled');
        //     },
        //     select: function() {
        //         currentEntity.set('enabled', true);
        //     }
        // };

        // menuData['disable'] = {
        //     title: 'Disable',
        //     icon: '&#58422;',
        //     hide: function () {
        //         return !currentEntity.get('enabled');
        //     },
        //     select: function() {
        //         currentEntity.set('enabled', false);
        //     }
        // };

        // menuData['copy'] = {
        //     title: 'Copy',
        //     icon: '&#57891;',
        //     select: function() {
        //         editor.call('entities:copy', currentEntity);
        //     }
        // };

        // menuData['paste'] = {
        //     title: 'Paste',
        //     icon: '&#57892;',
        //     filter: function () {
        //         return !editor.call('entities:clipboard:empty');
        //     },
        //     select: function() {
        //         editor.call('entities:paste', currentEntity);
        //     }
        // };

        // menuData['duplicate'] = {
        //     title: 'Duplicate',
        //     icon: '&#57908;',
        //     filter: function () {
        //         return currentEntity !== editor.call('entities:root');
        //     },
        //     select: function() {
        //         editor.call('entities:duplicate', currentEntity);
        //     }
        // };

        // menuData['delete'] = {
        //     title: 'Delete',
        //     icon: '&#58657;',
        //     filter: function () {
        //         return currentEntity !== editor.call('entities:root');
        //     },
        //     select: function() {
        //         editor.call('entities:delete', currentEntity);
        //     }
        // };


        // menu
        menu = ui.Menu.fromData(menuData);
        root.append(menu);
    });

    editor.method('viewport:contextmenu', function (x, y, entity) {
        if (! editor.call('permissions:write'))
            return;

        currentEntity = entity;
        menu.open = true;
        menu.position(x + 1, y);
    });
});


/* editor/viewport/viewport-tap.js */
editor.once('load', function() {
    'use strict';

    var canvas = editor.call('viewport:canvas');
    if (! canvas) return;

    function Tap(evt, rect, mouse) {
        this.x = this.lx = this.sx = evt.clientX - rect.left;
        this.y = this.ly = this.sy = evt.clientY - rect.top;
        this.nx = 0;
        this.ny = 0;
        this.move = false;
        this.down = true;
        this.button = evt.button;
        this.mouse = !! mouse;
    };
    Tap.prototype.update = function(evt, rect) {
        var x = evt.clientX - rect.left;
        var y = evt.clientY - rect.top;

        // if it's moved
        if (this.down && ! this.move && (Math.abs(this.sx - x) + Math.abs(this.sy - y)) > 8)
            this.move = true;

        // moving
        if (this.move) {
            this.nx = x - this.lx;
            this.ny = y - this.ly;
            this.lx = this.x;
            this.ly = this.y;
        }

        // coords
        this.x = x;
        this.y = y;
    };

    var taps = [ ];
    // var tapMouse = new Tap({ clientX: 0, clientY: 0 }, { left: 0, top: 0 });
    var inViewport = false;

    editor.method('viewport:inViewport', function() {
        return inViewport;
    });

    var evtMouseMove = function(evt) {
        var rect = canvas.element.getBoundingClientRect();
        for(var i = 0; i < taps.length; i++) {
            if (! taps[i].mouse)
                continue;

            taps[i].update(evt, rect);
            editor.emit('viewport:tap:move', taps[i], evt);
        }

        editor.emit('viewport:mouse:move', {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top,
            down: taps.length !== 0
        });

        // render if mouse moved within viewport
        if (evt.clientX >= rect.left && evt.clientX <= rect.right && evt.clientY >= rect.top && evt.clientY <= rect.bottom) {
            if (! inViewport) {
                inViewport = true;
                editor.emit('viewport:hover', true);
            }
            editor.call('viewport:render');
        } else if (inViewport) {
            inViewport = false;
            editor.emit('viewport:hover', false);
            editor.call('viewport:render');
        }
    };

    var evtMouseUp = function(evt) {
        var items = taps.slice(0);

        for(var i = 0; i < items.length; i++) {
            // if (tapMouse.down) {
            if (! items[i].mouse || ! items[i].down || items[i].button !== evt.button)
                continue;

            items[i].down = false;
            items[i].update(evt, canvas.element.getBoundingClientRect());
            editor.emit('viewport:tap:end', items[i], evt);

            if (! items[i].move)
                editor.emit('viewport:tap:click', items[i], evt);

            var ind = taps.indexOf(items[i]);
            if (ind !== -1)
                taps.splice(ind, 1);
        }

        var rect = canvas.element.getBoundingClientRect();

        editor.emit('viewport:mouse:move', {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top,
            down: taps.length !== 0
        });
    };

    canvas.element.addEventListener('mousedown', function(evt) {
        var rect = canvas.element.getBoundingClientRect();

        editor.emit('viewport:mouse:move', {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top,
            down: true
        });

        var tap = new Tap(evt, rect, true)
        taps.push(tap);

        editor.emit('viewport:tap:start', tap, evt);

        if (document.activeElement && document.activeElement.tagName.toLowerCase() === 'input')
            document.activeElement.blur();

        evt.preventDefault();
    }, false);

    canvas.element.addEventListener('mouseover', function() {
        editor.emit('viewport:hover', true);
        editor.call('viewport:render');
    }, false);

    canvas.element.addEventListener('mouseleave', function(evt) {
        // ignore tooltip
        var target = evt.toElement || evt.relatedTarget;
        if (target && target.classList.contains('cursor-tooltip'))
            return;

        editor.emit('viewport:hover', false);
        editor.call('viewport:render');
    }, false);

    window.addEventListener('mousemove', evtMouseMove, false);
    window.addEventListener('dragover', evtMouseMove, false);
    window.addEventListener('mouseup', evtMouseUp, false);
});


/* editor/viewport/viewport-pick.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var picker = new pc.scene.Picker(app.graphicsDevice, 1, 1);
    var pickedData = {
        node: null,
        picked: null
    };
    var mouseCoords = new pc.Vec2();
    var mouseTap = false;
    var inViewport = false;
    var picking = true;
    var filter = null;
    var mouseDown = false;

    editor.method('viewport:pick:filter', function(fn) {
        if (filter === fn)
            return;

        filter = fn;
    });

    editor.method('viewport:pick:state', function(state) {
        picking = state;
    });

    editor.on('viewport:update', function() {
        if (! mouseDown && ! inViewport && pickedData.node) {
            pickedData.node = null;
            pickedData.picked = null;
            editor.emit('viewport:pick:hover', null, null);
        }

        if (! inViewport || ! picking)
            return;

        // pick
        editor.call('viewport:pick', mouseCoords.x, mouseCoords.y, function(node, picked) {
            if (pickedData.node !== node || pickedData.picked !== picked) {
                pickedData.node = node;
                pickedData.picked = picked;

                editor.emit('viewport:pick:hover', pickedData.node, pickedData.picked);
            }
        });
    });

    editor.on('viewport:hover', function(hover) {
        inViewport = hover;
    });

    editor.on('viewport:resize', function(width, height) {
        picker.resize(width, height);
    });

    editor.method('viewport:pick', function(x, y, fn) {
        var scene = app.scene;

        if (filter) {
            scene = {
                drawCalls: app.scene.drawCalls.filter(filter)
            };
        }

        // prepare picker
        picker.prepare(editor.call('camera:current').camera.camera, scene);

        // pick node
        var picked = picker.getSelection(x, y);

        if (! picked.length || ! picked[0]) {
            fn(null, null);
        } else {
            var node = picked[0].node;

            // traverse to pc.Entity
            while (! (node instanceof pc.Entity) && node && node.getParent) {
                node = node.getParent();
            }
            if (! node) return;

            fn(node, picked[0]);
        }
    });

    editor.on('viewport:tap:start', function(tap) {
        if (! tap.mouse) return;

        mouseDown = true;
    });

    editor.on('viewport:tap:end', function(tap) {
        if (! tap.mouse) return;

        mouseDown = false;

        if (! inViewport && pickedData.node) {
            pickedData.node = null;
            pickedData.picked = null;
            editor.emit('viewport:pick:hover', null, null);
        }
    });

    editor.on('viewport:mouse:move', function(tap) {
        mouseCoords.x = tap.x;
        mouseCoords.y = tap.y;
    });

    editor.on('viewport:tap:click', function(tap) {
        if (! inViewport || (tap.mouse && tap.button !== 0))
            return;

        if (pickedData.node) {
            editor.emit('viewport:pick:node', pickedData.node, pickedData.picked);
        } else {
            editor.call('viewport:pick', tap.x, tap.y, function(node, picked) {
                if (pickedData.node !== node || pickedData.picked !== picked) {
                    pickedData.node = node;
                    pickedData.picked = picked;
                }

                if (pickedData.node) {
                    editor.emit('viewport:pick:node', pickedData.node, pickedData.picked);
                } else {
                    editor.emit('viewport:pick:clear');
                }
            });
        }
    });
});


/* editor/viewport/viewport-cursor.js */
editor.once('load', function() {
    'use strict';

    var state = false;
    var inViewport = false;

    // mouse hovering state on viewport
    editor.on('viewport:hover', function(hover) {
        if (inViewport === hover)
            return;

        inViewport = hover;

        if (! inViewport) {
            state = false;

            if (! editor.call('drop:active'))
                editor.call('cursor:set', '');
        }
    });

    var checkPicked = function(node, picked) {
        var hover = false;

        // if mouse in viewport && entity model has an asset
        // then set cursor to 'crosshair' to indicate
        // that next click will select node in model asset
        if (inViewport && node && node.model && node.model.asset && node.model.model) {
            if (editor.call('selector:type') === 'entity' &&
                editor.call('selector:count') === 1 &&
                editor.call('selector:items')[0].entity === node) {

                hover = true;
            }
        }

        // change cursor if needed
        if (state !== hover) {
            state = hover;
            editor.call('cursor:set', state ? 'crosshair' : '');
        }
    }

    editor.on('viewport:pick:node', checkPicked)
    editor.on('viewport:pick:hover', checkPicked);
});


/* editor/viewport/viewport-tooltips.js */
editor.once('load', function() {
    'use strict';

    var inViewport = false;
    var nameLast = '';
    var timeout = null;
    var pickedLast = null;
    var nodeLast = null;
    var delay = 500;

    editor.on('viewport:hover', function(state) {
        inViewport = state;

        if (! inViewport) {
            nameLast = '';
            pickedLast = null;
            nodeLast = null;
            editor.call('cursor:text', '');
            clearTimeout(timeout);
        }
    });

    var showTooltip = function() {
        editor.call('cursor:text', nameLast);
    };

    var checkPicked = function(node, picked) {
        var name = '';

        if (inViewport && node) {
            if (node._icon) {
                // icon
                var entity = node._getEntity && node._getEntity();
                if (entity)
                    name = entity.name;
            } else if (node._userCamera) {
                name = '@';
                editor.call('users:loadOne', node._userCamera, function(data) {
                    name = '@' + (data && data.username || 'anonymous');
                });
            } else if (node.model && node.model.asset && node.model.model && picked && picked.node) {
                // entity model meshInstance
                name = node.name + ' &#8594; ' + picked.node.name;
            } else {
                // normal entity
                if (editor.call('entities:get', node.getGuid()))
                    name = node.name;
            }
        }

        if (nodeLast !== node || pickedLast !== picked || nameLast !== name) {
            editor.call('cursor:text', '');
            clearTimeout(timeout);
            if (nameLast || name)
                timeout = setTimeout(showTooltip, delay);
        }

        if (nameLast !== name)
            nameLast = name;

        if (pickedLast !== picked)
            pickedLast = picked;

        if (nodeLast !== node)
            nodeLast = node;
    };

    editor.on('viewport:pick:node', checkPicked)
    editor.on('viewport:pick:hover', checkPicked);
});


/* editor/viewport/viewport-focus.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var defaultSize = new pc.Vec3(1, 1, 1);
    var defaultSizeSmall = new pc.Vec3(.2, .2, .2);
    var aabb = new pc.BoundingBox();
    var aabbA = new pc.BoundingBox();

    var calculateChildAABB = function(entity) {
        aabbA.add(editor.call('entities:boundingbox:entity', entity));

        var children = entity.getChildren();
        for(var i = 0; i < children.length; i++) {
            if (! (children[i] instanceof pc.Entity) || children[i].__editor)
                continue;

            calculateChildAABB(children[i]);
        }
    };

    editor.method('selection:aabb', function() {
        if (editor.call('selector:type') !== 'entity')
            return null;

        return editor.call('entities:aabb', editor.call('selector:items'));
    });

    editor.method('entities:aabb', function(items) {
        if (! items)
            return null;

        if (! (items instanceof Array))
            items = [ items ];

        aabb.center.set(0, 0, 0);
        aabb.halfExtents.copy(defaultSizeSmall);

        // calculate aabb for selected entities
        for(var i = 0; i < items.length; i++) {
            var entity = items[i].entity;

            if (! entity)
                continue;

            aabbA.center.copy(entity.getPosition());
            aabbA.halfExtents.copy(defaultSizeSmall);
            calculateChildAABB(entity);

            if (i === 0) {
                aabb.copy(aabbA);
            } else {
                aabb.add(aabbA);
            }
        }

        return aabb;
    });

    editor.method('viewport:focus', function() {
        var selection = editor.call('selection:aabb');
        if (! selection) return;

        var camera = editor.call('camera:current');

        // aabb
        var distance = Math.max(aabb.halfExtents.x, Math.max(aabb.halfExtents.y, aabb.halfExtents.z));
        // fov
        distance = (distance / Math.tan(0.5 * camera.camera.fov * Math.PI / 180.0));
        // extra space
        distance = distance * 1.1 + 1;

        editor.call('camera:focus', aabb.center, distance);
    });
});


/* editor/viewport/viewport-outline.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var renderer = app.renderer;
    var device = renderer.device;
    var scene = app.scene;

    var users = [ ];
    var selection = { };
    var colors = { };
    var render = 0;
    var cleared = false;

    var targets = [ ];
    var textures = [ ];


    editor.on('selector:change', function(type, items) {
        if (selection[config.self.id])
            render -= selection[config.self.id].length;

        if (! selection[config.self.id])
            users.unshift(config.self.id);

        selection[config.self.id] = [ ];

        if (type === 'entity') {
            for(var i = 0; i < items.length; i++) {
                var modelType = items[i].get('components.model.type');
                if (items[i].entity && (modelType === 'asset' && items[i].get('components.model.asset')) || modelType !== 'asset') {
                    selection[config.self.id].push(items[i].entity);
                    render++;
                }
            }
        }

        if (render)
            editor.call('viewport:render');
    });

    editor.on('selector:sync', function(user, data) {
        if (selection[user])
            render -= selection[user].length;

        if (! selection[user])
            users.push(user);

        selection[user] = [ ];

        if (data.type === 'entity') {
            for(var i = 0; i < data.ids.length; i++) {
                var entity = editor.call('entities:get', data.ids[i]);
                if (! entity) continue;

                var modelType = entity.get('components.model.type');
                if (entity.entity && (modelType === 'asset' && entity.get('components.model.asset')) || modelType !== 'asset') {
                    selection[user].push(entity.entity);
                    render++;
                }
            }
        }

        if (render)
            editor.call('viewport:render');
    });

    editor.on('whoisonline:remove', function(id) {
        if (! selection[id])
            return;

        render -= selection[id].length;

        delete selection[id];
        delete colors[id];
        var ind = users.indexOf(id);
        users.splice(ind, 1);
    });


    // material final
    var materialFinal = new pc.BasicMaterial();
    var shaderFinal;
    materialFinal.updateShader = function(device) {
        if (! shaderFinal) {
            shaderFinal = new pc.Shader(device, {
                attributes: {
                    aPosition: pc.SEMANTIC_POSITION
                },

                vshader: ' \
                    attribute vec2 aPosition;\n \
                    varying vec2 vUv0;\n \
                    void main(void)\n \
                    {\n \
                        gl_Position = vec4(aPosition, 0.0, 1.0);\n \
                        vUv0 = (aPosition.xy + 1.0) * 0.5;\n \
                    }\n',

                fshader: ' \
                    precision ' + device.precision + ' float;\n \
                    varying vec2 vUv0;\n \
                    uniform sampler2D uColorBuffer;\n \
                    void main(void)\n \
                    {\n \
                        gl_FragColor = texture2D(uColorBuffer, vUv0);\n \
                    }\n'
            });
        }
        this.shader = shaderFinal;
    };
    materialFinal.blend = true;
    materialFinal.blendDst = 8;
    materialFinal.blendEquation = 0;
    materialFinal.blendSrc = 6;
    materialFinal.blendType = 2;
    materialFinal.depthWrite = false;
    materialFinal.depthTest = false;
    materialFinal.update();


    var shaderBlurH = new pc.Shader(device, {
        attributes: {
            aPosition: pc.SEMANTIC_POSITION
        },

        vshader: ' \
            attribute vec2 aPosition;\n \
            varying vec2 vUv0;\n \
            void main(void)\n \
            {\n \
                gl_Position = vec4(aPosition, 0.0, 1.0);\n \
                vUv0 = (aPosition.xy + 1.0) * 0.5;\n \
            }\n',

        fshader: ' \
            precision ' + device.precision + ' float;\n \
            varying vec2 vUv0;\n \
            uniform float uOffset;\n \
            uniform sampler2D uColorBuffer;\n \
            void main(void)\n \
            {\n \
                float diff = 0.0;\n \
                vec4 pixel;\n \
                vec4 texel = texture2D(uColorBuffer, vUv0);\n \
                vec4 firstTexel = texel;\n \
                \n \
                pixel = texture2D(uColorBuffer, vUv0 + vec2(uOffset * -2.0, 0.0));\n \
                texel = max(texel, pixel);\n \
                diff = max(diff, length(firstTexel.rgb - pixel.rgb));\n \
                \n \
                pixel = texture2D(uColorBuffer, vUv0 + vec2(uOffset * -1.0, 0.0));\n \
                texel = max(texel, pixel);\n \
                diff = max(diff, length(firstTexel.rgb - pixel.rgb));\n \
                \n \
                pixel = texture2D(uColorBuffer, vUv0 + vec2(uOffset * +1.0, 0.0));\n \
                texel = max(texel, pixel);\n \
                diff = max(diff, length(firstTexel.rgb - pixel.rgb));\n \
                \n \
                pixel = texture2D(uColorBuffer, vUv0 + vec2(uOffset * +2.0, 0.0));\n \
                texel = max(texel, pixel);\n \
                diff = max(diff, length(firstTexel.rgb - pixel.rgb));\n \
                \n \
                gl_FragColor = vec4(texel.rgb, min(diff, 1.0));\n \
            }\n'
    });
    var shaderBlurV = new pc.Shader(device, {
        attributes: {
            aPosition: pc.SEMANTIC_POSITION
        },

        vshader: ' \
            attribute vec2 aPosition;\n \
            varying vec2 vUv0;\n \
            void main(void)\n \
            {\n \
                gl_Position = vec4(aPosition, 0.0, 1.0);\n \
                vUv0 = (aPosition.xy + 1.0) * 0.5;\n \
            }\n',

        fshader: ' \
            precision ' + device.precision + ' float;\n \
            varying vec2 vUv0;\n \
            uniform float uOffset;\n \
            uniform sampler2D uColorBuffer;\n \
            void main(void)\n \
            {\n \
                vec4 pixel;\n \
                vec4 texel = texture2D(uColorBuffer, vUv0);\n \
                vec4 firstTexel = texel;\n \
                float diff = texel.a;\n \
                \n \
                pixel = texture2D(uColorBuffer, vUv0 + vec2(0.0, uOffset * -2.0));\n \
                texel = max(texel, pixel);\n \
                diff = max(diff, length(firstTexel.rgb - pixel.rgb));\n \
                \n \
                pixel = texture2D(uColorBuffer, vUv0 + vec2(0.0, uOffset * -1.0));\n \
                texel = max(texel, pixel);\n \
                diff = max(diff, length(firstTexel.rgb - pixel.rgb));\n \
                \n \
                pixel = texture2D(uColorBuffer, vUv0 + vec2(0.0, uOffset * +1.0));\n \
                texel = max(texel, pixel);\n \
                diff = max(diff, length(firstTexel.rgb - pixel.rgb));\n \
                \n \
                pixel = texture2D(uColorBuffer, vUv0 + vec2(0.0, uOffset * +2.0));\n \
                texel = max(texel, pixel);\n \
                diff = max(diff, length(firstTexel.rgb - pixel.rgb));\n \
                \n \
                gl_FragColor = vec4(texel.rgb, min(diff, 1.0));\n \
            }\n'
    });


    var node = new pc.GraphNode();
    var mesh = new pc.Mesh();

    var vertexFormat = new pc.gfx.VertexFormat(device, [
        { semantic: pc.gfx.SEMANTIC_POSITION, components: 2, type: pc.gfx.ELEMENTTYPE_FLOAT32 }
    ]);
    var vertexBuffer = new pc.gfx.VertexBuffer(device, vertexFormat, 4);
    var iterator = new pc.gfx.VertexIterator(vertexBuffer);
    iterator.element[pc.SEMANTIC_POSITION].set(-1, -1);
    iterator.next();
    iterator.element[pc.SEMANTIC_POSITION].set(1, -1);
    iterator.next();
    iterator.element[pc.SEMANTIC_POSITION].set(-1, 1);
    iterator.next();
    iterator.element[pc.SEMANTIC_POSITION].set(1, 1);
    iterator.end();
    mesh.vertexBuffer = vertexBuffer;


    var indices = [ 0, 1, 2, 1, 3, 2 ];
    var indexBuffer = new pc.IndexBuffer(device, pc.INDEXFORMAT_UINT16, indices.length);
    var dst = new Uint16Array(indexBuffer.lock());
    dst.set(indices);
    indexBuffer.unlock();
    mesh.indexBuffer[0] = indexBuffer;

    mesh.primitive[0].type = pc.PRIMITIVE_TRIANGLES;
    mesh.primitive[0].base = 0;
    mesh.primitive[0].count = indices.length;
    mesh.primitive[0].indexed = true;

    var meshInstance = new pc.MeshInstance(node, mesh, materialFinal);
    meshInstance.updateKey = function() {
        this.key = pc._getDrawcallSortKey(14, this.material.blendType, false, 0);
    };
    meshInstance.layer = 14;
    meshInstance.updateKey();
    meshInstance.cull = false;
    meshInstance.pick = false;
    meshInstance.mask = 8;
    meshInstance.drawToDepth = false;

    scene.drawCalls.push(meshInstance);

    // add program lib with outline shader
    device.programLib.register('outline', {
        generateKey: function(device, options) {
            var key = 'outline';
            if (options.skin) key += '_skin';
            if (options.opacityMap) key += '_opam';
            if (options.instancing) key += '_inst';
            return key;
        },
        createShaderDefinition: function(device, options) {
            // attributes
            var attributes = {
                vertex_position: pc.SEMANTIC_POSITION
            };

            if (options.skin) {
                attributes.vertex_boneWeights = pc.SEMANTIC_BLENDWEIGHT;
                attributes.vertex_boneIndices = pc.SEMANTIC_BLENDINDICES;
            }

            if (options.opacityMap)
                attributes.vertex_texCoord0 = pc.SEMANTIC_TEXCOORD0;

            // vertex shader
            var chunks = pc.shaderChunks;
            var code = '';

            // vertex start
            code += chunks.transformDeclVS;
            if (options.skin) {
                code += pc.programlib.skinCode(device);
                code += chunks.transformSkinnedVS;
            } else if (options.instancing) {
                attributes.instance_line1 = pc.SEMANTIC_TEXCOORD2;
                attributes.instance_line2 = pc.SEMANTIC_TEXCOORD3;
                attributes.instance_line3 = pc.SEMANTIC_TEXCOORD4;
                attributes.instance_line4 = pc.SEMANTIC_TEXCOORD5;
                code += chunks.instancingVS;
                code += chunks.transformInstancedVS;
            } else {
                code += chunks.transformVS;
            }
            if (options.opacityMap) {
                code += "attribute vec2 vertex_texCoord0;\n\n";
                code += 'varying vec2 vUv0;\n\n';
            }

            // vertex body
            code += pc.programlib.begin();
            code += "   gl_Position = getPosition();\n";
            if (options.opacityMap)
                code += '    vUv0 = vertex_texCoord0;\n';
            code += pc.programlib.end();

            var vshader = code;

            // fragment shader
            code = pc.programlib.precisionCode(device);

            if (options.opacityMap) {
                code += 'varying vec2 vUv0;\n\n';
                code += 'uniform sampler2D texture_opacityMap;\n\n';
                code += chunks.alphaTestPS;
            }

            code += 'uniform vec4 uColor;\n';

            code += pc.programlib.begin();

            if (options.opacityMap) {
                code += '    alphaTest(texture2D(texture_opacityMap, vUv0).' + options.opacityChannel + ' );\n\n';
            }

            code += "float depth = gl_FragCoord.z / gl_FragCoord.w;\n";
            code += "gl_FragColor = uColor;\n";

            code += pc.programlib.end();
            var fshader = code;

            return {
                attributes: attributes,
                vshader: vshader,
                fshader: fshader
            };
        }
    });

    var shaderStatic = device.programLib.getProgram('outline', {
        skin: false
    });
    var shaderSkin = device.programLib.getProgram('outline', {
        skin: true
    });
    var shaderStaticOp = { };
    var shaderSkinOp = { };

    var chan = [ 'r', 'g', 'b', 'a' ];
    for(var c = 0; c < chan.length; c++) {
        shaderStaticOp[chan[c]] = device.programLib.getProgram('outline', {
            skin: false,
            opacityMap: true,
            opacityChannel: chan[c]
        });
        shaderSkinOp[chan[c]] = device.programLib.getProgram('outline', {
            skin: true,
            opacityMap: true,
            opacityChannel: chan[c]
        });
        shaderStaticOp[chan[c]] = device.programLib.getProgram('outline', {
            skin: false,
            opacityMap: true,
            opacityChannel: chan[c]
        });
        shaderSkinOp[chan[c]] = device.programLib.getProgram('outline', {
            skin: true,
            opacityMap: true,
            opacityChannel: chan[c]
        });
    }


    editor.on('viewport:postUpdate', function() {
        if (! render && cleared) return;

        if (targets[0] && (targets[0].width !== device.width || targets[1].height !== device.height)) {
            for(var i = 0; i < 2; i++) {
                targets[i].destroy();
                textures[i].destroy();
            }
            targets = [ ];
            textures = [ ];
        }

        if (! targets[0]) {
            for(var i = 0; i < 2; i++) {
                textures[i] = new pc.Texture(device, {
                    format: pc.PIXELFORMAT_R8_G8_B8_A8,
                    width: device.width,
                    height: device.height
                });
                textures[i].minFilter = pc.FILTER_NEAREST;
                textures[i].magFilter = pc.FILTER_NEAREST;
                textures[i].addressU = pc.ADDRESS_CLAMP_TO_EDGE;
                textures[i].addressV = pc.ADDRESS_CLAMP_TO_EDGE;

                targets[i] = new pc.RenderTarget(device, textures[i]);
            }

            meshInstance.setParameter('uColorBuffer', textures[0]);
        }


        var camera = editor.call('camera:current').camera.camera;

        var oldTarget = camera.renderTarget;

        if (render) {
            meshInstance.visible = true;
            camera.renderTarget = targets[0];
            renderer.setCamera(camera);

            device.clear({
                color: [ 0, 0, 0, 0 ],
                depth: 1.0,
                flags: pc.CLEARFLAG_COLOR | pc.CLEARFLAG_DEPTH
            });

            var ind = scene.drawCalls.indexOf(meshInstance);
            scene.drawCalls.splice(ind, 1);
            scene.drawCalls.push(meshInstance);

            var oldBlending = device.getBlending();
            device.setBlending(false);

            for(var u = 0; u < users.length; u++) {
                var id = parseInt(users[u], 10);

                if (! selection.hasOwnProperty(id) || ! selection[id].length)
                    continue;

                var color = colors[id];
                if (! color) {
                    var data = editor.call('whoisonline:color', id, 'data');
                    if (config.self.id === id)
                        data = [ 1, 1, 1 ];

                    colors[id] = new pc.Color(data[0], data[1], data[2]);
                    color = colors[id];
                }

                for(var i = 0; i < selection[id].length; i++) {
                    if (! selection[id][i])
                        continue;

                    var model = selection[id][i].model;
                    if (! model || ! model.model)
                        continue;

                    var meshes = model.meshInstances;
                    for(var m = 0; m < meshes.length; m++) {
                        var opChan = 'r';
                        var instance = meshes[m];

                        if (! instance.command && instance.drawToDepth && instance.material && instance.layer === pc.LAYER_WORLD) {
                            var mesh = instance.mesh;

                            var uColor = device.scope.resolve('uColor');
                            uColor.setValue(color.data);

                            renderer.modelMatrixId.setValue(instance.node.worldTransform.data);

                            var material = instance.material;
                            if (material.opacityMap) {
                                renderer.opacityMapId.setValue(material.opacityMap);
                                renderer.alphaTestId.setValue(material.alphaTest);
                                if (material.opacityMapChannel) opChan = material.opacityMapChannel;
                            }

                            if (instance.skinInstance) {
                                instance.skinInstance.updateMatrices();
                                instance.skinInstance.updateMatrixPalette();

                                renderer._skinDrawCalls++;
                                renderer.skinPosOffsetId.setValue(instance.skinInstance.rootNode.getPosition().data);
                                if (device.supportsBoneTextures) {
                                    var boneTexture = instance.skinInstance.boneTexture;
                                    renderer.boneTextureId.setValue(boneTexture);
                                    renderer.boneTextureSizeId.setValue([boneTexture.width, boneTexture.height]);
                                } else {
                                    renderer.poseMatrixId.setValue(instance.skinInstance.matrixPalette);
                                }
                                device.setShader(material.opacityMap ? shaderSkinOp[opChan] : shaderSkin);
                            } else {
                                device.setShader(material.opacityMap ? shaderStaticOp[opChan] : shaderStatic);
                            }

                            var style = instance.renderStyle;

                            device.setVertexBuffer(mesh.vertexBuffer, 0);
                            device.setIndexBuffer(mesh.indexBuffer[style]);
                            device.draw(mesh.primitive[style]);
                            renderer._depthDrawCalls++;
                        }
                    }
                }
            }

            // blur pass X
            camera.renderTarget = targets[1];
            renderer.setCamera(camera);
            var mesh = meshInstance.mesh;
            var uOffset = device.scope.resolve('uOffset');
            var uColorBuffer = device.scope.resolve('uColorBuffer');
            uOffset.setValue(1.0 / device.width / 2.0);
            uColorBuffer.setValue(textures[0]);
            device.setShader(shaderBlurH);
            device.setVertexBuffer(mesh.vertexBuffer, 0);
            device.setIndexBuffer(mesh.indexBuffer[0]);
            device.draw(mesh.primitive[0]);
            renderer._depthDrawCalls++;

            // blur pass Y
            camera.renderTarget = targets[0];
            renderer.setCamera(camera);
            var mesh = meshInstance.mesh;
            var uOffset = device.scope.resolve('uOffset');
            var uColorBuffer = device.scope.resolve('uColorBuffer');
            uOffset.setValue(1.0 / device.height / 2.0);
            uColorBuffer.setValue(textures[1]);
            device.setShader(shaderBlurV);
            device.setVertexBuffer(mesh.vertexBuffer, 0);
            device.setIndexBuffer(mesh.indexBuffer[0]);
            device.draw(mesh.primitive[0]);
            renderer._depthDrawCalls++;

            device.setBlending(oldBlending);
            cleared = false;
        } else {
            meshInstance.visible = false;
            cleared = true;
        }

        camera.renderTarget = oldTarget;
    });
});


/* editor/assets/assets-preview.js */
editor.once('load', function () {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var renderTargets = { };
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');

    var scene = new pc.Scene();
    scene.root = new pc.Entity();
    scene.root.name = 'root';
    scene.root._enabledInHierarchy = true;

    var queueSettings = false;
    var sceneSettings;

    var skyboxOnLoad = function(asset) {
        if (asset.resources) {
            scene.setSkybox(asset.resources);
            scene.skybox = null;
            editor.emit('preview:scene:changed');
        }
    };
    var skyboxAsset;

    editor.method('preview:skybox', function() {
        return skyboxAsset;
    });

    app._onSkyboxChangeOld = app._onSkyboxChange;
    app._onSkyboxChange = function(asset) {
        skyboxOnLoad(asset);
        app._onSkyboxChangeOld(asset);
    };

    app._skyboxLoadOld = app._skyboxLoad;
    app._skyboxLoad = function(asset) {
        app._skyboxLoadOld.call(this, asset);

        if (skyboxAsset)
            app.off('load:' + skyboxAsset.id, skyboxOnLoad);

        skyboxAsset = asset;
        app.on('load:' + skyboxAsset.id, skyboxOnLoad);

        skyboxOnLoad(asset);
    };

    app._skyboxRemoveOld = app._skyboxRemove;
    app._skyboxRemove = function(asset) {
        app._skyboxRemoveOld.call(this, asset);

        if (skyboxAsset && skyboxAsset.id === asset.id) {
            app.off('load:' + skyboxAsset.id, skyboxOnLoad);
            skyboxAsset = null;
            scene.setSkybox(null);
            editor.emit('preview:scene:changed');
        }
    };

    var applySettings = function() {
        queueSettings = false;
        var settings = sceneSettings.json();

        scene.ambientLight.set(settings.render.global_ambient[0], settings.render.global_ambient[1], settings.render.global_ambient[2]);
        scene.gammaCorrection = settings.render.gamma_correction;
        scene.toneMapping = settings.render.tonemapping;
        scene.exposure = settings.render.exposure;
        scene.skyboxIntensity = settings.render.skyboxIntensity === undefined ? 1 : settings.render.skyboxIntensity;

        editor.emit('preview:scene:changed');
    };

    var queueApplySettings = function() {
        if (queueSettings)
            return;

        queueSettings = true;
        requestAnimationFrame(applySettings);
    };

    editor.on('sceneSettings:load', function(settings) {
        sceneSettings = settings;
        sceneSettings.on('*:set', applySettings);
        queueApplySettings();
    });


    var nextPow2 = function(size) {
        return Math.pow(2, Math.ceil(Math.log(size) / Math.log(2)));
    };

    editor.method('preview:scene', function() {
        return scene;
    });

    editor.method('preview:getTexture', function(width, height) {
        var target = renderTargets[width + '-' + height];
        if (target) return target;

        var texture = new pc.Texture(app.graphicsDevice, {
            width: width,
            height: height,
            format: pc.PIXELFORMAT_R8_G8_B8_A8
        });

        target = new pc.RenderTarget(app.graphicsDevice, texture);
        renderTargets[width + '-' + height] = target;

        target.buffer = new ArrayBuffer(width * height * 4);
        target.pixels = new Uint8Array(target.buffer);
        target.pixelsClamped = new Uint8ClampedArray(target.buffer);

        return target;
    });

    editor.method('preview:render', function(asset, width, height, args, blob) {
        var gl = app.graphicsDevice.gl;

        // choose closest POT resolution
        width = nextPow2(width || 128);
        height = nextPow2(height || width);

        // get render target
        var target = editor.call('preview:getTexture', width, height);

        // render
        editor.call('preview:' + asset.get('type') + ':render', asset, target, args);

        canvas.width = width;
        canvas.height = height;

        // read pixels from texture
        gl.bindFramebuffer(gl.FRAMEBUFFER, target._glFrameBuffer);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, target.pixels);

        // mage image data
        var imageData = new ImageData(target.pixelsClamped, width, height);

        if (blob) {
            // upload to canvas
            ctx.putImageData(imageData, 0, 0);
            return canvas.toDataURL();
        } else {
            return imageData;
        }
    });
});


/* editor/assets/assets-preview-material.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var device = app.graphicsDevice;
    var renderer = app.renderer;
    var scene = editor.call('preview:scene');

    var pitch = 0;
    var yaw = 0;


    // material
    var material = new pc.StandardMaterial();
    material._scene = scene;

    var mapping = editor.call('assets:material:mapping');
    var mappingShading = {
        'phong': 0,
        'blinn': 1
    };
    var cubemapPrefiltered = [
        'prefilteredCubeMap128',
        'prefilteredCubeMap64',
        'prefilteredCubeMap32',
        'prefilteredCubeMap16',
        'prefilteredCubeMap8',
        'prefilteredCubeMap4'
    ];

    // sphere
    var sphereNode = new pc.GraphNode();

    var currentModel = 'sphere';

    var meshBox = pc.createBox(device, {
        halfExtents: new pc.Vec3(0.3, 0.3, 0.3)
    });
    var meshSphere = pc.createSphere(device, {
        radius: 0.5,
        latitudeBands: 64,
        longitudeBands: 64
    });

    var model = new pc.Model();
    model.node = sphereNode;
    model.meshInstances = [ new pc.MeshInstance(sphereNode, meshSphere, material ) ];


    // light
    var lightNode = new pc.GraphNode();
    lightNode.setLocalEulerAngles(45, 45, 0);

    var light = new pc.Light();
    light.enabled = true;
    light.type = pc.LIGHTTYPE_DIRECTIONAL;
    light._node = lightNode;


    // camera
    var cameraOrigin = new pc.GraphNode();

    var cameraNode = new pc.GraphNode();
    cameraNode.setLocalPosition(0, 0, 1.35);
    cameraOrigin.addChild(cameraNode);

    var camera = new pc.Camera();
    camera._node = cameraNode;
    camera.nearClip = 0.1;
    camera.farClip = 32;
    camera.clearColor = [ 41 / 255, 53 / 255, 56 / 255, 0.0 ];
    camera.frustumCulling = false;


    editor.method('preview:material:render', function(asset, target, args) {
        args = args || { };

        camera.aspectRatio = target.height / target.width;
        camera.renderTarget = target;

        var data = asset.get('data');
        if (! data) return;

        scene.addModel(model);
        scene.addLight(light);

        setModel(args.model || 'sphere');
        pitch = args.hasOwnProperty('rotation') ? args.rotation[0] : 0;
        yaw = args.hasOwnProperty('rotation') ? args.rotation[1] : 0;

        cameraOrigin.setLocalEulerAngles(pitch, yaw, 0);
        cameraOrigin.syncHierarchy();

        light.intensity = 1.0 / (Math.min(1.0, scene.exposure) || 0.01);

        // update material
        for(var key in mapping) {
            var value = data.hasOwnProperty(key) ? data[key] : mapping[key].default;

            if (args.params && args.params.hasOwnProperty(key))
                value = args.params[key];

            switch(mapping[key].type) {
                case 'boolean':
                case 'string':
                case 'int':
                case 'float':
                case 'number':
                    material[key] = value;
                    break;
                case 'vec2':
                    material[key].set(value[0], value[1]);
                    break;
                case 'rgb':
                case 'vec3':
                    material[key].set(value[0], value[1], value[2]);
                    break;
                case 'cubemap':
                    if (value) {
                        // TODO
                        // handle async
                        var textureAsset = app.assets.get(value);
                        if (textureAsset) {
                            if (textureAsset.resource) {
                                material[key] = textureAsset.resource;
                            } else {
                                material[key] = null;
                            }

                            if (textureAsset.file && textureAsset.resources && textureAsset.resources.length === 7) {
                                for(var i = 0; i < 6; i++)
                                    material[cubemapPrefiltered[i]] = textureAsset.resources[i + 1];
                            } else {
                                for(var i = 0; i < 6; i++)
                                    material[cubemapPrefiltered[i]] = null;
                            }

                            textureAsset.loadFaces = true;
                            app.assets.load(textureAsset);
                        } else {
                            material[key] = null;
                            for(var i = 0; i < 6; i++)
                                material[cubemapPrefiltered[i]] = null;
                        }
                    } else {
                        material[key] = null;
                        for(var i = 0; i < 6; i++)
                            material[cubemapPrefiltered[i]] = null;
                    }
                    break;
                case 'texture':
                    if (value) {
                        // TODO
                        // handle async
                        var textureAsset = app.assets.get(value);
                        if (textureAsset) {
                            if (textureAsset.resource) {
                                material[key] = textureAsset.resource;
                            } else {
                                app.assets.load(textureAsset);
                                material[key] = null;
                            }
                        } else {
                            material[key] = null;
                        }
                    } else {
                        material[key] = null;
                    }
                    break;
                case 'object':
                    switch(key) {
                        case 'cubeMapProjectionBox':
                            if (value) {
                                if (material.cubeMapProjectionBox) {
                                    material.cubeMapProjectionBox.center.set(0, 0, 0);
                                    material.cubeMapProjectionBox.halfExtents.set(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]);
                                } else {
                                    material.cubeMapProjectionBox = new pc.BoundingBox(new pc.Vec3(0, 0, 0), new pc.Vec3(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]));
                                }
                            } else {
                                material.cubeMapProjectionBox = null;
                            }
                            break;
                    }
                    break;
            }
        }

        material.shadingModel = mappingShading[data.shader];

        material.update();

        renderer.render(scene, camera);

        scene.removeModel(model);
        scene.removeLight(light);
    });

    var setModel = function(value) {
        if (currentModel === value)
            return;

        if (value === 'box') {
            currentModel = 'box';
            model.meshInstances[0].mesh = meshBox;
        } else {
            currentModel = 'sphere';
            model.meshInstances[0].mesh = meshSphere;
        }
    };
});


/* editor/assets/assets-preview-material-watch.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var watching = { };
    var slots = [ 'aoMap', 'diffuseMap', 'emissiveMap', 'glossMap', 'lightMap', 'metalnessMap', 'opacityMap', 'specularMap', 'normalMap', 'cubeMap', 'sphereMap' ];

    var addTextureWatch = function(watch, slot, id) {
        watch.textures[slot] = {
            id: id,
            fn: function() {
                trigger(watch, slot);
            }
        };
        app.assets.on('load:' + id, watch.textures[slot].fn);

        var asset = app.assets.get(id);
        if (asset) asset.on('change', watch.textures[slot].fn);

        if (watch.autoLoad) {
            var asset = app.assets.get(id);
            if (asset && ! asset.resource)
                app.assets.load(asset);
        }
    };

    var removeTextureWatch = function(watch, slot) {
        if (! watch.textures[slot])
            return;

        app.assets.off('load:' + watch.textures[slot].id, watch.textures[slot].fn);

        var asset = app.assets.get(watch.textures[slot].id);
        if (asset) asset.off('change', watch.textures[slot].fn);

        delete watch.textures[slot];
    };

    var addSlotWatch = function(watch, slot) {
        watch.watching[slot] = watch.asset.on('data.' + slot + ':set', function(value) {
            if (watch.textures[slot]) {
                if (value !== watch.textures[slot].id) {
                    removeTextureWatch(watch, slot);
                    if (value) addTextureWatch(watch, slot, value);
                }
            } else if (value) {
                addTextureWatch(watch, slot, value);
            }
        });
    };

    var subscribe = function(watch) {
        for(var i = 0; i < slots.length; i++) {
            var textureId = watch.asset.get('data.' + slots[i]);
            if (textureId)
                addTextureWatch(watch, slots[i], textureId);
        }

        watch.watching.data = watch.asset.on('*:set', function(path) {
            if (! path.startsWith('data.'))
                return;

            trigger(watch, null);
        });

        watch.watching.all = watch.asset.on('data:set', function(value) {
            if (value) {
                for(var i = 0; i < slots.length; i++) {
                    var id = value[slots[i]];
                    if (watch.textures[slots[i]]) {
                        if (id !== watch.textures[slots[i]].id) {
                            removeTextureWatch(watch, slots[i]);
                            if (id) addTextureWatch(watch, slots[i], id);
                        }
                    } else if (id) {
                        addTextureWatch(watch, slots[i], id);
                    }
                }
            } else {
                for(var i = 0; i < slots.length; i++) {
                    if (watch.textures[slots[i]])
                        removeTextureWatch(watch, slots[i]);
                }
            }
        });

        for(var i = 0; i < slots.length; i++)
            addSlotWatch(watch, slots[i]);
    };

    var unsubscribe = function(watch) {
        for(var key in watch.textures)
            removeTextureWatch(watch, key);

        for(var key in watch.watching)
            watch.watching[key].unbind();
    };

    var trigger = function(watch, slot) {
        for(var key in watch.callbacks)
            watch.callbacks[key].callback(slot);
    };


    editor.method('assets:material:watch', function(args) {
        var watch = watching[args.asset.get('id')];

        if (! watch) {
            watch = watching[args.asset.get('id')] = {
                asset: args.asset,
                autoLoad: 0,
                textures: { },
                watching: { },
                ind: 0,
                callbacks: { }
            };
            subscribe(watch);
        }

        var item = watch.callbacks[++watch.ind] = {
            autoLoad: args.autoLoad,
            callback: args.callback
        };

        if (args.autoLoad)
            watch.autoLoad++;

        if (watch.autoLoad === 1) {
            for(var key in watch.textures) {
                var asset = app.assets.get(watch.textures[key].id);
                if (asset && ! asset.resource)
                    app.assets.load(asset);
            }
        }

        return watch.ind;
    });


    editor.method('assets:material:unwatch', function(asset, handle) {
        var watch = watching[asset.get('id')];
        if (! watch) return;

        if (! watch.hasOwnProperty(handle))
            return;

        if (watch.callbacks[handle].autoLoad)
            watch.autoLoad--;

        delete watch.callbacks[handle];

        if (Object.keys(watch.callbacks).length === 0) {
            unsubscribe(watch);
            delete watching[asset.get('id')];
        }
    });
});


/* editor/assets/assets-preview-model.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var device = app.graphicsDevice;
    var renderer = app.renderer;
    var scene = editor.call('preview:scene');

    var pitch = -15;
    var yaw = 45;


    // material
    var material = new pc.StandardMaterial();
    material.useSkybox = false;
    material._scene = scene;

    var aabb = new pc.BoundingBox();

    // model
    var modelNode = new pc.GraphNode();

    var meshSphere = pc.createSphere(device, {
        radius: 0,
        latitudeBands: 2,
        longitudeBands: 2
    });

    var modelPlaceholder = new pc.Model();
    modelPlaceholder.node = modelNode;
    modelPlaceholder.meshInstances = [ new pc.MeshInstance(modelNode, meshSphere, material) ];


    // light
    var lightNode = new pc.GraphNode();
    lightNode.setLocalEulerAngles(45, 135, 0);

    var light = new pc.Light();
    light.enabled = true;
    light.type = pc.LIGHTTYPE_DIRECTIONAL;
    light._node = lightNode;


    // camera
    var cameraOrigin = new pc.GraphNode();

    var cameraNode = new pc.GraphNode();
    cameraNode.setLocalPosition(0, 0, 1.35);
    cameraOrigin.addChild(cameraNode);

    var camera = new pc.Camera();
    camera._node = cameraNode;
    camera.nearClip = 0.01;
    camera.farClip = 32;
    camera.clearColor = [ 41 / 255, 53 / 255, 56 / 255, 0.0 ];
    camera.frustumCulling = false;


    editor.method('preview:model:render', function(asset, target, args) {
        args = args || { };

        camera.aspectRatio = target.height / target.width;
        camera.renderTarget = target;

        var data = asset.get('data');
        if (! data) return;

        var modelAsset = app.assets.get(asset.get('id'));
        if (! modelAsset) return;

        var model = modelPlaceholder;

        if (modelAsset._editorPreviewModel)
            model = modelAsset._editorPreviewModel.clone();

        model.lights = [ light ];

        var first = true;

        var i;

        // initialize any skin instances
        for (i = 0; i < model.skinInstances.length; i++) {
            model.skinInstances[i].updateMatrices();
        }

        // generate aabb for model
        for(i = 0; i < model.meshInstances.length; i++) {
            model.meshInstances[i].material = material;

            if (first) {
                first = false;
                aabb.copy(model.meshInstances[i].aabb);
            } else {
                aabb.add(model.meshInstances[i].aabb);
            }
        }

        if (first) {
            aabb.center.set(0, 0, 0);
            aabb.halfExtents.set(0.1, 0.1, 0.1);
        }

        material.update();

        scene.addModel(model);

        pitch = args.hasOwnProperty('rotation') ? args.rotation[0] : -15;
        yaw = args.hasOwnProperty('rotation') ? args.rotation[1] : 45;

        var max = aabb.halfExtents.length();
        cameraNode.setLocalPosition(0, 0, max * 2.5);

        cameraOrigin.setLocalPosition(aabb.center);
        cameraOrigin.setLocalEulerAngles(pitch, yaw, 0);
        cameraOrigin.syncHierarchy();

        lightNode.setLocalRotation(cameraOrigin.getLocalRotation());
        lightNode.rotateLocal(90, 0, 0);

        camera.farClip = max * 5.0;

        light.intensity = 1.0 / (Math.min(1.0, scene.exposure) || 0.01);

        renderer.render(scene, camera);

        scene.removeModel(model);

        if (model !== modelPlaceholder)
            model.destroy();
    });
});


/* editor/assets/assets-preview-model-watch.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var watching = { };

    var subscribe = function(watch) {
        var onChange = function() {
            loadModel(watch, watch.engineAsset, true);
        };

        watch.watching.file = watch.asset.on('file.hash:set', function() {
            setTimeout(onChange, 0);
        });

        watch.watching.fileUnset = watch.asset.on('file.hash:unset', function() {
            setTimeout(onChange, 0);
        });

        watch.onAdd = function(asset) {
            app.assets.off('add:' + watch.asset.get('id'), watch.onAdd);
            watch.engineAsset = asset;
            watch.onAdd = null;

            if (watch.autoLoad) loadModel(watch, asset);
        };

        var asset = app.assets.get(watch.asset.get('id'));
        if (asset) {
            watch.onAdd(asset);
        } else {
            app.assets.once('add:' + watch.asset.get('id'), watch.onAdd);
        }
    };

    var unsubscribe = function(watch) {
        if (watch.engineAsset)
            watch.engineAsset.off('load', watch.onLoad);

        if (watch.onAdd)
            app.assets.off('add:' + watch.asset.get('id'), watch.onAdd);

        for(var key in watch.watching)
            watch.watching[key].unbind();
    };

    var loadModel = function(watch, asset, reload) {
        var url;
        var file = watch.asset.get('file');

        if (file && file.url) {
            url = file.url;

            if (app.assets.prefix && ! pc.ABSOLUTE_URL.test(url))
                url = app.assets.prefix + url;

            var separator = url.indexOf('?') !== -1 ? '&' : '?';
            url += separator + 't=' + file.hash;
        }

        if (url && (reload || ! asset._editorPreviewModel)) {
            app.assets._loader.load(url, asset.type, function(err, resource, extra) {
                asset._editorPreviewModel = resource;
                trigger(watch);
            });
        } else if (! url && asset._editorPreviewModel) {
            asset._editorPreviewModel = null;
            trigger(watch);
        }
    };

    var trigger = function(watch) {
        for(var key in watch.callbacks)
            watch.callbacks[key].callback();
    };


    editor.method('assets:model:watch', function(args) {
        var watch = watching[args.asset.get('id')];

        if (! watch) {
            watch = watching[args.asset.get('id')] = {
                asset: args.asset,
                engineAsset: null,
                autoLoad: 0,
                onLoad: null,
                onAdd: null,
                watching: { },
                ind: 0,
                callbacks: { }
            };
            subscribe(watch);
        }

        var item = watch.callbacks[++watch.ind] = {
            autoLoad: args.autoLoad,
            callback: args.callback
        };

        if (args.autoLoad)
            watch.autoLoad++;

        if (watch.autoLoad === 1) {
            var asset = app.assets.get(watch.asset.get('id'));
            if (asset) {
                watch.engineAsset = asset;
                loadModel(watch, asset);
            }
        }

        return watch.ind;
    });


    editor.method('assets:model:unwatch', function(asset, handle) {
        var watch = watching[asset.get('id')];
        if (! watch) return;

        if (! watch.callbacks.hasOwnProperty(handle))
            return;

        if (watch.callbacks[handle].autoLoad)
            watch.autoLoad--;

        delete watch.callbacks[handle];

        if (Object.keys(watch.callbacks).length === 0) {
            unsubscribe(watch);
            delete watching[asset.get('id')];
        }
    });
});


/* editor/assets/assets-preview-cubemap.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var device = app.graphicsDevice;
    var renderer = app.renderer;
    var scene = editor.call('preview:scene');

    var pitch = 0;
    var yaw = 0;

    var skyboxCurrent = null;

    var cubemapPrefiltered = [
        'prefilteredCubeMap128',
        'prefilteredCubeMap64',
        'prefilteredCubeMap32',
        'prefilteredCubeMap16',
        'prefilteredCubeMap8',
        'prefilteredCubeMap4'
    ];


    // camera
    var cameraNode = new pc.GraphNode();
    cameraNode.setLocalPosition(0, 0, 0);

    var camera = new pc.Camera();
    camera._node = cameraNode;
    camera.nearClip = 1;
    camera.farClip = 32;
    camera.clearColor = [ 0, 0, 0, 1 ];
    camera.fov = 75;
    camera.frustumCulling = false;


    editor.method('preview:cubemap:render', function(asset, target, args) {
        args = args || { };

        camera.aspectRatio = target.height / target.width;
        camera.renderTarget = target;

        pitch = args.hasOwnProperty('rotation') ? args.rotation[0] : 0;
        yaw = args.hasOwnProperty('rotation') ? args.rotation[1] : 0;

        cameraNode.setLocalEulerAngles(pitch, yaw, 0);

        var skyboxCurrent = editor.call('preview:skybox');
        var engineAsset = app.assets.get(asset.get('id'));

        if (engineAsset && engineAsset.resources) {
            scene.setSkybox(engineAsset.resources);

            if (engineAsset.file) {
                scene.skyboxMip = args.hasOwnProperty('mipLevel') ? args.mipLevel : 0;
            } else {
                scene.skyboxMip = 0;
            }
        } else {
            scene.setSkybox(null);
        }

        renderer.render(scene, camera);

        if (skyboxCurrent) {
            scene.setSkybox(skyboxCurrent.resources);
            scene.skybox = null;
            scene.skyboxMip = 0;
        } else {
            scene.setSkybox(null);
        }
    });
});


/* editor/assets/assets-preview-cubemap-watch.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available
    var watching = { };


    var addTextureWatch = function(watch, slot, id) {
        watch.textures[slot] = {
            id: id,
            fn: function() {
                trigger(watch, slot);
            }
        };
        app.assets.on('load:' + id, watch.textures[slot].fn);

        var asset = app.assets.get(id);
        if (asset) asset.on('change', watch.textures[slot].fn);

        var obj = editor.call('assets:get', id);
        if (obj) obj.on('thumbnails.s:set', watch.textures[slot].fn);

        if (watch.autoLoad) {
            var asset = app.assets.get(id);
            if (asset && ! asset.resource)
                app.assets.load(asset);

            var asset = app.assets.get(watch.asset.get('id'));
            if (asset && (! asset.resource || ! asset.loadFaces)) {
                asset.loadFaces = true;
                app.assets.load(asset);
            }
        }
    };

    var removeTextureWatch = function(watch, slot) {
        if (! watch.textures[slot])
            return;

        var id = watch.textures[slot].id;

        app.assets.off('load:' + id, watch.textures[slot].fn);

        var asset = app.assets.get(id);
        if (asset) asset.off('change', watch.textures[slot].fn);

        var obj = editor.call('assets:get', id);
        if (obj) obj.unbind('thumbnails.s:set', watch.textures[slot].fn);

        delete watch.textures[slot];
    };

    var addSlotWatch = function(watch, slot) {
        watch.watching[slot] = watch.asset.on('data.textures.' + slot + ':set', function(value) {
            if (watch.textures[slot]) {
                if (value !== watch.textures[slot].id) {
                    removeTextureWatch(watch, slot);
                    if (value) addTextureWatch(watch, slot, value);
                }
            } else if (value) {
                addTextureWatch(watch, slot, value);
            }
        });
    };

    var subscribe = function(watch) {
        for(var i = 0; i < 6; i++) {
            var textureId = watch.asset.get('data.textures.' + i);
            if (textureId)
                addTextureWatch(watch, i, textureId);
        }

        watch.watching.all = watch.asset.on('data.textures:set', function(value) {
            if (value) {
                for(var i = 0; i < 6; i++) {
                    var id = value[i];
                    if (watch.textures[i]) {
                        if (id !== watch.textures[i].id) {
                            removeTextureWatch(watch, i);
                            if (id) addTextureWatch(watch, i, id);
                        }
                    } else if (id) {
                        addTextureWatch(watch, i, id);
                    }
                }
            } else {
                for(var i = 0; i < 6; i++) {
                    if (watch.textures[i])
                        removeTextureWatch(watch, i);
                }
            }
        });

        for(var i = 0; i < 6; i++)
            addSlotWatch(watch, i);

        watch.onAdd = function(asset) {
            if (! watch.autoLoad)
                return;

            asset.loadFaces = true;
            app.assets.load(asset);
        };

        watch.onLoad = function(asset) {
            trigger(watch);
        };

        app.assets.on('add:' + watch.asset.get('id'), watch.onAdd);
        app.assets.on('load:' + watch.asset.get('id'), watch.onLoad);
    };

    var unsubscribe = function(watch) {
        for(var key in watch.textures)
            removeTextureWatch(watch, key);

        for(var key in watch.watching)
            watch.watching[key].unbind();

        app.assets.off('add:' + watch.asset.get('id'), watch.onAdd);
        app.assets.off('load:' + watch.asset.get('id'), watch.onLoad);
    };

    var trigger = function(watch, slot) {
        for(var key in watch.callbacks)
            watch.callbacks[key].callback(slot);
    };


    editor.method('assets:cubemap:watch', function(args) {
        var watch = watching[args.asset.get('id')];

        if (! watch) {
            watch = watching[args.asset.get('id')] = {
                asset: args.asset,
                autoLoad: 0,
                textures: { },
                watching: { },
                ind: 0,
                callbacks: { },
                onLoad: null,
                onAdd: null
            };
            subscribe(watch);
        }

        var item = watch.callbacks[++watch.ind] = {
            autoLoad: args.autoLoad,
            callback: args.callback
        };

        if (args.autoLoad)
            watch.autoLoad++;

        if (watch.autoLoad === 1) {
            var asset = app.assets.get(watch.asset.get('id'));
            if (asset && (! asset.loadFaces || ! asset.resource)) {
                asset.loadFaces = true;
                app.assets.load(asset);
            }
        }

        return watch.ind;
    });


    editor.method('assets:cubemap:unwatch', function(asset, handle) {
        var watch = watching[asset.get('id')];
        if (! watch) return;

        if (! watch.hasOwnProperty(handle))
            return;

        if (watch.callbacks[handle].autoLoad)
            watch.autoLoad--;

        delete watch.callbacks[handle];

        if (Object.keys(watch.callbacks).length === 0) {
            unsubscribe(watch);
            delete watching[asset.get('id')];
        }
    });
});


/* editor/assets/assets-preview-font.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available

    var device = app.graphicsDevice;
    var renderer = app.renderer;
    var scene = editor.call('preview:scene');

    // camera
    var cameraNode = new pc.GraphNode();
    cameraNode.setLocalPosition(0, 0, 1);

    var camera = new pc.Camera();
    camera._node = cameraNode;
    camera.nearClip = 1;
    camera.farClip = 32;
    camera.clearColor = [ 0, 0, 0, 0 ];
    camera.fov = 75;
    camera.frustumCulling = false;

    var defaultScreenSpaceTextMaterial = new pc.StandardMaterial();
    defaultScreenSpaceTextMaterial.useLighting = false;
    defaultScreenSpaceTextMaterial.useGammaTonemap = false;
    defaultScreenSpaceTextMaterial.useFog = false;
    defaultScreenSpaceTextMaterial.useSkybox = false;
    defaultScreenSpaceTextMaterial.emissive = new pc.Color(1,1,1,1);
    defaultScreenSpaceTextMaterial.opacity = 1;
    defaultScreenSpaceTextMaterial.blendType = pc.BLEND_PREMULTIPLIED;
    defaultScreenSpaceTextMaterial.depthWrite = false;
    defaultScreenSpaceTextMaterial.depthTest = false;
    defaultScreenSpaceTextMaterial.cull = pc.CULLFACE_NONE;
    defaultScreenSpaceTextMaterial.update();

    var positions = [];
    var normals = [];
    var uvs = [];
    var indices = [];

    // creates text mesh
    var createMesh = function (length) {
        positions.length = 0;
        normals.length = 0;
        uvs.length = 0;
        indices.length = 0;

        for (var i = 0; i < length; i++) {
            positions.push(0,0,0);
            positions.push(0,0,0);
            positions.push(0,0,0);
            positions.push(0,0,0);

            normals.push(0, 0, -1);
            normals.push(0, 0, -1);
            normals.push(0, 0, -1);
            normals.push(0, 0, -1);

            uvs.push(0, 1);
            uvs.push(1, 0);
            uvs.push(1, 1);
            uvs.push(0, 1);

            indices.push(i*4, i*4 + 1, i*4 + 3);
            indices.push(i*4 + 1, i*4 + 3, i*4 + 2);
        }

        return pc.createMesh(device, positions, {normals: normals, uvs: uvs, indices: indices});
    };

    // updates mesh positions and uvs based on the font and the text specified
    var updateMesh = function (text, font) {
        var vb = mesh.vertexBuffer;
        var it = new pc.VertexIterator(vb);

        var length = text.length;
        var maxScale = -1;
        var width = 1;
        var height = 1;
        var maxWidth = 0;
        var maxYOffset = 0;

        for (var i = 0; i < length; i++) {
            var char = text.charCodeAt(i);

            var charData = font.data.chars[char];
            if (! charData)
                return false;

            // find max character scale
            // so that we scale all smaller characters based on that value
            maxScale = Math.max(maxScale, 1 / (charData.scale || 1));

            // find max yoffset so that we line up characters a bit better in the preview
            maxYOffset = Math.max(maxYOffset, charData.yoffset / charData.height || 0);
        }

        positions.length = 0;
        uvs.length = 0;

        for (var i = 0; i < length; i++) {
            var char = text.charCodeAt(i);

            var charData = font.data.chars[char];
            if (! charData)
                return false;

            // scale of character relative to max scale
            var scale = 1 / (charData.scale || 1);
            scale = scale / maxScale;

            // yoffset of character relative to maxYOffset
            var yoffset = maxYOffset - (charData.yoffset / charData.height || 0) - height / 2;

            // calculate position for character
            positions.push(maxWidth, yoffset, 0);
            positions.push(maxWidth + scale*width, yoffset, 0);
            positions.push(maxWidth + scale*width, yoffset + height*scale, 0);
            positions.push(maxWidth, yoffset + height*scale, 0);

            // remember maxWidth
            maxWidth += scale*width;

            // calculate uvs
            var x1 = charData.x / font.data.info.width;
            var y1 = 1 - (charData.y + charData.height) / font.data.info.height;
            var x2 = (charData.x + charData.width) / font.data.info.width;
            var y2 = 1 - charData.y / font.data.info.height;

            uvs.push(x1, y1);
            uvs.push(x2, y1);
            uvs.push(x2, y2);
            uvs.push(x1, y2);
        }

        // offset positions to be centered vertically
        var offset = -maxWidth / 2;
        for (var i = 0; i < positions.length; i+=3) {
            positions[i] += offset;
        }

        // update vertices
        var numVertices = length * 4;
        for (var i = 0; i < numVertices; i++) {
            it.element[pc.SEMANTIC_POSITION].set(positions[i*3+0], positions[i*3+1], positions[i*3+2]);
            it.element[pc.SEMANTIC_TEXCOORD0].set(uvs[i*2+0], uvs[i*2+1]);

            it.next();
        }
        it.end();

        return true;

    };

    var hasChars = function (chars, font) {
        for (var i = 0; i < chars.length; i++)
            if (! font.data.chars[chars.charCodeAt(i)])
                return false;

        return true;
    };

    // create the mesh and a model and add them to the scene
    var mesh = createMesh(2);
    var node = new pc.GraphNode();
    var model = new pc.Model();
    var meshInstance = new pc.MeshInstance(node, mesh, defaultScreenSpaceTextMaterial);
    meshInstance.screenSpace = true;
    model.meshInstances.push(meshInstance);


    editor.method('preview:font:render', function(asset, target, args) {
        args = args || { };

        camera.aspectRatio = target.height / target.width;
        camera.renderTarget = target;

        var engineAsset = app.assets.get(asset.get('id'));

        // skip if the font isn't ready
        if (! engineAsset || ! engineAsset.resource || ! engineAsset.resource.texture || ! engineAsset.resource.data || ! engineAsset.resource.data.chars) {
            renderer.render(scene, camera);
            return;
        }

        // set the font texture
        defaultScreenSpaceTextMaterial.msdfMap = engineAsset.resource.texture;
        defaultScreenSpaceTextMaterial.setParameter('font_sdfIntensity', asset.get('data.intensity'));
        defaultScreenSpaceTextMaterial.update();

        // try to use Aa as the text in different languages
        // and if that is not found try the first two characters of the font

        // latin
        if (hasChars('Aa', engineAsset.resource)) {
            var text = 'Aa';
        }
        // greek
        else if (hasChars('', engineAsset.resource)) {
            var text = '';
        }
        // cyrillic
        else if (hasChars('', engineAsset.resource)) {
            var text = '';
        }
        // rest
        else {
            var text = '';
            var chars = asset.get('meta.chars');
            for (var i = 0, len = chars.length; i < len && text.length < 2; i++) {
                if (/\s/.test(chars[i])) continue;
                text += chars[i];
            }
        }

        scene.addModel(model);

        updateMesh(text, engineAsset.resource);

        renderer.render(scene, camera);

        scene.removeModel(model);

    });
});


/* editor/assets/assets-preview-font-watch.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:app');
    if (! app) return; // webgl not available
    var watching = { };

    var subscribe = function(watch) {
        // watch.watching.change = watch.asset.on('file.hash:set', function() {
        //     setTimeout(onChange, 0);
        // });

        // watch.watching.fileUnset = watch.asset.on('file.hash:unset', function() {
        //     setTimeout(onChange, 0);
        // });

        watch.onAdd = function(asset) {
            app.assets.off('add:' + watch.asset.get('id'), watch.onAdd);
            watch.onAdd = null;
            watch.engineAsset = asset;
            watch.engineAsset.off('load', watch.onLoad);
            watch.engineAsset.on('load', watch.onLoad);
            watch.engineAsset.off('change', onFontChange);
            watch.engineAsset.on('change', onFontChange);
            if (watch.autoLoad) loadFont(watch, asset);
        };

        watch.onLoad = function (asset) {
            trigger(watch);
        };

        var asset = app.assets.get(watch.asset.get('id'));
        if (asset) {
            watch.onAdd(asset);

        } else {
            app.assets.once('add:' + watch.asset.get('id'), watch.onAdd);
        }


    };

    var unsubscribe = function(watch) {
        if (watch.engineAsset) {
            watch.engineAsset.off('load', watch.onLoad);
            watch.engineAsset.off('change', onFontChange);
        }

        if (watch.onAdd)
            app.assets.off('add:' + watch.asset.get('id'), watch.onAdd);

        for(var key in watch.watching)
            watch.watching[key].unbind();


    };

    var loadFont = function(watch, asset, reload) {
        if (reload && asset) {
            asset.unload();
        }

        asset.ready(function () {
            trigger(watch);
        });
        app.assets.load(asset);
    };

    var onFontChange = function (asset, name, value) {
        if (name === 'data') {
            editor.emit('preview:scene:changed');
        }
    }
    var trigger = function(watch) {
        for(var key in watch.callbacks)
            watch.callbacks[key].callback();
    };


    editor.method('assets:font:watch', function(args) {
        var watch = watching[args.asset.get('id')];

        if (! watch) {
            watch = watching[args.asset.get('id')] = {
                asset: args.asset,
                engineAsset: null,
                autoLoad: 0,
                onLoad: null,
                onAdd: null,
                watching: { },
                ind: 0,
                callbacks: { }
            };
            subscribe(watch);
        }

        var item = watch.callbacks[++watch.ind] = {
            autoLoad: args.autoLoad,
            callback: args.callback
        };

        if (args.autoLoad)
            watch.autoLoad++;

        if (watch.autoLoad === 1) {
            var asset = app.assets.get(watch.asset.get('id'));
            if (asset) {
                watch.engineAsset = asset;
                loadFont(watch, asset);
            }
        }

        return watch.ind;
    });


    editor.method('assets:font:unwatch', function(asset, handle) {
        var watch = watching[asset.get('id')];
        if (! watch) return;

        if (! watch.callbacks.hasOwnProperty(handle))
            return;

        if (watch.callbacks[handle].autoLoad)
            watch.autoLoad--;

        delete watch.callbacks[handle];

        if (Object.keys(watch.callbacks).length === 0) {
            unsubscribe(watch);
            delete watching[asset.get('id')];
        }
    });
});


/* editor/viewport/viewport-preview-particles.js */
editor.once('load', function() {
    'use strict';

    var index = { };
    var render = 0;


    editor.on('viewport:update', function() {
        if (render !== 0) editor.call('viewport:render');
    });

    var checkState = function(item, remove) {
        if (remove || ! item.entity.entity || ! item.entity.entity.particlesystem) {
            if (item.active) {
                render--;
                item.active = false;

                if (item.entity.entity && item.entity.entity.particlesystem)
                    item.entity.entity.particlesystem.enabled = false;
            }
            return;
        }

        if (! remove && item.entity.get('components.particlesystem.enabled')) {
            if (! item.active) {
                render++;
                item.active = true;

                item.entity.entity.particlesystem.enabled = true;

                editor.call('viewport:render');
            }
        } else if (item.active) {
            render--;
            item.active = false;
            item.entity.entity.particlesystem.enabled = false;
        }
    };

    var add = function(entity) {
        var id = entity.get('resource_id');

        if (index[id])
            return;

        var onCheckState = function() {
            checkState(item);
        };

        var item = index[id] = {
            id: id,
            entity: entity,
            active: false,
            evtEnable: entity.on('components.particlesystem.enabled:set', function() {
                setTimeout(onCheckState, 0);
            }),
            evtSet: entity.on('components.particlesystem:set', onCheckState),
            evtUnset: entity.on('components.particlesystem:unset', onCheckState)
        };

        checkState(item);
    };

    var remove = function(item) {
        checkState(item, true);

        item.evtEnable.unbind();
        item.evtSet.unbind();
        item.evtUnset.unbind();

        delete index[item.id];
    };

    var clear = function() {
        var keys = Object.keys(index);

        for(var i = 0; i < keys.length; i++)
            remove(index[keys[i]]);
    };


    editor.on('selector:change', function(type, items) {
        clear();

        if (type !== 'entity')
            return;

        for(var i = 0; i < items.length; i++)
            add(items[i]);
    });
});


/* editor/viewport/viewport-preview-animation.js */
editor.once('load', function() {
    'use strict';

    var index = { };
    var render = 0;


    editor.on('viewport:update', function() {
        if (render !== 0) editor.call('viewport:render');
    });

    var checkState = function(item, remove) {
        if (remove || ! item.entity.entity || ! item.entity.entity.animation) {
            if (item.active) {
                render--;
                item.active = false;

                if (item.entity.entity && item.entity.entity.animation)
                    item.entity.entity.animation.enabled = false;
            }
            return;
        }

        if (! remove && item.entity.get('components.animation.enabled')) {
            if (! item.active) {
                render++;
                item.active = true;

                item.entity.entity.animation.enabled = true;

                editor.call('viewport:render');
            }
        } else if (item.active) {
            render--;
            item.active = false;
            item.entity.entity.animation.enabled = false;
        }
    };

    var add = function(entity) {
        var id = entity.get('resource_id');

        if (index[id])
            return;

        var onCheckState = function() {
            checkState(item);
        };

        var item = index[id] = {
            id: id,
            entity: entity,
            active: false,
            evtEnable: entity.on('components.animation.enabled:set', function() {
                setTimeout(onCheckState, 0);
            }),
            evtSet: entity.on('components.animation:set', onCheckState),
            evtUnset: entity.on('components.animation:unset', onCheckState)
        };

        checkState(item);
    };

    var remove = function(item) {
        checkState(item, true);

        item.evtEnable.unbind();
        item.evtSet.unbind();
        item.evtUnset.unbind();

        delete index[item.id];
    };

    var clear = function() {
        var keys = Object.keys(index);

        for(var i = 0; i < keys.length; i++)
            remove(index[keys[i]]);
    };


    editor.on('selector:change', function(type, items) {
        clear();

        if (type !== 'entity')
            return;

        for(var i = 0; i < items.length; i++)
            add(items[i]);
    });
});


/* editor/help/controls.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');

    var overlay = new ui.Overlay();
    overlay.class.add('help-controls');
    overlay.style.zIndex = 203;
    overlay.center = true;
    overlay.hidden = true;

    overlay.element.addEventListener('mousewheel', function(evt) {
        evt.stopPropagation();
    });

    // header
    var header = new ui.Label();
    header.text = '<span class="icon">&#57654;</span>Controls';
    header.class.add('header');
    overlay.append(header);

    // close
    var btnClose = new ui.Button();
    btnClose.class.add('close');
    btnClose.text = '&#57650;';
    btnClose.on('click', function() {
        overlay.hidden = true;
    });
    header.element.appendChild(btnClose.element);

    // top image
    var imgTop = new Image();
    imgTop.src = 'https://s3-eu-west-1.amazonaws.com/static.playcanvas.com/images/help-controls.png';
    imgTop.classList.add('top');
    imgTop.draggable = false;
    overlay.append(imgTop);

    var container = new ui.Panel();
    container.class.add('container');
    overlay.append(container);

    var legacyScripts = editor.call('settings:project').get('useLegacyScripts');

    var items = [
        {
            buttons: [ 'Ctrl', '$+', 'Enter' ],
            title: 'Launch',
            icons: [ '&#57649;' ]
        }, {
            buttons: [ 'Ctrl', '$+', 'E' ],
            title: 'New Entity',
            icons: [ '&#57632;' ]
        }, {
            buttons: [ 'Ctrl', '$+', 'C' ],
            title: 'Copy Entity',
            icons: [ '&#58193;' ]
        }, {
            buttons: [ 'Ctrl', '$+', 'V' ],
            title: 'Paste Entity',
            icons: [ '&#58184;' ]
        }, {
            buttons: [ 'Delete', '$/', 'Ctrl', '$+', 'Backspace' ],
            title: 'Delete Selected',
            icons: [ '&#57636;' ]
        }, {
            buttons: [ 'Ctrl', '$+', 'D' ],
            title: 'Duplicate Entity',
            icons: [ '&#57638;' ]
        }, {
            buttons: [ 'N', '$/', 'F2' ],
            title: 'Rename Entity / Asset',
            icons: [ '&#57895;' ],
        }, {
            buttons: [ 'F' ],
            title: 'Focus on Entity',
            icons: [ '&#58120;' ],
        }, {
            buttons: [ 'Shift', '$+', 'Z' ],
            title: 'Previous Selection',
            icons: [ '&#57671;' ],
        }, {
            buttons: [ 'Ctrl', '$+', 'Z' ],
            title: 'Undo',
            icons: [ '&#57620;' ]
        }, {
            buttons: [ 'Ctrl', '$+', 'Y', '$/', 'Ctrl', '$+', 'Shift', '$+', 'Z' ],
            title: 'Redo',
            icons: [ '&#57621;' ]
        }, {
            buttons: [ 'Ctrl', '$+', 'B' ],
            title: 'Beke / Recalculate Lights',
            icons: [ '&#57745;' ]
        }, {
            buttons: [ 'Space' ],
            title: 'Toggle All Panels',
            icons: [ '&#57639;' ]
        }, {
            buttons: [ '1', '2', '3' ],
            title: 'Translate / Rotate / Scale Gizmo',
            icons: [ '&#57618;', '&#57619;', '&#57617;' ]
        }, {
            buttons: [ 'L' ],
            title: 'Toggle space: World / Local ',
            icons: [ '&#57879;' ]
        }, {
            buttons: ['Shift', '$+', '?'],
            title: 'Controls',
            icons: [ '&#57654;']
        }, {
            buttons: ['Alt', '$+', 'A'],
            title: 'Focus on Assets Search Field',
            icons: [ '&#57641;']
        }, {
            buttons: ['Ctrl', '$+', 'Space'],
            title: 'How do I...?',
            icons: [ '&#57656;']
        }
    ];

    if (! legacyScripts) {
        items.push({
            buttons: ['Ctrl', '$+', 'I'],
            title: 'Open Code Editor',
            icons: [ '&#57648;' ]
        });
    }

    for(var i = 0; i < items.length; i++) {
        var row = document.createElement('div');
        row.classList.add('row');

        var buttons = document.createElement('div');
        buttons.classList.add('buttons');
        row.appendChild(buttons);

        for(var n = 0; n < items[i].buttons.length; n++) {
            var button = document.createElement('div');
            var divider = items[i].buttons[n].startsWith('$');
            var sign = '';
            if (divider) sign = items[i].buttons[n].slice(1);

            button.classList.add(divider ? 'divider': 'button');
            if (sign === '+') button.classList.add('plus');
            if (sign === '/') button.classList.add('or');

            button.textContent = divider ? sign : items[i].buttons[n];
            buttons.appendChild(button);
        }

        var title = document.createElement('div');
        title.classList.add('title');
        title.textContent = items[i].title;
        row.appendChild(title);

        for(var n = 0; n < items[i].icons.length; n++) {
            var icon = document.createElement('div');
            icon.classList.add('icon');
            icon.innerHTML = items[i].icons[n];
            title.appendChild(icon);
        }

        container.append(row);
    }

    root.append(overlay);


    editor.method('help:controls', function() {
        overlay.hidden = false;
    });

    overlay.on('show', function () {
        editor.emit('help:controls:open');
        window.addEventListener('keydown', onKey);
    });

    overlay.on('hide', function () {
        editor.emit('help:controls:close');
        window.removeEventListener('keydown', onKey);
    });

    var onKey = function (e) {
        if (e.keyCode === 27) {
            overlay.hidden = true;
        }
    };

    // hotkey
    editor.call('hotkey:register', 'help:controls', {
        key: 'forward slash',
        shift: true,
        callback: function() {
            editor.call('help:controls');
        }
    });
});


/* editor/help/howdoi.js */
editor.once('load', function () {
    'use strict';

    var viewport = editor.call('layout.viewport');
    var focusedMenuItem = null;
    var settings = editor.call('settings:user');

    // create main panel
    var panel = new ui.Panel();
    panel.class.add('help-howdoi');
    viewport.append(panel);
    panel.hidden = true;

    var settingsLoaded = false;
    var tipsLoaded = false;
    editor.once('help:howdoi:load', function () {
        tipsLoaded = true;
        checkShow();
    });

    editor.once('settings:user:load', function () {
        settingsLoaded = true;
        checkShow();
    });

    var checkShow = function () {
        if (tipsLoaded && settingsLoaded) {
            panel.hidden = !settings.get('editor.howdoi');
        }
    };

    // events when panel is shown
    panel.on('show', function () {
        editor.emit('help:howdoi:open');
        var history = settings.history;
        settings.history = false;
        settings.set('editor.howdoi', true);
        settings.history = history;

        editor.on('scene:name', positionWidget);
        editor.on('viewport:resize', positionWidget);
        positionWidget();
    });

    // events when panel is hidden
    panel.on('hide', function () {
        editor.emit('help:howdoi:close');

        var history = settings.history;
        settings.history = false;
        settings.set('editor.howdoi', false);
        settings.history = history;

        editor.unbind('scene:name', positionWidget);
        editor.unbind('viewport:resize', positionWidget);

        if (!config.self.tips['howdoi'])
            editor.call('guide:bubble:show', 'howdoi', bubble, 200, true);
    });

    // bubble that appears after closing the widget for the first time
    var bubble = function () {
        var bubble = editor.call(
            'guide:bubble',
            'Get more help when you need it',
            "Click here to bring back the help widget whenever you want.",
            40,
            '',
            'bottom',
            editor.call('layout.toolbar')
        );

        bubble.element.style.top = '';
        bubble.element.style.bottom = '164px';
        return bubble;
    };

    // open / close panel depending on settings
    settings.on('editor.howdoi:set', function (value) {
        panel.hidden = !value;
    });

    // input field
    var input = new ui.TextField();
    input.blurOnEnter = false;
    input.renderChanges = false;
    input.keyChange = true;
    input.elementInput.placeholder = 'How do I...?';
    panel.append(input);

    // close button
    var close = new ui.Button({
        text: 'Hide <span class="font-icon" style="position: absolute; top: 0">&#57650;</span>'
    });
    close.class.add('close');
    panel.append(close);

    close.on('click', function () {
        panel.hidden = true;
    });

    // menu with all the suggestions
    var menu = new ui.Menu();
    menu.open = false;
    panel.append(menu);
    menu.elementOverlay.parentElement.removeChild(menu.elementOverlay);

    var suggestions = [];

    // method to register new suggestions
    editor.method('help:howdoi:register', function (data) {

        // create new menu item
        var menuItem = new ui.MenuItem({
            text: data.title
        });

        menu.append(menuItem);

        // add suggestion
        suggestions.push({
            data: data,
            menuItem: menuItem
        });

        // method that opens the popup for this menu item
        var openPopup = function () {
            // store popup event
            storeEvent(input.value, data.title);

            // open popup
            editor.call('help:howdoi:popup', data);
            // reset input value and blur field
            input.value = '';
            input.elementInput.blur();
            // hide menu
            menu.open = false;
        };

        // open popup on mousedown instead of 'click' because
        // for some reason the 'click' event doesn't always work here
        menuItem.element.addEventListener('mousedown', function (e) {
            e.stopPropagation() ;
            openPopup();
        });

        // focus element on mouse enter
        var mouseEnter = function () {
            if (focusedMenuItem && focusedMenuItem !== menuItem.element)
                focusedMenuItem.classList.remove('focused');

            focusedMenuItem = menuItem.element;
            focusedMenuItem.classList.add('focused');

            // remove mouseenter listener until mouseleave fires to prevent
            // an issue with Firefox
            menuItem.element.removeEventListener('mouseenter', mouseEnter);
        };

        menuItem.element.addEventListener('mouseenter', mouseEnter);

        // unfocus element on mouse leave
        var mouseLeave = function () {
            if (focusedMenuItem && focusedMenuItem === menuItem.element) {
                focusedMenuItem.classList.remove('focused');
                focusedMenuItem = null;
            }

            menuItem.element.addEventListener('mouseenter', mouseEnter);
        };

        menuItem.element.addEventListener('mouseleave', mouseLeave);


        // on enter open the popup
        input.elementInput.addEventListener('keydown', function (e) {
            if (e.keyCode === 13) {
                if (focusedMenuItem === menuItem.element) {
                    e.preventDefault();
                    e.stopPropagation();

                    openPopup();
                }
            }
        });

    });

    // on esc delete the input text or hide the widget if no text is there
    input.elementInput.addEventListener('keydown', function (e) {
        if (e.keyCode === 27) {
            if (input.value) {
                storeEvent(input.value);
                input.value = '';
                input.elementInput.focus();
            } else {
                menu.open = false;
            }
        }
    });

    var blurTimeout;
    var focusing = false;

    // on focus open the menu and then refocus the input field
    input.elementInput.addEventListener('focus', function () {
        if (focusing) return;

        focusing = true;
        menu.open = true;

        if (blurTimeout) {
            clearTimeout(blurTimeout);
            blurTimeout = null;
        }

        setTimeout(function () {
            input.elementInput.focus();
            focusing = false;
        });

    });

    // on blur hide the menu
    input.elementInput.addEventListener('blur', function () {
        if (focusing) return;

        menu.open = false;
    });

    // Store event for when viewing (or not viewing) a topic
    var storeEvent = function (search, topic) {
        Ajax.post('/editor/scene/{{scene.id}}/events', {
            name: 'editor:help',
            title: topic,
            text: search
        });
    };

    // filter suggestions as the user types
    input.on('change', function (value) {
        filterSuggestions(value);
    });

    var filterSuggestions = function (text) {
        var valid;

        // sort suggestions by title first
        suggestions.sort(function (a, b) {
            if (a.data.title < b.data.title)
                return -1;

            if (a.data.title > b.data.title)
                return 1;

            if (a.data.title === b.data.title)
                return 0;
        });

        if (text) {
            var query = [];

            // turn each word in a regex
            var words = text.split(' ');
            words.forEach(function (word) {
                word = word.replace(/[^\w]/g, ''); // remove invalid chars
                if (! word.length) return;

                query.push(new RegExp('(^|\\s)' + word.replace(/[^\w]/, ''), 'i'));
            });


            suggestions.forEach(function (suggestion) {
                suggestion.score = 0;
            });

            var matched = suggestions.slice();
            var foundSomeMatches = false;

            // Score suggestions for each word in the text
            // Each word filters the results more and more
            query.forEach(function (q, index) {
                var stageMatches = [];

                matched.forEach(function (suggestion) {
                    // reset score and make menu item hidden
                    if (index === 0) {
                        suggestion.score = 0;
                        suggestion.menuItem.class.add('hidden');
                    }

                    var title = suggestion.data.title;
                    var keywords = suggestion.data.keywords;

                    var score = 0;

                    // match the title and increase score
                    // if match is closer to the start the score is bigger
                    var match = q.exec(title);
                    if (match) {
                        score += 1 / (match.index || 0.1);
                    }

                    // add to the score for each matched keyword
                    for (var i = 0, len = keywords.length; i < len; i++) {
                        match = q.exec(keywords[i]);
                        if (match) {
                            score++;
                        }
                    }

                    // add suggestion to this stage's matches
                    // each subsequent stage has less and less matches
                    if (score) {
                        suggestion.score += score;
                        stageMatches.push(suggestion);
                    }
                });

                if (stageMatches.length === 0) {
                    // if the first few words have no matches then
                    // skip them until we find some matches first
                    if (foundSomeMatches)
                        matched = stageMatches;
                } else {
                    foundSomeMatches = true;
                    matched = stageMatches;
                }
            });

            // sort matches by score
            matched.sort(function (a, b) {
                return b.score - a.score;
            });

            // show matches
            for (i = matched.length - 1; i >= 0; i--) {
                matched[i].menuItem.class.remove('hidden');
                menu.innerElement.insertBefore(matched[i].menuItem.element, menu.innerElement.firstChild);
            }
        } else {
            // show all suggestions
            for (i = suggestions.length - 1; i >= 0; i--) {
                suggestions[i].menuItem.class.remove('hidden');
                menu.innerElement.insertBefore(suggestions[i].menuItem.element, menu.innerElement.firstChild);
            }

        }

    };


    // handle clicking outside menu in order to close it
    var click = function (e) {
        var parent = e.target;
        while (parent) {
            if (parent === panel.innerElement) {
                input.elementInput.focus();
                return;
            }

            parent = parent.parentElement;
        }

        menu.open = false;
    };

    // handle arrow keys to focus next / previous suggestion
    var key = function (e) {
        var result;

        // up arrow
        if (e.keyCode === 38) {
            result = focusNextSuggestion(false);
        }
        // down arrow
        else if (e.keyCode === 40) {
            result = focusNextSuggestion(true);
        }

        if (result) {
            e.preventDefault();
            e.stopPropagation();
        }
    };

    // Focus next or previous suggestion
    var focusNextSuggestion = function (forward) {
        var next = forward ? menu.innerElement.firstChild : menu.innerElement.lastChild;
        if (focusedMenuItem) {
            focusedMenuItem.classList.remove('focused');

            if (forward) {
                if (focusedMenuItem.nextSibling)
                    next = focusedMenuItem.nextSibling;
            } else {
                if (focusedMenuItem.previousSibling)
                    next = focusedMenuItem.previousSibling;
            }
        }

        var valueBeforeLoop = next;

        while (next.classList.contains('hidden')) {
            if (forward) {
                next = next.nextSibling || menu.innerElement.firstChild;
            } else {
                next =  next.previousSibling || menu.innerElement.lastChild;
            }

            if (next === valueBeforeLoop) // avoid infinite loop
                return;
        }

        focusedMenuItem = next;
        focusedMenuItem.classList.add('focused');

        // scroll into view if needed
        var focusedRect = focusedMenuItem.getBoundingClientRect();
        var menuRect = menu.innerElement.getBoundingClientRect();

        if (focusedRect.bottom > menuRect.bottom)
            menu.innerElement.scrollTop += focusedRect.bottom - menuRect.bottom;
        else if (focusedRect.top < menuRect.top) {
            menu.innerElement.scrollTop -= menuRect.top - focusedRect.top;
        }

        return true;
    };

    // handle open event
    menu.on('open', function (open) {
        if (open) {
            window.addEventListener('click', click);
            window.addEventListener('keydown', key);
            input.class.add('focus');
            menu.innerElement.scrollTop = 0;
            close.hidden = true;

            filterSuggestions();
        }
        else {
            window.removeEventListener('click', click);
            window.removeEventListener('keydown', key);
            input.class.remove('focus');
            if (focusedMenuItem) {
                focusedMenuItem.classList.remove('focused');
                focusedMenuItem = null;
            }
            close.hidden = false;

            if (input.value)
                storeEvent(input.value);

            input.value = '';
        }

    });

    var toggleWidget = function (toggle) {
        panel.hidden = !toggle;
        if (toggle) {
            setTimeout(function () {
                input.elementInput.focus();
            });
        }
    };

    // method to show the widget
    editor.method('help:howdoi', function () {
        toggleWidget(true);
    });

    // method to toggle the widget
    editor.method('help:howdoi:toggle', function () {
        toggleWidget(panel.hidden);
    });

    // hotkey
    editor.call('hotkey:register', 'help:howdoi', {
        key: 'space',
        ctrl: true,
        callback: function() {
            editor.call('help:howdoi');
        }
    });

    // position widget between top elements in viewport
    var positionWidget = function () {
        var canvas = editor.call('viewport:canvas');
        if (! canvas) return;

        var canvasRect = canvas.element.getBoundingClientRect();

        var titleWidget = document.querySelector('.widget-title');
        var titleWidgetRect = titleWidget ? titleWidget.getBoundingClientRect() : null;

        var topLeftWidth = titleWidgetRect ? titleWidgetRect.right - canvasRect.left : 0;

        var topControls = document.querySelector('.viewport-camera');
        var topControlsRect = topControls ? topControls.getBoundingClientRect() : null;

        var topRightWidth = topControlsRect ? canvasRect.left + canvasRect.width - topControlsRect.left : 0;

        var width = canvasRect.width - topLeftWidth - topRightWidth - 20;
        if (width < 150) {
            panel.class.add('hidden');
        } else {
            panel.class.remove('hidden');

            if (width > 400)
                width = 400;
        }


        panel.style.width = width + 'px';
        panel.style.left = (topLeftWidth + (((topControlsRect.left - titleWidgetRect.right) - width) / 2)) + 'px';
    };

});


/* editor/help/howdoi-popup.js */
editor.once('load', function () {
    'use strict';

    var root = editor.call('layout.root');
    var overlay = new ui.Overlay();
    overlay.class.add('help-howdoi');
    overlay.hidden = true;
    overlay.clickable = true;
    root.append(overlay);

    var panel = new ui.Panel();
    overlay.append(panel);

    var content = new ui.Label();
    content.renderChanges = false;
    panel.append(content);

    var docs = new ui.Button({
        text: 'View Docs'
    });
    docs.class.add('docs');
    panel.append(docs);
    docs.hidden = true;

    var key = function (e) {
        // close on esc
        if (e.keyCode === 27) {
            overlay.hidden = true;
        }
    };

    overlay.on('show', function () {
        editor.emit('help:howdoi:popup:open');
        window.addEventListener('keydown', key);
    });

    overlay.on('hide', function () {
        window.removeEventListener('keydown', key);
        editor.emit('help:howdoi:popup:close');
    });


    editor.method('help:howdoi:popup', function (data) {
        overlay.hidden = false;
        content.text = data.text;

        setTimeout(function () {
            var closeButton = panel.innerElement.querySelector('.close');
            if (closeButton)
                closeButton.addEventListener('click', function () {
                    overlay.hidden = true;
                });
        });
    });

});

/* editor/help/howdoi-load.js */
editor.once('load', function () {
    var data = {
        url: config.url.howdoi,
        method: 'GET'
    };

    Ajax(data)
        .on('load', function(status, data) {
            if (! data || !data.length)
                return;

            data.forEach(function (tip) {
                editor.call('help:howdoi:register', {
                    title: tip.title,
                    text: tip.html,
                    keywords: tip.keywords
                });
            });

            editor.emit('help:howdoi:load');
        })
        .on('error', function(status, data) {
            console.error(status);
        });
});

/* editor/demo_project.js */
editor.once('load', function() {
    'use strict';

    if (config.self.openedEditor)
        return;

    if (config.project.name !== 'My First Project')
        return;

    // do not show if not owner
    if (config.owner.id !== config.self.id)
        return;

    var root = editor.call('layout.root');

    // overlay
    var overlay = new ui.Overlay();
    overlay.hidden = true;
    overlay.clickable = true;
    overlay.class.add('demo');
    root.append(overlay);

    // panel
    var panel = new ui.Panel();
    overlay.append(panel);

    // contents
    var header = new ui.Label({
        text: "Editor Intro"
    });
    header.class.add('header');
    panel.append(header);

    var main = new ui.Label({
        text: "To help you learn PlayCanvas we've created your first project. It's a simple ball rolling game. Complete the design of the level by adding an extra platform, then design your own levels.<br/><br/>We'll pop up some tips to help you along the way."
    });
    main.class.add('main');
    panel.append(main);

    var close = new ui.Button({
        text: "LET'S GO"
    });
    close.class.add('close');
    panel.append(close);
    close.on('click', function () {
        overlay.hidden = true;
    });

    editor.once('scene:raw', function() {
        overlay.hidden = false;
    });

    overlay.on('show', function () {
        editor.emit('help:demo:show');
    });

    overlay.on('hide', function () {
        editor.emit('help:demo:close');
    });
});


/* editor/guides/guide-bubbles.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');

    var overlay = new ui.Overlay();
    overlay.clickable = true;
    overlay.hidden = true;
    overlay.class.add('bubble');
    root.append(overlay);

    var panel = new ui.Panel();
    overlay.append(panel);

    var label = new ui.Label();
    label.renderChanges = false;
    panel.append(label);

    var btn = new ui.Button({
        text: 'GOT IT'
    });
    btn.class.add('next');
    btn.on('click', function() {
        overlay.hidden = true;
    });
    overlay.append(btn);

    editor.method('guide:bubble', function (title, text, x, y, align, parent) {
        var bubble = new ui.Bubble();

        if (!parent)
            parent = root;

        if (parent instanceof Node) {
            parent.appendChild(bubble.element);
        } else {
            parent.append(bubble.element);
        }

        bubble.position(x, y);

        var evt;

        bubble.on('activate', function () {
            var rect = bubble.element.getBoundingClientRect();

            panel.header = title;
            label.text = text;
            overlay.hidden = false;

            overlay.innerElement.style.top = rect.top + 'px';
            overlay.innerElement.style.left = rect.left + 'px';

            overlay.class.add('arrow-' + align);

            if (/^bottom/.test(align)) {
                var overlayRect = overlay.innerElement.getBoundingClientRect();
                overlay.innerElement.style.marginTop = (-40 - overlayRect.height) + 'px';
            }

            evt = overlay.once('hide', function () {
                bubble.deactivate();
            });
        });

        bubble.on('deactivate', function () {
            bubble.destroy();
            overlay.hidden = true;
            if (evt) {
                evt.unbind();
                evt = null;
            }
        });

        return bubble;
    });

    overlay.on('show', function () {
        overlay.class.remove('arrow-left');
        overlay.class.remove('arrow-top');
        overlay.class.remove('arrow-top-right');
        overlay.class.remove('arrow-right');
        overlay.class.remove('arrow-bottom');
        overlay.class.remove('arrow-bottom-right');
        overlay.innerElement.style.marginTop = '';
    });
});


/* editor/guides/guide-intro.js */
editor.once('load', function () {
    'use strict';

    var nextDelay = 500;

    var bubbles = [];

    var timeouts = {};

    var bubbleDemo1 = function () {
        var bubble = editor.call(
            'guide:bubble',
            'Complete this level (1 / 4)',
            "Let's duplicate one of those platforms. Click on a platform in the 3D view to select it.",
            '50%',
            '50%',
            'left',
            editor.call('layout.viewport')
        );


        return bubble;
    };

    var bubbleDemo2 = function () {
        var bubble = editor.call(
            'guide:bubble',
            'Complete this level (2 / 4)',
            'Hit Ctrl+D or click the <span class="font-icon">&#57638;</span> button to duplicate the selected platform.',
            '50%',
            '50%',
            'left',
            editor.call('layout.viewport')
        );


        return bubble;
    };

    var bubbleDemo3 = function () {
        var bubble = editor.call(
            'guide:bubble',
            'Complete this level (3 / 4)',
            "Use the arrows of the Translate tool to move the platform. Try to fill that gap so that the ball can safely reach the rightmost platform.",
            '50%',
            '50%',
            'left',
            editor.call('layout.viewport')
        );

        return bubble;
    };

    var bubbleDemo4 = function () {
        return editor.call(
            'guide:bubble',
            'Complete this level (4 / 4)',
            "Click <span class='font-icon'>&#57649;</span> <strong>Launch</strong> to play the game. Use the arrow keys to move the ball. The game will open in a new tab so just switch back to the Editor tab when you're done.<br/><br/>Any changes you make to the scene will automatically update the launched game.",
            46,
            29,
            'top-right',
            editor.call('layout.toolbar.launch')
        );
    };

    var bubbleHierarchy = function () {
        return editor.call(
            'guide:bubble',
            'Scene Hierarchy',
            'This is your <strong>Scene Hierarchy</strong> made up of <strong>Entities</strong>, which can be given new behaviours by adding Components.<br/><br/> <span class="font-icon">&#57632;</span> Add, <span class="font-icon">&#57638;</span> Duplicate and <span class="font-icon">&#57636;</span> Delete Entities using the controls in this panel.',
            295,
            60,
            'left'
        );
    };

    var bubbleLaunch = function () {
        return editor.call(
            'guide:bubble',
            'Launch Preview',
            'Click <span class="font-icon">&#57649;</span> <strong>Launch</strong> to preview your scene. Any changes you make to your scene while in the Editor will automatically update the launched scene.',
            46,
            29,
            'top-right',
            editor.call('layout.toolbar.launch')
        );
    };

    var bubbleDashboard = function () {
        return editor.call(
            'guide:bubble',
            'Dashboard',
            'This is the name of your <strong>Project</strong>. Click here to go to the <strong>Project Dashboard</strong>.<br/><br/>Visit your <strong>Dashboard</strong> to create a new <strong>Project</strong>.',
            55,
            28,
            'top',
            editor.call('layout.toolbar.scene')
        );
    };

    var bubbleAssets = function () {
        return editor.call(
            'guide:bubble',
            'Assets',
            '<strong>Drag`n`Drop</strong> files from your computer to upload assets or use the <span class="font-icon">&#57632;</span> Add button to create new assets.<br/><br/>You can filter and <span class="font-icon">&#57641;</span> search your assets using the controls at the top.',
            54,
            -39,
            'bottom',
            editor.call('layout.assets').element
        );
    };

    var bubbleStore = function () {
        var bubble = editor.call(
            'guide:bubble',
            'Asset Library',
            '<img width="424" height="133" src="https://s3-eu-west-1.amazonaws.com/static.playcanvas.com/instructions/asset_library.jpg"/><br/><br/>Click the <strong>Library</strong> button to open the Asset Library. Add free 3D models and assets from the library into your scene with a single click.',
            560,
            -36,
            'bottom-right',
            editor.call('layout.assets').element
        );

        bubble.style.zIndex = 'initial';
        return bubble;
    };

    var bubbleMenu = function () {
        return editor.call(
            'guide:bubble',
            'Main Menu',
            'The <span style="display:inline-block;background-image:url(\'https://s3-eu-west-1.amazonaws.com/static.playcanvas.com/images/editor_logo.png\');width:18px;height:18px;background-size:36px 18px;background-position:-18px 0;vertical-align:text-bottom;"></span> main menu and toolbar has every command available in the Editor. If you cant find a button or remember a hot key, you will always find the command in the menu.',
            18,
            40,
            'top'
        );
    };

    var bubbleControls = function () {
        var bubble = editor.call(
            'guide:bubble',
            'Controls',
            'Click here to see <strong>controls</strong> and <strong>shortcuts</strong> for the Editor.',
            41,
            0,
            'bottom',
            editor.call('layout.toolbar')
        );

        bubble.element.style.top = '';
        bubble.element.style.bottom = '119px';
        return bubble;
    };

    var bubbleEntity = function () {
        var bubble = editor.call(
            'guide:bubble',
            'Entity Inspector',
            'This is the <strong>Entity Inspector</strong>. Here you can enable or disable an Entity, edit its name or its position / rotation and scale. <br/><br/>If you want to add behaviours to your Entity click on Add Component.',
            0,
            100,
            'right',
            editor.call('layout.viewport')
        );

        bubble.element.style.left = '';
        bubble.element.style.right = '6px';

        return bubble;
    };

    var bubbleSoundComponent = function () {
        var bubble = editor.call(
            'guide:bubble',
            'Sound Component',
            'The Sound Component allows the Entity to play sounds. To play a sound you need to create a "slot", give it a name and assign an Audio Asset to it. If you set it to Auto Play the slot will begin playback when the application is loaded. Otherwise play it by script. You can create multiple slots to play different sounds. Check out this <a href="http://developer.playcanvas.com/en/tutorials/beginner/basic-audio/" target="_blank">tutorial</a> for more.',
            10,
            10,
            'right',
            document.querySelector('.ui-panel.sound')
        );

        return bubble;
    };

    var showBubble = function (name, bubbleFn, delay, force, callback) {
        if (!force && config.self.tips[name] !== false) return false;

        if (timeouts[name])
            clearTimeout(timeouts[name]);

        timeouts[name] = setTimeout(function () {
            delete timeouts[name];

            var bubble = bubbleFn();
            bubbles.push(bubble);

            bubble.on('deactivate', function () {
                config.self.tips[name] = true;
                Ajax.post('/editor/scene/{{scene.id}}/tips/' + name, {});

                if (callback)
                    callback();
            });
        }, delay);

        return true;
    };

    editor.method('guide:bubble:show', function (name, bubbleFn, delay, force, callback) {
        showBubble(name, bubbleFn, delay, force, callback);
    });


    var selectEvents = null;
    var showBubbles = function (initialDelay) {
        var delay = initialDelay;

        if (showBubble('mainMenu', bubbleMenu, delay))
            delay += nextDelay;

        if (showBubble('hierarchy', bubbleHierarchy, delay))
            delay += nextDelay;

        if (showBubble('dashboard', bubbleDashboard, delay))
            delay += nextDelay;

        if (showBubble('launch', bubbleLaunch, delay))
            delay += nextDelay;

        if (showBubble('assets', bubbleAssets, delay))
            delay += nextDelay;

        // show store bubble for existing users as well
        if (!config.self.tips.store && showBubble('store', bubbleStore, delay, true))
            delay += nextDelay;

        if (showBubble('controls', bubbleControls, delay))
            delay += nextDelay;

        // entity bubble on select entity
        if (config.self.tips.entityInspector === false) {
            var evtEntitySelect = editor.on('selector:change', function (type, items) {
                if (type !== 'entity') return;

                evtEntitySelect.unbind();

                showBubble('entityInspector', bubbleEntity, nextDelay);
            });
        }

        // sound component bubble
        if (!config.self.tips.soundComponent) {
            var evtEntityWithSoundSelect = editor.on('selector:change', function (type, items) {

                if (selectEvents) {
                    selectEvents.forEach(function (evt) {
                        evt.unbind();
                    });
                    selectEvents = null;
                }

                if (type !== 'entity') {
                    return;
                }

                var showSoundBubble = function () {
                    showBubble('soundComponent', bubbleSoundComponent, nextDelay, true);

                    evtEntityWithSoundSelect.unbind();

                    if (selectEvents) {
                        selectEvents.forEach(function (evt) {
                            evt.unbind();
                        });

                        selectEvents = null;
                    }
                };

                for (var i = 0; i < items.length; i++) {
                    if (items[i].has('components.sound')) {
                        showSoundBubble();
                        return;
                    }
                }

                // if a sound component is added show bubble
                if (! selectEvents) selectEvents = [];

                for (var i = 0; i < items.length; i++) {
                    selectEvents.push(items[i].on('components.sound:set', showSoundBubble));
                }
            });
        }

    };

    editor.method('editor:tips:reset', function () {
        // destroy existing bubbles
        bubbles.forEach(function (bubble) {
            bubble.destroy();
        });

        bubbles.length = 0;

        Ajax.post('/editor/scene/{{scene.id}}/tips/reset', {});

        ['hierarchy',
            'assets',
            'store',
            'dashboard',
            'entityInspector',
            'soundComponent',
            'mainMenu',
            'controls',
            'launch',
            'howdoi'].forEach(function (tip) {
            config.self.tips[tip] = false;
        });

        showBubbles(100);
    });

    var openedDemo = false;

    editor.once('help:demo:show', function () {
        openedDemo = true;

        editor.once('help:demo:close', function () {
            Ajax.post('/editor/scene/{{scene.id}}/opened', { });

            // show some demo specific bubbles first
            setTimeout(function () {
                bubbleDemo1().on('deactivate', function () {
                    setTimeout(function () {
                        bubbleDemo2().on('deactivate', function () {
                            setTimeout(function () {
                                bubbleDemo3().on('deactivate', function () {
                                    setTimeout(function () {
                                        bubbleDemo4().on('deactivate', function () {
                                            setTimeout(function () {
                                                showBubbles(0);
                                            }, 3000);
                                        });
                                    }, 2000);
                                });
                            }, 2000);
                        });
                    }, 2000);
                });
            }, 1000);
        });
    });

    editor.once('scene:raw', function () {
        // If the demo popup has opened show bubbles after it
        // otherwise show them right away
        setTimeout(function () {
            if (!openedDemo)
                showBubbles(0);
        }, 3000);
    });
});


/* editor/plugins.js */
editor.once('load', function() {
    'use strict';

    var pluginNameCheck = /[a-z0-9\-_]/i;
    var pluginsLoading = { };
    var plugins = { };
    var projectSettings = editor.call('settings:project');


    editor.method('plugins:load', function(name, fn) {
        if (! name || ! pluginNameCheck.test(name)) {
            if (fn) fn(new Error('invalid plugin name'));
            return;
        }

        if (pluginsLoading[name] || plugins[name])
            return;

        pluginsLoading[name] = true;

        var loaded = false;
        var element = document.createElement('script');
        element.async = false;

        element.addEventListener('error', function(err) {
            if (loaded)
                return;

            loaded = true;
            delete pluginsLoading[name];
            editor.emit('plugins:load:error', name, err);

            editor.call('status:error', 'plugins:load:error ' + name);

            if (fn) fn(err);
        });

        element.onload = element.onreadystatechange = function() {
            if (loaded)
                return;

            if (this.readyState && (this.readyState !== 'loaded' && this.readyState === 'complete'))
                return;

            loaded = true;
            delete pluginsLoading[name];
            plugins[name] = element;
            editor.emit('plugins:load', name);
            editor.emit('plugins:load:' + name);

            editor.call('status:text', 'plugins:load ' + name);

            if (fn) fn(null);
        };

        element.src = '/editor/scene/js/plugins/' + name + '.js';

        document.head.appendChild(element);

        editor.emit('plugins:loading', name);
    });

    editor.method('plugins:unload', function(name) {
        if (! plugins[name])
            return;

        document.head.removeChild(plugins[name]);
        delete plugins[name];

        editor.emit('plugins:removed', name);
    });


    var pluginsPreload = projectSettings.get('plugins');
    if (pluginsPreload) {
        for(var i = 0; i < pluginsPreload.length; i++)
            editor.call('plugins:load', pluginsPreload[i]);
    }
});


